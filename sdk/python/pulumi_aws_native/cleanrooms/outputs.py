# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AnalysisTemplateAnalysisParameter',
    'AnalysisTemplateAnalysisSchema',
    'AnalysisTemplateAnalysisSource0Properties',
    'AnalysisTemplateAnalysisSource1Properties',
    'AnalysisTemplateAnalysisSourceMetadataProperties',
    'AnalysisTemplateArtifact',
    'AnalysisTemplateArtifactMetadata',
    'AnalysisTemplateArtifacts',
    'AnalysisTemplateHash',
    'AnalysisTemplateS3Location',
    'CollaborationDataEncryptionMetadata',
    'CollaborationJobComputePaymentConfig',
    'CollaborationMemberSpecification',
    'CollaborationMlMemberAbilities',
    'CollaborationMlPaymentConfig',
    'CollaborationModelInferencePaymentConfig',
    'CollaborationModelTrainingPaymentConfig',
    'CollaborationPaymentConfiguration',
    'CollaborationQueryComputePaymentConfig',
    'ConfiguredTableAggregateColumn',
    'ConfiguredTableAggregationConstraint',
    'ConfiguredTableAnalysisRule',
    'ConfiguredTableAnalysisRuleAggregation',
    'ConfiguredTableAnalysisRuleCustom',
    'ConfiguredTableAnalysisRuleList',
    'ConfiguredTableAnalysisRulePolicy',
    'ConfiguredTableAnalysisRulePolicyV10Properties',
    'ConfiguredTableAnalysisRulePolicyV11Properties',
    'ConfiguredTableAnalysisRulePolicyV12Properties',
    'ConfiguredTableAssociationAnalysisRule',
    'ConfiguredTableAssociationAnalysisRuleAggregation',
    'ConfiguredTableAssociationAnalysisRuleCustom',
    'ConfiguredTableAssociationAnalysisRuleList',
    'ConfiguredTableAssociationAnalysisRulePolicy',
    'ConfiguredTableAssociationAnalysisRulePolicyV10Properties',
    'ConfiguredTableAssociationAnalysisRulePolicyV11Properties',
    'ConfiguredTableAssociationAnalysisRulePolicyV12Properties',
    'ConfiguredTableAthenaTableReference',
    'ConfiguredTableDifferentialPrivacy',
    'ConfiguredTableDifferentialPrivacyColumn',
    'ConfiguredTableGlueTableReference',
    'ConfiguredTableSnowflakeTableReference',
    'ConfiguredTableSnowflakeTableSchemaProperties',
    'ConfiguredTableSnowflakeTableSchemaV1',
    'ConfiguredTableTableReference0Properties',
    'ConfiguredTableTableReference1Properties',
    'ConfiguredTableTableReference2Properties',
    'IdMappingTableInputReferenceConfig',
    'IdMappingTableInputReferenceProperties',
    'IdMappingTableInputSource',
    'IdNamespaceAssociationDocument',
    'IdNamespaceAssociationIdMappingConfig',
    'IdNamespaceAssociationInputReferenceConfig',
    'IdNamespaceAssociationInputReferenceProperties',
    'MembershipJobComputePaymentConfig',
    'MembershipMlPaymentConfig',
    'MembershipModelInferencePaymentConfig',
    'MembershipModelTrainingPaymentConfig',
    'MembershipPaymentConfiguration',
    'MembershipProtectedJobOutputConfiguration',
    'MembershipProtectedJobResultConfiguration',
    'MembershipProtectedJobS3OutputConfigurationInput',
    'MembershipProtectedQueryOutputConfiguration',
    'MembershipProtectedQueryResultConfiguration',
    'MembershipProtectedQueryS3OutputConfiguration',
    'MembershipQueryComputePaymentConfig',
    'ParametersProperties',
]

@pulumi.output_type
class AnalysisTemplateAnalysisParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTemplateAnalysisParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTemplateAnalysisParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTemplateAnalysisParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 type: 'AnalysisTemplateAnalysisParameterType',
                 default_value: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        :param 'AnalysisTemplateAnalysisParameterType' type: The type of parameter.
        :param builtins.str default_value: Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> 'AnalysisTemplateAnalysisParameterType':
        """
        The type of parameter.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[builtins.str]:
        """
        Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        """
        return pulumi.get(self, "default_value")


@pulumi.output_type
class AnalysisTemplateAnalysisSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referencedTables":
            suggest = "referenced_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTemplateAnalysisSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTemplateAnalysisSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTemplateAnalysisSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 referenced_tables: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] referenced_tables: The tables referenced in the analysis schema.
        """
        pulumi.set(__self__, "referenced_tables", referenced_tables)

    @property
    @pulumi.getter(name="referencedTables")
    def referenced_tables(self) -> Sequence[builtins.str]:
        """
        The tables referenced in the analysis schema.
        """
        return pulumi.get(self, "referenced_tables")


@pulumi.output_type
class AnalysisTemplateAnalysisSource0Properties(dict):
    def __init__(__self__, *,
                 text: builtins.str):
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> builtins.str:
        return pulumi.get(self, "text")


@pulumi.output_type
class AnalysisTemplateAnalysisSource1Properties(dict):
    def __init__(__self__, *,
                 artifacts: 'outputs.AnalysisTemplateArtifacts'):
        pulumi.set(__self__, "artifacts", artifacts)

    @property
    @pulumi.getter
    def artifacts(self) -> 'outputs.AnalysisTemplateArtifacts':
        return pulumi.get(self, "artifacts")


@pulumi.output_type
class AnalysisTemplateAnalysisSourceMetadataProperties(dict):
    def __init__(__self__, *,
                 artifacts: 'outputs.AnalysisTemplateArtifactMetadata'):
        pulumi.set(__self__, "artifacts", artifacts)

    @property
    @pulumi.getter
    def artifacts(self) -> 'outputs.AnalysisTemplateArtifactMetadata':
        return pulumi.get(self, "artifacts")


@pulumi.output_type
class AnalysisTemplateArtifact(dict):
    def __init__(__self__, *,
                 location: 'outputs.AnalysisTemplateS3Location'):
        pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def location(self) -> 'outputs.AnalysisTemplateS3Location':
        return pulumi.get(self, "location")


@pulumi.output_type
class AnalysisTemplateArtifactMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPointHash":
            suggest = "entry_point_hash"
        elif key == "additionalArtifactHashes":
            suggest = "additional_artifact_hashes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTemplateArtifactMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTemplateArtifactMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTemplateArtifactMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_point_hash: 'outputs.AnalysisTemplateHash',
                 additional_artifact_hashes: Optional[Sequence['outputs.AnalysisTemplateHash']] = None):
        pulumi.set(__self__, "entry_point_hash", entry_point_hash)
        if additional_artifact_hashes is not None:
            pulumi.set(__self__, "additional_artifact_hashes", additional_artifact_hashes)

    @property
    @pulumi.getter(name="entryPointHash")
    def entry_point_hash(self) -> 'outputs.AnalysisTemplateHash':
        return pulumi.get(self, "entry_point_hash")

    @property
    @pulumi.getter(name="additionalArtifactHashes")
    def additional_artifact_hashes(self) -> Optional[Sequence['outputs.AnalysisTemplateHash']]:
        return pulumi.get(self, "additional_artifact_hashes")


@pulumi.output_type
class AnalysisTemplateArtifacts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPoint":
            suggest = "entry_point"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "additionalArtifacts":
            suggest = "additional_artifacts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTemplateArtifacts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTemplateArtifacts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTemplateArtifacts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_point: 'outputs.AnalysisTemplateArtifact',
                 role_arn: builtins.str,
                 additional_artifacts: Optional[Sequence['outputs.AnalysisTemplateArtifact']] = None):
        pulumi.set(__self__, "entry_point", entry_point)
        pulumi.set(__self__, "role_arn", role_arn)
        if additional_artifacts is not None:
            pulumi.set(__self__, "additional_artifacts", additional_artifacts)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> 'outputs.AnalysisTemplateArtifact':
        return pulumi.get(self, "entry_point")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> builtins.str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="additionalArtifacts")
    def additional_artifacts(self) -> Optional[Sequence['outputs.AnalysisTemplateArtifact']]:
        return pulumi.get(self, "additional_artifacts")


@pulumi.output_type
class AnalysisTemplateHash(dict):
    def __init__(__self__, *,
                 sha256: Optional[builtins.str] = None):
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter
    def sha256(self) -> Optional[builtins.str]:
        return pulumi.get(self, "sha256")


@pulumi.output_type
class AnalysisTemplateS3Location(dict):
    def __init__(__self__, *,
                 bucket: builtins.str,
                 key: builtins.str):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> builtins.str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")


@pulumi.output_type
class CollaborationDataEncryptionMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCleartext":
            suggest = "allow_cleartext"
        elif key == "allowDuplicates":
            suggest = "allow_duplicates"
        elif key == "allowJoinsOnColumnsWithDifferentNames":
            suggest = "allow_joins_on_columns_with_different_names"
        elif key == "preserveNulls":
            suggest = "preserve_nulls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationDataEncryptionMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationDataEncryptionMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationDataEncryptionMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_cleartext: builtins.bool,
                 allow_duplicates: builtins.bool,
                 allow_joins_on_columns_with_different_names: builtins.bool,
                 preserve_nulls: builtins.bool):
        """
        :param builtins.bool allow_cleartext: Indicates whether encrypted tables can contain cleartext data ( `TRUE` ) or are to cryptographically process every column ( `FALSE` ).
        :param builtins.bool allow_duplicates: Indicates whether Fingerprint columns can contain duplicate entries ( `TRUE` ) or are to contain only non-repeated values ( `FALSE` ).
        :param builtins.bool allow_joins_on_columns_with_different_names: Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name ( `TRUE` ) or can only be joined on Fingerprint columns of the same name ( `FALSE` ).
        :param builtins.bool preserve_nulls: Indicates whether NULL values are to be copied as NULL to encrypted tables ( `TRUE` ) or cryptographically processed ( `FALSE` ).
        """
        pulumi.set(__self__, "allow_cleartext", allow_cleartext)
        pulumi.set(__self__, "allow_duplicates", allow_duplicates)
        pulumi.set(__self__, "allow_joins_on_columns_with_different_names", allow_joins_on_columns_with_different_names)
        pulumi.set(__self__, "preserve_nulls", preserve_nulls)

    @property
    @pulumi.getter(name="allowCleartext")
    def allow_cleartext(self) -> builtins.bool:
        """
        Indicates whether encrypted tables can contain cleartext data ( `TRUE` ) or are to cryptographically process every column ( `FALSE` ).
        """
        return pulumi.get(self, "allow_cleartext")

    @property
    @pulumi.getter(name="allowDuplicates")
    def allow_duplicates(self) -> builtins.bool:
        """
        Indicates whether Fingerprint columns can contain duplicate entries ( `TRUE` ) or are to contain only non-repeated values ( `FALSE` ).
        """
        return pulumi.get(self, "allow_duplicates")

    @property
    @pulumi.getter(name="allowJoinsOnColumnsWithDifferentNames")
    def allow_joins_on_columns_with_different_names(self) -> builtins.bool:
        """
        Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name ( `TRUE` ) or can only be joined on Fingerprint columns of the same name ( `FALSE` ).
        """
        return pulumi.get(self, "allow_joins_on_columns_with_different_names")

    @property
    @pulumi.getter(name="preserveNulls")
    def preserve_nulls(self) -> builtins.bool:
        """
        Indicates whether NULL values are to be copied as NULL to encrypted tables ( `TRUE` ) or cryptographically processed ( `FALSE` ).
        """
        return pulumi.get(self, "preserve_nulls")


@pulumi.output_type
class CollaborationJobComputePaymentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isResponsible":
            suggest = "is_responsible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationJobComputePaymentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationJobComputePaymentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationJobComputePaymentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_responsible: builtins.bool):
        """
        :param builtins.bool is_responsible: Indicates whether the collaboration creator has configured the collaboration member to pay for query and job compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query and job compute costs ( `FALSE` ).
               
               Exactly one member can be configured to pay for query and job compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.
               
               An error is returned if the collaboration creator sets a `FALSE` value for the member who can run queries and jobs.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> builtins.bool:
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for query and job compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query and job compute costs ( `FALSE` ).

        Exactly one member can be configured to pay for query and job compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        An error is returned if the collaboration creator sets a `FALSE` value for the member who can run queries and jobs.
        """
        return pulumi.get(self, "is_responsible")


@pulumi.output_type
class CollaborationMemberSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "memberAbilities":
            suggest = "member_abilities"
        elif key == "mlMemberAbilities":
            suggest = "ml_member_abilities"
        elif key == "paymentConfiguration":
            suggest = "payment_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationMemberSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationMemberSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationMemberSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: builtins.str,
                 display_name: builtins.str,
                 member_abilities: Sequence['CollaborationMemberAbility'],
                 ml_member_abilities: Optional['outputs.CollaborationMlMemberAbilities'] = None,
                 payment_configuration: Optional['outputs.CollaborationPaymentConfiguration'] = None):
        """
        :param builtins.str account_id: The identifier used to reference members of the collaboration. Currently only supports AWS account ID.
        :param builtins.str display_name: The member's display name.
        :param Sequence['CollaborationMemberAbility'] member_abilities: The abilities granted to the collaboration member.
               
               *Allowed Values* : `CAN_QUERY` | `CAN_RECEIVE_RESULTS`
        :param 'CollaborationMlMemberAbilities' ml_member_abilities: The ML abilities granted to the collaboration member.
        :param 'CollaborationPaymentConfiguration' payment_configuration: The collaboration member's payment responsibilities set by the collaboration creator.
               
               If the collaboration creator hasn't speciï¬ed anyone as the member paying for query compute costs, then the member who can query is the default payer.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "member_abilities", member_abilities)
        if ml_member_abilities is not None:
            pulumi.set(__self__, "ml_member_abilities", ml_member_abilities)
        if payment_configuration is not None:
            pulumi.set(__self__, "payment_configuration", payment_configuration)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> builtins.str:
        """
        The identifier used to reference members of the collaboration. Currently only supports AWS account ID.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        The member's display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="memberAbilities")
    def member_abilities(self) -> Sequence['CollaborationMemberAbility']:
        """
        The abilities granted to the collaboration member.

        *Allowed Values* : `CAN_QUERY` | `CAN_RECEIVE_RESULTS`
        """
        return pulumi.get(self, "member_abilities")

    @property
    @pulumi.getter(name="mlMemberAbilities")
    def ml_member_abilities(self) -> Optional['outputs.CollaborationMlMemberAbilities']:
        """
        The ML abilities granted to the collaboration member.
        """
        return pulumi.get(self, "ml_member_abilities")

    @property
    @pulumi.getter(name="paymentConfiguration")
    def payment_configuration(self) -> Optional['outputs.CollaborationPaymentConfiguration']:
        """
        The collaboration member's payment responsibilities set by the collaboration creator.

        If the collaboration creator hasn't speciï¬ed anyone as the member paying for query compute costs, then the member who can query is the default payer.
        """
        return pulumi.get(self, "payment_configuration")


@pulumi.output_type
class CollaborationMlMemberAbilities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customMlMemberAbilities":
            suggest = "custom_ml_member_abilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationMlMemberAbilities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationMlMemberAbilities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationMlMemberAbilities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_ml_member_abilities: Sequence['CollaborationCustomMlMemberAbility']):
        """
        :param Sequence['CollaborationCustomMlMemberAbility'] custom_ml_member_abilities: The custom ML member abilities for a collaboration member.
        """
        pulumi.set(__self__, "custom_ml_member_abilities", custom_ml_member_abilities)

    @property
    @pulumi.getter(name="customMlMemberAbilities")
    def custom_ml_member_abilities(self) -> Sequence['CollaborationCustomMlMemberAbility']:
        """
        The custom ML member abilities for a collaboration member.
        """
        return pulumi.get(self, "custom_ml_member_abilities")


@pulumi.output_type
class CollaborationMlPaymentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelInference":
            suggest = "model_inference"
        elif key == "modelTraining":
            suggest = "model_training"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationMlPaymentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationMlPaymentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationMlPaymentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_inference: Optional['outputs.CollaborationModelInferencePaymentConfig'] = None,
                 model_training: Optional['outputs.CollaborationModelTrainingPaymentConfig'] = None):
        """
        :param 'CollaborationModelInferencePaymentConfig' model_inference: The payment responsibilities accepted by the member for model inference.
        :param 'CollaborationModelTrainingPaymentConfig' model_training: The payment responsibilities accepted by the member for model training.
        """
        if model_inference is not None:
            pulumi.set(__self__, "model_inference", model_inference)
        if model_training is not None:
            pulumi.set(__self__, "model_training", model_training)

    @property
    @pulumi.getter(name="modelInference")
    def model_inference(self) -> Optional['outputs.CollaborationModelInferencePaymentConfig']:
        """
        The payment responsibilities accepted by the member for model inference.
        """
        return pulumi.get(self, "model_inference")

    @property
    @pulumi.getter(name="modelTraining")
    def model_training(self) -> Optional['outputs.CollaborationModelTrainingPaymentConfig']:
        """
        The payment responsibilities accepted by the member for model training.
        """
        return pulumi.get(self, "model_training")


@pulumi.output_type
class CollaborationModelInferencePaymentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isResponsible":
            suggest = "is_responsible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationModelInferencePaymentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationModelInferencePaymentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationModelInferencePaymentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_responsible: builtins.bool):
        """
        :param builtins.bool is_responsible: Indicates whether the collaboration creator has configured the collaboration member to pay for model inference costs ( `TRUE` ) or has not configured the collaboration member to pay for model inference costs ( `FALSE` ).
               
               Exactly one member can be configured to pay for model inference costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.
               
               If the collaboration creator hasn't specified anyone as the member paying for model inference costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> builtins.bool:
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for model inference costs ( `TRUE` ) or has not configured the collaboration member to pay for model inference costs ( `FALSE` ).

        Exactly one member can be configured to pay for model inference costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        If the collaboration creator hasn't specified anyone as the member paying for model inference costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        return pulumi.get(self, "is_responsible")


@pulumi.output_type
class CollaborationModelTrainingPaymentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isResponsible":
            suggest = "is_responsible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationModelTrainingPaymentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationModelTrainingPaymentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationModelTrainingPaymentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_responsible: builtins.bool):
        """
        :param builtins.bool is_responsible: Indicates whether the collaboration creator has configured the collaboration member to pay for model training costs ( `TRUE` ) or has not configured the collaboration member to pay for model training costs ( `FALSE` ).
               
               Exactly one member can be configured to pay for model training costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.
               
               If the collaboration creator hasn't specified anyone as the member paying for model training costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> builtins.bool:
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for model training costs ( `TRUE` ) or has not configured the collaboration member to pay for model training costs ( `FALSE` ).

        Exactly one member can be configured to pay for model training costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        If the collaboration creator hasn't specified anyone as the member paying for model training costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        return pulumi.get(self, "is_responsible")


@pulumi.output_type
class CollaborationPaymentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryCompute":
            suggest = "query_compute"
        elif key == "jobCompute":
            suggest = "job_compute"
        elif key == "machineLearning":
            suggest = "machine_learning"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationPaymentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationPaymentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationPaymentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_compute: 'outputs.CollaborationQueryComputePaymentConfig',
                 job_compute: Optional['outputs.CollaborationJobComputePaymentConfig'] = None,
                 machine_learning: Optional['outputs.CollaborationMlPaymentConfig'] = None):
        """
        :param 'CollaborationQueryComputePaymentConfig' query_compute: The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        :param 'CollaborationJobComputePaymentConfig' job_compute: The compute configuration for the job.
        :param 'CollaborationMlPaymentConfig' machine_learning: An object representing the collaboration member's machine learning payment responsibilities set by the collaboration creator.
        """
        pulumi.set(__self__, "query_compute", query_compute)
        if job_compute is not None:
            pulumi.set(__self__, "job_compute", job_compute)
        if machine_learning is not None:
            pulumi.set(__self__, "machine_learning", machine_learning)

    @property
    @pulumi.getter(name="queryCompute")
    def query_compute(self) -> 'outputs.CollaborationQueryComputePaymentConfig':
        """
        The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        """
        return pulumi.get(self, "query_compute")

    @property
    @pulumi.getter(name="jobCompute")
    def job_compute(self) -> Optional['outputs.CollaborationJobComputePaymentConfig']:
        """
        The compute configuration for the job.
        """
        return pulumi.get(self, "job_compute")

    @property
    @pulumi.getter(name="machineLearning")
    def machine_learning(self) -> Optional['outputs.CollaborationMlPaymentConfig']:
        """
        An object representing the collaboration member's machine learning payment responsibilities set by the collaboration creator.
        """
        return pulumi.get(self, "machine_learning")


@pulumi.output_type
class CollaborationQueryComputePaymentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isResponsible":
            suggest = "is_responsible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationQueryComputePaymentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationQueryComputePaymentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationQueryComputePaymentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_responsible: builtins.bool):
        """
        :param builtins.bool is_responsible: Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query compute costs ( `FALSE` ).
               
               Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.
               
               If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> builtins.bool:
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query compute costs ( `FALSE` ).

        Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        return pulumi.get(self, "is_responsible")


@pulumi.output_type
class ConfiguredTableAggregateColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAggregateColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAggregateColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAggregateColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Sequence[builtins.str],
                 function: 'ConfiguredTableAggregateFunctionName'):
        pulumi.set(__self__, "column_names", column_names)
        pulumi.set(__self__, "function", function)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "column_names")

    @property
    @pulumi.getter
    def function(self) -> 'ConfiguredTableAggregateFunctionName':
        return pulumi.get(self, "function")


@pulumi.output_type
class ConfiguredTableAggregationConstraint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAggregationConstraint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAggregationConstraint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAggregationConstraint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: builtins.str,
                 minimum: builtins.float,
                 type: 'ConfiguredTableAggregationType'):
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "minimum", minimum)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> builtins.str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def minimum(self) -> builtins.float:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def type(self) -> 'ConfiguredTableAggregationType':
        return pulumi.get(self, "type")


@pulumi.output_type
class ConfiguredTableAnalysisRule(dict):
    def __init__(__self__, *,
                 policy: 'outputs.ConfiguredTableAnalysisRulePolicy',
                 type: 'ConfiguredTableAnalysisRuleType'):
        """
        :param 'ConfiguredTableAnalysisRulePolicy' policy: A policy that describes the associated data usage limitations.
        :param 'ConfiguredTableAnalysisRuleType' type: The type of analysis rule.
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def policy(self) -> 'outputs.ConfiguredTableAnalysisRulePolicy':
        """
        A policy that describes the associated data usage limitations.
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def type(self) -> 'ConfiguredTableAnalysisRuleType':
        """
        The type of analysis rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ConfiguredTableAnalysisRuleAggregation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateColumns":
            suggest = "aggregate_columns"
        elif key == "dimensionColumns":
            suggest = "dimension_columns"
        elif key == "joinColumns":
            suggest = "join_columns"
        elif key == "outputConstraints":
            suggest = "output_constraints"
        elif key == "scalarFunctions":
            suggest = "scalar_functions"
        elif key == "additionalAnalyses":
            suggest = "additional_analyses"
        elif key == "allowedJoinOperators":
            suggest = "allowed_join_operators"
        elif key == "joinRequired":
            suggest = "join_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAnalysisRuleAggregation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAnalysisRuleAggregation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAnalysisRuleAggregation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregate_columns: Sequence['outputs.ConfiguredTableAggregateColumn'],
                 dimension_columns: Sequence[builtins.str],
                 join_columns: Sequence[builtins.str],
                 output_constraints: Sequence['outputs.ConfiguredTableAggregationConstraint'],
                 scalar_functions: Sequence['ConfiguredTableScalarFunctions'],
                 additional_analyses: Optional['ConfiguredTableAdditionalAnalyses'] = None,
                 allowed_join_operators: Optional[Sequence['ConfiguredTableJoinOperator']] = None,
                 join_required: Optional['ConfiguredTableJoinRequiredOption'] = None):
        pulumi.set(__self__, "aggregate_columns", aggregate_columns)
        pulumi.set(__self__, "dimension_columns", dimension_columns)
        pulumi.set(__self__, "join_columns", join_columns)
        pulumi.set(__self__, "output_constraints", output_constraints)
        pulumi.set(__self__, "scalar_functions", scalar_functions)
        if additional_analyses is not None:
            pulumi.set(__self__, "additional_analyses", additional_analyses)
        if allowed_join_operators is not None:
            pulumi.set(__self__, "allowed_join_operators", allowed_join_operators)
        if join_required is not None:
            pulumi.set(__self__, "join_required", join_required)

    @property
    @pulumi.getter(name="aggregateColumns")
    def aggregate_columns(self) -> Sequence['outputs.ConfiguredTableAggregateColumn']:
        return pulumi.get(self, "aggregate_columns")

    @property
    @pulumi.getter(name="dimensionColumns")
    def dimension_columns(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "dimension_columns")

    @property
    @pulumi.getter(name="joinColumns")
    def join_columns(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "join_columns")

    @property
    @pulumi.getter(name="outputConstraints")
    def output_constraints(self) -> Sequence['outputs.ConfiguredTableAggregationConstraint']:
        return pulumi.get(self, "output_constraints")

    @property
    @pulumi.getter(name="scalarFunctions")
    def scalar_functions(self) -> Sequence['ConfiguredTableScalarFunctions']:
        return pulumi.get(self, "scalar_functions")

    @property
    @pulumi.getter(name="additionalAnalyses")
    def additional_analyses(self) -> Optional['ConfiguredTableAdditionalAnalyses']:
        return pulumi.get(self, "additional_analyses")

    @property
    @pulumi.getter(name="allowedJoinOperators")
    def allowed_join_operators(self) -> Optional[Sequence['ConfiguredTableJoinOperator']]:
        return pulumi.get(self, "allowed_join_operators")

    @property
    @pulumi.getter(name="joinRequired")
    def join_required(self) -> Optional['ConfiguredTableJoinRequiredOption']:
        return pulumi.get(self, "join_required")


@pulumi.output_type
class ConfiguredTableAnalysisRuleCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAnalyses":
            suggest = "allowed_analyses"
        elif key == "additionalAnalyses":
            suggest = "additional_analyses"
        elif key == "allowedAnalysisProviders":
            suggest = "allowed_analysis_providers"
        elif key == "differentialPrivacy":
            suggest = "differential_privacy"
        elif key == "disallowedOutputColumns":
            suggest = "disallowed_output_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAnalysisRuleCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAnalysisRuleCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAnalysisRuleCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_analyses: Sequence[builtins.str],
                 additional_analyses: Optional['ConfiguredTableAdditionalAnalyses'] = None,
                 allowed_analysis_providers: Optional[Sequence[builtins.str]] = None,
                 differential_privacy: Optional['outputs.ConfiguredTableDifferentialPrivacy'] = None,
                 disallowed_output_columns: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "allowed_analyses", allowed_analyses)
        if additional_analyses is not None:
            pulumi.set(__self__, "additional_analyses", additional_analyses)
        if allowed_analysis_providers is not None:
            pulumi.set(__self__, "allowed_analysis_providers", allowed_analysis_providers)
        if differential_privacy is not None:
            pulumi.set(__self__, "differential_privacy", differential_privacy)
        if disallowed_output_columns is not None:
            pulumi.set(__self__, "disallowed_output_columns", disallowed_output_columns)

    @property
    @pulumi.getter(name="allowedAnalyses")
    def allowed_analyses(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "allowed_analyses")

    @property
    @pulumi.getter(name="additionalAnalyses")
    def additional_analyses(self) -> Optional['ConfiguredTableAdditionalAnalyses']:
        return pulumi.get(self, "additional_analyses")

    @property
    @pulumi.getter(name="allowedAnalysisProviders")
    def allowed_analysis_providers(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "allowed_analysis_providers")

    @property
    @pulumi.getter(name="differentialPrivacy")
    def differential_privacy(self) -> Optional['outputs.ConfiguredTableDifferentialPrivacy']:
        return pulumi.get(self, "differential_privacy")

    @property
    @pulumi.getter(name="disallowedOutputColumns")
    def disallowed_output_columns(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "disallowed_output_columns")


@pulumi.output_type
class ConfiguredTableAnalysisRuleList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "joinColumns":
            suggest = "join_columns"
        elif key == "listColumns":
            suggest = "list_columns"
        elif key == "additionalAnalyses":
            suggest = "additional_analyses"
        elif key == "allowedJoinOperators":
            suggest = "allowed_join_operators"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAnalysisRuleList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAnalysisRuleList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAnalysisRuleList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 join_columns: Sequence[builtins.str],
                 list_columns: Sequence[builtins.str],
                 additional_analyses: Optional['ConfiguredTableAdditionalAnalyses'] = None,
                 allowed_join_operators: Optional[Sequence['ConfiguredTableJoinOperator']] = None):
        pulumi.set(__self__, "join_columns", join_columns)
        pulumi.set(__self__, "list_columns", list_columns)
        if additional_analyses is not None:
            pulumi.set(__self__, "additional_analyses", additional_analyses)
        if allowed_join_operators is not None:
            pulumi.set(__self__, "allowed_join_operators", allowed_join_operators)

    @property
    @pulumi.getter(name="joinColumns")
    def join_columns(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "join_columns")

    @property
    @pulumi.getter(name="listColumns")
    def list_columns(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "list_columns")

    @property
    @pulumi.getter(name="additionalAnalyses")
    def additional_analyses(self) -> Optional['ConfiguredTableAdditionalAnalyses']:
        return pulumi.get(self, "additional_analyses")

    @property
    @pulumi.getter(name="allowedJoinOperators")
    def allowed_join_operators(self) -> Optional[Sequence['ConfiguredTableJoinOperator']]:
        return pulumi.get(self, "allowed_join_operators")


@pulumi.output_type
class ConfiguredTableAnalysisRulePolicy(dict):
    def __init__(__self__, *,
                 v1: Any):
        """
        :param Union['ConfiguredTableAnalysisRulePolicyV10Properties', 'ConfiguredTableAnalysisRulePolicyV11Properties', 'ConfiguredTableAnalysisRulePolicyV12Properties'] v1: Controls on the query specifications that can be run on a configured table.
        """
        pulumi.set(__self__, "v1", v1)

    @property
    @pulumi.getter
    def v1(self) -> Any:
        """
        Controls on the query specifications that can be run on a configured table.
        """
        return pulumi.get(self, "v1")


@pulumi.output_type
class ConfiguredTableAnalysisRulePolicyV10Properties(dict):
    def __init__(__self__, *,
                 list: 'outputs.ConfiguredTableAnalysisRuleList'):
        pulumi.set(__self__, "list", list)

    @property
    @pulumi.getter
    def list(self) -> 'outputs.ConfiguredTableAnalysisRuleList':
        return pulumi.get(self, "list")


@pulumi.output_type
class ConfiguredTableAnalysisRulePolicyV11Properties(dict):
    def __init__(__self__, *,
                 aggregation: 'outputs.ConfiguredTableAnalysisRuleAggregation'):
        pulumi.set(__self__, "aggregation", aggregation)

    @property
    @pulumi.getter
    def aggregation(self) -> 'outputs.ConfiguredTableAnalysisRuleAggregation':
        return pulumi.get(self, "aggregation")


@pulumi.output_type
class ConfiguredTableAnalysisRulePolicyV12Properties(dict):
    def __init__(__self__, *,
                 custom: 'outputs.ConfiguredTableAnalysisRuleCustom'):
        pulumi.set(__self__, "custom", custom)

    @property
    @pulumi.getter
    def custom(self) -> 'outputs.ConfiguredTableAnalysisRuleCustom':
        return pulumi.get(self, "custom")


@pulumi.output_type
class ConfiguredTableAssociationAnalysisRule(dict):
    def __init__(__self__, *,
                 policy: 'outputs.ConfiguredTableAssociationAnalysisRulePolicy',
                 type: 'ConfiguredTableAssociationAnalysisRuleType'):
        """
        :param 'ConfiguredTableAssociationAnalysisRulePolicy' policy: The policy of the configured table association analysis rule.
        :param 'ConfiguredTableAssociationAnalysisRuleType' type: The type of the configured table association analysis rule.
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def policy(self) -> 'outputs.ConfiguredTableAssociationAnalysisRulePolicy':
        """
        The policy of the configured table association analysis rule.
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def type(self) -> 'ConfiguredTableAssociationAnalysisRuleType':
        """
        The type of the configured table association analysis rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ConfiguredTableAssociationAnalysisRuleAggregation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAdditionalAnalyses":
            suggest = "allowed_additional_analyses"
        elif key == "allowedResultReceivers":
            suggest = "allowed_result_receivers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAssociationAnalysisRuleAggregation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAssociationAnalysisRuleAggregation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAssociationAnalysisRuleAggregation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_additional_analyses: Optional[Sequence[builtins.str]] = None,
                 allowed_result_receivers: Optional[Sequence[builtins.str]] = None):
        if allowed_additional_analyses is not None:
            pulumi.set(__self__, "allowed_additional_analyses", allowed_additional_analyses)
        if allowed_result_receivers is not None:
            pulumi.set(__self__, "allowed_result_receivers", allowed_result_receivers)

    @property
    @pulumi.getter(name="allowedAdditionalAnalyses")
    def allowed_additional_analyses(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "allowed_additional_analyses")

    @property
    @pulumi.getter(name="allowedResultReceivers")
    def allowed_result_receivers(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "allowed_result_receivers")


@pulumi.output_type
class ConfiguredTableAssociationAnalysisRuleCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAdditionalAnalyses":
            suggest = "allowed_additional_analyses"
        elif key == "allowedResultReceivers":
            suggest = "allowed_result_receivers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAssociationAnalysisRuleCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAssociationAnalysisRuleCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAssociationAnalysisRuleCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_additional_analyses: Optional[Sequence[builtins.str]] = None,
                 allowed_result_receivers: Optional[Sequence[builtins.str]] = None):
        if allowed_additional_analyses is not None:
            pulumi.set(__self__, "allowed_additional_analyses", allowed_additional_analyses)
        if allowed_result_receivers is not None:
            pulumi.set(__self__, "allowed_result_receivers", allowed_result_receivers)

    @property
    @pulumi.getter(name="allowedAdditionalAnalyses")
    def allowed_additional_analyses(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "allowed_additional_analyses")

    @property
    @pulumi.getter(name="allowedResultReceivers")
    def allowed_result_receivers(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "allowed_result_receivers")


@pulumi.output_type
class ConfiguredTableAssociationAnalysisRuleList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAdditionalAnalyses":
            suggest = "allowed_additional_analyses"
        elif key == "allowedResultReceivers":
            suggest = "allowed_result_receivers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAssociationAnalysisRuleList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAssociationAnalysisRuleList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAssociationAnalysisRuleList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_additional_analyses: Optional[Sequence[builtins.str]] = None,
                 allowed_result_receivers: Optional[Sequence[builtins.str]] = None):
        if allowed_additional_analyses is not None:
            pulumi.set(__self__, "allowed_additional_analyses", allowed_additional_analyses)
        if allowed_result_receivers is not None:
            pulumi.set(__self__, "allowed_result_receivers", allowed_result_receivers)

    @property
    @pulumi.getter(name="allowedAdditionalAnalyses")
    def allowed_additional_analyses(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "allowed_additional_analyses")

    @property
    @pulumi.getter(name="allowedResultReceivers")
    def allowed_result_receivers(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "allowed_result_receivers")


@pulumi.output_type
class ConfiguredTableAssociationAnalysisRulePolicy(dict):
    def __init__(__self__, *,
                 v1: Any):
        """
        :param Union['ConfiguredTableAssociationAnalysisRulePolicyV10Properties', 'ConfiguredTableAssociationAnalysisRulePolicyV11Properties', 'ConfiguredTableAssociationAnalysisRulePolicyV12Properties'] v1: The policy for the configured table association analysis rule.
        """
        pulumi.set(__self__, "v1", v1)

    @property
    @pulumi.getter
    def v1(self) -> Any:
        """
        The policy for the configured table association analysis rule.
        """
        return pulumi.get(self, "v1")


@pulumi.output_type
class ConfiguredTableAssociationAnalysisRulePolicyV10Properties(dict):
    def __init__(__self__, *,
                 list: 'outputs.ConfiguredTableAssociationAnalysisRuleList'):
        pulumi.set(__self__, "list", list)

    @property
    @pulumi.getter
    def list(self) -> 'outputs.ConfiguredTableAssociationAnalysisRuleList':
        return pulumi.get(self, "list")


@pulumi.output_type
class ConfiguredTableAssociationAnalysisRulePolicyV11Properties(dict):
    def __init__(__self__, *,
                 aggregation: 'outputs.ConfiguredTableAssociationAnalysisRuleAggregation'):
        pulumi.set(__self__, "aggregation", aggregation)

    @property
    @pulumi.getter
    def aggregation(self) -> 'outputs.ConfiguredTableAssociationAnalysisRuleAggregation':
        return pulumi.get(self, "aggregation")


@pulumi.output_type
class ConfiguredTableAssociationAnalysisRulePolicyV12Properties(dict):
    def __init__(__self__, *,
                 custom: 'outputs.ConfiguredTableAssociationAnalysisRuleCustom'):
        pulumi.set(__self__, "custom", custom)

    @property
    @pulumi.getter
    def custom(self) -> 'outputs.ConfiguredTableAssociationAnalysisRuleCustom':
        return pulumi.get(self, "custom")


@pulumi.output_type
class ConfiguredTableAthenaTableReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "workGroup":
            suggest = "work_group"
        elif key == "outputLocation":
            suggest = "output_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAthenaTableReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAthenaTableReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAthenaTableReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: builtins.str,
                 table_name: builtins.str,
                 work_group: builtins.str,
                 output_location: Optional[builtins.str] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "work_group", work_group)
        if output_location is not None:
            pulumi.set(__self__, "output_location", output_location)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> builtins.str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> builtins.str:
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="workGroup")
    def work_group(self) -> builtins.str:
        return pulumi.get(self, "work_group")

    @property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> Optional[builtins.str]:
        return pulumi.get(self, "output_location")


@pulumi.output_type
class ConfiguredTableDifferentialPrivacy(dict):
    def __init__(__self__, *,
                 columns: Sequence['outputs.ConfiguredTableDifferentialPrivacyColumn']):
        pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.ConfiguredTableDifferentialPrivacyColumn']:
        return pulumi.get(self, "columns")


@pulumi.output_type
class ConfiguredTableDifferentialPrivacyColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class ConfiguredTableGlueTableReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableGlueTableReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableGlueTableReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableGlueTableReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: builtins.str,
                 table_name: builtins.str):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> builtins.str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> builtins.str:
        return pulumi.get(self, "table_name")


@pulumi.output_type
class ConfiguredTableSnowflakeTableReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountIdentifier":
            suggest = "account_identifier"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "secretArn":
            suggest = "secret_arn"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "tableSchema":
            suggest = "table_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableSnowflakeTableReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableSnowflakeTableReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableSnowflakeTableReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_identifier: builtins.str,
                 database_name: builtins.str,
                 schema_name: builtins.str,
                 secret_arn: builtins.str,
                 table_name: builtins.str,
                 table_schema: 'outputs.ConfiguredTableSnowflakeTableSchemaProperties'):
        pulumi.set(__self__, "account_identifier", account_identifier)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "secret_arn", secret_arn)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "table_schema", table_schema)

    @property
    @pulumi.getter(name="accountIdentifier")
    def account_identifier(self) -> builtins.str:
        return pulumi.get(self, "account_identifier")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> builtins.str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> builtins.str:
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> builtins.str:
        return pulumi.get(self, "secret_arn")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> builtins.str:
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="tableSchema")
    def table_schema(self) -> 'outputs.ConfiguredTableSnowflakeTableSchemaProperties':
        return pulumi.get(self, "table_schema")


@pulumi.output_type
class ConfiguredTableSnowflakeTableSchemaProperties(dict):
    def __init__(__self__, *,
                 v1: Sequence['outputs.ConfiguredTableSnowflakeTableSchemaV1']):
        pulumi.set(__self__, "v1", v1)

    @property
    @pulumi.getter
    def v1(self) -> Sequence['outputs.ConfiguredTableSnowflakeTableSchemaV1']:
        return pulumi.get(self, "v1")


@pulumi.output_type
class ConfiguredTableSnowflakeTableSchemaV1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "columnType":
            suggest = "column_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableSnowflakeTableSchemaV1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableSnowflakeTableSchemaV1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableSnowflakeTableSchemaV1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: builtins.str,
                 column_type: builtins.str):
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "column_type", column_type)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> builtins.str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="columnType")
    def column_type(self) -> builtins.str:
        return pulumi.get(self, "column_type")


@pulumi.output_type
class ConfiguredTableTableReference0Properties(dict):
    def __init__(__self__, *,
                 glue: 'outputs.ConfiguredTableGlueTableReference'):
        pulumi.set(__self__, "glue", glue)

    @property
    @pulumi.getter
    def glue(self) -> 'outputs.ConfiguredTableGlueTableReference':
        return pulumi.get(self, "glue")


@pulumi.output_type
class ConfiguredTableTableReference1Properties(dict):
    def __init__(__self__, *,
                 snowflake: 'outputs.ConfiguredTableSnowflakeTableReference'):
        pulumi.set(__self__, "snowflake", snowflake)

    @property
    @pulumi.getter
    def snowflake(self) -> 'outputs.ConfiguredTableSnowflakeTableReference':
        return pulumi.get(self, "snowflake")


@pulumi.output_type
class ConfiguredTableTableReference2Properties(dict):
    def __init__(__self__, *,
                 athena: 'outputs.ConfiguredTableAthenaTableReference'):
        pulumi.set(__self__, "athena", athena)

    @property
    @pulumi.getter
    def athena(self) -> 'outputs.ConfiguredTableAthenaTableReference':
        return pulumi.get(self, "athena")


@pulumi.output_type
class IdMappingTableInputReferenceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputReferenceArn":
            suggest = "input_reference_arn"
        elif key == "manageResourcePolicies":
            suggest = "manage_resource_policies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdMappingTableInputReferenceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdMappingTableInputReferenceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdMappingTableInputReferenceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_reference_arn: builtins.str,
                 manage_resource_policies: builtins.bool):
        """
        :param builtins.str input_reference_arn: The Amazon Resource Name (ARN) of the referenced resource in AWS Entity Resolution . Valid values are ID mapping workflow ARNs.
        :param builtins.bool manage_resource_policies: When `TRUE` , AWS Clean Rooms manages permissions for the ID mapping table resource.
               
               When `FALSE` , the resource owner manages permissions for the ID mapping table resource.
        """
        pulumi.set(__self__, "input_reference_arn", input_reference_arn)
        pulumi.set(__self__, "manage_resource_policies", manage_resource_policies)

    @property
    @pulumi.getter(name="inputReferenceArn")
    def input_reference_arn(self) -> builtins.str:
        """
        The Amazon Resource Name (ARN) of the referenced resource in AWS Entity Resolution . Valid values are ID mapping workflow ARNs.
        """
        return pulumi.get(self, "input_reference_arn")

    @property
    @pulumi.getter(name="manageResourcePolicies")
    def manage_resource_policies(self) -> builtins.bool:
        """
        When `TRUE` , AWS Clean Rooms manages permissions for the ID mapping table resource.

        When `FALSE` , the resource owner manages permissions for the ID mapping table resource.
        """
        return pulumi.get(self, "manage_resource_policies")


@pulumi.output_type
class IdMappingTableInputReferenceProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idMappingTableInputSource":
            suggest = "id_mapping_table_input_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdMappingTableInputReferenceProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdMappingTableInputReferenceProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdMappingTableInputReferenceProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id_mapping_table_input_source: Sequence['outputs.IdMappingTableInputSource']):
        """
        :param Sequence['IdMappingTableInputSource'] id_mapping_table_input_source: The input source of the ID mapping table.
        """
        pulumi.set(__self__, "id_mapping_table_input_source", id_mapping_table_input_source)

    @property
    @pulumi.getter(name="idMappingTableInputSource")
    def id_mapping_table_input_source(self) -> Sequence['outputs.IdMappingTableInputSource']:
        """
        The input source of the ID mapping table.
        """
        return pulumi.get(self, "id_mapping_table_input_source")


@pulumi.output_type
class IdMappingTableInputSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idNamespaceAssociationId":
            suggest = "id_namespace_association_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdMappingTableInputSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdMappingTableInputSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdMappingTableInputSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id_namespace_association_id: builtins.str,
                 type: 'IdMappingTableInputSourceType'):
        """
        :param builtins.str id_namespace_association_id: The unique identifier of the ID namespace association.
        :param 'IdMappingTableInputSourceType' type: The type of the input source of the ID mapping table.
        """
        pulumi.set(__self__, "id_namespace_association_id", id_namespace_association_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="idNamespaceAssociationId")
    def id_namespace_association_id(self) -> builtins.str:
        """
        The unique identifier of the ID namespace association.
        """
        return pulumi.get(self, "id_namespace_association_id")

    @property
    @pulumi.getter
    def type(self) -> 'IdMappingTableInputSourceType':
        """
        The type of the input source of the ID mapping table.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IdNamespaceAssociationDocument(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IdNamespaceAssociationIdMappingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowUseAsDimensionColumn":
            suggest = "allow_use_as_dimension_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdNamespaceAssociationIdMappingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdNamespaceAssociationIdMappingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdNamespaceAssociationIdMappingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_use_as_dimension_column: builtins.bool):
        """
        :param builtins.bool allow_use_as_dimension_column: An indicator as to whether you can use your column as a dimension column in the ID mapping table ( `TRUE` ) or not ( `FALSE` ).
               
               Default is `FALSE` .
        """
        pulumi.set(__self__, "allow_use_as_dimension_column", allow_use_as_dimension_column)

    @property
    @pulumi.getter(name="allowUseAsDimensionColumn")
    def allow_use_as_dimension_column(self) -> builtins.bool:
        """
        An indicator as to whether you can use your column as a dimension column in the ID mapping table ( `TRUE` ) or not ( `FALSE` ).

        Default is `FALSE` .
        """
        return pulumi.get(self, "allow_use_as_dimension_column")


@pulumi.output_type
class IdNamespaceAssociationInputReferenceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputReferenceArn":
            suggest = "input_reference_arn"
        elif key == "manageResourcePolicies":
            suggest = "manage_resource_policies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdNamespaceAssociationInputReferenceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdNamespaceAssociationInputReferenceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdNamespaceAssociationInputReferenceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_reference_arn: builtins.str,
                 manage_resource_policies: builtins.bool):
        """
        :param builtins.str input_reference_arn: The Amazon Resource Name (ARN) of the AWS Entity Resolution resource that is being associated to the collaboration. Valid resource ARNs are from the ID namespaces that you own.
        :param builtins.bool manage_resource_policies: When `TRUE` , AWS Clean Rooms manages permissions for the ID namespace association resource.
               
               When `FALSE` , the resource owner manages permissions for the ID namespace association resource.
        """
        pulumi.set(__self__, "input_reference_arn", input_reference_arn)
        pulumi.set(__self__, "manage_resource_policies", manage_resource_policies)

    @property
    @pulumi.getter(name="inputReferenceArn")
    def input_reference_arn(self) -> builtins.str:
        """
        The Amazon Resource Name (ARN) of the AWS Entity Resolution resource that is being associated to the collaboration. Valid resource ARNs are from the ID namespaces that you own.
        """
        return pulumi.get(self, "input_reference_arn")

    @property
    @pulumi.getter(name="manageResourcePolicies")
    def manage_resource_policies(self) -> builtins.bool:
        """
        When `TRUE` , AWS Clean Rooms manages permissions for the ID namespace association resource.

        When `FALSE` , the resource owner manages permissions for the ID namespace association resource.
        """
        return pulumi.get(self, "manage_resource_policies")


@pulumi.output_type
class IdNamespaceAssociationInputReferenceProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idMappingWorkflowsSupported":
            suggest = "id_mapping_workflows_supported"
        elif key == "idNamespaceType":
            suggest = "id_namespace_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdNamespaceAssociationInputReferenceProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdNamespaceAssociationInputReferenceProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdNamespaceAssociationInputReferenceProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id_mapping_workflows_supported: Optional[Sequence['outputs.IdNamespaceAssociationDocument']] = None,
                 id_namespace_type: Optional['IdNamespaceAssociationInputReferencePropertiesIdNamespaceType'] = None):
        """
        :param Sequence['IdNamespaceAssociationDocument'] id_mapping_workflows_supported: Defines how ID mapping workflows are supported for this ID namespace association.
        :param 'IdNamespaceAssociationInputReferencePropertiesIdNamespaceType' id_namespace_type: The ID namespace type for this ID namespace association.
        """
        if id_mapping_workflows_supported is not None:
            pulumi.set(__self__, "id_mapping_workflows_supported", id_mapping_workflows_supported)
        if id_namespace_type is not None:
            pulumi.set(__self__, "id_namespace_type", id_namespace_type)

    @property
    @pulumi.getter(name="idMappingWorkflowsSupported")
    def id_mapping_workflows_supported(self) -> Optional[Sequence['outputs.IdNamespaceAssociationDocument']]:
        """
        Defines how ID mapping workflows are supported for this ID namespace association.
        """
        return pulumi.get(self, "id_mapping_workflows_supported")

    @property
    @pulumi.getter(name="idNamespaceType")
    def id_namespace_type(self) -> Optional['IdNamespaceAssociationInputReferencePropertiesIdNamespaceType']:
        """
        The ID namespace type for this ID namespace association.
        """
        return pulumi.get(self, "id_namespace_type")


@pulumi.output_type
class MembershipJobComputePaymentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isResponsible":
            suggest = "is_responsible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipJobComputePaymentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipJobComputePaymentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipJobComputePaymentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_responsible: builtins.bool):
        """
        :param builtins.bool is_responsible: Indicates whether the collaboration member has accepted to pay for job compute costs ( `TRUE` ) or has not accepted to pay for query and job compute costs ( `FALSE` ).
               
               There is only one member who pays for queries and jobs.
               
               An error message is returned for the following reasons:
               
               - If you set the value to `FALSE` but you are responsible to pay for query and job compute costs.
               - If you set the value to `TRUE` but you are not responsible to pay for query and job compute costs.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> builtins.bool:
        """
        Indicates whether the collaboration member has accepted to pay for job compute costs ( `TRUE` ) or has not accepted to pay for query and job compute costs ( `FALSE` ).

        There is only one member who pays for queries and jobs.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for query and job compute costs.
        - If you set the value to `TRUE` but you are not responsible to pay for query and job compute costs.
        """
        return pulumi.get(self, "is_responsible")


@pulumi.output_type
class MembershipMlPaymentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelInference":
            suggest = "model_inference"
        elif key == "modelTraining":
            suggest = "model_training"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipMlPaymentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipMlPaymentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipMlPaymentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_inference: Optional['outputs.MembershipModelInferencePaymentConfig'] = None,
                 model_training: Optional['outputs.MembershipModelTrainingPaymentConfig'] = None):
        """
        :param 'MembershipModelInferencePaymentConfig' model_inference: The payment responsibilities accepted by the member for model inference.
        :param 'MembershipModelTrainingPaymentConfig' model_training: The payment responsibilities accepted by the member for model training.
        """
        if model_inference is not None:
            pulumi.set(__self__, "model_inference", model_inference)
        if model_training is not None:
            pulumi.set(__self__, "model_training", model_training)

    @property
    @pulumi.getter(name="modelInference")
    def model_inference(self) -> Optional['outputs.MembershipModelInferencePaymentConfig']:
        """
        The payment responsibilities accepted by the member for model inference.
        """
        return pulumi.get(self, "model_inference")

    @property
    @pulumi.getter(name="modelTraining")
    def model_training(self) -> Optional['outputs.MembershipModelTrainingPaymentConfig']:
        """
        The payment responsibilities accepted by the member for model training.
        """
        return pulumi.get(self, "model_training")


@pulumi.output_type
class MembershipModelInferencePaymentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isResponsible":
            suggest = "is_responsible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipModelInferencePaymentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipModelInferencePaymentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipModelInferencePaymentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_responsible: builtins.bool):
        """
        :param builtins.bool is_responsible: Indicates whether the collaboration member has accepted to pay for model inference costs ( `TRUE` ) or has not accepted to pay for model inference costs ( `FALSE` ).
               
               If the collaboration creator has not specified anyone to pay for model inference costs, then the member who can query is the default payer.
               
               An error message is returned for the following reasons:
               
               - If you set the value to `FALSE` but you are responsible to pay for model inference costs.
               - If you set the value to `TRUE` but you are not responsible to pay for model inference costs.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> builtins.bool:
        """
        Indicates whether the collaboration member has accepted to pay for model inference costs ( `TRUE` ) or has not accepted to pay for model inference costs ( `FALSE` ).

        If the collaboration creator has not specified anyone to pay for model inference costs, then the member who can query is the default payer.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for model inference costs.
        - If you set the value to `TRUE` but you are not responsible to pay for model inference costs.
        """
        return pulumi.get(self, "is_responsible")


@pulumi.output_type
class MembershipModelTrainingPaymentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isResponsible":
            suggest = "is_responsible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipModelTrainingPaymentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipModelTrainingPaymentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipModelTrainingPaymentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_responsible: builtins.bool):
        """
        :param builtins.bool is_responsible: Indicates whether the collaboration member has accepted to pay for model training costs ( `TRUE` ) or has not accepted to pay for model training costs ( `FALSE` ).
               
               If the collaboration creator has not specified anyone to pay for model training costs, then the member who can query is the default payer.
               
               An error message is returned for the following reasons:
               
               - If you set the value to `FALSE` but you are responsible to pay for model training costs.
               - If you set the value to `TRUE` but you are not responsible to pay for model training costs.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> builtins.bool:
        """
        Indicates whether the collaboration member has accepted to pay for model training costs ( `TRUE` ) or has not accepted to pay for model training costs ( `FALSE` ).

        If the collaboration creator has not specified anyone to pay for model training costs, then the member who can query is the default payer.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for model training costs.
        - If you set the value to `TRUE` but you are not responsible to pay for model training costs.
        """
        return pulumi.get(self, "is_responsible")


@pulumi.output_type
class MembershipPaymentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryCompute":
            suggest = "query_compute"
        elif key == "jobCompute":
            suggest = "job_compute"
        elif key == "machineLearning":
            suggest = "machine_learning"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipPaymentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipPaymentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipPaymentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_compute: 'outputs.MembershipQueryComputePaymentConfig',
                 job_compute: Optional['outputs.MembershipJobComputePaymentConfig'] = None,
                 machine_learning: Optional['outputs.MembershipMlPaymentConfig'] = None):
        """
        :param 'MembershipQueryComputePaymentConfig' query_compute: The payment responsibilities accepted by the collaboration member for query compute costs.
        :param 'MembershipJobComputePaymentConfig' job_compute: The payment responsibilities accepted by the collaboration member for job compute costs.
        :param 'MembershipMlPaymentConfig' machine_learning: The payment responsibilities accepted by the collaboration member for machine learning costs.
        """
        pulumi.set(__self__, "query_compute", query_compute)
        if job_compute is not None:
            pulumi.set(__self__, "job_compute", job_compute)
        if machine_learning is not None:
            pulumi.set(__self__, "machine_learning", machine_learning)

    @property
    @pulumi.getter(name="queryCompute")
    def query_compute(self) -> 'outputs.MembershipQueryComputePaymentConfig':
        """
        The payment responsibilities accepted by the collaboration member for query compute costs.
        """
        return pulumi.get(self, "query_compute")

    @property
    @pulumi.getter(name="jobCompute")
    def job_compute(self) -> Optional['outputs.MembershipJobComputePaymentConfig']:
        """
        The payment responsibilities accepted by the collaboration member for job compute costs.
        """
        return pulumi.get(self, "job_compute")

    @property
    @pulumi.getter(name="machineLearning")
    def machine_learning(self) -> Optional['outputs.MembershipMlPaymentConfig']:
        """
        The payment responsibilities accepted by the collaboration member for machine learning costs.
        """
        return pulumi.get(self, "machine_learning")


@pulumi.output_type
class MembershipProtectedJobOutputConfiguration(dict):
    def __init__(__self__, *,
                 s3: 'outputs.MembershipProtectedJobS3OutputConfigurationInput'):
        """
        :param 'MembershipProtectedJobS3OutputConfigurationInput' s3: Contains the configuration to write the job results to S3.
        """
        pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def s3(self) -> 'outputs.MembershipProtectedJobS3OutputConfigurationInput':
        """
        Contains the configuration to write the job results to S3.
        """
        return pulumi.get(self, "s3")


@pulumi.output_type
class MembershipProtectedJobResultConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputConfiguration":
            suggest = "output_configuration"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipProtectedJobResultConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipProtectedJobResultConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipProtectedJobResultConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_configuration: 'outputs.MembershipProtectedJobOutputConfiguration',
                 role_arn: builtins.str):
        """
        :param 'MembershipProtectedJobOutputConfiguration' output_configuration: The output configuration for a protected job result.
        :param builtins.str role_arn: The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected job results to the result location, given by the member who can receive results.
        """
        pulumi.set(__self__, "output_configuration", output_configuration)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="outputConfiguration")
    def output_configuration(self) -> 'outputs.MembershipProtectedJobOutputConfiguration':
        """
        The output configuration for a protected job result.
        """
        return pulumi.get(self, "output_configuration")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> builtins.str:
        """
        The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected job results to the result location, given by the member who can receive results.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class MembershipProtectedJobS3OutputConfigurationInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyPrefix":
            suggest = "key_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipProtectedJobS3OutputConfigurationInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipProtectedJobS3OutputConfigurationInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipProtectedJobS3OutputConfigurationInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: builtins.str,
                 key_prefix: Optional[builtins.str] = None):
        """
        :param builtins.str bucket: The S3 bucket for job output.
        :param builtins.str key_prefix: The S3 prefix to unload the protected job results.
        """
        pulumi.set(__self__, "bucket", bucket)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)

    @property
    @pulumi.getter
    def bucket(self) -> builtins.str:
        """
        The S3 bucket for job output.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[builtins.str]:
        """
        The S3 prefix to unload the protected job results.
        """
        return pulumi.get(self, "key_prefix")


@pulumi.output_type
class MembershipProtectedQueryOutputConfiguration(dict):
    def __init__(__self__, *,
                 s3: 'outputs.MembershipProtectedQueryS3OutputConfiguration'):
        """
        :param 'MembershipProtectedQueryS3OutputConfiguration' s3: Required configuration for a protected query with an `s3` output type.
        """
        pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def s3(self) -> 'outputs.MembershipProtectedQueryS3OutputConfiguration':
        """
        Required configuration for a protected query with an `s3` output type.
        """
        return pulumi.get(self, "s3")


@pulumi.output_type
class MembershipProtectedQueryResultConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputConfiguration":
            suggest = "output_configuration"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipProtectedQueryResultConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipProtectedQueryResultConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipProtectedQueryResultConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_configuration: 'outputs.MembershipProtectedQueryOutputConfiguration',
                 role_arn: Optional[builtins.str] = None):
        """
        :param 'MembershipProtectedQueryOutputConfiguration' output_configuration: Configuration for protected query results.
        :param builtins.str role_arn: The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        """
        pulumi.set(__self__, "output_configuration", output_configuration)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="outputConfiguration")
    def output_configuration(self) -> 'outputs.MembershipProtectedQueryOutputConfiguration':
        """
        Configuration for protected query results.
        """
        return pulumi.get(self, "output_configuration")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class MembershipProtectedQueryS3OutputConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultFormat":
            suggest = "result_format"
        elif key == "keyPrefix":
            suggest = "key_prefix"
        elif key == "singleFileOutput":
            suggest = "single_file_output"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipProtectedQueryS3OutputConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipProtectedQueryS3OutputConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipProtectedQueryS3OutputConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: builtins.str,
                 result_format: 'MembershipResultFormat',
                 key_prefix: Optional[builtins.str] = None,
                 single_file_output: Optional[builtins.bool] = None):
        """
        :param builtins.str bucket: The S3 bucket to unload the protected query results.
        :param 'MembershipResultFormat' result_format: Intended file format of the result.
        :param builtins.str key_prefix: The S3 prefix to unload the protected query results.
        :param builtins.bool single_file_output: Indicates whether files should be output as a single file ( `TRUE` ) or output as multiple files ( `FALSE` ). This parameter is only supported for analyses with the Spark analytics engine.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "result_format", result_format)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)
        if single_file_output is not None:
            pulumi.set(__self__, "single_file_output", single_file_output)

    @property
    @pulumi.getter
    def bucket(self) -> builtins.str:
        """
        The S3 bucket to unload the protected query results.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="resultFormat")
    def result_format(self) -> 'MembershipResultFormat':
        """
        Intended file format of the result.
        """
        return pulumi.get(self, "result_format")

    @property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[builtins.str]:
        """
        The S3 prefix to unload the protected query results.
        """
        return pulumi.get(self, "key_prefix")

    @property
    @pulumi.getter(name="singleFileOutput")
    def single_file_output(self) -> Optional[builtins.bool]:
        """
        Indicates whether files should be output as a single file ( `TRUE` ) or output as multiple files ( `FALSE` ). This parameter is only supported for analyses with the Spark analytics engine.
        """
        return pulumi.get(self, "single_file_output")


@pulumi.output_type
class MembershipQueryComputePaymentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isResponsible":
            suggest = "is_responsible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipQueryComputePaymentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipQueryComputePaymentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipQueryComputePaymentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_responsible: builtins.bool):
        """
        :param builtins.bool is_responsible: Indicates whether the collaboration member has accepted to pay for query compute costs ( `TRUE` ) or has not accepted to pay for query compute costs ( `FALSE` ).
               
               If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer.
               
               An error message is returned for the following reasons:
               
               - If you set the value to `FALSE` but you are responsible to pay for query compute costs.
               - If you set the value to `TRUE` but you are not responsible to pay for query compute costs.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> builtins.bool:
        """
        Indicates whether the collaboration member has accepted to pay for query compute costs ( `TRUE` ) or has not accepted to pay for query compute costs ( `FALSE` ).

        If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for query compute costs.
        - If you set the value to `TRUE` but you are not responsible to pay for query compute costs.
        """
        return pulumi.get(self, "is_responsible")


@pulumi.output_type
class ParametersProperties(dict):
    """
    Specifies the epsilon and noise parameters for the privacy budget template.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usersNoisePerQuery":
            suggest = "users_noise_per_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ParametersProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ParametersProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ParametersProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epsilon: builtins.int,
                 users_noise_per_query: builtins.int):
        """
        Specifies the epsilon and noise parameters for the privacy budget template.
        :param builtins.int epsilon: The epsilon value that you want to use.
        :param builtins.int users_noise_per_query: Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        """
        pulumi.set(__self__, "epsilon", epsilon)
        pulumi.set(__self__, "users_noise_per_query", users_noise_per_query)

    @property
    @pulumi.getter
    def epsilon(self) -> builtins.int:
        """
        The epsilon value that you want to use.
        """
        return pulumi.get(self, "epsilon")

    @property
    @pulumi.getter(name="usersNoisePerQuery")
    def users_noise_per_query(self) -> builtins.int:
        """
        Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        """
        return pulumi.get(self, "users_noise_per_query")


