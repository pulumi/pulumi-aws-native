# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AnalysisTemplateAnalysisParameterArgs',
    'AnalysisTemplateAnalysisParameterArgsDict',
    'AnalysisTemplateAnalysisSourceArgs',
    'AnalysisTemplateAnalysisSourceArgsDict',
    'CollaborationDataEncryptionMetadataArgs',
    'CollaborationDataEncryptionMetadataArgsDict',
    'CollaborationMemberSpecificationArgs',
    'CollaborationMemberSpecificationArgsDict',
    'CollaborationPaymentConfigurationArgs',
    'CollaborationPaymentConfigurationArgsDict',
    'CollaborationQueryComputePaymentConfigArgs',
    'CollaborationQueryComputePaymentConfigArgsDict',
    'ConfiguredTableAggregateColumnArgs',
    'ConfiguredTableAggregateColumnArgsDict',
    'ConfiguredTableAggregationConstraintArgs',
    'ConfiguredTableAggregationConstraintArgsDict',
    'ConfiguredTableAnalysisRuleAggregationArgs',
    'ConfiguredTableAnalysisRuleAggregationArgsDict',
    'ConfiguredTableAnalysisRuleCustomArgs',
    'ConfiguredTableAnalysisRuleCustomArgsDict',
    'ConfiguredTableAnalysisRuleListArgs',
    'ConfiguredTableAnalysisRuleListArgsDict',
    'ConfiguredTableAnalysisRulePolicyV10PropertiesArgs',
    'ConfiguredTableAnalysisRulePolicyV10PropertiesArgsDict',
    'ConfiguredTableAnalysisRulePolicyV11PropertiesArgs',
    'ConfiguredTableAnalysisRulePolicyV11PropertiesArgsDict',
    'ConfiguredTableAnalysisRulePolicyV12PropertiesArgs',
    'ConfiguredTableAnalysisRulePolicyV12PropertiesArgsDict',
    'ConfiguredTableAnalysisRulePolicyArgs',
    'ConfiguredTableAnalysisRulePolicyArgsDict',
    'ConfiguredTableAnalysisRuleArgs',
    'ConfiguredTableAnalysisRuleArgsDict',
    'ConfiguredTableAssociationAnalysisRuleAggregationArgs',
    'ConfiguredTableAssociationAnalysisRuleAggregationArgsDict',
    'ConfiguredTableAssociationAnalysisRuleCustomArgs',
    'ConfiguredTableAssociationAnalysisRuleCustomArgsDict',
    'ConfiguredTableAssociationAnalysisRuleListArgs',
    'ConfiguredTableAssociationAnalysisRuleListArgsDict',
    'ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs',
    'ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgsDict',
    'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs',
    'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgsDict',
    'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs',
    'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgsDict',
    'ConfiguredTableAssociationAnalysisRulePolicyArgs',
    'ConfiguredTableAssociationAnalysisRulePolicyArgsDict',
    'ConfiguredTableAssociationAnalysisRuleArgs',
    'ConfiguredTableAssociationAnalysisRuleArgsDict',
    'ConfiguredTableDifferentialPrivacyColumnArgs',
    'ConfiguredTableDifferentialPrivacyColumnArgsDict',
    'ConfiguredTableDifferentialPrivacyArgs',
    'ConfiguredTableDifferentialPrivacyArgsDict',
    'ConfiguredTableGlueTableReferenceArgs',
    'ConfiguredTableGlueTableReferenceArgsDict',
    'ConfiguredTableTableReferenceArgs',
    'ConfiguredTableTableReferenceArgsDict',
    'IdMappingTableInputReferenceConfigArgs',
    'IdMappingTableInputReferenceConfigArgsDict',
    'IdNamespaceAssociationIdMappingConfigArgs',
    'IdNamespaceAssociationIdMappingConfigArgsDict',
    'IdNamespaceAssociationInputReferenceConfigArgs',
    'IdNamespaceAssociationInputReferenceConfigArgsDict',
    'MembershipPaymentConfigurationArgs',
    'MembershipPaymentConfigurationArgsDict',
    'MembershipProtectedQueryOutputConfigurationArgs',
    'MembershipProtectedQueryOutputConfigurationArgsDict',
    'MembershipProtectedQueryResultConfigurationArgs',
    'MembershipProtectedQueryResultConfigurationArgsDict',
    'MembershipProtectedQueryS3OutputConfigurationArgs',
    'MembershipProtectedQueryS3OutputConfigurationArgsDict',
    'MembershipQueryComputePaymentConfigArgs',
    'MembershipQueryComputePaymentConfigArgsDict',
    'ParametersPropertiesArgs',
    'ParametersPropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class AnalysisTemplateAnalysisParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        """
        type: pulumi.Input['AnalysisTemplateAnalysisParameterType']
        """
        The type of parameter.
        """
        default_value: NotRequired[pulumi.Input[str]]
        """
        Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        """
elif False:
    AnalysisTemplateAnalysisParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateAnalysisParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input['AnalysisTemplateAnalysisParameterType'],
                 default_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        :param pulumi.Input['AnalysisTemplateAnalysisParameterType'] type: The type of parameter.
        :param pulumi.Input[str] default_value: Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['AnalysisTemplateAnalysisParameterType']:
        """
        The type of parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['AnalysisTemplateAnalysisParameterType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_value", value)


if not MYPY:
    class AnalysisTemplateAnalysisSourceArgsDict(TypedDict):
        text: pulumi.Input[str]
        """
        The query text.
        """
elif False:
    AnalysisTemplateAnalysisSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateAnalysisSourceArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[str]):
        """
        :param pulumi.Input[str] text: The query text.
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The query text.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CollaborationDataEncryptionMetadataArgsDict(TypedDict):
        allow_cleartext: pulumi.Input[bool]
        """
        Indicates whether encrypted tables can contain cleartext data ( `TRUE` ) or are to cryptographically process every column ( `FALSE` ).
        """
        allow_duplicates: pulumi.Input[bool]
        """
        Indicates whether Fingerprint columns can contain duplicate entries ( `TRUE` ) or are to contain only non-repeated values ( `FALSE` ).
        """
        allow_joins_on_columns_with_different_names: pulumi.Input[bool]
        """
        Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name ( `TRUE` ) or can only be joined on Fingerprint columns of the same name ( `FALSE` ).
        """
        preserve_nulls: pulumi.Input[bool]
        """
        Indicates whether NULL values are to be copied as NULL to encrypted tables ( `TRUE` ) or cryptographically processed ( `FALSE` ).
        """
elif False:
    CollaborationDataEncryptionMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationDataEncryptionMetadataArgs:
    def __init__(__self__, *,
                 allow_cleartext: pulumi.Input[bool],
                 allow_duplicates: pulumi.Input[bool],
                 allow_joins_on_columns_with_different_names: pulumi.Input[bool],
                 preserve_nulls: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] allow_cleartext: Indicates whether encrypted tables can contain cleartext data ( `TRUE` ) or are to cryptographically process every column ( `FALSE` ).
        :param pulumi.Input[bool] allow_duplicates: Indicates whether Fingerprint columns can contain duplicate entries ( `TRUE` ) or are to contain only non-repeated values ( `FALSE` ).
        :param pulumi.Input[bool] allow_joins_on_columns_with_different_names: Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name ( `TRUE` ) or can only be joined on Fingerprint columns of the same name ( `FALSE` ).
        :param pulumi.Input[bool] preserve_nulls: Indicates whether NULL values are to be copied as NULL to encrypted tables ( `TRUE` ) or cryptographically processed ( `FALSE` ).
        """
        pulumi.set(__self__, "allow_cleartext", allow_cleartext)
        pulumi.set(__self__, "allow_duplicates", allow_duplicates)
        pulumi.set(__self__, "allow_joins_on_columns_with_different_names", allow_joins_on_columns_with_different_names)
        pulumi.set(__self__, "preserve_nulls", preserve_nulls)

    @property
    @pulumi.getter(name="allowCleartext")
    def allow_cleartext(self) -> pulumi.Input[bool]:
        """
        Indicates whether encrypted tables can contain cleartext data ( `TRUE` ) or are to cryptographically process every column ( `FALSE` ).
        """
        return pulumi.get(self, "allow_cleartext")

    @allow_cleartext.setter
    def allow_cleartext(self, value: pulumi.Input[bool]):
        pulumi.set(self, "allow_cleartext", value)

    @property
    @pulumi.getter(name="allowDuplicates")
    def allow_duplicates(self) -> pulumi.Input[bool]:
        """
        Indicates whether Fingerprint columns can contain duplicate entries ( `TRUE` ) or are to contain only non-repeated values ( `FALSE` ).
        """
        return pulumi.get(self, "allow_duplicates")

    @allow_duplicates.setter
    def allow_duplicates(self, value: pulumi.Input[bool]):
        pulumi.set(self, "allow_duplicates", value)

    @property
    @pulumi.getter(name="allowJoinsOnColumnsWithDifferentNames")
    def allow_joins_on_columns_with_different_names(self) -> pulumi.Input[bool]:
        """
        Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name ( `TRUE` ) or can only be joined on Fingerprint columns of the same name ( `FALSE` ).
        """
        return pulumi.get(self, "allow_joins_on_columns_with_different_names")

    @allow_joins_on_columns_with_different_names.setter
    def allow_joins_on_columns_with_different_names(self, value: pulumi.Input[bool]):
        pulumi.set(self, "allow_joins_on_columns_with_different_names", value)

    @property
    @pulumi.getter(name="preserveNulls")
    def preserve_nulls(self) -> pulumi.Input[bool]:
        """
        Indicates whether NULL values are to be copied as NULL to encrypted tables ( `TRUE` ) or cryptographically processed ( `FALSE` ).
        """
        return pulumi.get(self, "preserve_nulls")

    @preserve_nulls.setter
    def preserve_nulls(self, value: pulumi.Input[bool]):
        pulumi.set(self, "preserve_nulls", value)


if not MYPY:
    class CollaborationMemberSpecificationArgsDict(TypedDict):
        account_id: pulumi.Input[str]
        """
        The identifier used to reference members of the collaboration. Currently only supports AWS account ID.
        """
        display_name: pulumi.Input[str]
        """
        The member's display name.
        """
        member_abilities: pulumi.Input[Sequence[pulumi.Input['CollaborationMemberAbility']]]
        """
        The abilities granted to the collaboration member.

        *Allowed Values* : `CAN_QUERY` | `CAN_RECEIVE_RESULTS`
        """
        payment_configuration: NotRequired[pulumi.Input['CollaborationPaymentConfigurationArgsDict']]
        """
        The collaboration member's payment responsibilities set by the collaboration creator.

        If the collaboration creator hasn't speciﬁed anyone as the member paying for query compute costs, then the member who can query is the default payer.
        """
elif False:
    CollaborationMemberSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationMemberSpecificationArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[str],
                 display_name: pulumi.Input[str],
                 member_abilities: pulumi.Input[Sequence[pulumi.Input['CollaborationMemberAbility']]],
                 payment_configuration: Optional[pulumi.Input['CollaborationPaymentConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] account_id: The identifier used to reference members of the collaboration. Currently only supports AWS account ID.
        :param pulumi.Input[str] display_name: The member's display name.
        :param pulumi.Input[Sequence[pulumi.Input['CollaborationMemberAbility']]] member_abilities: The abilities granted to the collaboration member.
               
               *Allowed Values* : `CAN_QUERY` | `CAN_RECEIVE_RESULTS`
        :param pulumi.Input['CollaborationPaymentConfigurationArgs'] payment_configuration: The collaboration member's payment responsibilities set by the collaboration creator.
               
               If the collaboration creator hasn't speciﬁed anyone as the member paying for query compute costs, then the member who can query is the default payer.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "member_abilities", member_abilities)
        if payment_configuration is not None:
            pulumi.set(__self__, "payment_configuration", payment_configuration)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[str]:
        """
        The identifier used to reference members of the collaboration. Currently only supports AWS account ID.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        The member's display name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="memberAbilities")
    def member_abilities(self) -> pulumi.Input[Sequence[pulumi.Input['CollaborationMemberAbility']]]:
        """
        The abilities granted to the collaboration member.

        *Allowed Values* : `CAN_QUERY` | `CAN_RECEIVE_RESULTS`
        """
        return pulumi.get(self, "member_abilities")

    @member_abilities.setter
    def member_abilities(self, value: pulumi.Input[Sequence[pulumi.Input['CollaborationMemberAbility']]]):
        pulumi.set(self, "member_abilities", value)

    @property
    @pulumi.getter(name="paymentConfiguration")
    def payment_configuration(self) -> Optional[pulumi.Input['CollaborationPaymentConfigurationArgs']]:
        """
        The collaboration member's payment responsibilities set by the collaboration creator.

        If the collaboration creator hasn't speciﬁed anyone as the member paying for query compute costs, then the member who can query is the default payer.
        """
        return pulumi.get(self, "payment_configuration")

    @payment_configuration.setter
    def payment_configuration(self, value: Optional[pulumi.Input['CollaborationPaymentConfigurationArgs']]):
        pulumi.set(self, "payment_configuration", value)


if not MYPY:
    class CollaborationPaymentConfigurationArgsDict(TypedDict):
        query_compute: pulumi.Input['CollaborationQueryComputePaymentConfigArgsDict']
        """
        The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        """
elif False:
    CollaborationPaymentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationPaymentConfigurationArgs:
    def __init__(__self__, *,
                 query_compute: pulumi.Input['CollaborationQueryComputePaymentConfigArgs']):
        """
        :param pulumi.Input['CollaborationQueryComputePaymentConfigArgs'] query_compute: The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        """
        pulumi.set(__self__, "query_compute", query_compute)

    @property
    @pulumi.getter(name="queryCompute")
    def query_compute(self) -> pulumi.Input['CollaborationQueryComputePaymentConfigArgs']:
        """
        The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        """
        return pulumi.get(self, "query_compute")

    @query_compute.setter
    def query_compute(self, value: pulumi.Input['CollaborationQueryComputePaymentConfigArgs']):
        pulumi.set(self, "query_compute", value)


if not MYPY:
    class CollaborationQueryComputePaymentConfigArgsDict(TypedDict):
        is_responsible: pulumi.Input[bool]
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query compute costs ( `FALSE` ).

        Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
elif False:
    CollaborationQueryComputePaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationQueryComputePaymentConfigArgs:
    def __init__(__self__, *,
                 is_responsible: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] is_responsible: Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query compute costs ( `FALSE` ).
               
               Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.
               
               If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> pulumi.Input[bool]:
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query compute costs ( `FALSE` ).

        Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        return pulumi.get(self, "is_responsible")

    @is_responsible.setter
    def is_responsible(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_responsible", value)


if not MYPY:
    class ConfiguredTableAggregateColumnArgsDict(TypedDict):
        column_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        function: pulumi.Input['ConfiguredTableAggregateFunctionName']
elif False:
    ConfiguredTableAggregateColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAggregateColumnArgs:
    def __init__(__self__, *,
                 column_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 function: pulumi.Input['ConfiguredTableAggregateFunctionName']):
        pulumi.set(__self__, "column_names", column_names)
        pulumi.set(__self__, "function", function)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter
    def function(self) -> pulumi.Input['ConfiguredTableAggregateFunctionName']:
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: pulumi.Input['ConfiguredTableAggregateFunctionName']):
        pulumi.set(self, "function", value)


if not MYPY:
    class ConfiguredTableAggregationConstraintArgsDict(TypedDict):
        column_name: pulumi.Input[str]
        minimum: pulumi.Input[float]
        type: pulumi.Input['ConfiguredTableAggregationType']
elif False:
    ConfiguredTableAggregationConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAggregationConstraintArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[str],
                 minimum: pulumi.Input[float],
                 type: pulumi.Input['ConfiguredTableAggregationType']):
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "minimum", minimum)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter
    def minimum(self) -> pulumi.Input[float]:
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: pulumi.Input[float]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['ConfiguredTableAggregationType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ConfiguredTableAggregationType']):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConfiguredTableAnalysisRuleAggregationArgsDict(TypedDict):
        aggregate_columns: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregateColumnArgsDict']]]
        dimension_columns: pulumi.Input[Sequence[pulumi.Input[str]]]
        join_columns: pulumi.Input[Sequence[pulumi.Input[str]]]
        output_constraints: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregationConstraintArgsDict']]]
        scalar_functions: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableScalarFunctions']]]
        additional_analyses: NotRequired[pulumi.Input['ConfiguredTableAdditionalAnalyses']]
        allowed_join_operators: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]
        join_required: NotRequired[pulumi.Input['ConfiguredTableJoinRequiredOption']]
elif False:
    ConfiguredTableAnalysisRuleAggregationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRuleAggregationArgs:
    def __init__(__self__, *,
                 aggregate_columns: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregateColumnArgs']]],
                 dimension_columns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 join_columns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 output_constraints: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregationConstraintArgs']]],
                 scalar_functions: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableScalarFunctions']]],
                 additional_analyses: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']] = None,
                 allowed_join_operators: Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]] = None,
                 join_required: Optional[pulumi.Input['ConfiguredTableJoinRequiredOption']] = None):
        pulumi.set(__self__, "aggregate_columns", aggregate_columns)
        pulumi.set(__self__, "dimension_columns", dimension_columns)
        pulumi.set(__self__, "join_columns", join_columns)
        pulumi.set(__self__, "output_constraints", output_constraints)
        pulumi.set(__self__, "scalar_functions", scalar_functions)
        if additional_analyses is not None:
            pulumi.set(__self__, "additional_analyses", additional_analyses)
        if allowed_join_operators is not None:
            pulumi.set(__self__, "allowed_join_operators", allowed_join_operators)
        if join_required is not None:
            pulumi.set(__self__, "join_required", join_required)

    @property
    @pulumi.getter(name="aggregateColumns")
    def aggregate_columns(self) -> pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregateColumnArgs']]]:
        return pulumi.get(self, "aggregate_columns")

    @aggregate_columns.setter
    def aggregate_columns(self, value: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregateColumnArgs']]]):
        pulumi.set(self, "aggregate_columns", value)

    @property
    @pulumi.getter(name="dimensionColumns")
    def dimension_columns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "dimension_columns")

    @dimension_columns.setter
    def dimension_columns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dimension_columns", value)

    @property
    @pulumi.getter(name="joinColumns")
    def join_columns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "join_columns")

    @join_columns.setter
    def join_columns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "join_columns", value)

    @property
    @pulumi.getter(name="outputConstraints")
    def output_constraints(self) -> pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregationConstraintArgs']]]:
        return pulumi.get(self, "output_constraints")

    @output_constraints.setter
    def output_constraints(self, value: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregationConstraintArgs']]]):
        pulumi.set(self, "output_constraints", value)

    @property
    @pulumi.getter(name="scalarFunctions")
    def scalar_functions(self) -> pulumi.Input[Sequence[pulumi.Input['ConfiguredTableScalarFunctions']]]:
        return pulumi.get(self, "scalar_functions")

    @scalar_functions.setter
    def scalar_functions(self, value: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableScalarFunctions']]]):
        pulumi.set(self, "scalar_functions", value)

    @property
    @pulumi.getter(name="additionalAnalyses")
    def additional_analyses(self) -> Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]:
        return pulumi.get(self, "additional_analyses")

    @additional_analyses.setter
    def additional_analyses(self, value: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]):
        pulumi.set(self, "additional_analyses", value)

    @property
    @pulumi.getter(name="allowedJoinOperators")
    def allowed_join_operators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]:
        return pulumi.get(self, "allowed_join_operators")

    @allowed_join_operators.setter
    def allowed_join_operators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]):
        pulumi.set(self, "allowed_join_operators", value)

    @property
    @pulumi.getter(name="joinRequired")
    def join_required(self) -> Optional[pulumi.Input['ConfiguredTableJoinRequiredOption']]:
        return pulumi.get(self, "join_required")

    @join_required.setter
    def join_required(self, value: Optional[pulumi.Input['ConfiguredTableJoinRequiredOption']]):
        pulumi.set(self, "join_required", value)


if not MYPY:
    class ConfiguredTableAnalysisRuleCustomArgsDict(TypedDict):
        allowed_analyses: pulumi.Input[Sequence[pulumi.Input[str]]]
        additional_analyses: NotRequired[pulumi.Input['ConfiguredTableAdditionalAnalyses']]
        allowed_analysis_providers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        differential_privacy: NotRequired[pulumi.Input['ConfiguredTableDifferentialPrivacyArgsDict']]
        disallowed_output_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ConfiguredTableAnalysisRuleCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRuleCustomArgs:
    def __init__(__self__, *,
                 allowed_analyses: pulumi.Input[Sequence[pulumi.Input[str]]],
                 additional_analyses: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']] = None,
                 allowed_analysis_providers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 differential_privacy: Optional[pulumi.Input['ConfiguredTableDifferentialPrivacyArgs']] = None,
                 disallowed_output_columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "allowed_analyses", allowed_analyses)
        if additional_analyses is not None:
            pulumi.set(__self__, "additional_analyses", additional_analyses)
        if allowed_analysis_providers is not None:
            pulumi.set(__self__, "allowed_analysis_providers", allowed_analysis_providers)
        if differential_privacy is not None:
            pulumi.set(__self__, "differential_privacy", differential_privacy)
        if disallowed_output_columns is not None:
            pulumi.set(__self__, "disallowed_output_columns", disallowed_output_columns)

    @property
    @pulumi.getter(name="allowedAnalyses")
    def allowed_analyses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "allowed_analyses")

    @allowed_analyses.setter
    def allowed_analyses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_analyses", value)

    @property
    @pulumi.getter(name="additionalAnalyses")
    def additional_analyses(self) -> Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]:
        return pulumi.get(self, "additional_analyses")

    @additional_analyses.setter
    def additional_analyses(self, value: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]):
        pulumi.set(self, "additional_analyses", value)

    @property
    @pulumi.getter(name="allowedAnalysisProviders")
    def allowed_analysis_providers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_analysis_providers")

    @allowed_analysis_providers.setter
    def allowed_analysis_providers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_analysis_providers", value)

    @property
    @pulumi.getter(name="differentialPrivacy")
    def differential_privacy(self) -> Optional[pulumi.Input['ConfiguredTableDifferentialPrivacyArgs']]:
        return pulumi.get(self, "differential_privacy")

    @differential_privacy.setter
    def differential_privacy(self, value: Optional[pulumi.Input['ConfiguredTableDifferentialPrivacyArgs']]):
        pulumi.set(self, "differential_privacy", value)

    @property
    @pulumi.getter(name="disallowedOutputColumns")
    def disallowed_output_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "disallowed_output_columns")

    @disallowed_output_columns.setter
    def disallowed_output_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "disallowed_output_columns", value)


if not MYPY:
    class ConfiguredTableAnalysisRuleListArgsDict(TypedDict):
        join_columns: pulumi.Input[Sequence[pulumi.Input[str]]]
        list_columns: pulumi.Input[Sequence[pulumi.Input[str]]]
        additional_analyses: NotRequired[pulumi.Input['ConfiguredTableAdditionalAnalyses']]
        allowed_join_operators: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]
elif False:
    ConfiguredTableAnalysisRuleListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRuleListArgs:
    def __init__(__self__, *,
                 join_columns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 list_columns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 additional_analyses: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']] = None,
                 allowed_join_operators: Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]] = None):
        pulumi.set(__self__, "join_columns", join_columns)
        pulumi.set(__self__, "list_columns", list_columns)
        if additional_analyses is not None:
            pulumi.set(__self__, "additional_analyses", additional_analyses)
        if allowed_join_operators is not None:
            pulumi.set(__self__, "allowed_join_operators", allowed_join_operators)

    @property
    @pulumi.getter(name="joinColumns")
    def join_columns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "join_columns")

    @join_columns.setter
    def join_columns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "join_columns", value)

    @property
    @pulumi.getter(name="listColumns")
    def list_columns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "list_columns")

    @list_columns.setter
    def list_columns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "list_columns", value)

    @property
    @pulumi.getter(name="additionalAnalyses")
    def additional_analyses(self) -> Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]:
        return pulumi.get(self, "additional_analyses")

    @additional_analyses.setter
    def additional_analyses(self, value: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]):
        pulumi.set(self, "additional_analyses", value)

    @property
    @pulumi.getter(name="allowedJoinOperators")
    def allowed_join_operators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]:
        return pulumi.get(self, "allowed_join_operators")

    @allowed_join_operators.setter
    def allowed_join_operators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]):
        pulumi.set(self, "allowed_join_operators", value)


if not MYPY:
    class ConfiguredTableAnalysisRulePolicyV10PropertiesArgsDict(TypedDict):
        list: pulumi.Input['ConfiguredTableAnalysisRuleListArgsDict']
elif False:
    ConfiguredTableAnalysisRulePolicyV10PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRulePolicyV10PropertiesArgs:
    def __init__(__self__, *,
                 list: pulumi.Input['ConfiguredTableAnalysisRuleListArgs']):
        pulumi.set(__self__, "list", list)

    @property
    @pulumi.getter
    def list(self) -> pulumi.Input['ConfiguredTableAnalysisRuleListArgs']:
        return pulumi.get(self, "list")

    @list.setter
    def list(self, value: pulumi.Input['ConfiguredTableAnalysisRuleListArgs']):
        pulumi.set(self, "list", value)


if not MYPY:
    class ConfiguredTableAnalysisRulePolicyV11PropertiesArgsDict(TypedDict):
        aggregation: pulumi.Input['ConfiguredTableAnalysisRuleAggregationArgsDict']
elif False:
    ConfiguredTableAnalysisRulePolicyV11PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRulePolicyV11PropertiesArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input['ConfiguredTableAnalysisRuleAggregationArgs']):
        pulumi.set(__self__, "aggregation", aggregation)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input['ConfiguredTableAnalysisRuleAggregationArgs']:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input['ConfiguredTableAnalysisRuleAggregationArgs']):
        pulumi.set(self, "aggregation", value)


if not MYPY:
    class ConfiguredTableAnalysisRulePolicyV12PropertiesArgsDict(TypedDict):
        custom: pulumi.Input['ConfiguredTableAnalysisRuleCustomArgsDict']
elif False:
    ConfiguredTableAnalysisRulePolicyV12PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRulePolicyV12PropertiesArgs:
    def __init__(__self__, *,
                 custom: pulumi.Input['ConfiguredTableAnalysisRuleCustomArgs']):
        pulumi.set(__self__, "custom", custom)

    @property
    @pulumi.getter
    def custom(self) -> pulumi.Input['ConfiguredTableAnalysisRuleCustomArgs']:
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: pulumi.Input['ConfiguredTableAnalysisRuleCustomArgs']):
        pulumi.set(self, "custom", value)


if not MYPY:
    class ConfiguredTableAnalysisRulePolicyArgsDict(TypedDict):
        v1: pulumi.Input[Union['ConfiguredTableAnalysisRulePolicyV10PropertiesArgsDict', 'ConfiguredTableAnalysisRulePolicyV11PropertiesArgsDict', 'ConfiguredTableAnalysisRulePolicyV12PropertiesArgsDict']]
        """
        Controls on the query specifications that can be run on a configured table.
        """
elif False:
    ConfiguredTableAnalysisRulePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRulePolicyArgs:
    def __init__(__self__, *,
                 v1: pulumi.Input[Union['ConfiguredTableAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV12PropertiesArgs']]):
        """
        :param pulumi.Input[Union['ConfiguredTableAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV12PropertiesArgs']] v1: Controls on the query specifications that can be run on a configured table.
        """
        pulumi.set(__self__, "v1", v1)

    @property
    @pulumi.getter
    def v1(self) -> pulumi.Input[Union['ConfiguredTableAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV12PropertiesArgs']]:
        """
        Controls on the query specifications that can be run on a configured table.
        """
        return pulumi.get(self, "v1")

    @v1.setter
    def v1(self, value: pulumi.Input[Union['ConfiguredTableAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV12PropertiesArgs']]):
        pulumi.set(self, "v1", value)


if not MYPY:
    class ConfiguredTableAnalysisRuleArgsDict(TypedDict):
        policy: pulumi.Input['ConfiguredTableAnalysisRulePolicyArgsDict']
        """
        A policy that describes the associated data usage limitations.
        """
        type: pulumi.Input['ConfiguredTableAnalysisRuleType']
        """
        The type of analysis rule.
        """
elif False:
    ConfiguredTableAnalysisRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRuleArgs:
    def __init__(__self__, *,
                 policy: pulumi.Input['ConfiguredTableAnalysisRulePolicyArgs'],
                 type: pulumi.Input['ConfiguredTableAnalysisRuleType']):
        """
        :param pulumi.Input['ConfiguredTableAnalysisRulePolicyArgs'] policy: A policy that describes the associated data usage limitations.
        :param pulumi.Input['ConfiguredTableAnalysisRuleType'] type: The type of analysis rule.
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def policy(self) -> pulumi.Input['ConfiguredTableAnalysisRulePolicyArgs']:
        """
        A policy that describes the associated data usage limitations.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: pulumi.Input['ConfiguredTableAnalysisRulePolicyArgs']):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['ConfiguredTableAnalysisRuleType']:
        """
        The type of analysis rule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ConfiguredTableAnalysisRuleType']):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRuleAggregationArgsDict(TypedDict):
        allowed_additional_analyses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        allowed_result_receivers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ConfiguredTableAssociationAnalysisRuleAggregationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRuleAggregationArgs:
    def __init__(__self__, *,
                 allowed_additional_analyses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_result_receivers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if allowed_additional_analyses is not None:
            pulumi.set(__self__, "allowed_additional_analyses", allowed_additional_analyses)
        if allowed_result_receivers is not None:
            pulumi.set(__self__, "allowed_result_receivers", allowed_result_receivers)

    @property
    @pulumi.getter(name="allowedAdditionalAnalyses")
    def allowed_additional_analyses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_additional_analyses")

    @allowed_additional_analyses.setter
    def allowed_additional_analyses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_additional_analyses", value)

    @property
    @pulumi.getter(name="allowedResultReceivers")
    def allowed_result_receivers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_result_receivers")

    @allowed_result_receivers.setter
    def allowed_result_receivers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_result_receivers", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRuleCustomArgsDict(TypedDict):
        allowed_additional_analyses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        allowed_result_receivers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ConfiguredTableAssociationAnalysisRuleCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRuleCustomArgs:
    def __init__(__self__, *,
                 allowed_additional_analyses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_result_receivers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if allowed_additional_analyses is not None:
            pulumi.set(__self__, "allowed_additional_analyses", allowed_additional_analyses)
        if allowed_result_receivers is not None:
            pulumi.set(__self__, "allowed_result_receivers", allowed_result_receivers)

    @property
    @pulumi.getter(name="allowedAdditionalAnalyses")
    def allowed_additional_analyses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_additional_analyses")

    @allowed_additional_analyses.setter
    def allowed_additional_analyses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_additional_analyses", value)

    @property
    @pulumi.getter(name="allowedResultReceivers")
    def allowed_result_receivers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_result_receivers")

    @allowed_result_receivers.setter
    def allowed_result_receivers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_result_receivers", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRuleListArgsDict(TypedDict):
        allowed_additional_analyses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        allowed_result_receivers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ConfiguredTableAssociationAnalysisRuleListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRuleListArgs:
    def __init__(__self__, *,
                 allowed_additional_analyses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_result_receivers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if allowed_additional_analyses is not None:
            pulumi.set(__self__, "allowed_additional_analyses", allowed_additional_analyses)
        if allowed_result_receivers is not None:
            pulumi.set(__self__, "allowed_result_receivers", allowed_result_receivers)

    @property
    @pulumi.getter(name="allowedAdditionalAnalyses")
    def allowed_additional_analyses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_additional_analyses")

    @allowed_additional_analyses.setter
    def allowed_additional_analyses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_additional_analyses", value)

    @property
    @pulumi.getter(name="allowedResultReceivers")
    def allowed_result_receivers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_result_receivers")

    @allowed_result_receivers.setter
    def allowed_result_receivers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_result_receivers", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgsDict(TypedDict):
        list: pulumi.Input['ConfiguredTableAssociationAnalysisRuleListArgsDict']
elif False:
    ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs:
    def __init__(__self__, *,
                 list: pulumi.Input['ConfiguredTableAssociationAnalysisRuleListArgs']):
        pulumi.set(__self__, "list", list)

    @property
    @pulumi.getter
    def list(self) -> pulumi.Input['ConfiguredTableAssociationAnalysisRuleListArgs']:
        return pulumi.get(self, "list")

    @list.setter
    def list(self, value: pulumi.Input['ConfiguredTableAssociationAnalysisRuleListArgs']):
        pulumi.set(self, "list", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgsDict(TypedDict):
        aggregation: pulumi.Input['ConfiguredTableAssociationAnalysisRuleAggregationArgsDict']
elif False:
    ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input['ConfiguredTableAssociationAnalysisRuleAggregationArgs']):
        pulumi.set(__self__, "aggregation", aggregation)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input['ConfiguredTableAssociationAnalysisRuleAggregationArgs']:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input['ConfiguredTableAssociationAnalysisRuleAggregationArgs']):
        pulumi.set(self, "aggregation", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgsDict(TypedDict):
        custom: pulumi.Input['ConfiguredTableAssociationAnalysisRuleCustomArgsDict']
elif False:
    ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs:
    def __init__(__self__, *,
                 custom: pulumi.Input['ConfiguredTableAssociationAnalysisRuleCustomArgs']):
        pulumi.set(__self__, "custom", custom)

    @property
    @pulumi.getter
    def custom(self) -> pulumi.Input['ConfiguredTableAssociationAnalysisRuleCustomArgs']:
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: pulumi.Input['ConfiguredTableAssociationAnalysisRuleCustomArgs']):
        pulumi.set(self, "custom", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRulePolicyArgsDict(TypedDict):
        v1: pulumi.Input[Union['ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgsDict', 'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgsDict', 'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgsDict']]
        """
        The policy for the configured table association analysis rule.
        """
elif False:
    ConfiguredTableAssociationAnalysisRulePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRulePolicyArgs:
    def __init__(__self__, *,
                 v1: pulumi.Input[Union['ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs']]):
        """
        :param pulumi.Input[Union['ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs']] v1: The policy for the configured table association analysis rule.
        """
        pulumi.set(__self__, "v1", v1)

    @property
    @pulumi.getter
    def v1(self) -> pulumi.Input[Union['ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs']]:
        """
        The policy for the configured table association analysis rule.
        """
        return pulumi.get(self, "v1")

    @v1.setter
    def v1(self, value: pulumi.Input[Union['ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs']]):
        pulumi.set(self, "v1", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRuleArgsDict(TypedDict):
        policy: pulumi.Input['ConfiguredTableAssociationAnalysisRulePolicyArgsDict']
        """
        The policy of the configured table association analysis rule.
        """
        type: pulumi.Input['ConfiguredTableAssociationAnalysisRuleType']
        """
        The type of the configured table association analysis rule.
        """
elif False:
    ConfiguredTableAssociationAnalysisRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRuleArgs:
    def __init__(__self__, *,
                 policy: pulumi.Input['ConfiguredTableAssociationAnalysisRulePolicyArgs'],
                 type: pulumi.Input['ConfiguredTableAssociationAnalysisRuleType']):
        """
        :param pulumi.Input['ConfiguredTableAssociationAnalysisRulePolicyArgs'] policy: The policy of the configured table association analysis rule.
        :param pulumi.Input['ConfiguredTableAssociationAnalysisRuleType'] type: The type of the configured table association analysis rule.
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def policy(self) -> pulumi.Input['ConfiguredTableAssociationAnalysisRulePolicyArgs']:
        """
        The policy of the configured table association analysis rule.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: pulumi.Input['ConfiguredTableAssociationAnalysisRulePolicyArgs']):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['ConfiguredTableAssociationAnalysisRuleType']:
        """
        The type of the configured table association analysis rule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ConfiguredTableAssociationAnalysisRuleType']):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConfiguredTableDifferentialPrivacyColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
elif False:
    ConfiguredTableDifferentialPrivacyColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableDifferentialPrivacyColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ConfiguredTableDifferentialPrivacyArgsDict(TypedDict):
        columns: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableDifferentialPrivacyColumnArgsDict']]]
elif False:
    ConfiguredTableDifferentialPrivacyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableDifferentialPrivacyArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableDifferentialPrivacyColumnArgs']]]):
        pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input['ConfiguredTableDifferentialPrivacyColumnArgs']]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableDifferentialPrivacyColumnArgs']]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class ConfiguredTableGlueTableReferenceArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of the database the AWS Glue table belongs to.
        """
        table_name: pulumi.Input[str]
        """
        The name of the AWS Glue table.
        """
elif False:
    ConfiguredTableGlueTableReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableGlueTableReferenceArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 table_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database_name: The name of the database the AWS Glue table belongs to.
        :param pulumi.Input[str] table_name: The name of the AWS Glue table.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database the AWS Glue table belongs to.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the AWS Glue table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class ConfiguredTableTableReferenceArgsDict(TypedDict):
        glue: pulumi.Input['ConfiguredTableGlueTableReferenceArgsDict']
        """
        If present, a reference to the AWS Glue table referred to by this table reference.
        """
elif False:
    ConfiguredTableTableReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableTableReferenceArgs:
    def __init__(__self__, *,
                 glue: pulumi.Input['ConfiguredTableGlueTableReferenceArgs']):
        """
        :param pulumi.Input['ConfiguredTableGlueTableReferenceArgs'] glue: If present, a reference to the AWS Glue table referred to by this table reference.
        """
        pulumi.set(__self__, "glue", glue)

    @property
    @pulumi.getter
    def glue(self) -> pulumi.Input['ConfiguredTableGlueTableReferenceArgs']:
        """
        If present, a reference to the AWS Glue table referred to by this table reference.
        """
        return pulumi.get(self, "glue")

    @glue.setter
    def glue(self, value: pulumi.Input['ConfiguredTableGlueTableReferenceArgs']):
        pulumi.set(self, "glue", value)


if not MYPY:
    class IdMappingTableInputReferenceConfigArgsDict(TypedDict):
        input_reference_arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the referenced resource in AWS Entity Resolution . Valid values are ID mapping workflow ARNs.
        """
        manage_resource_policies: pulumi.Input[bool]
        """
        When `TRUE` , AWS Clean Rooms manages permissions for the ID mapping table resource.

        When `FALSE` , the resource owner manages permissions for the ID mapping table resource.
        """
elif False:
    IdMappingTableInputReferenceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdMappingTableInputReferenceConfigArgs:
    def __init__(__self__, *,
                 input_reference_arn: pulumi.Input[str],
                 manage_resource_policies: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] input_reference_arn: The Amazon Resource Name (ARN) of the referenced resource in AWS Entity Resolution . Valid values are ID mapping workflow ARNs.
        :param pulumi.Input[bool] manage_resource_policies: When `TRUE` , AWS Clean Rooms manages permissions for the ID mapping table resource.
               
               When `FALSE` , the resource owner manages permissions for the ID mapping table resource.
        """
        pulumi.set(__self__, "input_reference_arn", input_reference_arn)
        pulumi.set(__self__, "manage_resource_policies", manage_resource_policies)

    @property
    @pulumi.getter(name="inputReferenceArn")
    def input_reference_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the referenced resource in AWS Entity Resolution . Valid values are ID mapping workflow ARNs.
        """
        return pulumi.get(self, "input_reference_arn")

    @input_reference_arn.setter
    def input_reference_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_reference_arn", value)

    @property
    @pulumi.getter(name="manageResourcePolicies")
    def manage_resource_policies(self) -> pulumi.Input[bool]:
        """
        When `TRUE` , AWS Clean Rooms manages permissions for the ID mapping table resource.

        When `FALSE` , the resource owner manages permissions for the ID mapping table resource.
        """
        return pulumi.get(self, "manage_resource_policies")

    @manage_resource_policies.setter
    def manage_resource_policies(self, value: pulumi.Input[bool]):
        pulumi.set(self, "manage_resource_policies", value)


if not MYPY:
    class IdNamespaceAssociationIdMappingConfigArgsDict(TypedDict):
        allow_use_as_dimension_column: pulumi.Input[bool]
        """
        An indicator as to whether you can use your column as a dimension column in the ID mapping table ( `TRUE` ) or not ( `FALSE` ).

        Default is `FALSE` .
        """
elif False:
    IdNamespaceAssociationIdMappingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdNamespaceAssociationIdMappingConfigArgs:
    def __init__(__self__, *,
                 allow_use_as_dimension_column: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] allow_use_as_dimension_column: An indicator as to whether you can use your column as a dimension column in the ID mapping table ( `TRUE` ) or not ( `FALSE` ).
               
               Default is `FALSE` .
        """
        pulumi.set(__self__, "allow_use_as_dimension_column", allow_use_as_dimension_column)

    @property
    @pulumi.getter(name="allowUseAsDimensionColumn")
    def allow_use_as_dimension_column(self) -> pulumi.Input[bool]:
        """
        An indicator as to whether you can use your column as a dimension column in the ID mapping table ( `TRUE` ) or not ( `FALSE` ).

        Default is `FALSE` .
        """
        return pulumi.get(self, "allow_use_as_dimension_column")

    @allow_use_as_dimension_column.setter
    def allow_use_as_dimension_column(self, value: pulumi.Input[bool]):
        pulumi.set(self, "allow_use_as_dimension_column", value)


if not MYPY:
    class IdNamespaceAssociationInputReferenceConfigArgsDict(TypedDict):
        input_reference_arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the AWS Entity Resolution resource that is being associated to the collaboration. Valid resource ARNs are from the ID namespaces that you own.
        """
        manage_resource_policies: pulumi.Input[bool]
        """
        When `TRUE` , AWS Clean Rooms manages permissions for the ID namespace association resource.

        When `FALSE` , the resource owner manages permissions for the ID namespace association resource.
        """
elif False:
    IdNamespaceAssociationInputReferenceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdNamespaceAssociationInputReferenceConfigArgs:
    def __init__(__self__, *,
                 input_reference_arn: pulumi.Input[str],
                 manage_resource_policies: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] input_reference_arn: The Amazon Resource Name (ARN) of the AWS Entity Resolution resource that is being associated to the collaboration. Valid resource ARNs are from the ID namespaces that you own.
        :param pulumi.Input[bool] manage_resource_policies: When `TRUE` , AWS Clean Rooms manages permissions for the ID namespace association resource.
               
               When `FALSE` , the resource owner manages permissions for the ID namespace association resource.
        """
        pulumi.set(__self__, "input_reference_arn", input_reference_arn)
        pulumi.set(__self__, "manage_resource_policies", manage_resource_policies)

    @property
    @pulumi.getter(name="inputReferenceArn")
    def input_reference_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the AWS Entity Resolution resource that is being associated to the collaboration. Valid resource ARNs are from the ID namespaces that you own.
        """
        return pulumi.get(self, "input_reference_arn")

    @input_reference_arn.setter
    def input_reference_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_reference_arn", value)

    @property
    @pulumi.getter(name="manageResourcePolicies")
    def manage_resource_policies(self) -> pulumi.Input[bool]:
        """
        When `TRUE` , AWS Clean Rooms manages permissions for the ID namespace association resource.

        When `FALSE` , the resource owner manages permissions for the ID namespace association resource.
        """
        return pulumi.get(self, "manage_resource_policies")

    @manage_resource_policies.setter
    def manage_resource_policies(self, value: pulumi.Input[bool]):
        pulumi.set(self, "manage_resource_policies", value)


if not MYPY:
    class MembershipPaymentConfigurationArgsDict(TypedDict):
        query_compute: pulumi.Input['MembershipQueryComputePaymentConfigArgsDict']
        """
        The payment responsibilities accepted by the collaboration member for query compute costs.
        """
elif False:
    MembershipPaymentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipPaymentConfigurationArgs:
    def __init__(__self__, *,
                 query_compute: pulumi.Input['MembershipQueryComputePaymentConfigArgs']):
        """
        :param pulumi.Input['MembershipQueryComputePaymentConfigArgs'] query_compute: The payment responsibilities accepted by the collaboration member for query compute costs.
        """
        pulumi.set(__self__, "query_compute", query_compute)

    @property
    @pulumi.getter(name="queryCompute")
    def query_compute(self) -> pulumi.Input['MembershipQueryComputePaymentConfigArgs']:
        """
        The payment responsibilities accepted by the collaboration member for query compute costs.
        """
        return pulumi.get(self, "query_compute")

    @query_compute.setter
    def query_compute(self, value: pulumi.Input['MembershipQueryComputePaymentConfigArgs']):
        pulumi.set(self, "query_compute", value)


if not MYPY:
    class MembershipProtectedQueryOutputConfigurationArgsDict(TypedDict):
        s3: pulumi.Input['MembershipProtectedQueryS3OutputConfigurationArgsDict']
        """
        Required configuration for a protected query with an `s3` output type.
        """
elif False:
    MembershipProtectedQueryOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipProtectedQueryOutputConfigurationArgs:
    def __init__(__self__, *,
                 s3: pulumi.Input['MembershipProtectedQueryS3OutputConfigurationArgs']):
        """
        :param pulumi.Input['MembershipProtectedQueryS3OutputConfigurationArgs'] s3: Required configuration for a protected query with an `s3` output type.
        """
        pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def s3(self) -> pulumi.Input['MembershipProtectedQueryS3OutputConfigurationArgs']:
        """
        Required configuration for a protected query with an `s3` output type.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: pulumi.Input['MembershipProtectedQueryS3OutputConfigurationArgs']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class MembershipProtectedQueryResultConfigurationArgsDict(TypedDict):
        output_configuration: pulumi.Input['MembershipProtectedQueryOutputConfigurationArgsDict']
        """
        Configuration for protected query results.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        """
elif False:
    MembershipProtectedQueryResultConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipProtectedQueryResultConfigurationArgs:
    def __init__(__self__, *,
                 output_configuration: pulumi.Input['MembershipProtectedQueryOutputConfigurationArgs'],
                 role_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['MembershipProtectedQueryOutputConfigurationArgs'] output_configuration: Configuration for protected query results.
        :param pulumi.Input[str] role_arn: The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        """
        pulumi.set(__self__, "output_configuration", output_configuration)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="outputConfiguration")
    def output_configuration(self) -> pulumi.Input['MembershipProtectedQueryOutputConfigurationArgs']:
        """
        Configuration for protected query results.
        """
        return pulumi.get(self, "output_configuration")

    @output_configuration.setter
    def output_configuration(self, value: pulumi.Input['MembershipProtectedQueryOutputConfigurationArgs']):
        pulumi.set(self, "output_configuration", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class MembershipProtectedQueryS3OutputConfigurationArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        """
        The S3 bucket to unload the protected query results.
        """
        result_format: pulumi.Input['MembershipResultFormat']
        """
        Intended file format of the result.
        """
        key_prefix: NotRequired[pulumi.Input[str]]
        """
        The S3 prefix to unload the protected query results.
        """
        single_file_output: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether files should be output as a single file ( `TRUE` ) or output as multiple files ( `FALSE` ). This parameter is only supported for analyses with the Spark analytics engine.
        """
elif False:
    MembershipProtectedQueryS3OutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipProtectedQueryS3OutputConfigurationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 result_format: pulumi.Input['MembershipResultFormat'],
                 key_prefix: Optional[pulumi.Input[str]] = None,
                 single_file_output: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bucket: The S3 bucket to unload the protected query results.
        :param pulumi.Input['MembershipResultFormat'] result_format: Intended file format of the result.
        :param pulumi.Input[str] key_prefix: The S3 prefix to unload the protected query results.
        :param pulumi.Input[bool] single_file_output: Indicates whether files should be output as a single file ( `TRUE` ) or output as multiple files ( `FALSE` ). This parameter is only supported for analyses with the Spark analytics engine.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "result_format", result_format)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)
        if single_file_output is not None:
            pulumi.set(__self__, "single_file_output", single_file_output)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The S3 bucket to unload the protected query results.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="resultFormat")
    def result_format(self) -> pulumi.Input['MembershipResultFormat']:
        """
        Intended file format of the result.
        """
        return pulumi.get(self, "result_format")

    @result_format.setter
    def result_format(self, value: pulumi.Input['MembershipResultFormat']):
        pulumi.set(self, "result_format", value)

    @property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The S3 prefix to unload the protected query results.
        """
        return pulumi.get(self, "key_prefix")

    @key_prefix.setter
    def key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_prefix", value)

    @property
    @pulumi.getter(name="singleFileOutput")
    def single_file_output(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether files should be output as a single file ( `TRUE` ) or output as multiple files ( `FALSE` ). This parameter is only supported for analyses with the Spark analytics engine.
        """
        return pulumi.get(self, "single_file_output")

    @single_file_output.setter
    def single_file_output(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "single_file_output", value)


if not MYPY:
    class MembershipQueryComputePaymentConfigArgsDict(TypedDict):
        is_responsible: pulumi.Input[bool]
        """
        Indicates whether the collaboration member has accepted to pay for query compute costs ( `TRUE` ) or has not accepted to pay for query compute costs ( `FALSE` ).

        If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for query compute costs.
        - If you set the value to `TRUE` but you are not responsible to pay for query compute costs.
        """
elif False:
    MembershipQueryComputePaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipQueryComputePaymentConfigArgs:
    def __init__(__self__, *,
                 is_responsible: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] is_responsible: Indicates whether the collaboration member has accepted to pay for query compute costs ( `TRUE` ) or has not accepted to pay for query compute costs ( `FALSE` ).
               
               If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer.
               
               An error message is returned for the following reasons:
               
               - If you set the value to `FALSE` but you are responsible to pay for query compute costs.
               - If you set the value to `TRUE` but you are not responsible to pay for query compute costs.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> pulumi.Input[bool]:
        """
        Indicates whether the collaboration member has accepted to pay for query compute costs ( `TRUE` ) or has not accepted to pay for query compute costs ( `FALSE` ).

        If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for query compute costs.
        - If you set the value to `TRUE` but you are not responsible to pay for query compute costs.
        """
        return pulumi.get(self, "is_responsible")

    @is_responsible.setter
    def is_responsible(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_responsible", value)


if not MYPY:
    class ParametersPropertiesArgsDict(TypedDict):
        """
        Specifies the epsilon and noise parameters for the privacy budget template.
        """
        epsilon: pulumi.Input[int]
        """
        The epsilon value that you want to use.
        """
        users_noise_per_query: pulumi.Input[int]
        """
        Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        """
elif False:
    ParametersPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ParametersPropertiesArgs:
    def __init__(__self__, *,
                 epsilon: pulumi.Input[int],
                 users_noise_per_query: pulumi.Input[int]):
        """
        Specifies the epsilon and noise parameters for the privacy budget template.
        :param pulumi.Input[int] epsilon: The epsilon value that you want to use.
        :param pulumi.Input[int] users_noise_per_query: Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        """
        pulumi.set(__self__, "epsilon", epsilon)
        pulumi.set(__self__, "users_noise_per_query", users_noise_per_query)

    @property
    @pulumi.getter
    def epsilon(self) -> pulumi.Input[int]:
        """
        The epsilon value that you want to use.
        """
        return pulumi.get(self, "epsilon")

    @epsilon.setter
    def epsilon(self, value: pulumi.Input[int]):
        pulumi.set(self, "epsilon", value)

    @property
    @pulumi.getter(name="usersNoisePerQuery")
    def users_noise_per_query(self) -> pulumi.Input[int]:
        """
        Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        """
        return pulumi.get(self, "users_noise_per_query")

    @users_noise_per_query.setter
    def users_noise_per_query(self, value: pulumi.Input[int]):
        pulumi.set(self, "users_noise_per_query", value)


