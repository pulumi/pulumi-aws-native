# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AnalysisTemplateAnalysisParameterArgs',
    'AnalysisTemplateAnalysisParameterArgsDict',
    'AnalysisTemplateAnalysisSchemaArgs',
    'AnalysisTemplateAnalysisSchemaArgsDict',
    'AnalysisTemplateAnalysisSource0PropertiesArgs',
    'AnalysisTemplateAnalysisSource0PropertiesArgsDict',
    'AnalysisTemplateAnalysisSource1PropertiesArgs',
    'AnalysisTemplateAnalysisSource1PropertiesArgsDict',
    'AnalysisTemplateAnalysisSourceMetadataPropertiesArgs',
    'AnalysisTemplateAnalysisSourceMetadataPropertiesArgsDict',
    'AnalysisTemplateArtifactMetadataArgs',
    'AnalysisTemplateArtifactMetadataArgsDict',
    'AnalysisTemplateArtifactsArgs',
    'AnalysisTemplateArtifactsArgsDict',
    'AnalysisTemplateArtifactArgs',
    'AnalysisTemplateArtifactArgsDict',
    'AnalysisTemplateErrorMessageConfigurationArgs',
    'AnalysisTemplateErrorMessageConfigurationArgsDict',
    'AnalysisTemplateHashArgs',
    'AnalysisTemplateHashArgsDict',
    'AnalysisTemplateS3LocationArgs',
    'AnalysisTemplateS3LocationArgsDict',
    'CollaborationDataEncryptionMetadataArgs',
    'CollaborationDataEncryptionMetadataArgsDict',
    'CollaborationJobComputePaymentConfigArgs',
    'CollaborationJobComputePaymentConfigArgsDict',
    'CollaborationMemberSpecificationArgs',
    'CollaborationMemberSpecificationArgsDict',
    'CollaborationMlMemberAbilitiesArgs',
    'CollaborationMlMemberAbilitiesArgsDict',
    'CollaborationMlPaymentConfigArgs',
    'CollaborationMlPaymentConfigArgsDict',
    'CollaborationModelInferencePaymentConfigArgs',
    'CollaborationModelInferencePaymentConfigArgsDict',
    'CollaborationModelTrainingPaymentConfigArgs',
    'CollaborationModelTrainingPaymentConfigArgsDict',
    'CollaborationPaymentConfigurationArgs',
    'CollaborationPaymentConfigurationArgsDict',
    'CollaborationQueryComputePaymentConfigArgs',
    'CollaborationQueryComputePaymentConfigArgsDict',
    'ConfiguredTableAggregateColumnArgs',
    'ConfiguredTableAggregateColumnArgsDict',
    'ConfiguredTableAggregationConstraintArgs',
    'ConfiguredTableAggregationConstraintArgsDict',
    'ConfiguredTableAnalysisRuleAggregationArgs',
    'ConfiguredTableAnalysisRuleAggregationArgsDict',
    'ConfiguredTableAnalysisRuleCustomArgs',
    'ConfiguredTableAnalysisRuleCustomArgsDict',
    'ConfiguredTableAnalysisRuleListArgs',
    'ConfiguredTableAnalysisRuleListArgsDict',
    'ConfiguredTableAnalysisRulePolicyV10PropertiesArgs',
    'ConfiguredTableAnalysisRulePolicyV10PropertiesArgsDict',
    'ConfiguredTableAnalysisRulePolicyV11PropertiesArgs',
    'ConfiguredTableAnalysisRulePolicyV11PropertiesArgsDict',
    'ConfiguredTableAnalysisRulePolicyV12PropertiesArgs',
    'ConfiguredTableAnalysisRulePolicyV12PropertiesArgsDict',
    'ConfiguredTableAnalysisRulePolicyArgs',
    'ConfiguredTableAnalysisRulePolicyArgsDict',
    'ConfiguredTableAnalysisRuleArgs',
    'ConfiguredTableAnalysisRuleArgsDict',
    'ConfiguredTableAssociationAnalysisRuleAggregationArgs',
    'ConfiguredTableAssociationAnalysisRuleAggregationArgsDict',
    'ConfiguredTableAssociationAnalysisRuleCustomArgs',
    'ConfiguredTableAssociationAnalysisRuleCustomArgsDict',
    'ConfiguredTableAssociationAnalysisRuleListArgs',
    'ConfiguredTableAssociationAnalysisRuleListArgsDict',
    'ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs',
    'ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgsDict',
    'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs',
    'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgsDict',
    'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs',
    'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgsDict',
    'ConfiguredTableAssociationAnalysisRulePolicyArgs',
    'ConfiguredTableAssociationAnalysisRulePolicyArgsDict',
    'ConfiguredTableAssociationAnalysisRuleArgs',
    'ConfiguredTableAssociationAnalysisRuleArgsDict',
    'ConfiguredTableAthenaTableReferenceArgs',
    'ConfiguredTableAthenaTableReferenceArgsDict',
    'ConfiguredTableDifferentialPrivacyColumnArgs',
    'ConfiguredTableDifferentialPrivacyColumnArgsDict',
    'ConfiguredTableDifferentialPrivacyArgs',
    'ConfiguredTableDifferentialPrivacyArgsDict',
    'ConfiguredTableGlueTableReferenceArgs',
    'ConfiguredTableGlueTableReferenceArgsDict',
    'ConfiguredTableSnowflakeTableReferenceArgs',
    'ConfiguredTableSnowflakeTableReferenceArgsDict',
    'ConfiguredTableSnowflakeTableSchemaPropertiesArgs',
    'ConfiguredTableSnowflakeTableSchemaPropertiesArgsDict',
    'ConfiguredTableSnowflakeTableSchemaV1Args',
    'ConfiguredTableSnowflakeTableSchemaV1ArgsDict',
    'ConfiguredTableTableReference0PropertiesArgs',
    'ConfiguredTableTableReference0PropertiesArgsDict',
    'ConfiguredTableTableReference1PropertiesArgs',
    'ConfiguredTableTableReference1PropertiesArgsDict',
    'ConfiguredTableTableReference2PropertiesArgs',
    'ConfiguredTableTableReference2PropertiesArgsDict',
    'IdMappingTableInputReferenceConfigArgs',
    'IdMappingTableInputReferenceConfigArgsDict',
    'IdNamespaceAssociationIdMappingConfigArgs',
    'IdNamespaceAssociationIdMappingConfigArgsDict',
    'IdNamespaceAssociationInputReferenceConfigArgs',
    'IdNamespaceAssociationInputReferenceConfigArgsDict',
    'MembershipJobComputePaymentConfigArgs',
    'MembershipJobComputePaymentConfigArgsDict',
    'MembershipMlPaymentConfigArgs',
    'MembershipMlPaymentConfigArgsDict',
    'MembershipModelInferencePaymentConfigArgs',
    'MembershipModelInferencePaymentConfigArgsDict',
    'MembershipModelTrainingPaymentConfigArgs',
    'MembershipModelTrainingPaymentConfigArgsDict',
    'MembershipPaymentConfigurationArgs',
    'MembershipPaymentConfigurationArgsDict',
    'MembershipProtectedJobOutputConfigurationArgs',
    'MembershipProtectedJobOutputConfigurationArgsDict',
    'MembershipProtectedJobResultConfigurationArgs',
    'MembershipProtectedJobResultConfigurationArgsDict',
    'MembershipProtectedJobS3OutputConfigurationInputArgs',
    'MembershipProtectedJobS3OutputConfigurationInputArgsDict',
    'MembershipProtectedQueryOutputConfigurationArgs',
    'MembershipProtectedQueryOutputConfigurationArgsDict',
    'MembershipProtectedQueryResultConfigurationArgs',
    'MembershipProtectedQueryResultConfigurationArgsDict',
    'MembershipProtectedQueryS3OutputConfigurationArgs',
    'MembershipProtectedQueryS3OutputConfigurationArgsDict',
    'MembershipQueryComputePaymentConfigArgs',
    'MembershipQueryComputePaymentConfigArgsDict',
    'ParametersPropertiesArgs',
    'ParametersPropertiesArgsDict',
    'PrivacyBudgetTemplateBudgetParameterArgs',
    'PrivacyBudgetTemplateBudgetParameterArgsDict',
]

MYPY = False

if not MYPY:
    class AnalysisTemplateAnalysisParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        """
        type: pulumi.Input['AnalysisTemplateAnalysisParameterType']
        """
        The type of parameter.
        """
        default_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        """
elif False:
    AnalysisTemplateAnalysisParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateAnalysisParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input['AnalysisTemplateAnalysisParameterType'],
                 default_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        :param pulumi.Input['AnalysisTemplateAnalysisParameterType'] type: The type of parameter.
        :param pulumi.Input[_builtins.str] default_value: Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['AnalysisTemplateAnalysisParameterType']:
        """
        The type of parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['AnalysisTemplateAnalysisParameterType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)


if not MYPY:
    class AnalysisTemplateAnalysisSchemaArgsDict(TypedDict):
        referenced_tables: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The tables referenced in the analysis schema.
        """
elif False:
    AnalysisTemplateAnalysisSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateAnalysisSchemaArgs:
    def __init__(__self__, *,
                 referenced_tables: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] referenced_tables: The tables referenced in the analysis schema.
        """
        pulumi.set(__self__, "referenced_tables", referenced_tables)

    @_builtins.property
    @pulumi.getter(name="referencedTables")
    def referenced_tables(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The tables referenced in the analysis schema.
        """
        return pulumi.get(self, "referenced_tables")

    @referenced_tables.setter
    def referenced_tables(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "referenced_tables", value)


if not MYPY:
    class AnalysisTemplateAnalysisSource0PropertiesArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
elif False:
    AnalysisTemplateAnalysisSource0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateAnalysisSource0PropertiesArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AnalysisTemplateAnalysisSource1PropertiesArgsDict(TypedDict):
        artifacts: pulumi.Input['AnalysisTemplateArtifactsArgsDict']
elif False:
    AnalysisTemplateAnalysisSource1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateAnalysisSource1PropertiesArgs:
    def __init__(__self__, *,
                 artifacts: pulumi.Input['AnalysisTemplateArtifactsArgs']):
        pulumi.set(__self__, "artifacts", artifacts)

    @_builtins.property
    @pulumi.getter
    def artifacts(self) -> pulumi.Input['AnalysisTemplateArtifactsArgs']:
        return pulumi.get(self, "artifacts")

    @artifacts.setter
    def artifacts(self, value: pulumi.Input['AnalysisTemplateArtifactsArgs']):
        pulumi.set(self, "artifacts", value)


if not MYPY:
    class AnalysisTemplateAnalysisSourceMetadataPropertiesArgsDict(TypedDict):
        artifacts: pulumi.Input['AnalysisTemplateArtifactMetadataArgsDict']
elif False:
    AnalysisTemplateAnalysisSourceMetadataPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateAnalysisSourceMetadataPropertiesArgs:
    def __init__(__self__, *,
                 artifacts: pulumi.Input['AnalysisTemplateArtifactMetadataArgs']):
        pulumi.set(__self__, "artifacts", artifacts)

    @_builtins.property
    @pulumi.getter
    def artifacts(self) -> pulumi.Input['AnalysisTemplateArtifactMetadataArgs']:
        return pulumi.get(self, "artifacts")

    @artifacts.setter
    def artifacts(self, value: pulumi.Input['AnalysisTemplateArtifactMetadataArgs']):
        pulumi.set(self, "artifacts", value)


if not MYPY:
    class AnalysisTemplateArtifactMetadataArgsDict(TypedDict):
        entry_point_hash: pulumi.Input['AnalysisTemplateHashArgsDict']
        additional_artifact_hashes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnalysisTemplateHashArgsDict']]]]
elif False:
    AnalysisTemplateArtifactMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateArtifactMetadataArgs:
    def __init__(__self__, *,
                 entry_point_hash: pulumi.Input['AnalysisTemplateHashArgs'],
                 additional_artifact_hashes: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisTemplateHashArgs']]]] = None):
        pulumi.set(__self__, "entry_point_hash", entry_point_hash)
        if additional_artifact_hashes is not None:
            pulumi.set(__self__, "additional_artifact_hashes", additional_artifact_hashes)

    @_builtins.property
    @pulumi.getter(name="entryPointHash")
    def entry_point_hash(self) -> pulumi.Input['AnalysisTemplateHashArgs']:
        return pulumi.get(self, "entry_point_hash")

    @entry_point_hash.setter
    def entry_point_hash(self, value: pulumi.Input['AnalysisTemplateHashArgs']):
        pulumi.set(self, "entry_point_hash", value)

    @_builtins.property
    @pulumi.getter(name="additionalArtifactHashes")
    def additional_artifact_hashes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisTemplateHashArgs']]]]:
        return pulumi.get(self, "additional_artifact_hashes")

    @additional_artifact_hashes.setter
    def additional_artifact_hashes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisTemplateHashArgs']]]]):
        pulumi.set(self, "additional_artifact_hashes", value)


if not MYPY:
    class AnalysisTemplateArtifactsArgsDict(TypedDict):
        entry_point: pulumi.Input['AnalysisTemplateArtifactArgsDict']
        role_arn: pulumi.Input[_builtins.str]
        additional_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnalysisTemplateArtifactArgsDict']]]]
elif False:
    AnalysisTemplateArtifactsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateArtifactsArgs:
    def __init__(__self__, *,
                 entry_point: pulumi.Input['AnalysisTemplateArtifactArgs'],
                 role_arn: pulumi.Input[_builtins.str],
                 additional_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisTemplateArtifactArgs']]]] = None):
        pulumi.set(__self__, "entry_point", entry_point)
        pulumi.set(__self__, "role_arn", role_arn)
        if additional_artifacts is not None:
            pulumi.set(__self__, "additional_artifacts", additional_artifacts)

    @_builtins.property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> pulumi.Input['AnalysisTemplateArtifactArgs']:
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: pulumi.Input['AnalysisTemplateArtifactArgs']):
        pulumi.set(self, "entry_point", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="additionalArtifacts")
    def additional_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisTemplateArtifactArgs']]]]:
        return pulumi.get(self, "additional_artifacts")

    @additional_artifacts.setter
    def additional_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisTemplateArtifactArgs']]]]):
        pulumi.set(self, "additional_artifacts", value)


if not MYPY:
    class AnalysisTemplateArtifactArgsDict(TypedDict):
        location: pulumi.Input['AnalysisTemplateS3LocationArgsDict']
elif False:
    AnalysisTemplateArtifactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateArtifactArgs:
    def __init__(__self__, *,
                 location: pulumi.Input['AnalysisTemplateS3LocationArgs']):
        pulumi.set(__self__, "location", location)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input['AnalysisTemplateS3LocationArgs']:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input['AnalysisTemplateS3LocationArgs']):
        pulumi.set(self, "location", value)


if not MYPY:
    class AnalysisTemplateErrorMessageConfigurationArgsDict(TypedDict):
        type: pulumi.Input['AnalysisTemplateErrorMessageConfigurationType']
        """
        The level of detail for error messages returned by the PySpark job. When set to DETAILED, error messages include more information to help troubleshoot issues with your PySpark job.

        Because this setting may expose sensitive data, it is recommended for development and testing environments.
        """
elif False:
    AnalysisTemplateErrorMessageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateErrorMessageConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['AnalysisTemplateErrorMessageConfigurationType']):
        """
        :param pulumi.Input['AnalysisTemplateErrorMessageConfigurationType'] type: The level of detail for error messages returned by the PySpark job. When set to DETAILED, error messages include more information to help troubleshoot issues with your PySpark job.
               
               Because this setting may expose sensitive data, it is recommended for development and testing environments.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['AnalysisTemplateErrorMessageConfigurationType']:
        """
        The level of detail for error messages returned by the PySpark job. When set to DETAILED, error messages include more information to help troubleshoot issues with your PySpark job.

        Because this setting may expose sensitive data, it is recommended for development and testing environments.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['AnalysisTemplateErrorMessageConfigurationType']):
        pulumi.set(self, "type", value)


if not MYPY:
    class AnalysisTemplateHashArgsDict(TypedDict):
        sha256: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AnalysisTemplateHashArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateHashArgs:
    def __init__(__self__, *,
                 sha256: Optional[pulumi.Input[_builtins.str]] = None):
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sha256", value)


if not MYPY:
    class AnalysisTemplateS3LocationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        key: pulumi.Input[_builtins.str]
elif False:
    AnalysisTemplateS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisTemplateS3LocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class CollaborationDataEncryptionMetadataArgsDict(TypedDict):
        allow_cleartext: pulumi.Input[_builtins.bool]
        """
        Indicates whether encrypted tables can contain cleartext data ( `TRUE` ) or are to cryptographically process every column ( `FALSE` ).
        """
        allow_duplicates: pulumi.Input[_builtins.bool]
        """
        Indicates whether Fingerprint columns can contain duplicate entries ( `TRUE` ) or are to contain only non-repeated values ( `FALSE` ).
        """
        allow_joins_on_columns_with_different_names: pulumi.Input[_builtins.bool]
        """
        Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name ( `TRUE` ) or can only be joined on Fingerprint columns of the same name ( `FALSE` ).
        """
        preserve_nulls: pulumi.Input[_builtins.bool]
        """
        Indicates whether NULL values are to be copied as NULL to encrypted tables ( `TRUE` ) or cryptographically processed ( `FALSE` ).
        """
elif False:
    CollaborationDataEncryptionMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationDataEncryptionMetadataArgs:
    def __init__(__self__, *,
                 allow_cleartext: pulumi.Input[_builtins.bool],
                 allow_duplicates: pulumi.Input[_builtins.bool],
                 allow_joins_on_columns_with_different_names: pulumi.Input[_builtins.bool],
                 preserve_nulls: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] allow_cleartext: Indicates whether encrypted tables can contain cleartext data ( `TRUE` ) or are to cryptographically process every column ( `FALSE` ).
        :param pulumi.Input[_builtins.bool] allow_duplicates: Indicates whether Fingerprint columns can contain duplicate entries ( `TRUE` ) or are to contain only non-repeated values ( `FALSE` ).
        :param pulumi.Input[_builtins.bool] allow_joins_on_columns_with_different_names: Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name ( `TRUE` ) or can only be joined on Fingerprint columns of the same name ( `FALSE` ).
        :param pulumi.Input[_builtins.bool] preserve_nulls: Indicates whether NULL values are to be copied as NULL to encrypted tables ( `TRUE` ) or cryptographically processed ( `FALSE` ).
        """
        pulumi.set(__self__, "allow_cleartext", allow_cleartext)
        pulumi.set(__self__, "allow_duplicates", allow_duplicates)
        pulumi.set(__self__, "allow_joins_on_columns_with_different_names", allow_joins_on_columns_with_different_names)
        pulumi.set(__self__, "preserve_nulls", preserve_nulls)

    @_builtins.property
    @pulumi.getter(name="allowCleartext")
    def allow_cleartext(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether encrypted tables can contain cleartext data ( `TRUE` ) or are to cryptographically process every column ( `FALSE` ).
        """
        return pulumi.get(self, "allow_cleartext")

    @allow_cleartext.setter
    def allow_cleartext(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "allow_cleartext", value)

    @_builtins.property
    @pulumi.getter(name="allowDuplicates")
    def allow_duplicates(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether Fingerprint columns can contain duplicate entries ( `TRUE` ) or are to contain only non-repeated values ( `FALSE` ).
        """
        return pulumi.get(self, "allow_duplicates")

    @allow_duplicates.setter
    def allow_duplicates(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "allow_duplicates", value)

    @_builtins.property
    @pulumi.getter(name="allowJoinsOnColumnsWithDifferentNames")
    def allow_joins_on_columns_with_different_names(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name ( `TRUE` ) or can only be joined on Fingerprint columns of the same name ( `FALSE` ).
        """
        return pulumi.get(self, "allow_joins_on_columns_with_different_names")

    @allow_joins_on_columns_with_different_names.setter
    def allow_joins_on_columns_with_different_names(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "allow_joins_on_columns_with_different_names", value)

    @_builtins.property
    @pulumi.getter(name="preserveNulls")
    def preserve_nulls(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether NULL values are to be copied as NULL to encrypted tables ( `TRUE` ) or cryptographically processed ( `FALSE` ).
        """
        return pulumi.get(self, "preserve_nulls")

    @preserve_nulls.setter
    def preserve_nulls(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "preserve_nulls", value)


if not MYPY:
    class CollaborationJobComputePaymentConfigArgsDict(TypedDict):
        is_responsible: pulumi.Input[_builtins.bool]
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for query and job compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query and job compute costs ( `FALSE` ).

        Exactly one member can be configured to pay for query and job compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        An error is returned if the collaboration creator sets a `FALSE` value for the member who can run queries and jobs.
        """
elif False:
    CollaborationJobComputePaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationJobComputePaymentConfigArgs:
    def __init__(__self__, *,
                 is_responsible: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] is_responsible: Indicates whether the collaboration creator has configured the collaboration member to pay for query and job compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query and job compute costs ( `FALSE` ).
               
               Exactly one member can be configured to pay for query and job compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.
               
               An error is returned if the collaboration creator sets a `FALSE` value for the member who can run queries and jobs.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @_builtins.property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for query and job compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query and job compute costs ( `FALSE` ).

        Exactly one member can be configured to pay for query and job compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        An error is returned if the collaboration creator sets a `FALSE` value for the member who can run queries and jobs.
        """
        return pulumi.get(self, "is_responsible")

    @is_responsible.setter
    def is_responsible(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_responsible", value)


if not MYPY:
    class CollaborationMemberSpecificationArgsDict(TypedDict):
        account_id: pulumi.Input[_builtins.str]
        """
        The identifier used to reference members of the collaboration. Currently only supports AWS account ID.
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The member's display name.
        """
        member_abilities: NotRequired[pulumi.Input[Sequence[pulumi.Input['CollaborationMemberAbility']]]]
        """
        The abilities granted to the collaboration member.

        *Allowed Values* : `CAN_QUERY` | `CAN_RECEIVE_RESULTS`
        """
        ml_member_abilities: NotRequired[pulumi.Input['CollaborationMlMemberAbilitiesArgsDict']]
        """
        The ML abilities granted to the collaboration member.
        """
        payment_configuration: NotRequired[pulumi.Input['CollaborationPaymentConfigurationArgsDict']]
        """
        The collaboration member's payment responsibilities set by the collaboration creator.

        If the collaboration creator hasn't speciﬁed anyone as the member paying for query compute costs, then the member who can query is the default payer.
        """
elif False:
    CollaborationMemberSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationMemberSpecificationArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 member_abilities: Optional[pulumi.Input[Sequence[pulumi.Input['CollaborationMemberAbility']]]] = None,
                 ml_member_abilities: Optional[pulumi.Input['CollaborationMlMemberAbilitiesArgs']] = None,
                 payment_configuration: Optional[pulumi.Input['CollaborationPaymentConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] account_id: The identifier used to reference members of the collaboration. Currently only supports AWS account ID.
        :param pulumi.Input[_builtins.str] display_name: The member's display name.
        :param pulumi.Input[Sequence[pulumi.Input['CollaborationMemberAbility']]] member_abilities: The abilities granted to the collaboration member.
               
               *Allowed Values* : `CAN_QUERY` | `CAN_RECEIVE_RESULTS`
        :param pulumi.Input['CollaborationMlMemberAbilitiesArgs'] ml_member_abilities: The ML abilities granted to the collaboration member.
        :param pulumi.Input['CollaborationPaymentConfigurationArgs'] payment_configuration: The collaboration member's payment responsibilities set by the collaboration creator.
               
               If the collaboration creator hasn't speciﬁed anyone as the member paying for query compute costs, then the member who can query is the default payer.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "display_name", display_name)
        if member_abilities is not None:
            pulumi.set(__self__, "member_abilities", member_abilities)
        if ml_member_abilities is not None:
            pulumi.set(__self__, "ml_member_abilities", ml_member_abilities)
        if payment_configuration is not None:
            pulumi.set(__self__, "payment_configuration", payment_configuration)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier used to reference members of the collaboration. Currently only supports AWS account ID.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The member's display name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="memberAbilities")
    def member_abilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CollaborationMemberAbility']]]]:
        """
        The abilities granted to the collaboration member.

        *Allowed Values* : `CAN_QUERY` | `CAN_RECEIVE_RESULTS`
        """
        return pulumi.get(self, "member_abilities")

    @member_abilities.setter
    def member_abilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CollaborationMemberAbility']]]]):
        pulumi.set(self, "member_abilities", value)

    @_builtins.property
    @pulumi.getter(name="mlMemberAbilities")
    def ml_member_abilities(self) -> Optional[pulumi.Input['CollaborationMlMemberAbilitiesArgs']]:
        """
        The ML abilities granted to the collaboration member.
        """
        return pulumi.get(self, "ml_member_abilities")

    @ml_member_abilities.setter
    def ml_member_abilities(self, value: Optional[pulumi.Input['CollaborationMlMemberAbilitiesArgs']]):
        pulumi.set(self, "ml_member_abilities", value)

    @_builtins.property
    @pulumi.getter(name="paymentConfiguration")
    def payment_configuration(self) -> Optional[pulumi.Input['CollaborationPaymentConfigurationArgs']]:
        """
        The collaboration member's payment responsibilities set by the collaboration creator.

        If the collaboration creator hasn't speciﬁed anyone as the member paying for query compute costs, then the member who can query is the default payer.
        """
        return pulumi.get(self, "payment_configuration")

    @payment_configuration.setter
    def payment_configuration(self, value: Optional[pulumi.Input['CollaborationPaymentConfigurationArgs']]):
        pulumi.set(self, "payment_configuration", value)


if not MYPY:
    class CollaborationMlMemberAbilitiesArgsDict(TypedDict):
        custom_ml_member_abilities: pulumi.Input[Sequence[pulumi.Input['CollaborationCustomMlMemberAbility']]]
        """
        The custom ML member abilities for a collaboration member.
        """
elif False:
    CollaborationMlMemberAbilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationMlMemberAbilitiesArgs:
    def __init__(__self__, *,
                 custom_ml_member_abilities: pulumi.Input[Sequence[pulumi.Input['CollaborationCustomMlMemberAbility']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CollaborationCustomMlMemberAbility']]] custom_ml_member_abilities: The custom ML member abilities for a collaboration member.
        """
        pulumi.set(__self__, "custom_ml_member_abilities", custom_ml_member_abilities)

    @_builtins.property
    @pulumi.getter(name="customMlMemberAbilities")
    def custom_ml_member_abilities(self) -> pulumi.Input[Sequence[pulumi.Input['CollaborationCustomMlMemberAbility']]]:
        """
        The custom ML member abilities for a collaboration member.
        """
        return pulumi.get(self, "custom_ml_member_abilities")

    @custom_ml_member_abilities.setter
    def custom_ml_member_abilities(self, value: pulumi.Input[Sequence[pulumi.Input['CollaborationCustomMlMemberAbility']]]):
        pulumi.set(self, "custom_ml_member_abilities", value)


if not MYPY:
    class CollaborationMlPaymentConfigArgsDict(TypedDict):
        model_inference: NotRequired[pulumi.Input['CollaborationModelInferencePaymentConfigArgsDict']]
        """
        The payment responsibilities accepted by the member for model inference.
        """
        model_training: NotRequired[pulumi.Input['CollaborationModelTrainingPaymentConfigArgsDict']]
        """
        The payment responsibilities accepted by the member for model training.
        """
elif False:
    CollaborationMlPaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationMlPaymentConfigArgs:
    def __init__(__self__, *,
                 model_inference: Optional[pulumi.Input['CollaborationModelInferencePaymentConfigArgs']] = None,
                 model_training: Optional[pulumi.Input['CollaborationModelTrainingPaymentConfigArgs']] = None):
        """
        :param pulumi.Input['CollaborationModelInferencePaymentConfigArgs'] model_inference: The payment responsibilities accepted by the member for model inference.
        :param pulumi.Input['CollaborationModelTrainingPaymentConfigArgs'] model_training: The payment responsibilities accepted by the member for model training.
        """
        if model_inference is not None:
            pulumi.set(__self__, "model_inference", model_inference)
        if model_training is not None:
            pulumi.set(__self__, "model_training", model_training)

    @_builtins.property
    @pulumi.getter(name="modelInference")
    def model_inference(self) -> Optional[pulumi.Input['CollaborationModelInferencePaymentConfigArgs']]:
        """
        The payment responsibilities accepted by the member for model inference.
        """
        return pulumi.get(self, "model_inference")

    @model_inference.setter
    def model_inference(self, value: Optional[pulumi.Input['CollaborationModelInferencePaymentConfigArgs']]):
        pulumi.set(self, "model_inference", value)

    @_builtins.property
    @pulumi.getter(name="modelTraining")
    def model_training(self) -> Optional[pulumi.Input['CollaborationModelTrainingPaymentConfigArgs']]:
        """
        The payment responsibilities accepted by the member for model training.
        """
        return pulumi.get(self, "model_training")

    @model_training.setter
    def model_training(self, value: Optional[pulumi.Input['CollaborationModelTrainingPaymentConfigArgs']]):
        pulumi.set(self, "model_training", value)


if not MYPY:
    class CollaborationModelInferencePaymentConfigArgsDict(TypedDict):
        is_responsible: pulumi.Input[_builtins.bool]
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for model inference costs ( `TRUE` ) or has not configured the collaboration member to pay for model inference costs ( `FALSE` ).

        Exactly one member can be configured to pay for model inference costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        If the collaboration creator hasn't specified anyone as the member paying for model inference costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
elif False:
    CollaborationModelInferencePaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationModelInferencePaymentConfigArgs:
    def __init__(__self__, *,
                 is_responsible: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] is_responsible: Indicates whether the collaboration creator has configured the collaboration member to pay for model inference costs ( `TRUE` ) or has not configured the collaboration member to pay for model inference costs ( `FALSE` ).
               
               Exactly one member can be configured to pay for model inference costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.
               
               If the collaboration creator hasn't specified anyone as the member paying for model inference costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @_builtins.property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for model inference costs ( `TRUE` ) or has not configured the collaboration member to pay for model inference costs ( `FALSE` ).

        Exactly one member can be configured to pay for model inference costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        If the collaboration creator hasn't specified anyone as the member paying for model inference costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        return pulumi.get(self, "is_responsible")

    @is_responsible.setter
    def is_responsible(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_responsible", value)


if not MYPY:
    class CollaborationModelTrainingPaymentConfigArgsDict(TypedDict):
        is_responsible: pulumi.Input[_builtins.bool]
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for model training costs ( `TRUE` ) or has not configured the collaboration member to pay for model training costs ( `FALSE` ).

        Exactly one member can be configured to pay for model training costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        If the collaboration creator hasn't specified anyone as the member paying for model training costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
elif False:
    CollaborationModelTrainingPaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationModelTrainingPaymentConfigArgs:
    def __init__(__self__, *,
                 is_responsible: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] is_responsible: Indicates whether the collaboration creator has configured the collaboration member to pay for model training costs ( `TRUE` ) or has not configured the collaboration member to pay for model training costs ( `FALSE` ).
               
               Exactly one member can be configured to pay for model training costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.
               
               If the collaboration creator hasn't specified anyone as the member paying for model training costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @_builtins.property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for model training costs ( `TRUE` ) or has not configured the collaboration member to pay for model training costs ( `FALSE` ).

        Exactly one member can be configured to pay for model training costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        If the collaboration creator hasn't specified anyone as the member paying for model training costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        return pulumi.get(self, "is_responsible")

    @is_responsible.setter
    def is_responsible(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_responsible", value)


if not MYPY:
    class CollaborationPaymentConfigurationArgsDict(TypedDict):
        query_compute: pulumi.Input['CollaborationQueryComputePaymentConfigArgsDict']
        """
        The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        """
        job_compute: NotRequired[pulumi.Input['CollaborationJobComputePaymentConfigArgsDict']]
        """
        The compute configuration for the job.
        """
        machine_learning: NotRequired[pulumi.Input['CollaborationMlPaymentConfigArgsDict']]
        """
        An object representing the collaboration member's machine learning payment responsibilities set by the collaboration creator.
        """
elif False:
    CollaborationPaymentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationPaymentConfigurationArgs:
    def __init__(__self__, *,
                 query_compute: pulumi.Input['CollaborationQueryComputePaymentConfigArgs'],
                 job_compute: Optional[pulumi.Input['CollaborationJobComputePaymentConfigArgs']] = None,
                 machine_learning: Optional[pulumi.Input['CollaborationMlPaymentConfigArgs']] = None):
        """
        :param pulumi.Input['CollaborationQueryComputePaymentConfigArgs'] query_compute: The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        :param pulumi.Input['CollaborationJobComputePaymentConfigArgs'] job_compute: The compute configuration for the job.
        :param pulumi.Input['CollaborationMlPaymentConfigArgs'] machine_learning: An object representing the collaboration member's machine learning payment responsibilities set by the collaboration creator.
        """
        pulumi.set(__self__, "query_compute", query_compute)
        if job_compute is not None:
            pulumi.set(__self__, "job_compute", job_compute)
        if machine_learning is not None:
            pulumi.set(__self__, "machine_learning", machine_learning)

    @_builtins.property
    @pulumi.getter(name="queryCompute")
    def query_compute(self) -> pulumi.Input['CollaborationQueryComputePaymentConfigArgs']:
        """
        The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        """
        return pulumi.get(self, "query_compute")

    @query_compute.setter
    def query_compute(self, value: pulumi.Input['CollaborationQueryComputePaymentConfigArgs']):
        pulumi.set(self, "query_compute", value)

    @_builtins.property
    @pulumi.getter(name="jobCompute")
    def job_compute(self) -> Optional[pulumi.Input['CollaborationJobComputePaymentConfigArgs']]:
        """
        The compute configuration for the job.
        """
        return pulumi.get(self, "job_compute")

    @job_compute.setter
    def job_compute(self, value: Optional[pulumi.Input['CollaborationJobComputePaymentConfigArgs']]):
        pulumi.set(self, "job_compute", value)

    @_builtins.property
    @pulumi.getter(name="machineLearning")
    def machine_learning(self) -> Optional[pulumi.Input['CollaborationMlPaymentConfigArgs']]:
        """
        An object representing the collaboration member's machine learning payment responsibilities set by the collaboration creator.
        """
        return pulumi.get(self, "machine_learning")

    @machine_learning.setter
    def machine_learning(self, value: Optional[pulumi.Input['CollaborationMlPaymentConfigArgs']]):
        pulumi.set(self, "machine_learning", value)


if not MYPY:
    class CollaborationQueryComputePaymentConfigArgsDict(TypedDict):
        is_responsible: pulumi.Input[_builtins.bool]
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query compute costs ( `FALSE` ).

        Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
elif False:
    CollaborationQueryComputePaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollaborationQueryComputePaymentConfigArgs:
    def __init__(__self__, *,
                 is_responsible: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] is_responsible: Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query compute costs ( `FALSE` ).
               
               Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.
               
               If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @_builtins.property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs ( `TRUE` ) or has not configured the collaboration member to pay for query compute costs ( `FALSE` ).

        Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a `TRUE` value for more than one member in the collaboration.

        If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a `FALSE` value for the member who can query.
        """
        return pulumi.get(self, "is_responsible")

    @is_responsible.setter
    def is_responsible(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_responsible", value)


if not MYPY:
    class ConfiguredTableAggregateColumnArgsDict(TypedDict):
        column_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        function: pulumi.Input['ConfiguredTableAggregateFunctionName']
elif False:
    ConfiguredTableAggregateColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAggregateColumnArgs:
    def __init__(__self__, *,
                 column_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 function: pulumi.Input['ConfiguredTableAggregateFunctionName']):
        pulumi.set(__self__, "column_names", column_names)
        pulumi.set(__self__, "function", function)

    @_builtins.property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "column_names", value)

    @_builtins.property
    @pulumi.getter
    def function(self) -> pulumi.Input['ConfiguredTableAggregateFunctionName']:
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: pulumi.Input['ConfiguredTableAggregateFunctionName']):
        pulumi.set(self, "function", value)


if not MYPY:
    class ConfiguredTableAggregationConstraintArgsDict(TypedDict):
        column_name: pulumi.Input[_builtins.str]
        minimum: pulumi.Input[_builtins.float]
        type: pulumi.Input['ConfiguredTableAggregationType']
elif False:
    ConfiguredTableAggregationConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAggregationConstraintArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[_builtins.str],
                 minimum: pulumi.Input[_builtins.float],
                 type: pulumi.Input['ConfiguredTableAggregationType']):
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "minimum", minimum)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "minimum", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['ConfiguredTableAggregationType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ConfiguredTableAggregationType']):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConfiguredTableAnalysisRuleAggregationArgsDict(TypedDict):
        aggregate_columns: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregateColumnArgsDict']]]
        dimension_columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        join_columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        output_constraints: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregationConstraintArgsDict']]]
        scalar_functions: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableScalarFunctions']]]
        additional_analyses: NotRequired[pulumi.Input['ConfiguredTableAdditionalAnalyses']]
        allowed_join_operators: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]
        join_required: NotRequired[pulumi.Input['ConfiguredTableJoinRequiredOption']]
elif False:
    ConfiguredTableAnalysisRuleAggregationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRuleAggregationArgs:
    def __init__(__self__, *,
                 aggregate_columns: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregateColumnArgs']]],
                 dimension_columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 join_columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 output_constraints: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregationConstraintArgs']]],
                 scalar_functions: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableScalarFunctions']]],
                 additional_analyses: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']] = None,
                 allowed_join_operators: Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]] = None,
                 join_required: Optional[pulumi.Input['ConfiguredTableJoinRequiredOption']] = None):
        pulumi.set(__self__, "aggregate_columns", aggregate_columns)
        pulumi.set(__self__, "dimension_columns", dimension_columns)
        pulumi.set(__self__, "join_columns", join_columns)
        pulumi.set(__self__, "output_constraints", output_constraints)
        pulumi.set(__self__, "scalar_functions", scalar_functions)
        if additional_analyses is not None:
            pulumi.set(__self__, "additional_analyses", additional_analyses)
        if allowed_join_operators is not None:
            pulumi.set(__self__, "allowed_join_operators", allowed_join_operators)
        if join_required is not None:
            pulumi.set(__self__, "join_required", join_required)

    @_builtins.property
    @pulumi.getter(name="aggregateColumns")
    def aggregate_columns(self) -> pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregateColumnArgs']]]:
        return pulumi.get(self, "aggregate_columns")

    @aggregate_columns.setter
    def aggregate_columns(self, value: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregateColumnArgs']]]):
        pulumi.set(self, "aggregate_columns", value)

    @_builtins.property
    @pulumi.getter(name="dimensionColumns")
    def dimension_columns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "dimension_columns")

    @dimension_columns.setter
    def dimension_columns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "dimension_columns", value)

    @_builtins.property
    @pulumi.getter(name="joinColumns")
    def join_columns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "join_columns")

    @join_columns.setter
    def join_columns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "join_columns", value)

    @_builtins.property
    @pulumi.getter(name="outputConstraints")
    def output_constraints(self) -> pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregationConstraintArgs']]]:
        return pulumi.get(self, "output_constraints")

    @output_constraints.setter
    def output_constraints(self, value: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableAggregationConstraintArgs']]]):
        pulumi.set(self, "output_constraints", value)

    @_builtins.property
    @pulumi.getter(name="scalarFunctions")
    def scalar_functions(self) -> pulumi.Input[Sequence[pulumi.Input['ConfiguredTableScalarFunctions']]]:
        return pulumi.get(self, "scalar_functions")

    @scalar_functions.setter
    def scalar_functions(self, value: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableScalarFunctions']]]):
        pulumi.set(self, "scalar_functions", value)

    @_builtins.property
    @pulumi.getter(name="additionalAnalyses")
    def additional_analyses(self) -> Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]:
        return pulumi.get(self, "additional_analyses")

    @additional_analyses.setter
    def additional_analyses(self, value: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]):
        pulumi.set(self, "additional_analyses", value)

    @_builtins.property
    @pulumi.getter(name="allowedJoinOperators")
    def allowed_join_operators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]:
        return pulumi.get(self, "allowed_join_operators")

    @allowed_join_operators.setter
    def allowed_join_operators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]):
        pulumi.set(self, "allowed_join_operators", value)

    @_builtins.property
    @pulumi.getter(name="joinRequired")
    def join_required(self) -> Optional[pulumi.Input['ConfiguredTableJoinRequiredOption']]:
        return pulumi.get(self, "join_required")

    @join_required.setter
    def join_required(self, value: Optional[pulumi.Input['ConfiguredTableJoinRequiredOption']]):
        pulumi.set(self, "join_required", value)


if not MYPY:
    class ConfiguredTableAnalysisRuleCustomArgsDict(TypedDict):
        allowed_analyses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        additional_analyses: NotRequired[pulumi.Input['ConfiguredTableAdditionalAnalyses']]
        allowed_analysis_providers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        differential_privacy: NotRequired[pulumi.Input['ConfiguredTableDifferentialPrivacyArgsDict']]
        disallowed_output_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ConfiguredTableAnalysisRuleCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRuleCustomArgs:
    def __init__(__self__, *,
                 allowed_analyses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 additional_analyses: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']] = None,
                 allowed_analysis_providers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 differential_privacy: Optional[pulumi.Input['ConfiguredTableDifferentialPrivacyArgs']] = None,
                 disallowed_output_columns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "allowed_analyses", allowed_analyses)
        if additional_analyses is not None:
            pulumi.set(__self__, "additional_analyses", additional_analyses)
        if allowed_analysis_providers is not None:
            pulumi.set(__self__, "allowed_analysis_providers", allowed_analysis_providers)
        if differential_privacy is not None:
            pulumi.set(__self__, "differential_privacy", differential_privacy)
        if disallowed_output_columns is not None:
            pulumi.set(__self__, "disallowed_output_columns", disallowed_output_columns)

    @_builtins.property
    @pulumi.getter(name="allowedAnalyses")
    def allowed_analyses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "allowed_analyses")

    @allowed_analyses.setter
    def allowed_analyses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_analyses", value)

    @_builtins.property
    @pulumi.getter(name="additionalAnalyses")
    def additional_analyses(self) -> Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]:
        return pulumi.get(self, "additional_analyses")

    @additional_analyses.setter
    def additional_analyses(self, value: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]):
        pulumi.set(self, "additional_analyses", value)

    @_builtins.property
    @pulumi.getter(name="allowedAnalysisProviders")
    def allowed_analysis_providers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allowed_analysis_providers")

    @allowed_analysis_providers.setter
    def allowed_analysis_providers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_analysis_providers", value)

    @_builtins.property
    @pulumi.getter(name="differentialPrivacy")
    def differential_privacy(self) -> Optional[pulumi.Input['ConfiguredTableDifferentialPrivacyArgs']]:
        return pulumi.get(self, "differential_privacy")

    @differential_privacy.setter
    def differential_privacy(self, value: Optional[pulumi.Input['ConfiguredTableDifferentialPrivacyArgs']]):
        pulumi.set(self, "differential_privacy", value)

    @_builtins.property
    @pulumi.getter(name="disallowedOutputColumns")
    def disallowed_output_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "disallowed_output_columns")

    @disallowed_output_columns.setter
    def disallowed_output_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "disallowed_output_columns", value)


if not MYPY:
    class ConfiguredTableAnalysisRuleListArgsDict(TypedDict):
        join_columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        list_columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        additional_analyses: NotRequired[pulumi.Input['ConfiguredTableAdditionalAnalyses']]
        allowed_join_operators: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]
elif False:
    ConfiguredTableAnalysisRuleListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRuleListArgs:
    def __init__(__self__, *,
                 join_columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 list_columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 additional_analyses: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']] = None,
                 allowed_join_operators: Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]] = None):
        pulumi.set(__self__, "join_columns", join_columns)
        pulumi.set(__self__, "list_columns", list_columns)
        if additional_analyses is not None:
            pulumi.set(__self__, "additional_analyses", additional_analyses)
        if allowed_join_operators is not None:
            pulumi.set(__self__, "allowed_join_operators", allowed_join_operators)

    @_builtins.property
    @pulumi.getter(name="joinColumns")
    def join_columns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "join_columns")

    @join_columns.setter
    def join_columns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "join_columns", value)

    @_builtins.property
    @pulumi.getter(name="listColumns")
    def list_columns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "list_columns")

    @list_columns.setter
    def list_columns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "list_columns", value)

    @_builtins.property
    @pulumi.getter(name="additionalAnalyses")
    def additional_analyses(self) -> Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]:
        return pulumi.get(self, "additional_analyses")

    @additional_analyses.setter
    def additional_analyses(self, value: Optional[pulumi.Input['ConfiguredTableAdditionalAnalyses']]):
        pulumi.set(self, "additional_analyses", value)

    @_builtins.property
    @pulumi.getter(name="allowedJoinOperators")
    def allowed_join_operators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]:
        return pulumi.get(self, "allowed_join_operators")

    @allowed_join_operators.setter
    def allowed_join_operators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfiguredTableJoinOperator']]]]):
        pulumi.set(self, "allowed_join_operators", value)


if not MYPY:
    class ConfiguredTableAnalysisRulePolicyV10PropertiesArgsDict(TypedDict):
        list: pulumi.Input['ConfiguredTableAnalysisRuleListArgsDict']
elif False:
    ConfiguredTableAnalysisRulePolicyV10PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRulePolicyV10PropertiesArgs:
    def __init__(__self__, *,
                 list: pulumi.Input['ConfiguredTableAnalysisRuleListArgs']):
        pulumi.set(__self__, "list", list)

    @_builtins.property
    @pulumi.getter
    def list(self) -> pulumi.Input['ConfiguredTableAnalysisRuleListArgs']:
        return pulumi.get(self, "list")

    @list.setter
    def list(self, value: pulumi.Input['ConfiguredTableAnalysisRuleListArgs']):
        pulumi.set(self, "list", value)


if not MYPY:
    class ConfiguredTableAnalysisRulePolicyV11PropertiesArgsDict(TypedDict):
        aggregation: pulumi.Input['ConfiguredTableAnalysisRuleAggregationArgsDict']
elif False:
    ConfiguredTableAnalysisRulePolicyV11PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRulePolicyV11PropertiesArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input['ConfiguredTableAnalysisRuleAggregationArgs']):
        pulumi.set(__self__, "aggregation", aggregation)

    @_builtins.property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input['ConfiguredTableAnalysisRuleAggregationArgs']:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input['ConfiguredTableAnalysisRuleAggregationArgs']):
        pulumi.set(self, "aggregation", value)


if not MYPY:
    class ConfiguredTableAnalysisRulePolicyV12PropertiesArgsDict(TypedDict):
        custom: pulumi.Input['ConfiguredTableAnalysisRuleCustomArgsDict']
elif False:
    ConfiguredTableAnalysisRulePolicyV12PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRulePolicyV12PropertiesArgs:
    def __init__(__self__, *,
                 custom: pulumi.Input['ConfiguredTableAnalysisRuleCustomArgs']):
        pulumi.set(__self__, "custom", custom)

    @_builtins.property
    @pulumi.getter
    def custom(self) -> pulumi.Input['ConfiguredTableAnalysisRuleCustomArgs']:
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: pulumi.Input['ConfiguredTableAnalysisRuleCustomArgs']):
        pulumi.set(self, "custom", value)


if not MYPY:
    class ConfiguredTableAnalysisRulePolicyArgsDict(TypedDict):
        v1: pulumi.Input[Union['ConfiguredTableAnalysisRulePolicyV10PropertiesArgsDict', 'ConfiguredTableAnalysisRulePolicyV11PropertiesArgsDict', 'ConfiguredTableAnalysisRulePolicyV12PropertiesArgsDict']]
        """
        Controls on the query specifications that can be run on a configured table.
        """
elif False:
    ConfiguredTableAnalysisRulePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRulePolicyArgs:
    def __init__(__self__, *,
                 v1: pulumi.Input[Union['ConfiguredTableAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV12PropertiesArgs']]):
        """
        :param pulumi.Input[Union['ConfiguredTableAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV12PropertiesArgs']] v1: Controls on the query specifications that can be run on a configured table.
        """
        pulumi.set(__self__, "v1", v1)

    @_builtins.property
    @pulumi.getter
    def v1(self) -> pulumi.Input[Union['ConfiguredTableAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV12PropertiesArgs']]:
        """
        Controls on the query specifications that can be run on a configured table.
        """
        return pulumi.get(self, "v1")

    @v1.setter
    def v1(self, value: pulumi.Input[Union['ConfiguredTableAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAnalysisRulePolicyV12PropertiesArgs']]):
        pulumi.set(self, "v1", value)


if not MYPY:
    class ConfiguredTableAnalysisRuleArgsDict(TypedDict):
        policy: pulumi.Input['ConfiguredTableAnalysisRulePolicyArgsDict']
        """
        A policy that describes the associated data usage limitations.
        """
        type: pulumi.Input['ConfiguredTableAnalysisRuleType']
        """
        The type of analysis rule.
        """
elif False:
    ConfiguredTableAnalysisRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAnalysisRuleArgs:
    def __init__(__self__, *,
                 policy: pulumi.Input['ConfiguredTableAnalysisRulePolicyArgs'],
                 type: pulumi.Input['ConfiguredTableAnalysisRuleType']):
        """
        :param pulumi.Input['ConfiguredTableAnalysisRulePolicyArgs'] policy: A policy that describes the associated data usage limitations.
        :param pulumi.Input['ConfiguredTableAnalysisRuleType'] type: The type of analysis rule.
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> pulumi.Input['ConfiguredTableAnalysisRulePolicyArgs']:
        """
        A policy that describes the associated data usage limitations.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: pulumi.Input['ConfiguredTableAnalysisRulePolicyArgs']):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['ConfiguredTableAnalysisRuleType']:
        """
        The type of analysis rule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ConfiguredTableAnalysisRuleType']):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRuleAggregationArgsDict(TypedDict):
        allowed_additional_analyses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        allowed_result_receivers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ConfiguredTableAssociationAnalysisRuleAggregationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRuleAggregationArgs:
    def __init__(__self__, *,
                 allowed_additional_analyses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_result_receivers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if allowed_additional_analyses is not None:
            pulumi.set(__self__, "allowed_additional_analyses", allowed_additional_analyses)
        if allowed_result_receivers is not None:
            pulumi.set(__self__, "allowed_result_receivers", allowed_result_receivers)

    @_builtins.property
    @pulumi.getter(name="allowedAdditionalAnalyses")
    def allowed_additional_analyses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allowed_additional_analyses")

    @allowed_additional_analyses.setter
    def allowed_additional_analyses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_additional_analyses", value)

    @_builtins.property
    @pulumi.getter(name="allowedResultReceivers")
    def allowed_result_receivers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allowed_result_receivers")

    @allowed_result_receivers.setter
    def allowed_result_receivers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_result_receivers", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRuleCustomArgsDict(TypedDict):
        allowed_additional_analyses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        allowed_result_receivers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ConfiguredTableAssociationAnalysisRuleCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRuleCustomArgs:
    def __init__(__self__, *,
                 allowed_additional_analyses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_result_receivers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if allowed_additional_analyses is not None:
            pulumi.set(__self__, "allowed_additional_analyses", allowed_additional_analyses)
        if allowed_result_receivers is not None:
            pulumi.set(__self__, "allowed_result_receivers", allowed_result_receivers)

    @_builtins.property
    @pulumi.getter(name="allowedAdditionalAnalyses")
    def allowed_additional_analyses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allowed_additional_analyses")

    @allowed_additional_analyses.setter
    def allowed_additional_analyses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_additional_analyses", value)

    @_builtins.property
    @pulumi.getter(name="allowedResultReceivers")
    def allowed_result_receivers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allowed_result_receivers")

    @allowed_result_receivers.setter
    def allowed_result_receivers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_result_receivers", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRuleListArgsDict(TypedDict):
        allowed_additional_analyses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        allowed_result_receivers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ConfiguredTableAssociationAnalysisRuleListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRuleListArgs:
    def __init__(__self__, *,
                 allowed_additional_analyses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_result_receivers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if allowed_additional_analyses is not None:
            pulumi.set(__self__, "allowed_additional_analyses", allowed_additional_analyses)
        if allowed_result_receivers is not None:
            pulumi.set(__self__, "allowed_result_receivers", allowed_result_receivers)

    @_builtins.property
    @pulumi.getter(name="allowedAdditionalAnalyses")
    def allowed_additional_analyses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allowed_additional_analyses")

    @allowed_additional_analyses.setter
    def allowed_additional_analyses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_additional_analyses", value)

    @_builtins.property
    @pulumi.getter(name="allowedResultReceivers")
    def allowed_result_receivers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allowed_result_receivers")

    @allowed_result_receivers.setter
    def allowed_result_receivers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_result_receivers", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgsDict(TypedDict):
        list: pulumi.Input['ConfiguredTableAssociationAnalysisRuleListArgsDict']
elif False:
    ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs:
    def __init__(__self__, *,
                 list: pulumi.Input['ConfiguredTableAssociationAnalysisRuleListArgs']):
        pulumi.set(__self__, "list", list)

    @_builtins.property
    @pulumi.getter
    def list(self) -> pulumi.Input['ConfiguredTableAssociationAnalysisRuleListArgs']:
        return pulumi.get(self, "list")

    @list.setter
    def list(self, value: pulumi.Input['ConfiguredTableAssociationAnalysisRuleListArgs']):
        pulumi.set(self, "list", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgsDict(TypedDict):
        aggregation: pulumi.Input['ConfiguredTableAssociationAnalysisRuleAggregationArgsDict']
elif False:
    ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input['ConfiguredTableAssociationAnalysisRuleAggregationArgs']):
        pulumi.set(__self__, "aggregation", aggregation)

    @_builtins.property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input['ConfiguredTableAssociationAnalysisRuleAggregationArgs']:
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input['ConfiguredTableAssociationAnalysisRuleAggregationArgs']):
        pulumi.set(self, "aggregation", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgsDict(TypedDict):
        custom: pulumi.Input['ConfiguredTableAssociationAnalysisRuleCustomArgsDict']
elif False:
    ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs:
    def __init__(__self__, *,
                 custom: pulumi.Input['ConfiguredTableAssociationAnalysisRuleCustomArgs']):
        pulumi.set(__self__, "custom", custom)

    @_builtins.property
    @pulumi.getter
    def custom(self) -> pulumi.Input['ConfiguredTableAssociationAnalysisRuleCustomArgs']:
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: pulumi.Input['ConfiguredTableAssociationAnalysisRuleCustomArgs']):
        pulumi.set(self, "custom", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRulePolicyArgsDict(TypedDict):
        v1: pulumi.Input[Union['ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgsDict', 'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgsDict', 'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgsDict']]
        """
        The policy for the configured table association analysis rule.
        """
elif False:
    ConfiguredTableAssociationAnalysisRulePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRulePolicyArgs:
    def __init__(__self__, *,
                 v1: pulumi.Input[Union['ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs']]):
        """
        :param pulumi.Input[Union['ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs']] v1: The policy for the configured table association analysis rule.
        """
        pulumi.set(__self__, "v1", v1)

    @_builtins.property
    @pulumi.getter
    def v1(self) -> pulumi.Input[Union['ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs']]:
        """
        The policy for the configured table association analysis rule.
        """
        return pulumi.get(self, "v1")

    @v1.setter
    def v1(self, value: pulumi.Input[Union['ConfiguredTableAssociationAnalysisRulePolicyV10PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV11PropertiesArgs', 'ConfiguredTableAssociationAnalysisRulePolicyV12PropertiesArgs']]):
        pulumi.set(self, "v1", value)


if not MYPY:
    class ConfiguredTableAssociationAnalysisRuleArgsDict(TypedDict):
        policy: pulumi.Input['ConfiguredTableAssociationAnalysisRulePolicyArgsDict']
        """
        The policy of the configured table association analysis rule.
        """
        type: pulumi.Input['ConfiguredTableAssociationAnalysisRuleType']
        """
        The type of the configured table association analysis rule.
        """
elif False:
    ConfiguredTableAssociationAnalysisRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAssociationAnalysisRuleArgs:
    def __init__(__self__, *,
                 policy: pulumi.Input['ConfiguredTableAssociationAnalysisRulePolicyArgs'],
                 type: pulumi.Input['ConfiguredTableAssociationAnalysisRuleType']):
        """
        :param pulumi.Input['ConfiguredTableAssociationAnalysisRulePolicyArgs'] policy: The policy of the configured table association analysis rule.
        :param pulumi.Input['ConfiguredTableAssociationAnalysisRuleType'] type: The type of the configured table association analysis rule.
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> pulumi.Input['ConfiguredTableAssociationAnalysisRulePolicyArgs']:
        """
        The policy of the configured table association analysis rule.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: pulumi.Input['ConfiguredTableAssociationAnalysisRulePolicyArgs']):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['ConfiguredTableAssociationAnalysisRuleType']:
        """
        The type of the configured table association analysis rule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ConfiguredTableAssociationAnalysisRuleType']):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConfiguredTableAthenaTableReferenceArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        table_name: pulumi.Input[_builtins.str]
        work_group: pulumi.Input[_builtins.str]
        output_location: NotRequired[pulumi.Input[_builtins.str]]
        region: NotRequired[pulumi.Input['ConfiguredTableCommercialRegion']]
elif False:
    ConfiguredTableAthenaTableReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableAthenaTableReferenceArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 work_group: pulumi.Input[_builtins.str],
                 output_location: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input['ConfiguredTableCommercialRegion']] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "work_group", work_group)
        if output_location is not None:
            pulumi.set(__self__, "output_location", output_location)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="workGroup")
    def work_group(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "work_group")

    @work_group.setter
    def work_group(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "work_group", value)

    @_builtins.property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "output_location")

    @output_location.setter
    def output_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_location", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input['ConfiguredTableCommercialRegion']]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input['ConfiguredTableCommercialRegion']]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ConfiguredTableDifferentialPrivacyColumnArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    ConfiguredTableDifferentialPrivacyColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableDifferentialPrivacyColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ConfiguredTableDifferentialPrivacyArgsDict(TypedDict):
        columns: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableDifferentialPrivacyColumnArgsDict']]]
elif False:
    ConfiguredTableDifferentialPrivacyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableDifferentialPrivacyArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableDifferentialPrivacyColumnArgs']]]):
        pulumi.set(__self__, "columns", columns)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input['ConfiguredTableDifferentialPrivacyColumnArgs']]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableDifferentialPrivacyColumnArgs']]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class ConfiguredTableGlueTableReferenceArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        table_name: pulumi.Input[_builtins.str]
        region: NotRequired[pulumi.Input['ConfiguredTableCommercialRegion']]
elif False:
    ConfiguredTableGlueTableReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableGlueTableReferenceArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 region: Optional[pulumi.Input['ConfiguredTableCommercialRegion']] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input['ConfiguredTableCommercialRegion']]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input['ConfiguredTableCommercialRegion']]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ConfiguredTableSnowflakeTableReferenceArgsDict(TypedDict):
        account_identifier: pulumi.Input[_builtins.str]
        database_name: pulumi.Input[_builtins.str]
        schema_name: pulumi.Input[_builtins.str]
        secret_arn: pulumi.Input[_builtins.str]
        table_name: pulumi.Input[_builtins.str]
        table_schema: pulumi.Input['ConfiguredTableSnowflakeTableSchemaPropertiesArgsDict']
elif False:
    ConfiguredTableSnowflakeTableReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableSnowflakeTableReferenceArgs:
    def __init__(__self__, *,
                 account_identifier: pulumi.Input[_builtins.str],
                 database_name: pulumi.Input[_builtins.str],
                 schema_name: pulumi.Input[_builtins.str],
                 secret_arn: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 table_schema: pulumi.Input['ConfiguredTableSnowflakeTableSchemaPropertiesArgs']):
        pulumi.set(__self__, "account_identifier", account_identifier)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "secret_arn", secret_arn)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "table_schema", table_schema)

    @_builtins.property
    @pulumi.getter(name="accountIdentifier")
    def account_identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "account_identifier")

    @account_identifier.setter
    def account_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_identifier", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schema_name", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="tableSchema")
    def table_schema(self) -> pulumi.Input['ConfiguredTableSnowflakeTableSchemaPropertiesArgs']:
        return pulumi.get(self, "table_schema")

    @table_schema.setter
    def table_schema(self, value: pulumi.Input['ConfiguredTableSnowflakeTableSchemaPropertiesArgs']):
        pulumi.set(self, "table_schema", value)


if not MYPY:
    class ConfiguredTableSnowflakeTableSchemaPropertiesArgsDict(TypedDict):
        v1: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableSnowflakeTableSchemaV1ArgsDict']]]
elif False:
    ConfiguredTableSnowflakeTableSchemaPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableSnowflakeTableSchemaPropertiesArgs:
    def __init__(__self__, *,
                 v1: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableSnowflakeTableSchemaV1Args']]]):
        pulumi.set(__self__, "v1", v1)

    @_builtins.property
    @pulumi.getter
    def v1(self) -> pulumi.Input[Sequence[pulumi.Input['ConfiguredTableSnowflakeTableSchemaV1Args']]]:
        return pulumi.get(self, "v1")

    @v1.setter
    def v1(self, value: pulumi.Input[Sequence[pulumi.Input['ConfiguredTableSnowflakeTableSchemaV1Args']]]):
        pulumi.set(self, "v1", value)


if not MYPY:
    class ConfiguredTableSnowflakeTableSchemaV1ArgsDict(TypedDict):
        column_name: pulumi.Input[_builtins.str]
        column_type: pulumi.Input[_builtins.str]
elif False:
    ConfiguredTableSnowflakeTableSchemaV1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableSnowflakeTableSchemaV1Args:
    def __init__(__self__, *,
                 column_name: pulumi.Input[_builtins.str],
                 column_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "column_type", column_type)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter(name="columnType")
    def column_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column_type")

    @column_type.setter
    def column_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_type", value)


if not MYPY:
    class ConfiguredTableTableReference0PropertiesArgsDict(TypedDict):
        glue: pulumi.Input['ConfiguredTableGlueTableReferenceArgsDict']
elif False:
    ConfiguredTableTableReference0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableTableReference0PropertiesArgs:
    def __init__(__self__, *,
                 glue: pulumi.Input['ConfiguredTableGlueTableReferenceArgs']):
        pulumi.set(__self__, "glue", glue)

    @_builtins.property
    @pulumi.getter
    def glue(self) -> pulumi.Input['ConfiguredTableGlueTableReferenceArgs']:
        return pulumi.get(self, "glue")

    @glue.setter
    def glue(self, value: pulumi.Input['ConfiguredTableGlueTableReferenceArgs']):
        pulumi.set(self, "glue", value)


if not MYPY:
    class ConfiguredTableTableReference1PropertiesArgsDict(TypedDict):
        snowflake: pulumi.Input['ConfiguredTableSnowflakeTableReferenceArgsDict']
elif False:
    ConfiguredTableTableReference1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableTableReference1PropertiesArgs:
    def __init__(__self__, *,
                 snowflake: pulumi.Input['ConfiguredTableSnowflakeTableReferenceArgs']):
        pulumi.set(__self__, "snowflake", snowflake)

    @_builtins.property
    @pulumi.getter
    def snowflake(self) -> pulumi.Input['ConfiguredTableSnowflakeTableReferenceArgs']:
        return pulumi.get(self, "snowflake")

    @snowflake.setter
    def snowflake(self, value: pulumi.Input['ConfiguredTableSnowflakeTableReferenceArgs']):
        pulumi.set(self, "snowflake", value)


if not MYPY:
    class ConfiguredTableTableReference2PropertiesArgsDict(TypedDict):
        athena: pulumi.Input['ConfiguredTableAthenaTableReferenceArgsDict']
elif False:
    ConfiguredTableTableReference2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfiguredTableTableReference2PropertiesArgs:
    def __init__(__self__, *,
                 athena: pulumi.Input['ConfiguredTableAthenaTableReferenceArgs']):
        pulumi.set(__self__, "athena", athena)

    @_builtins.property
    @pulumi.getter
    def athena(self) -> pulumi.Input['ConfiguredTableAthenaTableReferenceArgs']:
        return pulumi.get(self, "athena")

    @athena.setter
    def athena(self, value: pulumi.Input['ConfiguredTableAthenaTableReferenceArgs']):
        pulumi.set(self, "athena", value)


if not MYPY:
    class IdMappingTableInputReferenceConfigArgsDict(TypedDict):
        input_reference_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the referenced resource in AWS Entity Resolution . Valid values are ID mapping workflow ARNs.
        """
        manage_resource_policies: pulumi.Input[_builtins.bool]
        """
        When `TRUE` , AWS Clean Rooms manages permissions for the ID mapping table resource.

        When `FALSE` , the resource owner manages permissions for the ID mapping table resource.
        """
elif False:
    IdMappingTableInputReferenceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdMappingTableInputReferenceConfigArgs:
    def __init__(__self__, *,
                 input_reference_arn: pulumi.Input[_builtins.str],
                 manage_resource_policies: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.str] input_reference_arn: The Amazon Resource Name (ARN) of the referenced resource in AWS Entity Resolution . Valid values are ID mapping workflow ARNs.
        :param pulumi.Input[_builtins.bool] manage_resource_policies: When `TRUE` , AWS Clean Rooms manages permissions for the ID mapping table resource.
               
               When `FALSE` , the resource owner manages permissions for the ID mapping table resource.
        """
        pulumi.set(__self__, "input_reference_arn", input_reference_arn)
        pulumi.set(__self__, "manage_resource_policies", manage_resource_policies)

    @_builtins.property
    @pulumi.getter(name="inputReferenceArn")
    def input_reference_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the referenced resource in AWS Entity Resolution . Valid values are ID mapping workflow ARNs.
        """
        return pulumi.get(self, "input_reference_arn")

    @input_reference_arn.setter
    def input_reference_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_reference_arn", value)

    @_builtins.property
    @pulumi.getter(name="manageResourcePolicies")
    def manage_resource_policies(self) -> pulumi.Input[_builtins.bool]:
        """
        When `TRUE` , AWS Clean Rooms manages permissions for the ID mapping table resource.

        When `FALSE` , the resource owner manages permissions for the ID mapping table resource.
        """
        return pulumi.get(self, "manage_resource_policies")

    @manage_resource_policies.setter
    def manage_resource_policies(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "manage_resource_policies", value)


if not MYPY:
    class IdNamespaceAssociationIdMappingConfigArgsDict(TypedDict):
        allow_use_as_dimension_column: pulumi.Input[_builtins.bool]
        """
        An indicator as to whether you can use your column as a dimension column in the ID mapping table ( `TRUE` ) or not ( `FALSE` ).

        Default is `FALSE` .
        """
elif False:
    IdNamespaceAssociationIdMappingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdNamespaceAssociationIdMappingConfigArgs:
    def __init__(__self__, *,
                 allow_use_as_dimension_column: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] allow_use_as_dimension_column: An indicator as to whether you can use your column as a dimension column in the ID mapping table ( `TRUE` ) or not ( `FALSE` ).
               
               Default is `FALSE` .
        """
        pulumi.set(__self__, "allow_use_as_dimension_column", allow_use_as_dimension_column)

    @_builtins.property
    @pulumi.getter(name="allowUseAsDimensionColumn")
    def allow_use_as_dimension_column(self) -> pulumi.Input[_builtins.bool]:
        """
        An indicator as to whether you can use your column as a dimension column in the ID mapping table ( `TRUE` ) or not ( `FALSE` ).

        Default is `FALSE` .
        """
        return pulumi.get(self, "allow_use_as_dimension_column")

    @allow_use_as_dimension_column.setter
    def allow_use_as_dimension_column(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "allow_use_as_dimension_column", value)


if not MYPY:
    class IdNamespaceAssociationInputReferenceConfigArgsDict(TypedDict):
        input_reference_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the AWS Entity Resolution resource that is being associated to the collaboration. Valid resource ARNs are from the ID namespaces that you own.
        """
        manage_resource_policies: pulumi.Input[_builtins.bool]
        """
        When `TRUE` , AWS Clean Rooms manages permissions for the ID namespace association resource.

        When `FALSE` , the resource owner manages permissions for the ID namespace association resource.
        """
elif False:
    IdNamespaceAssociationInputReferenceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdNamespaceAssociationInputReferenceConfigArgs:
    def __init__(__self__, *,
                 input_reference_arn: pulumi.Input[_builtins.str],
                 manage_resource_policies: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.str] input_reference_arn: The Amazon Resource Name (ARN) of the AWS Entity Resolution resource that is being associated to the collaboration. Valid resource ARNs are from the ID namespaces that you own.
        :param pulumi.Input[_builtins.bool] manage_resource_policies: When `TRUE` , AWS Clean Rooms manages permissions for the ID namespace association resource.
               
               When `FALSE` , the resource owner manages permissions for the ID namespace association resource.
        """
        pulumi.set(__self__, "input_reference_arn", input_reference_arn)
        pulumi.set(__self__, "manage_resource_policies", manage_resource_policies)

    @_builtins.property
    @pulumi.getter(name="inputReferenceArn")
    def input_reference_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the AWS Entity Resolution resource that is being associated to the collaboration. Valid resource ARNs are from the ID namespaces that you own.
        """
        return pulumi.get(self, "input_reference_arn")

    @input_reference_arn.setter
    def input_reference_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_reference_arn", value)

    @_builtins.property
    @pulumi.getter(name="manageResourcePolicies")
    def manage_resource_policies(self) -> pulumi.Input[_builtins.bool]:
        """
        When `TRUE` , AWS Clean Rooms manages permissions for the ID namespace association resource.

        When `FALSE` , the resource owner manages permissions for the ID namespace association resource.
        """
        return pulumi.get(self, "manage_resource_policies")

    @manage_resource_policies.setter
    def manage_resource_policies(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "manage_resource_policies", value)


if not MYPY:
    class MembershipJobComputePaymentConfigArgsDict(TypedDict):
        is_responsible: pulumi.Input[_builtins.bool]
        """
        Indicates whether the collaboration member has accepted to pay for job compute costs ( `TRUE` ) or has not accepted to pay for query and job compute costs ( `FALSE` ).

        There is only one member who pays for queries and jobs.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for query and job compute costs.
        - If you set the value to `TRUE` but you are not responsible to pay for query and job compute costs.
        """
elif False:
    MembershipJobComputePaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipJobComputePaymentConfigArgs:
    def __init__(__self__, *,
                 is_responsible: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] is_responsible: Indicates whether the collaboration member has accepted to pay for job compute costs ( `TRUE` ) or has not accepted to pay for query and job compute costs ( `FALSE` ).
               
               There is only one member who pays for queries and jobs.
               
               An error message is returned for the following reasons:
               
               - If you set the value to `FALSE` but you are responsible to pay for query and job compute costs.
               - If you set the value to `TRUE` but you are not responsible to pay for query and job compute costs.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @_builtins.property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether the collaboration member has accepted to pay for job compute costs ( `TRUE` ) or has not accepted to pay for query and job compute costs ( `FALSE` ).

        There is only one member who pays for queries and jobs.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for query and job compute costs.
        - If you set the value to `TRUE` but you are not responsible to pay for query and job compute costs.
        """
        return pulumi.get(self, "is_responsible")

    @is_responsible.setter
    def is_responsible(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_responsible", value)


if not MYPY:
    class MembershipMlPaymentConfigArgsDict(TypedDict):
        model_inference: NotRequired[pulumi.Input['MembershipModelInferencePaymentConfigArgsDict']]
        """
        The payment responsibilities accepted by the member for model inference.
        """
        model_training: NotRequired[pulumi.Input['MembershipModelTrainingPaymentConfigArgsDict']]
        """
        The payment responsibilities accepted by the member for model training.
        """
elif False:
    MembershipMlPaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipMlPaymentConfigArgs:
    def __init__(__self__, *,
                 model_inference: Optional[pulumi.Input['MembershipModelInferencePaymentConfigArgs']] = None,
                 model_training: Optional[pulumi.Input['MembershipModelTrainingPaymentConfigArgs']] = None):
        """
        :param pulumi.Input['MembershipModelInferencePaymentConfigArgs'] model_inference: The payment responsibilities accepted by the member for model inference.
        :param pulumi.Input['MembershipModelTrainingPaymentConfigArgs'] model_training: The payment responsibilities accepted by the member for model training.
        """
        if model_inference is not None:
            pulumi.set(__self__, "model_inference", model_inference)
        if model_training is not None:
            pulumi.set(__self__, "model_training", model_training)

    @_builtins.property
    @pulumi.getter(name="modelInference")
    def model_inference(self) -> Optional[pulumi.Input['MembershipModelInferencePaymentConfigArgs']]:
        """
        The payment responsibilities accepted by the member for model inference.
        """
        return pulumi.get(self, "model_inference")

    @model_inference.setter
    def model_inference(self, value: Optional[pulumi.Input['MembershipModelInferencePaymentConfigArgs']]):
        pulumi.set(self, "model_inference", value)

    @_builtins.property
    @pulumi.getter(name="modelTraining")
    def model_training(self) -> Optional[pulumi.Input['MembershipModelTrainingPaymentConfigArgs']]:
        """
        The payment responsibilities accepted by the member for model training.
        """
        return pulumi.get(self, "model_training")

    @model_training.setter
    def model_training(self, value: Optional[pulumi.Input['MembershipModelTrainingPaymentConfigArgs']]):
        pulumi.set(self, "model_training", value)


if not MYPY:
    class MembershipModelInferencePaymentConfigArgsDict(TypedDict):
        is_responsible: pulumi.Input[_builtins.bool]
        """
        Indicates whether the collaboration member has accepted to pay for model inference costs ( `TRUE` ) or has not accepted to pay for model inference costs ( `FALSE` ).

        If the collaboration creator has not specified anyone to pay for model inference costs, then the member who can query is the default payer.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for model inference costs.
        - If you set the value to `TRUE` but you are not responsible to pay for model inference costs.
        """
elif False:
    MembershipModelInferencePaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipModelInferencePaymentConfigArgs:
    def __init__(__self__, *,
                 is_responsible: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] is_responsible: Indicates whether the collaboration member has accepted to pay for model inference costs ( `TRUE` ) or has not accepted to pay for model inference costs ( `FALSE` ).
               
               If the collaboration creator has not specified anyone to pay for model inference costs, then the member who can query is the default payer.
               
               An error message is returned for the following reasons:
               
               - If you set the value to `FALSE` but you are responsible to pay for model inference costs.
               - If you set the value to `TRUE` but you are not responsible to pay for model inference costs.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @_builtins.property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether the collaboration member has accepted to pay for model inference costs ( `TRUE` ) or has not accepted to pay for model inference costs ( `FALSE` ).

        If the collaboration creator has not specified anyone to pay for model inference costs, then the member who can query is the default payer.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for model inference costs.
        - If you set the value to `TRUE` but you are not responsible to pay for model inference costs.
        """
        return pulumi.get(self, "is_responsible")

    @is_responsible.setter
    def is_responsible(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_responsible", value)


if not MYPY:
    class MembershipModelTrainingPaymentConfigArgsDict(TypedDict):
        is_responsible: pulumi.Input[_builtins.bool]
        """
        Indicates whether the collaboration member has accepted to pay for model training costs ( `TRUE` ) or has not accepted to pay for model training costs ( `FALSE` ).

        If the collaboration creator has not specified anyone to pay for model training costs, then the member who can query is the default payer.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for model training costs.
        - If you set the value to `TRUE` but you are not responsible to pay for model training costs.
        """
elif False:
    MembershipModelTrainingPaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipModelTrainingPaymentConfigArgs:
    def __init__(__self__, *,
                 is_responsible: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] is_responsible: Indicates whether the collaboration member has accepted to pay for model training costs ( `TRUE` ) or has not accepted to pay for model training costs ( `FALSE` ).
               
               If the collaboration creator has not specified anyone to pay for model training costs, then the member who can query is the default payer.
               
               An error message is returned for the following reasons:
               
               - If you set the value to `FALSE` but you are responsible to pay for model training costs.
               - If you set the value to `TRUE` but you are not responsible to pay for model training costs.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @_builtins.property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether the collaboration member has accepted to pay for model training costs ( `TRUE` ) or has not accepted to pay for model training costs ( `FALSE` ).

        If the collaboration creator has not specified anyone to pay for model training costs, then the member who can query is the default payer.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for model training costs.
        - If you set the value to `TRUE` but you are not responsible to pay for model training costs.
        """
        return pulumi.get(self, "is_responsible")

    @is_responsible.setter
    def is_responsible(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_responsible", value)


if not MYPY:
    class MembershipPaymentConfigurationArgsDict(TypedDict):
        query_compute: pulumi.Input['MembershipQueryComputePaymentConfigArgsDict']
        """
        The payment responsibilities accepted by the collaboration member for query compute costs.
        """
        job_compute: NotRequired[pulumi.Input['MembershipJobComputePaymentConfigArgsDict']]
        """
        The payment responsibilities accepted by the collaboration member for job compute costs.
        """
        machine_learning: NotRequired[pulumi.Input['MembershipMlPaymentConfigArgsDict']]
        """
        The payment responsibilities accepted by the collaboration member for machine learning costs.
        """
elif False:
    MembershipPaymentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipPaymentConfigurationArgs:
    def __init__(__self__, *,
                 query_compute: pulumi.Input['MembershipQueryComputePaymentConfigArgs'],
                 job_compute: Optional[pulumi.Input['MembershipJobComputePaymentConfigArgs']] = None,
                 machine_learning: Optional[pulumi.Input['MembershipMlPaymentConfigArgs']] = None):
        """
        :param pulumi.Input['MembershipQueryComputePaymentConfigArgs'] query_compute: The payment responsibilities accepted by the collaboration member for query compute costs.
        :param pulumi.Input['MembershipJobComputePaymentConfigArgs'] job_compute: The payment responsibilities accepted by the collaboration member for job compute costs.
        :param pulumi.Input['MembershipMlPaymentConfigArgs'] machine_learning: The payment responsibilities accepted by the collaboration member for machine learning costs.
        """
        pulumi.set(__self__, "query_compute", query_compute)
        if job_compute is not None:
            pulumi.set(__self__, "job_compute", job_compute)
        if machine_learning is not None:
            pulumi.set(__self__, "machine_learning", machine_learning)

    @_builtins.property
    @pulumi.getter(name="queryCompute")
    def query_compute(self) -> pulumi.Input['MembershipQueryComputePaymentConfigArgs']:
        """
        The payment responsibilities accepted by the collaboration member for query compute costs.
        """
        return pulumi.get(self, "query_compute")

    @query_compute.setter
    def query_compute(self, value: pulumi.Input['MembershipQueryComputePaymentConfigArgs']):
        pulumi.set(self, "query_compute", value)

    @_builtins.property
    @pulumi.getter(name="jobCompute")
    def job_compute(self) -> Optional[pulumi.Input['MembershipJobComputePaymentConfigArgs']]:
        """
        The payment responsibilities accepted by the collaboration member for job compute costs.
        """
        return pulumi.get(self, "job_compute")

    @job_compute.setter
    def job_compute(self, value: Optional[pulumi.Input['MembershipJobComputePaymentConfigArgs']]):
        pulumi.set(self, "job_compute", value)

    @_builtins.property
    @pulumi.getter(name="machineLearning")
    def machine_learning(self) -> Optional[pulumi.Input['MembershipMlPaymentConfigArgs']]:
        """
        The payment responsibilities accepted by the collaboration member for machine learning costs.
        """
        return pulumi.get(self, "machine_learning")

    @machine_learning.setter
    def machine_learning(self, value: Optional[pulumi.Input['MembershipMlPaymentConfigArgs']]):
        pulumi.set(self, "machine_learning", value)


if not MYPY:
    class MembershipProtectedJobOutputConfigurationArgsDict(TypedDict):
        s3: pulumi.Input['MembershipProtectedJobS3OutputConfigurationInputArgsDict']
        """
        Contains the configuration to write the job results to S3.
        """
elif False:
    MembershipProtectedJobOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipProtectedJobOutputConfigurationArgs:
    def __init__(__self__, *,
                 s3: pulumi.Input['MembershipProtectedJobS3OutputConfigurationInputArgs']):
        """
        :param pulumi.Input['MembershipProtectedJobS3OutputConfigurationInputArgs'] s3: Contains the configuration to write the job results to S3.
        """
        pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> pulumi.Input['MembershipProtectedJobS3OutputConfigurationInputArgs']:
        """
        Contains the configuration to write the job results to S3.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: pulumi.Input['MembershipProtectedJobS3OutputConfigurationInputArgs']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class MembershipProtectedJobResultConfigurationArgsDict(TypedDict):
        output_configuration: pulumi.Input['MembershipProtectedJobOutputConfigurationArgsDict']
        """
        The output configuration for a protected job result.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected job results to the result location, given by the member who can receive results.
        """
elif False:
    MembershipProtectedJobResultConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipProtectedJobResultConfigurationArgs:
    def __init__(__self__, *,
                 output_configuration: pulumi.Input['MembershipProtectedJobOutputConfigurationArgs'],
                 role_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['MembershipProtectedJobOutputConfigurationArgs'] output_configuration: The output configuration for a protected job result.
        :param pulumi.Input[_builtins.str] role_arn: The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected job results to the result location, given by the member who can receive results.
        """
        pulumi.set(__self__, "output_configuration", output_configuration)
        pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="outputConfiguration")
    def output_configuration(self) -> pulumi.Input['MembershipProtectedJobOutputConfigurationArgs']:
        """
        The output configuration for a protected job result.
        """
        return pulumi.get(self, "output_configuration")

    @output_configuration.setter
    def output_configuration(self, value: pulumi.Input['MembershipProtectedJobOutputConfigurationArgs']):
        pulumi.set(self, "output_configuration", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected job results to the result location, given by the member who can receive results.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class MembershipProtectedJobS3OutputConfigurationInputArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        The S3 bucket for job output.
        """
        key_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The S3 prefix to unload the protected job results.
        """
elif False:
    MembershipProtectedJobS3OutputConfigurationInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipProtectedJobS3OutputConfigurationInputArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 key_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: The S3 bucket for job output.
        :param pulumi.Input[_builtins.str] key_prefix: The S3 prefix to unload the protected job results.
        """
        pulumi.set(__self__, "bucket", bucket)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 bucket for job output.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The S3 prefix to unload the protected job results.
        """
        return pulumi.get(self, "key_prefix")

    @key_prefix.setter
    def key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_prefix", value)


if not MYPY:
    class MembershipProtectedQueryOutputConfigurationArgsDict(TypedDict):
        s3: pulumi.Input['MembershipProtectedQueryS3OutputConfigurationArgsDict']
        """
        Required configuration for a protected query with an `s3` output type.
        """
elif False:
    MembershipProtectedQueryOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipProtectedQueryOutputConfigurationArgs:
    def __init__(__self__, *,
                 s3: pulumi.Input['MembershipProtectedQueryS3OutputConfigurationArgs']):
        """
        :param pulumi.Input['MembershipProtectedQueryS3OutputConfigurationArgs'] s3: Required configuration for a protected query with an `s3` output type.
        """
        pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> pulumi.Input['MembershipProtectedQueryS3OutputConfigurationArgs']:
        """
        Required configuration for a protected query with an `s3` output type.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: pulumi.Input['MembershipProtectedQueryS3OutputConfigurationArgs']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class MembershipProtectedQueryResultConfigurationArgsDict(TypedDict):
        output_configuration: pulumi.Input['MembershipProtectedQueryOutputConfigurationArgsDict']
        """
        Configuration for protected query results.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        """
elif False:
    MembershipProtectedQueryResultConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipProtectedQueryResultConfigurationArgs:
    def __init__(__self__, *,
                 output_configuration: pulumi.Input['MembershipProtectedQueryOutputConfigurationArgs'],
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['MembershipProtectedQueryOutputConfigurationArgs'] output_configuration: Configuration for protected query results.
        :param pulumi.Input[_builtins.str] role_arn: The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        """
        pulumi.set(__self__, "output_configuration", output_configuration)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="outputConfiguration")
    def output_configuration(self) -> pulumi.Input['MembershipProtectedQueryOutputConfigurationArgs']:
        """
        Configuration for protected query results.
        """
        return pulumi.get(self, "output_configuration")

    @output_configuration.setter
    def output_configuration(self, value: pulumi.Input['MembershipProtectedQueryOutputConfigurationArgs']):
        pulumi.set(self, "output_configuration", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class MembershipProtectedQueryS3OutputConfigurationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        The S3 bucket to unload the protected query results.
        """
        result_format: pulumi.Input['MembershipResultFormat']
        """
        Intended file format of the result.
        """
        key_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The S3 prefix to unload the protected query results.
        """
        single_file_output: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether files should be output as a single file ( `TRUE` ) or output as multiple files ( `FALSE` ). This parameter is only supported for analyses with the Spark analytics engine.
        """
elif False:
    MembershipProtectedQueryS3OutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipProtectedQueryS3OutputConfigurationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 result_format: pulumi.Input['MembershipResultFormat'],
                 key_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 single_file_output: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: The S3 bucket to unload the protected query results.
        :param pulumi.Input['MembershipResultFormat'] result_format: Intended file format of the result.
        :param pulumi.Input[_builtins.str] key_prefix: The S3 prefix to unload the protected query results.
        :param pulumi.Input[_builtins.bool] single_file_output: Indicates whether files should be output as a single file ( `TRUE` ) or output as multiple files ( `FALSE` ). This parameter is only supported for analyses with the Spark analytics engine.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "result_format", result_format)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)
        if single_file_output is not None:
            pulumi.set(__self__, "single_file_output", single_file_output)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 bucket to unload the protected query results.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="resultFormat")
    def result_format(self) -> pulumi.Input['MembershipResultFormat']:
        """
        Intended file format of the result.
        """
        return pulumi.get(self, "result_format")

    @result_format.setter
    def result_format(self, value: pulumi.Input['MembershipResultFormat']):
        pulumi.set(self, "result_format", value)

    @_builtins.property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The S3 prefix to unload the protected query results.
        """
        return pulumi.get(self, "key_prefix")

    @key_prefix.setter
    def key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_prefix", value)

    @_builtins.property
    @pulumi.getter(name="singleFileOutput")
    def single_file_output(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether files should be output as a single file ( `TRUE` ) or output as multiple files ( `FALSE` ). This parameter is only supported for analyses with the Spark analytics engine.
        """
        return pulumi.get(self, "single_file_output")

    @single_file_output.setter
    def single_file_output(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "single_file_output", value)


if not MYPY:
    class MembershipQueryComputePaymentConfigArgsDict(TypedDict):
        is_responsible: pulumi.Input[_builtins.bool]
        """
        Indicates whether the collaboration member has accepted to pay for query compute costs ( `TRUE` ) or has not accepted to pay for query compute costs ( `FALSE` ).

        If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for query compute costs.
        - If you set the value to `TRUE` but you are not responsible to pay for query compute costs.
        """
elif False:
    MembershipQueryComputePaymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipQueryComputePaymentConfigArgs:
    def __init__(__self__, *,
                 is_responsible: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] is_responsible: Indicates whether the collaboration member has accepted to pay for query compute costs ( `TRUE` ) or has not accepted to pay for query compute costs ( `FALSE` ).
               
               If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer.
               
               An error message is returned for the following reasons:
               
               - If you set the value to `FALSE` but you are responsible to pay for query compute costs.
               - If you set the value to `TRUE` but you are not responsible to pay for query compute costs.
        """
        pulumi.set(__self__, "is_responsible", is_responsible)

    @_builtins.property
    @pulumi.getter(name="isResponsible")
    def is_responsible(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether the collaboration member has accepted to pay for query compute costs ( `TRUE` ) or has not accepted to pay for query compute costs ( `FALSE` ).

        If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer.

        An error message is returned for the following reasons:

        - If you set the value to `FALSE` but you are responsible to pay for query compute costs.
        - If you set the value to `TRUE` but you are not responsible to pay for query compute costs.
        """
        return pulumi.get(self, "is_responsible")

    @is_responsible.setter
    def is_responsible(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_responsible", value)


if not MYPY:
    class ParametersPropertiesArgsDict(TypedDict):
        """
        Specifies the epsilon and noise parameters for the privacy budget template.
        """
        budget_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['PrivacyBudgetTemplateBudgetParameterArgsDict']]]]
        epsilon: NotRequired[pulumi.Input[_builtins.int]]
        """
        The epsilon value that you want to use.
        """
        resource_arn: NotRequired[pulumi.Input[_builtins.str]]
        users_noise_per_query: NotRequired[pulumi.Input[_builtins.int]]
        """
        Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        """
elif False:
    ParametersPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ParametersPropertiesArgs:
    def __init__(__self__, *,
                 budget_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['PrivacyBudgetTemplateBudgetParameterArgs']]]] = None,
                 epsilon: Optional[pulumi.Input[_builtins.int]] = None,
                 resource_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 users_noise_per_query: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Specifies the epsilon and noise parameters for the privacy budget template.
        :param pulumi.Input[_builtins.int] epsilon: The epsilon value that you want to use.
        :param pulumi.Input[_builtins.int] users_noise_per_query: Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        """
        if budget_parameters is not None:
            pulumi.set(__self__, "budget_parameters", budget_parameters)
        if epsilon is not None:
            pulumi.set(__self__, "epsilon", epsilon)
        if resource_arn is not None:
            pulumi.set(__self__, "resource_arn", resource_arn)
        if users_noise_per_query is not None:
            pulumi.set(__self__, "users_noise_per_query", users_noise_per_query)

    @_builtins.property
    @pulumi.getter(name="budgetParameters")
    def budget_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PrivacyBudgetTemplateBudgetParameterArgs']]]]:
        return pulumi.get(self, "budget_parameters")

    @budget_parameters.setter
    def budget_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PrivacyBudgetTemplateBudgetParameterArgs']]]]):
        pulumi.set(self, "budget_parameters", value)

    @_builtins.property
    @pulumi.getter
    def epsilon(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The epsilon value that you want to use.
        """
        return pulumi.get(self, "epsilon")

    @epsilon.setter
    def epsilon(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "epsilon", value)

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_arn", value)

    @_builtins.property
    @pulumi.getter(name="usersNoisePerQuery")
    def users_noise_per_query(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        """
        return pulumi.get(self, "users_noise_per_query")

    @users_noise_per_query.setter
    def users_noise_per_query(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "users_noise_per_query", value)


if not MYPY:
    class PrivacyBudgetTemplateBudgetParameterArgsDict(TypedDict):
        budget: pulumi.Input[_builtins.int]
        """
        The budget allocation amount for this specific parameter.
        """
        type: pulumi.Input['PrivacyBudgetTemplateBudgetParameterType']
        """
        The type of budget parameter being configured.
        """
        auto_refresh: NotRequired[pulumi.Input['PrivacyBudgetTemplateBudgetParameterAutoRefresh']]
        """
        Whether this individual budget parameter automatically refreshes when the budget period resets.
        """
elif False:
    PrivacyBudgetTemplateBudgetParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivacyBudgetTemplateBudgetParameterArgs:
    def __init__(__self__, *,
                 budget: pulumi.Input[_builtins.int],
                 type: pulumi.Input['PrivacyBudgetTemplateBudgetParameterType'],
                 auto_refresh: Optional[pulumi.Input['PrivacyBudgetTemplateBudgetParameterAutoRefresh']] = None):
        """
        :param pulumi.Input[_builtins.int] budget: The budget allocation amount for this specific parameter.
        :param pulumi.Input['PrivacyBudgetTemplateBudgetParameterType'] type: The type of budget parameter being configured.
        :param pulumi.Input['PrivacyBudgetTemplateBudgetParameterAutoRefresh'] auto_refresh: Whether this individual budget parameter automatically refreshes when the budget period resets.
        """
        pulumi.set(__self__, "budget", budget)
        pulumi.set(__self__, "type", type)
        if auto_refresh is not None:
            pulumi.set(__self__, "auto_refresh", auto_refresh)

    @_builtins.property
    @pulumi.getter
    def budget(self) -> pulumi.Input[_builtins.int]:
        """
        The budget allocation amount for this specific parameter.
        """
        return pulumi.get(self, "budget")

    @budget.setter
    def budget(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "budget", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['PrivacyBudgetTemplateBudgetParameterType']:
        """
        The type of budget parameter being configured.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['PrivacyBudgetTemplateBudgetParameterType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="autoRefresh")
    def auto_refresh(self) -> Optional[pulumi.Input['PrivacyBudgetTemplateBudgetParameterAutoRefresh']]:
        """
        Whether this individual budget parameter automatically refreshes when the budget period resets.
        """
        return pulumi.get(self, "auto_refresh")

    @auto_refresh.setter
    def auto_refresh(self, value: Optional[pulumi.Input['PrivacyBudgetTemplateBudgetParameterAutoRefresh']]):
        pulumi.set(self, "auto_refresh", value)


