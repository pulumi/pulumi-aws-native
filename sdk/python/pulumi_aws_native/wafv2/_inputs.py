# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'IPSetTagArgs',
    'LoggingConfigurationConditionActionConditionPropertiesArgs',
    'LoggingConfigurationConditionLabelNameConditionPropertiesArgs',
    'LoggingConfigurationConditionArgs',
    'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs',
    'LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs',
    'LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs',
    'LoggingConfigurationFieldToMatchArgs',
    'LoggingConfigurationFilterArgs',
    'LoggingFilterPropertiesArgs',
    'RegexPatternSetTagArgs',
    'RuleGroupAndStatementArgs',
    'RuleGroupByteMatchStatementArgs',
    'RuleGroupCaptchaConfigArgs',
    'RuleGroupCustomHTTPHeaderArgs',
    'RuleGroupCustomRequestHandlingArgs',
    'RuleGroupCustomResponseBodiesArgs',
    'RuleGroupCustomResponseArgs',
    'RuleGroupFieldToMatchSingleHeaderPropertiesArgs',
    'RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs',
    'RuleGroupFieldToMatchArgs',
    'RuleGroupForwardedIPConfigurationArgs',
    'RuleGroupGeoMatchStatementArgs',
    'RuleGroupIPSetForwardedIPConfigurationArgs',
    'RuleGroupIPSetReferenceStatementArgs',
    'RuleGroupImmunityTimePropertyArgs',
    'RuleGroupJsonBodyArgs',
    'RuleGroupJsonMatchPatternArgs',
    'RuleGroupLabelMatchStatementArgs',
    'RuleGroupLabelArgs',
    'RuleGroupNotStatementArgs',
    'RuleGroupOrStatementArgs',
    'RuleGroupRateBasedStatementArgs',
    'RuleGroupRegexMatchStatementArgs',
    'RuleGroupRegexPatternSetReferenceStatementArgs',
    'RuleGroupRuleActionAllowPropertiesArgs',
    'RuleGroupRuleActionBlockPropertiesArgs',
    'RuleGroupRuleActionCaptchaPropertiesArgs',
    'RuleGroupRuleActionCountPropertiesArgs',
    'RuleGroupRuleActionArgs',
    'RuleGroupRuleArgs',
    'RuleGroupSizeConstraintStatementArgs',
    'RuleGroupSqliMatchStatementArgs',
    'RuleGroupStatementArgs',
    'RuleGroupTagArgs',
    'RuleGroupTextTransformationArgs',
    'RuleGroupVisibilityConfigArgs',
    'RuleGroupXssMatchStatementArgs',
    'WebACLAllowActionArgs',
    'WebACLAndStatementArgs',
    'WebACLBlockActionArgs',
    'WebACLByteMatchStatementArgs',
    'WebACLCaptchaActionArgs',
    'WebACLCaptchaConfigArgs',
    'WebACLCountActionArgs',
    'WebACLCustomHTTPHeaderArgs',
    'WebACLCustomRequestHandlingArgs',
    'WebACLCustomResponseBodiesArgs',
    'WebACLCustomResponseArgs',
    'WebACLDefaultActionArgs',
    'WebACLExcludedRuleArgs',
    'WebACLFieldToMatchSingleHeaderPropertiesArgs',
    'WebACLFieldToMatchSingleQueryArgumentPropertiesArgs',
    'WebACLFieldToMatchArgs',
    'WebACLForwardedIPConfigurationArgs',
    'WebACLGeoMatchStatementArgs',
    'WebACLIPSetForwardedIPConfigurationArgs',
    'WebACLIPSetReferenceStatementArgs',
    'WebACLImmunityTimePropertyArgs',
    'WebACLJsonBodyArgs',
    'WebACLJsonMatchPatternArgs',
    'WebACLLabelMatchStatementArgs',
    'WebACLLabelArgs',
    'WebACLManagedRuleGroupStatementArgs',
    'WebACLNotStatementArgs',
    'WebACLOrStatementArgs',
    'WebACLOverrideActionArgs',
    'WebACLRateBasedStatementArgs',
    'WebACLRegexMatchStatementArgs',
    'WebACLRegexPatternSetReferenceStatementArgs',
    'WebACLRuleActionArgs',
    'WebACLRuleGroupReferenceStatementArgs',
    'WebACLRuleArgs',
    'WebACLSizeConstraintStatementArgs',
    'WebACLSqliMatchStatementArgs',
    'WebACLStatementArgs',
    'WebACLTagArgs',
    'WebACLTextTransformationArgs',
    'WebACLVisibilityConfigArgs',
    'WebACLXssMatchStatementArgs',
]

@pulumi.input_type
class IPSetTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class LoggingConfigurationConditionActionConditionPropertiesArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesAction']):
        """
        A single action condition.
        :param pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesAction'] action: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesAction']:
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesAction']):
        pulumi.set(self, "action", value)


@pulumi.input_type
class LoggingConfigurationConditionLabelNameConditionPropertiesArgs:
    def __init__(__self__, *,
                 label_name: pulumi.Input[str]):
        """
        A single label name condition.
        :param pulumi.Input[str] label_name: The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
        """
        pulumi.set(__self__, "label_name", label_name)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> pulumi.Input[str]:
        """
        The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
        """
        return pulumi.get(self, "label_name")

    @label_name.setter
    def label_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "label_name", value)


@pulumi.input_type
class LoggingConfigurationConditionArgs:
    def __init__(__self__, *,
                 action_condition: Optional[pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesArgs']] = None,
                 label_name_condition: Optional[pulumi.Input['LoggingConfigurationConditionLabelNameConditionPropertiesArgs']] = None):
        """
        :param pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesArgs'] action_condition: A single action condition.
        :param pulumi.Input['LoggingConfigurationConditionLabelNameConditionPropertiesArgs'] label_name_condition: A single label name condition.
        """
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional[pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesArgs']]:
        """
        A single action condition.
        """
        return pulumi.get(self, "action_condition")

    @action_condition.setter
    def action_condition(self, value: Optional[pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesArgs']]):
        pulumi.set(self, "action_condition", value)

    @property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional[pulumi.Input['LoggingConfigurationConditionLabelNameConditionPropertiesArgs']]:
        """
        A single label name condition.
        """
        return pulumi.get(self, "label_name_condition")

    @label_name_condition.setter
    def label_name_condition(self, value: Optional[pulumi.Input['LoggingConfigurationConditionLabelNameConditionPropertiesArgs']]):
        pulumi.set(self, "label_name_condition", value)


@pulumi.input_type
class LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs:
    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        :param Any all: Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_paths: Match only the specified include paths. See also MatchScope in JsonBody.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[Any]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match only the specified include paths. See also MatchScope in JsonBody.
        """
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs'],
                 match_scope: pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope'],
                 invalid_fallback_behavior: Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior']] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        :param pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs'] match_pattern: The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        :param pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope'] match_scope: The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
        :param pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior'] invalid_fallback_behavior: What AWS WAF should do if it fails to completely parse the JSON body.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs']:
        """
        The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope']:
        """
        The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope']):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior']]:
        """
        What AWS WAF should do if it fails to completely parse the JSON body.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior']]):
        pulumi.set(self, "invalid_fallback_behavior", value)


@pulumi.input_type
class LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        :param pulumi.Input[str] name: The name of the query header to inspect.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LoggingConfigurationFieldToMatchArgs:
    def __init__(__self__, *,
                 json_body: Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs']] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional[pulumi.Input['LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs']] = None,
                 uri_path: Optional[Any] = None):
        """
        A key-value pair to associate with a resource.
        :param pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs'] json_body: Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        :param Any method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
        :param Any query_string: Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
        :param pulumi.Input['LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs'] single_header: Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        :param Any uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
        """
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs']]:
        """
        Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[Any]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[Any]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs']]:
        """
        Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[Any]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class LoggingConfigurationFilterArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input['LoggingConfigurationFilterBehavior'],
                 conditions: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationConditionArgs']]],
                 requirement: pulumi.Input['LoggingConfigurationFilterRequirement']):
        """
        :param pulumi.Input['LoggingConfigurationFilterBehavior'] behavior: How to handle logs that satisfy the filter's conditions and requirement. 
        :param pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationConditionArgs']]] conditions: Match conditions for the filter.
        :param pulumi.Input['LoggingConfigurationFilterRequirement'] requirement: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "requirement", requirement)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input['LoggingConfigurationFilterBehavior']:
        """
        How to handle logs that satisfy the filter's conditions and requirement. 
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input['LoggingConfigurationFilterBehavior']):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationConditionArgs']]]:
        """
        Match conditions for the filter.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def requirement(self) -> pulumi.Input['LoggingConfigurationFilterRequirement']:
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "requirement")

    @requirement.setter
    def requirement(self, value: pulumi.Input['LoggingConfigurationFilterRequirement']):
        pulumi.set(self, "requirement", value)


@pulumi.input_type
class LoggingFilterPropertiesArgs:
    def __init__(__self__, *,
                 default_behavior: pulumi.Input['LoggingConfigurationLoggingFilterPropertiesDefaultBehavior'],
                 filters: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationFilterArgs']]]):
        """
        Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
        :param pulumi.Input['LoggingConfigurationLoggingFilterPropertiesDefaultBehavior'] default_behavior: Default handling for logs that don't match any of the specified filtering conditions.
        :param pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationFilterArgs']]] filters: The filters that you want to apply to the logs.
        """
        pulumi.set(__self__, "default_behavior", default_behavior)
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> pulumi.Input['LoggingConfigurationLoggingFilterPropertiesDefaultBehavior']:
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        """
        return pulumi.get(self, "default_behavior")

    @default_behavior.setter
    def default_behavior(self, value: pulumi.Input['LoggingConfigurationLoggingFilterPropertiesDefaultBehavior']):
        pulumi.set(self, "default_behavior", value)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationFilterArgs']]]:
        """
        The filters that you want to apply to the logs.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationFilterArgs']]]):
        pulumi.set(self, "filters", value)


@pulumi.input_type
class RegexPatternSetTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class RuleGroupByteMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 positional_constraint: pulumi.Input['RuleGroupPositionalConstraint'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]],
                 search_string: Optional[pulumi.Input[str]] = None,
                 search_string_base64: Optional[pulumi.Input[str]] = None):
        """
        Byte Match statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if search_string is not None:
            pulumi.set(__self__, "search_string", search_string)
        if search_string_base64 is not None:
            pulumi.set(__self__, "search_string_base64", search_string_base64)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input['RuleGroupPositionalConstraint']:
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input['RuleGroupPositionalConstraint']):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="searchStringBase64")
    def search_string_base64(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_string_base64")

    @search_string_base64.setter
    def search_string_base64(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_string_base64", value)


@pulumi.input_type
class RuleGroupCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['RuleGroupImmunityTimePropertyArgs']] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['RuleGroupImmunityTimePropertyArgs']]:
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['RuleGroupImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


@pulumi.input_type
class RuleGroupCustomHTTPHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]):
        """
        Custom request handling.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]] insert_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class RuleGroupCustomResponseBodiesArgs:
    def __init__(__self__):
        """
        Custom response key and body map.
        """
        pass


@pulumi.input_type
class RuleGroupCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]] = None):
        """
        Custom response.
        :param pulumi.Input[str] custom_response_body_key: Custom response body key.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]] response_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        Custom response body key.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


@pulumi.input_type
class RuleGroupFieldToMatchSingleHeaderPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[Any] = None,
                 body: Optional[Any] = None,
                 json_body: Optional[pulumi.Input['RuleGroupJsonBodyArgs']] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional[pulumi.Input['RuleGroupFieldToMatchSingleHeaderPropertiesArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs']] = None,
                 uri_path: Optional[Any] = None):
        """
        Field of the request to match.
        :param Any all_query_arguments: All query arguments of a web request.
        :param Any body: The body of a web request. This immediately follows the request headers.
        :param Any method: The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        :param Any query_string: The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        :param pulumi.Input['RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs'] single_query_argument: One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        :param Any uri_path: The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[Any]:
        """
        All query arguments of a web request.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[Any]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[Any]:
        """
        The body of a web request. This immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[Any]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[Any]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[Any]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupFieldToMatchSingleHeaderPropertiesArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupFieldToMatchSingleHeaderPropertiesArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs']]:
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[Any]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupForwardedIPConfigurationArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input['RuleGroupForwardedIPConfigurationFallbackBehavior'],
                 header_name: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input['RuleGroupForwardedIPConfigurationFallbackBehavior']:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input['RuleGroupForwardedIPConfigurationFallbackBehavior']):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


@pulumi.input_type
class RuleGroupGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']] = None):
        if country_codes is not None:
            pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


@pulumi.input_type
class RuleGroupIPSetForwardedIPConfigurationArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input['RuleGroupIPSetForwardedIPConfigurationFallbackBehavior'],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input['RuleGroupIPSetForwardedIPConfigurationPosition']):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input['RuleGroupIPSetForwardedIPConfigurationFallbackBehavior']:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input['RuleGroupIPSetForwardedIPConfigurationFallbackBehavior']):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input['RuleGroupIPSetForwardedIPConfigurationPosition']:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input['RuleGroupIPSetForwardedIPConfigurationPosition']):
        pulumi.set(self, "position", value)


@pulumi.input_type
class RuleGroupIPSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 i_p_set_forwarded_ip_config: Optional[pulumi.Input['RuleGroupIPSetForwardedIPConfigurationArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        if i_p_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "i_p_set_forwarded_ip_config", i_p_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="iPSetForwardedIPConfig")
    def i_p_set_forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupIPSetForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "i_p_set_forwarded_ip_config")

    @i_p_set_forwarded_ip_config.setter
    def i_p_set_forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupIPSetForwardedIPConfigurationArgs']]):
        pulumi.set(self, "i_p_set_forwarded_ip_config", value)


@pulumi.input_type
class RuleGroupImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: pulumi.Input[int]):
        pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> pulumi.Input[int]:
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: pulumi.Input[int]):
        pulumi.set(self, "immunity_time", value)


@pulumi.input_type
class RuleGroupJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupJsonMatchPatternArgs'],
                 match_scope: pulumi.Input['RuleGroupJsonMatchScope'],
                 invalid_fallback_behavior: Optional[pulumi.Input['RuleGroupBodyParsingFallbackBehavior']] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupJsonMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupJsonMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input['RuleGroupJsonMatchScope']:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input['RuleGroupJsonMatchScope']):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input['RuleGroupBodyParsingFallbackBehavior']]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input['RuleGroupBodyParsingFallbackBehavior']]):
        pulumi.set(self, "invalid_fallback_behavior", value)


@pulumi.input_type
class RuleGroupJsonMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The pattern to look for in the JSON body.
        :param Any all: Inspect all parts of the web request's JSON body.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request's JSON body.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[Any]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input['RuleGroupLabelMatchScope']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input['RuleGroupLabelMatchScope']:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input['RuleGroupLabelMatchScope']):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class RuleGroupLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupNotStatementArgs:
    def __init__(__self__, *,
                 statement: pulumi.Input['RuleGroupStatementArgs']):
        pulumi.set(__self__, "statement", statement)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['RuleGroupStatementArgs']:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['RuleGroupStatementArgs']):
        pulumi.set(self, "statement", value)


@pulumi.input_type
class RuleGroupOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class RuleGroupRateBasedStatementArgs:
    def __init__(__self__, *,
                 aggregate_key_type: pulumi.Input['RuleGroupRateBasedStatementAggregateKeyType'],
                 limit: pulumi.Input[int],
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']] = None,
                 scope_down_statement: Optional[pulumi.Input['RuleGroupStatementArgs']] = None):
        pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        pulumi.set(__self__, "limit", limit)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> pulumi.Input['RuleGroupRateBasedStatementAggregateKeyType']:
        return pulumi.get(self, "aggregate_key_type")

    @aggregate_key_type.setter
    def aggregate_key_type(self, value: pulumi.Input['RuleGroupRateBasedStatementAggregateKeyType']):
        pulumi.set(self, "aggregate_key_type", value)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['RuleGroupStatementArgs']]:
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['RuleGroupStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)


@pulumi.input_type
class RuleGroupRegexMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRuleActionAllowPropertiesArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class RuleGroupRuleActionBlockPropertiesArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['RuleGroupCustomResponseArgs']] = None):
        """
        Block traffic towards application.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['RuleGroupCustomResponseArgs']]:
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['RuleGroupCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


@pulumi.input_type
class RuleGroupRuleActionCaptchaPropertiesArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']] = None):
        """
        Checks valid token exists with request.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class RuleGroupRuleActionCountPropertiesArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']] = None):
        """
        Count traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class RuleGroupRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['RuleGroupRuleActionAllowPropertiesArgs']] = None,
                 block: Optional[pulumi.Input['RuleGroupRuleActionBlockPropertiesArgs']] = None,
                 captcha: Optional[pulumi.Input['RuleGroupRuleActionCaptchaPropertiesArgs']] = None,
                 count: Optional[pulumi.Input['RuleGroupRuleActionCountPropertiesArgs']] = None):
        """
        Action taken when Rule matches its condition.
        :param pulumi.Input['RuleGroupRuleActionAllowPropertiesArgs'] allow: Allow traffic towards application.
        :param pulumi.Input['RuleGroupRuleActionBlockPropertiesArgs'] block: Block traffic towards application.
        :param pulumi.Input['RuleGroupRuleActionCaptchaPropertiesArgs'] captcha: Checks valid token exists with request.
        :param pulumi.Input['RuleGroupRuleActionCountPropertiesArgs'] count: Count traffic towards application.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['RuleGroupRuleActionAllowPropertiesArgs']]:
        """
        Allow traffic towards application.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['RuleGroupRuleActionAllowPropertiesArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['RuleGroupRuleActionBlockPropertiesArgs']]:
        """
        Block traffic towards application.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['RuleGroupRuleActionBlockPropertiesArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['RuleGroupRuleActionCaptchaPropertiesArgs']]:
        """
        Checks valid token exists with request.
        """
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['RuleGroupRuleActionCaptchaPropertiesArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['RuleGroupRuleActionCountPropertiesArgs']]:
        """
        Count traffic towards application.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['RuleGroupRuleActionCountPropertiesArgs']]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class RuleGroupRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 statement: pulumi.Input['RuleGroupStatementArgs'],
                 visibility_config: pulumi.Input['RuleGroupVisibilityConfigArgs'],
                 action: Optional[pulumi.Input['RuleGroupRuleActionArgs']] = None,
                 captcha_config: Optional[pulumi.Input['RuleGroupCaptchaConfigArgs']] = None,
                 rule_labels: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupLabelArgs']]]] = None):
        """
        Rule of RuleGroup that contains condition and action.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupLabelArgs']]] rule_labels: Collection of Rule Labels.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['RuleGroupStatementArgs']:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['RuleGroupStatementArgs']):
        pulumi.set(self, "statement", value)

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> pulumi.Input['RuleGroupVisibilityConfigArgs']:
        return pulumi.get(self, "visibility_config")

    @visibility_config.setter
    def visibility_config(self, value: pulumi.Input['RuleGroupVisibilityConfigArgs']):
        pulumi.set(self, "visibility_config", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['RuleGroupRuleActionArgs']]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['RuleGroupRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional[pulumi.Input['RuleGroupCaptchaConfigArgs']]:
        return pulumi.get(self, "captcha_config")

    @captcha_config.setter
    def captcha_config(self, value: Optional[pulumi.Input['RuleGroupCaptchaConfigArgs']]):
        pulumi.set(self, "captcha_config", value)

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupLabelArgs']]]]:
        """
        Collection of Rule Labels.
        """
        return pulumi.get(self, "rule_labels")

    @rule_labels.setter
    def rule_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupLabelArgs']]]]):
        pulumi.set(self, "rule_labels", value)


@pulumi.input_type
class RuleGroupSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input['RuleGroupSizeConstraintStatementComparisonOperator'],
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 size: pulumi.Input[float],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        """
        Size Constraint statement.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input['RuleGroupSizeConstraintStatementComparisonOperator']:
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input['RuleGroupSizeConstraintStatementComparisonOperator']):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[float]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[float]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupSqliMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        """
        Sqli Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['RuleGroupAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['RuleGroupByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['RuleGroupGeoMatchStatementArgs']] = None,
                 i_p_set_reference_statement: Optional[pulumi.Input['RuleGroupIPSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['RuleGroupLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['RuleGroupNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['RuleGroupOrStatementArgs']] = None,
                 rate_based_statement: Optional[pulumi.Input['RuleGroupRateBasedStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['RuleGroupRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['RuleGroupRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['RuleGroupSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['RuleGroupSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['RuleGroupXssMatchStatementArgs']] = None):
        """
        First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if i_p_set_reference_statement is not None:
            pulumi.set(__self__, "i_p_set_reference_statement", i_p_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['RuleGroupAndStatementArgs']]:
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['RuleGroupAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['RuleGroupByteMatchStatementArgs']]:
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['RuleGroupByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['RuleGroupGeoMatchStatementArgs']]:
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['RuleGroupGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="iPSetReferenceStatement")
    def i_p_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupIPSetReferenceStatementArgs']]:
        return pulumi.get(self, "i_p_set_reference_statement")

    @i_p_set_reference_statement.setter
    def i_p_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupIPSetReferenceStatementArgs']]):
        pulumi.set(self, "i_p_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['RuleGroupLabelMatchStatementArgs']]:
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['RuleGroupLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['RuleGroupNotStatementArgs']]:
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['RuleGroupNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['RuleGroupOrStatementArgs']]:
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['RuleGroupOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional[pulumi.Input['RuleGroupRateBasedStatementArgs']]:
        return pulumi.get(self, "rate_based_statement")

    @rate_based_statement.setter
    def rate_based_statement(self, value: Optional[pulumi.Input['RuleGroupRateBasedStatementArgs']]):
        pulumi.set(self, "rate_based_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['RuleGroupRegexMatchStatementArgs']]:
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['RuleGroupRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRegexPatternSetReferenceStatementArgs']]:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['RuleGroupSizeConstraintStatementArgs']]:
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['RuleGroupSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['RuleGroupSqliMatchStatementArgs']]:
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['RuleGroupSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['RuleGroupXssMatchStatementArgs']]:
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['RuleGroupXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


@pulumi.input_type
class RuleGroupTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input['RuleGroupTextTransformationType']):
        """
        Text Transformation on the Search String before match.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['RuleGroupTextTransformationType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['RuleGroupTextTransformationType']):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloud_watch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        Visibility Metric of the RuleGroup.
        """
        pulumi.set(__self__, "cloud_watch_metrics_enabled", cloud_watch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudWatchMetricsEnabled")
    def cloud_watch_metrics_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "cloud_watch_metrics_enabled")

    @cloud_watch_metrics_enabled.setter
    def cloud_watch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloud_watch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


@pulumi.input_type
class RuleGroupXssMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        """
        Xss Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLAllowActionArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebACLAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebACLBlockActionArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebACLCustomResponseArgs']] = None):
        """
        Block traffic towards application.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebACLCustomResponseArgs']]:
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebACLCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


@pulumi.input_type
class WebACLByteMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 positional_constraint: pulumi.Input['WebACLPositionalConstraint'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]],
                 search_string: Optional[pulumi.Input[str]] = None,
                 search_string_base64: Optional[pulumi.Input[str]] = None):
        """
        Byte Match statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if search_string is not None:
            pulumi.set(__self__, "search_string", search_string)
        if search_string_base64 is not None:
            pulumi.set(__self__, "search_string_base64", search_string_base64)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input['WebACLPositionalConstraint']:
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input['WebACLPositionalConstraint']):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="searchStringBase64")
    def search_string_base64(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_string_base64")

    @search_string_base64.setter
    def search_string_base64(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_string_base64", value)


@pulumi.input_type
class WebACLCaptchaActionArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']] = None):
        """
        Checks valid token exists with request.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebACLCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebACLImmunityTimePropertyArgs']] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebACLImmunityTimePropertyArgs']]:
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebACLImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


@pulumi.input_type
class WebACLCountActionArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebACLCustomHTTPHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebACLCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]):
        """
        Custom request handling.
        :param pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]] insert_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebACLCustomResponseBodiesArgs:
    def __init__(__self__):
        """
        Custom response key and body map.
        """
        pass


@pulumi.input_type
class WebACLCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]] = None):
        """
        Custom response.
        :param pulumi.Input[str] custom_response_body_key: Custom response body key.
        :param pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]] response_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        Custom response body key.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


@pulumi.input_type
class WebACLDefaultActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebACLAllowActionArgs']] = None,
                 block: Optional[pulumi.Input['WebACLBlockActionArgs']] = None):
        """
        Default Action WebACL will take against ingress traffic when there is no matching Rule.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebACLAllowActionArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebACLAllowActionArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebACLBlockActionArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebACLBlockActionArgs']]):
        pulumi.set(self, "block", value)


@pulumi.input_type
class WebACLExcludedRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebACLFieldToMatchSingleHeaderPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebACLFieldToMatchSingleQueryArgumentPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebACLFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[Any] = None,
                 body: Optional[Any] = None,
                 json_body: Optional[pulumi.Input['WebACLJsonBodyArgs']] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional[pulumi.Input['WebACLFieldToMatchSingleHeaderPropertiesArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebACLFieldToMatchSingleQueryArgumentPropertiesArgs']] = None,
                 uri_path: Optional[Any] = None):
        """
        Field of the request to match.
        :param Any all_query_arguments: All query arguments of a web request.
        :param Any body: The body of a web request. This immediately follows the request headers.
        :param Any method: The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        :param Any query_string: The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        :param pulumi.Input['WebACLFieldToMatchSingleQueryArgumentPropertiesArgs'] single_query_argument: One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        :param Any uri_path: The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[Any]:
        """
        All query arguments of a web request.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[Any]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[Any]:
        """
        The body of a web request. This immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[Any]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebACLJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebACLJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[Any]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[Any]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebACLFieldToMatchSingleHeaderPropertiesArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebACLFieldToMatchSingleHeaderPropertiesArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebACLFieldToMatchSingleQueryArgumentPropertiesArgs']]:
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebACLFieldToMatchSingleQueryArgumentPropertiesArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[Any]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebACLForwardedIPConfigurationArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input['WebACLForwardedIPConfigurationFallbackBehavior'],
                 header_name: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input['WebACLForwardedIPConfigurationFallbackBehavior']:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input['WebACLForwardedIPConfigurationFallbackBehavior']):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


@pulumi.input_type
class WebACLGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']] = None):
        if country_codes is not None:
            pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


@pulumi.input_type
class WebACLIPSetForwardedIPConfigurationArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input['WebACLIPSetForwardedIPConfigurationFallbackBehavior'],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input['WebACLIPSetForwardedIPConfigurationPosition']):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input['WebACLIPSetForwardedIPConfigurationFallbackBehavior']:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input['WebACLIPSetForwardedIPConfigurationFallbackBehavior']):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input['WebACLIPSetForwardedIPConfigurationPosition']:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input['WebACLIPSetForwardedIPConfigurationPosition']):
        pulumi.set(self, "position", value)


@pulumi.input_type
class WebACLIPSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 i_p_set_forwarded_ip_config: Optional[pulumi.Input['WebACLIPSetForwardedIPConfigurationArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        if i_p_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "i_p_set_forwarded_ip_config", i_p_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="iPSetForwardedIPConfig")
    def i_p_set_forwarded_ip_config(self) -> Optional[pulumi.Input['WebACLIPSetForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "i_p_set_forwarded_ip_config")

    @i_p_set_forwarded_ip_config.setter
    def i_p_set_forwarded_ip_config(self, value: Optional[pulumi.Input['WebACLIPSetForwardedIPConfigurationArgs']]):
        pulumi.set(self, "i_p_set_forwarded_ip_config", value)


@pulumi.input_type
class WebACLImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: pulumi.Input[int]):
        pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> pulumi.Input[int]:
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: pulumi.Input[int]):
        pulumi.set(self, "immunity_time", value)


@pulumi.input_type
class WebACLJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebACLJsonMatchPatternArgs'],
                 match_scope: pulumi.Input['WebACLJsonMatchScope'],
                 invalid_fallback_behavior: Optional[pulumi.Input['WebACLBodyParsingFallbackBehavior']] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebACLJsonMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebACLJsonMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input['WebACLJsonMatchScope']:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input['WebACLJsonMatchScope']):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input['WebACLBodyParsingFallbackBehavior']]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input['WebACLBodyParsingFallbackBehavior']]):
        pulumi.set(self, "invalid_fallback_behavior", value)


@pulumi.input_type
class WebACLJsonMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The pattern to look for in the JSON body.
        :param Any all: Inspect all parts of the web request's JSON body.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request's JSON body.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[Any]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebACLLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input['WebACLLabelMatchScope']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input['WebACLLabelMatchScope']:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input['WebACLLabelMatchScope']):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class WebACLLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebACLManagedRuleGroupStatementArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 vendor_name: pulumi.Input[str],
                 excluded_rules: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]] = None,
                 scope_down_statement: Optional[pulumi.Input['WebACLStatementArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vendor_name", vendor_name)
        if excluded_rules is not None:
            pulumi.set(__self__, "excluded_rules", excluded_rules)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "vendor_name")

    @vendor_name.setter
    def vendor_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vendor_name", value)

    @property
    @pulumi.getter(name="excludedRules")
    def excluded_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]]:
        return pulumi.get(self, "excluded_rules")

    @excluded_rules.setter
    def excluded_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]]):
        pulumi.set(self, "excluded_rules", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['WebACLStatementArgs']]:
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['WebACLStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class WebACLNotStatementArgs:
    def __init__(__self__, *,
                 statement: pulumi.Input['WebACLStatementArgs']):
        pulumi.set(__self__, "statement", statement)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['WebACLStatementArgs']:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['WebACLStatementArgs']):
        pulumi.set(self, "statement", value)


@pulumi.input_type
class WebACLOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebACLOverrideActionArgs:
    def __init__(__self__, *,
                 count: Optional[Any] = None,
                 none: Optional[Any] = None):
        """
        Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
        :param Any count: Count traffic towards application.
        :param Any none: Keep the RuleGroup or ManagedRuleGroup behavior as is.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @property
    @pulumi.getter
    def count(self) -> Optional[Any]:
        """
        Count traffic towards application.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[Any]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def none(self) -> Optional[Any]:
        """
        Keep the RuleGroup or ManagedRuleGroup behavior as is.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[Any]):
        pulumi.set(self, "none", value)


@pulumi.input_type
class WebACLRateBasedStatementArgs:
    def __init__(__self__, *,
                 aggregate_key_type: pulumi.Input['WebACLRateBasedStatementAggregateKeyType'],
                 limit: pulumi.Input[int],
                 forwarded_ip_config: Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']] = None,
                 scope_down_statement: Optional[pulumi.Input['WebACLStatementArgs']] = None):
        pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        pulumi.set(__self__, "limit", limit)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> pulumi.Input['WebACLRateBasedStatementAggregateKeyType']:
        return pulumi.get(self, "aggregate_key_type")

    @aggregate_key_type.setter
    def aggregate_key_type(self, value: pulumi.Input['WebACLRateBasedStatementAggregateKeyType']):
        pulumi.set(self, "aggregate_key_type", value)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['WebACLStatementArgs']]:
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['WebACLStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)


@pulumi.input_type
class WebACLRegexMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebACLAllowActionArgs']] = None,
                 block: Optional[pulumi.Input['WebACLBlockActionArgs']] = None,
                 captcha: Optional[pulumi.Input['WebACLCaptchaActionArgs']] = None,
                 count: Optional[pulumi.Input['WebACLCountActionArgs']] = None):
        """
        Action taken when Rule matches its condition.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebACLAllowActionArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebACLAllowActionArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebACLBlockActionArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebACLBlockActionArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebACLCaptchaActionArgs']]:
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebACLCaptchaActionArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebACLCountActionArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebACLCountActionArgs']]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class WebACLRuleGroupReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 excluded_rules: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]] = None):
        pulumi.set(__self__, "arn", arn)
        if excluded_rules is not None:
            pulumi.set(__self__, "excluded_rules", excluded_rules)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="excludedRules")
    def excluded_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]]:
        return pulumi.get(self, "excluded_rules")

    @excluded_rules.setter
    def excluded_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]]):
        pulumi.set(self, "excluded_rules", value)


@pulumi.input_type
class WebACLRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 statement: pulumi.Input['WebACLStatementArgs'],
                 visibility_config: pulumi.Input['WebACLVisibilityConfigArgs'],
                 action: Optional[pulumi.Input['WebACLRuleActionArgs']] = None,
                 captcha_config: Optional[pulumi.Input['WebACLCaptchaConfigArgs']] = None,
                 override_action: Optional[pulumi.Input['WebACLOverrideActionArgs']] = None,
                 rule_labels: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLLabelArgs']]]] = None):
        """
        Rule of WebACL that contains condition and action.
        :param pulumi.Input[Sequence[pulumi.Input['WebACLLabelArgs']]] rule_labels: Collection of Rule Labels.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if override_action is not None:
            pulumi.set(__self__, "override_action", override_action)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['WebACLStatementArgs']:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['WebACLStatementArgs']):
        pulumi.set(self, "statement", value)

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> pulumi.Input['WebACLVisibilityConfigArgs']:
        return pulumi.get(self, "visibility_config")

    @visibility_config.setter
    def visibility_config(self, value: pulumi.Input['WebACLVisibilityConfigArgs']):
        pulumi.set(self, "visibility_config", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['WebACLRuleActionArgs']]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['WebACLRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional[pulumi.Input['WebACLCaptchaConfigArgs']]:
        return pulumi.get(self, "captcha_config")

    @captcha_config.setter
    def captcha_config(self, value: Optional[pulumi.Input['WebACLCaptchaConfigArgs']]):
        pulumi.set(self, "captcha_config", value)

    @property
    @pulumi.getter(name="overrideAction")
    def override_action(self) -> Optional[pulumi.Input['WebACLOverrideActionArgs']]:
        return pulumi.get(self, "override_action")

    @override_action.setter
    def override_action(self, value: Optional[pulumi.Input['WebACLOverrideActionArgs']]):
        pulumi.set(self, "override_action", value)

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLLabelArgs']]]]:
        """
        Collection of Rule Labels.
        """
        return pulumi.get(self, "rule_labels")

    @rule_labels.setter
    def rule_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLLabelArgs']]]]):
        pulumi.set(self, "rule_labels", value)


@pulumi.input_type
class WebACLSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input['WebACLSizeConstraintStatementComparisonOperator'],
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 size: pulumi.Input[float],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        """
        Size Constraint statement.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input['WebACLSizeConstraintStatementComparisonOperator']:
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input['WebACLSizeConstraintStatementComparisonOperator']):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[float]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[float]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLSqliMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        """
        Sqli Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['WebACLAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['WebACLByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['WebACLGeoMatchStatementArgs']] = None,
                 i_p_set_reference_statement: Optional[pulumi.Input['WebACLIPSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['WebACLLabelMatchStatementArgs']] = None,
                 managed_rule_group_statement: Optional[pulumi.Input['WebACLManagedRuleGroupStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['WebACLNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['WebACLOrStatementArgs']] = None,
                 rate_based_statement: Optional[pulumi.Input['WebACLRateBasedStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['WebACLRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['WebACLRegexPatternSetReferenceStatementArgs']] = None,
                 rule_group_reference_statement: Optional[pulumi.Input['WebACLRuleGroupReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['WebACLSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['WebACLSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['WebACLXssMatchStatementArgs']] = None):
        """
        First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if i_p_set_reference_statement is not None:
            pulumi.set(__self__, "i_p_set_reference_statement", i_p_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if managed_rule_group_statement is not None:
            pulumi.set(__self__, "managed_rule_group_statement", managed_rule_group_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if rule_group_reference_statement is not None:
            pulumi.set(__self__, "rule_group_reference_statement", rule_group_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['WebACLAndStatementArgs']]:
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['WebACLAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['WebACLByteMatchStatementArgs']]:
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['WebACLByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['WebACLGeoMatchStatementArgs']]:
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['WebACLGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="iPSetReferenceStatement")
    def i_p_set_reference_statement(self) -> Optional[pulumi.Input['WebACLIPSetReferenceStatementArgs']]:
        return pulumi.get(self, "i_p_set_reference_statement")

    @i_p_set_reference_statement.setter
    def i_p_set_reference_statement(self, value: Optional[pulumi.Input['WebACLIPSetReferenceStatementArgs']]):
        pulumi.set(self, "i_p_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['WebACLLabelMatchStatementArgs']]:
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['WebACLLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="managedRuleGroupStatement")
    def managed_rule_group_statement(self) -> Optional[pulumi.Input['WebACLManagedRuleGroupStatementArgs']]:
        return pulumi.get(self, "managed_rule_group_statement")

    @managed_rule_group_statement.setter
    def managed_rule_group_statement(self, value: Optional[pulumi.Input['WebACLManagedRuleGroupStatementArgs']]):
        pulumi.set(self, "managed_rule_group_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['WebACLNotStatementArgs']]:
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['WebACLNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['WebACLOrStatementArgs']]:
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['WebACLOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional[pulumi.Input['WebACLRateBasedStatementArgs']]:
        return pulumi.get(self, "rate_based_statement")

    @rate_based_statement.setter
    def rate_based_statement(self, value: Optional[pulumi.Input['WebACLRateBasedStatementArgs']]):
        pulumi.set(self, "rate_based_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['WebACLRegexMatchStatementArgs']]:
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['WebACLRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['WebACLRegexPatternSetReferenceStatementArgs']]:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['WebACLRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="ruleGroupReferenceStatement")
    def rule_group_reference_statement(self) -> Optional[pulumi.Input['WebACLRuleGroupReferenceStatementArgs']]:
        return pulumi.get(self, "rule_group_reference_statement")

    @rule_group_reference_statement.setter
    def rule_group_reference_statement(self, value: Optional[pulumi.Input['WebACLRuleGroupReferenceStatementArgs']]):
        pulumi.set(self, "rule_group_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['WebACLSizeConstraintStatementArgs']]:
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['WebACLSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['WebACLSqliMatchStatementArgs']]:
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['WebACLSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['WebACLXssMatchStatementArgs']]:
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['WebACLXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


@pulumi.input_type
class WebACLTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebACLTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input['WebACLTextTransformationType']):
        """
        Text Transformation on the Search String before match.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['WebACLTextTransformationType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['WebACLTextTransformationType']):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebACLVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloud_watch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        Visibility Metric of the WebACL.
        """
        pulumi.set(__self__, "cloud_watch_metrics_enabled", cloud_watch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudWatchMetricsEnabled")
    def cloud_watch_metrics_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "cloud_watch_metrics_enabled")

    @cloud_watch_metrics_enabled.setter
    def cloud_watch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloud_watch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


@pulumi.input_type
class WebACLXssMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        """
        Xss Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


