# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'IPSetTagArgs',
    'LoggingConfigurationConditionActionConditionPropertiesArgs',
    'LoggingConfigurationConditionLabelNameConditionPropertiesArgs',
    'LoggingConfigurationConditionArgs',
    'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs',
    'LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs',
    'LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs',
    'LoggingConfigurationFieldToMatchArgs',
    'LoggingConfigurationFilterArgs',
    'LoggingFilterPropertiesArgs',
    'RegexPatternSetTagArgs',
    'RuleGroupAllowActionArgs',
    'RuleGroupAndStatementArgs',
    'RuleGroupBlockActionArgs',
    'RuleGroupBodyArgs',
    'RuleGroupByteMatchStatementArgs',
    'RuleGroupCaptchaActionArgs',
    'RuleGroupCaptchaConfigArgs',
    'RuleGroupChallengeActionArgs',
    'RuleGroupChallengeConfigArgs',
    'RuleGroupCookieMatchPatternArgs',
    'RuleGroupCookiesArgs',
    'RuleGroupCountActionArgs',
    'RuleGroupCustomHTTPHeaderArgs',
    'RuleGroupCustomRequestHandlingArgs',
    'RuleGroupCustomResponseBodiesArgs',
    'RuleGroupCustomResponseArgs',
    'RuleGroupFieldToMatchSingleHeaderPropertiesArgs',
    'RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs',
    'RuleGroupFieldToMatchArgs',
    'RuleGroupForwardedIPConfigurationArgs',
    'RuleGroupGeoMatchStatementArgs',
    'RuleGroupHeaderMatchPatternArgs',
    'RuleGroupHeadersArgs',
    'RuleGroupIPSetForwardedIPConfigurationArgs',
    'RuleGroupIPSetReferenceStatementArgs',
    'RuleGroupImmunityTimePropertyArgs',
    'RuleGroupJsonBodyArgs',
    'RuleGroupJsonMatchPatternArgs',
    'RuleGroupLabelMatchStatementArgs',
    'RuleGroupLabelSummaryArgs',
    'RuleGroupLabelArgs',
    'RuleGroupNotStatementArgs',
    'RuleGroupOrStatementArgs',
    'RuleGroupRateBasedStatementCustomKeyArgs',
    'RuleGroupRateBasedStatementArgs',
    'RuleGroupRateLimitCookieArgs',
    'RuleGroupRateLimitForwardedIPArgs',
    'RuleGroupRateLimitHTTPMethodArgs',
    'RuleGroupRateLimitHeaderArgs',
    'RuleGroupRateLimitIPArgs',
    'RuleGroupRateLimitLabelNamespaceArgs',
    'RuleGroupRateLimitQueryArgumentArgs',
    'RuleGroupRateLimitQueryStringArgs',
    'RuleGroupRateLimitUriPathArgs',
    'RuleGroupRegexMatchStatementArgs',
    'RuleGroupRegexPatternSetReferenceStatementArgs',
    'RuleGroupRuleActionArgs',
    'RuleGroupRuleArgs',
    'RuleGroupSizeConstraintStatementArgs',
    'RuleGroupSqliMatchStatementArgs',
    'RuleGroupStatementArgs',
    'RuleGroupTagArgs',
    'RuleGroupTextTransformationArgs',
    'RuleGroupVisibilityConfigArgs',
    'RuleGroupXssMatchStatementArgs',
    'WebACLAWSManagedRulesATPRuleSetArgs',
    'WebACLAWSManagedRulesBotControlRuleSetArgs',
    'WebACLAllowActionArgs',
    'WebACLAndStatementArgs',
    'WebACLAssociationConfigArgs',
    'WebACLBlockActionArgs',
    'WebACLBodyArgs',
    'WebACLByteMatchStatementArgs',
    'WebACLCaptchaActionArgs',
    'WebACLCaptchaConfigArgs',
    'WebACLChallengeActionArgs',
    'WebACLChallengeConfigArgs',
    'WebACLCookieMatchPatternArgs',
    'WebACLCookiesArgs',
    'WebACLCountActionArgs',
    'WebACLCustomHTTPHeaderArgs',
    'WebACLCustomRequestHandlingArgs',
    'WebACLCustomResponseBodiesArgs',
    'WebACLCustomResponseArgs',
    'WebACLDefaultActionArgs',
    'WebACLExcludedRuleArgs',
    'WebACLFieldIdentifierArgs',
    'WebACLFieldToMatchSingleHeaderPropertiesArgs',
    'WebACLFieldToMatchSingleQueryArgumentPropertiesArgs',
    'WebACLFieldToMatchArgs',
    'WebACLForwardedIPConfigurationArgs',
    'WebACLGeoMatchStatementArgs',
    'WebACLHeaderMatchPatternArgs',
    'WebACLHeadersArgs',
    'WebACLIPSetForwardedIPConfigurationArgs',
    'WebACLIPSetReferenceStatementArgs',
    'WebACLImmunityTimePropertyArgs',
    'WebACLJsonBodyArgs',
    'WebACLJsonMatchPatternArgs',
    'WebACLLabelMatchStatementArgs',
    'WebACLLabelArgs',
    'WebACLManagedRuleGroupConfigArgs',
    'WebACLManagedRuleGroupStatementArgs',
    'WebACLNotStatementArgs',
    'WebACLOrStatementArgs',
    'WebACLOverrideActionArgs',
    'WebACLRateBasedStatementCustomKeyArgs',
    'WebACLRateBasedStatementArgs',
    'WebACLRateLimitCookieArgs',
    'WebACLRateLimitForwardedIPArgs',
    'WebACLRateLimitHTTPMethodArgs',
    'WebACLRateLimitHeaderArgs',
    'WebACLRateLimitIPArgs',
    'WebACLRateLimitLabelNamespaceArgs',
    'WebACLRateLimitQueryArgumentArgs',
    'WebACLRateLimitQueryStringArgs',
    'WebACLRateLimitUriPathArgs',
    'WebACLRegexMatchStatementArgs',
    'WebACLRegexPatternSetReferenceStatementArgs',
    'WebACLRequestBodyArgs',
    'WebACLRequestInspectionArgs',
    'WebACLResponseInspectionBodyContainsArgs',
    'WebACLResponseInspectionHeaderArgs',
    'WebACLResponseInspectionJsonArgs',
    'WebACLResponseInspectionStatusCodeArgs',
    'WebACLResponseInspectionArgs',
    'WebACLRuleActionOverrideArgs',
    'WebACLRuleActionArgs',
    'WebACLRuleGroupReferenceStatementArgs',
    'WebACLRuleArgs',
    'WebACLSizeConstraintStatementArgs',
    'WebACLSqliMatchStatementArgs',
    'WebACLStatementArgs',
    'WebACLTagArgs',
    'WebACLTextTransformationArgs',
    'WebACLVisibilityConfigArgs',
    'WebACLXssMatchStatementArgs',
]

@pulumi.input_type
class IPSetTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class LoggingConfigurationConditionActionConditionPropertiesArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesAction']):
        """
        A single action condition.
        :param pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesAction'] action: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesAction']:
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesAction']):
        pulumi.set(self, "action", value)


@pulumi.input_type
class LoggingConfigurationConditionLabelNameConditionPropertiesArgs:
    def __init__(__self__, *,
                 label_name: pulumi.Input[str]):
        """
        A single label name condition.
        :param pulumi.Input[str] label_name: The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
        """
        pulumi.set(__self__, "label_name", label_name)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> pulumi.Input[str]:
        """
        The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
        """
        return pulumi.get(self, "label_name")

    @label_name.setter
    def label_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "label_name", value)


@pulumi.input_type
class LoggingConfigurationConditionArgs:
    def __init__(__self__, *,
                 action_condition: Optional[pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesArgs']] = None,
                 label_name_condition: Optional[pulumi.Input['LoggingConfigurationConditionLabelNameConditionPropertiesArgs']] = None):
        """
        :param pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesArgs'] action_condition: A single action condition.
        :param pulumi.Input['LoggingConfigurationConditionLabelNameConditionPropertiesArgs'] label_name_condition: A single label name condition.
        """
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional[pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesArgs']]:
        """
        A single action condition.
        """
        return pulumi.get(self, "action_condition")

    @action_condition.setter
    def action_condition(self, value: Optional[pulumi.Input['LoggingConfigurationConditionActionConditionPropertiesArgs']]):
        pulumi.set(self, "action_condition", value)

    @property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional[pulumi.Input['LoggingConfigurationConditionLabelNameConditionPropertiesArgs']]:
        """
        A single label name condition.
        """
        return pulumi.get(self, "label_name_condition")

    @label_name_condition.setter
    def label_name_condition(self, value: Optional[pulumi.Input['LoggingConfigurationConditionLabelNameConditionPropertiesArgs']]):
        pulumi.set(self, "label_name_condition", value)


@pulumi.input_type
class LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs:
    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        :param Any all: Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_paths: Match only the specified include paths. See also MatchScope in JsonBody.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[Any]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match only the specified include paths. See also MatchScope in JsonBody.
        """
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs'],
                 match_scope: pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope'],
                 invalid_fallback_behavior: Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior']] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        :param pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs'] match_pattern: The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        :param pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope'] match_scope: The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
        :param pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior'] invalid_fallback_behavior: What AWS WAF should do if it fails to completely parse the JSON body.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs']:
        """
        The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternPropertiesArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope']:
        """
        The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope']):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior']]:
        """
        What AWS WAF should do if it fails to completely parse the JSON body.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior']]):
        pulumi.set(self, "invalid_fallback_behavior", value)


@pulumi.input_type
class LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        :param pulumi.Input[str] name: The name of the query header to inspect.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LoggingConfigurationFieldToMatchArgs:
    def __init__(__self__, *,
                 json_body: Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs']] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional[pulumi.Input['LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs']] = None,
                 uri_path: Optional[Any] = None):
        """
        A key-value pair to associate with a resource.
        :param pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs'] json_body: Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        :param Any method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
        :param Any query_string: Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
        :param pulumi.Input['LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs'] single_header: Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        :param Any uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
        """
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs']]:
        """
        Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['LoggingConfigurationFieldToMatchJsonBodyPropertiesArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[Any]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[Any]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs']]:
        """
        Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[Any]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class LoggingConfigurationFilterArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input['LoggingConfigurationFilterBehavior'],
                 conditions: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationConditionArgs']]],
                 requirement: pulumi.Input['LoggingConfigurationFilterRequirement']):
        """
        :param pulumi.Input['LoggingConfigurationFilterBehavior'] behavior: How to handle logs that satisfy the filter's conditions and requirement. 
        :param pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationConditionArgs']]] conditions: Match conditions for the filter.
        :param pulumi.Input['LoggingConfigurationFilterRequirement'] requirement: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "requirement", requirement)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input['LoggingConfigurationFilterBehavior']:
        """
        How to handle logs that satisfy the filter's conditions and requirement. 
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input['LoggingConfigurationFilterBehavior']):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationConditionArgs']]]:
        """
        Match conditions for the filter.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def requirement(self) -> pulumi.Input['LoggingConfigurationFilterRequirement']:
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "requirement")

    @requirement.setter
    def requirement(self, value: pulumi.Input['LoggingConfigurationFilterRequirement']):
        pulumi.set(self, "requirement", value)


@pulumi.input_type
class LoggingFilterPropertiesArgs:
    def __init__(__self__, *,
                 default_behavior: pulumi.Input['LoggingConfigurationLoggingFilterPropertiesDefaultBehavior'],
                 filters: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationFilterArgs']]]):
        """
        Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
        :param pulumi.Input['LoggingConfigurationLoggingFilterPropertiesDefaultBehavior'] default_behavior: Default handling for logs that don't match any of the specified filtering conditions.
        :param pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationFilterArgs']]] filters: The filters that you want to apply to the logs.
        """
        pulumi.set(__self__, "default_behavior", default_behavior)
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> pulumi.Input['LoggingConfigurationLoggingFilterPropertiesDefaultBehavior']:
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        """
        return pulumi.get(self, "default_behavior")

    @default_behavior.setter
    def default_behavior(self, value: pulumi.Input['LoggingConfigurationLoggingFilterPropertiesDefaultBehavior']):
        pulumi.set(self, "default_behavior", value)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationFilterArgs']]]:
        """
        The filters that you want to apply to the logs.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationFilterArgs']]]):
        pulumi.set(self, "filters", value)


@pulumi.input_type
class RegexPatternSetTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupAllowActionArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class RuleGroupAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class RuleGroupBlockActionArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['RuleGroupCustomResponseArgs']] = None):
        """
        Block traffic towards application.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['RuleGroupCustomResponseArgs']]:
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['RuleGroupCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


@pulumi.input_type
class RuleGroupBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input['RuleGroupOversizeHandling']] = None):
        """
        The body of a web request. This immediately follows the request headers.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input['RuleGroupOversizeHandling']]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input['RuleGroupOversizeHandling']]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupByteMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 positional_constraint: pulumi.Input['RuleGroupPositionalConstraint'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]],
                 search_string: Optional[pulumi.Input[str]] = None,
                 search_string_base64: Optional[pulumi.Input[str]] = None):
        """
        Byte Match statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if search_string is not None:
            pulumi.set(__self__, "search_string", search_string)
        if search_string_base64 is not None:
            pulumi.set(__self__, "search_string_base64", search_string_base64)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input['RuleGroupPositionalConstraint']:
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input['RuleGroupPositionalConstraint']):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="searchStringBase64")
    def search_string_base64(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_string_base64")

    @search_string_base64.setter
    def search_string_base64(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_string_base64", value)


@pulumi.input_type
class RuleGroupCaptchaActionArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']] = None):
        """
        Checks valid token exists with request.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class RuleGroupCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['RuleGroupImmunityTimePropertyArgs']] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['RuleGroupImmunityTimePropertyArgs']]:
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['RuleGroupImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


@pulumi.input_type
class RuleGroupChallengeActionArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']] = None):
        """
        Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class RuleGroupChallengeConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['RuleGroupImmunityTimePropertyArgs']] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['RuleGroupImmunityTimePropertyArgs']]:
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['RuleGroupImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


@pulumi.input_type
class RuleGroupCookieMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The pattern to look for in the request cookies.
        :param Any all: Inspect all parts of the web request cookies.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request cookies.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[Any]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupCookiesArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupCookieMatchPatternArgs'],
                 match_scope: pulumi.Input['RuleGroupMapMatchScope'],
                 oversize_handling: pulumi.Input['RuleGroupOversizeHandling']):
        """
        Includes headers of a web request.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupCookieMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupCookieMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input['RuleGroupMapMatchScope']:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input['RuleGroupMapMatchScope']):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input['RuleGroupOversizeHandling']:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input['RuleGroupOversizeHandling']):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupCountActionArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']] = None):
        """
        Count traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class RuleGroupCustomHTTPHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]):
        """
        Custom request handling.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]] insert_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class RuleGroupCustomResponseBodiesArgs:
    def __init__(__self__):
        """
        Custom response key and body map.
        """
        pass


@pulumi.input_type
class RuleGroupCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]] = None):
        """
        Custom response.
        :param pulumi.Input[str] custom_response_body_key: Custom response body key.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]] response_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        Custom response body key.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomHTTPHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


@pulumi.input_type
class RuleGroupFieldToMatchSingleHeaderPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[Any] = None,
                 body: Optional[pulumi.Input['RuleGroupBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupCookiesArgs']] = None,
                 headers: Optional[pulumi.Input['RuleGroupHeadersArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupJsonBodyArgs']] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional[pulumi.Input['RuleGroupFieldToMatchSingleHeaderPropertiesArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs']] = None,
                 uri_path: Optional[Any] = None):
        """
        Field of the request to match.
        :param Any all_query_arguments: All query arguments of a web request.
        :param Any method: The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        :param Any query_string: The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        :param pulumi.Input['RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs'] single_query_argument: One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        :param Any uri_path: The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[Any]:
        """
        All query arguments of a web request.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[Any]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['RuleGroupHeadersArgs']]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['RuleGroupHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[Any]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[Any]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupFieldToMatchSingleHeaderPropertiesArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupFieldToMatchSingleHeaderPropertiesArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs']]:
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[Any]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupForwardedIPConfigurationArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input['RuleGroupForwardedIPConfigurationFallbackBehavior'],
                 header_name: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input['RuleGroupForwardedIPConfigurationFallbackBehavior']:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input['RuleGroupForwardedIPConfigurationFallbackBehavior']):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


@pulumi.input_type
class RuleGroupGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']] = None):
        if country_codes is not None:
            pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


@pulumi.input_type
class RuleGroupHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The pattern to look for in the request headers.
        :param Any all: Inspect all parts of the web request headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[Any]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupHeadersArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input['RuleGroupMapMatchScope'],
                 oversize_handling: pulumi.Input['RuleGroupOversizeHandling']):
        """
        Includes headers of a web request.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input['RuleGroupMapMatchScope']:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input['RuleGroupMapMatchScope']):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input['RuleGroupOversizeHandling']:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input['RuleGroupOversizeHandling']):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupIPSetForwardedIPConfigurationArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input['RuleGroupIPSetForwardedIPConfigurationFallbackBehavior'],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input['RuleGroupIPSetForwardedIPConfigurationPosition']):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input['RuleGroupIPSetForwardedIPConfigurationFallbackBehavior']:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input['RuleGroupIPSetForwardedIPConfigurationFallbackBehavior']):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input['RuleGroupIPSetForwardedIPConfigurationPosition']:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input['RuleGroupIPSetForwardedIPConfigurationPosition']):
        pulumi.set(self, "position", value)


@pulumi.input_type
class RuleGroupIPSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 i_p_set_forwarded_ip_config: Optional[pulumi.Input['RuleGroupIPSetForwardedIPConfigurationArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        if i_p_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "i_p_set_forwarded_ip_config", i_p_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="iPSetForwardedIPConfig")
    def i_p_set_forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupIPSetForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "i_p_set_forwarded_ip_config")

    @i_p_set_forwarded_ip_config.setter
    def i_p_set_forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupIPSetForwardedIPConfigurationArgs']]):
        pulumi.set(self, "i_p_set_forwarded_ip_config", value)


@pulumi.input_type
class RuleGroupImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: pulumi.Input[int]):
        pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> pulumi.Input[int]:
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: pulumi.Input[int]):
        pulumi.set(self, "immunity_time", value)


@pulumi.input_type
class RuleGroupJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupJsonMatchPatternArgs'],
                 match_scope: pulumi.Input['RuleGroupJsonMatchScope'],
                 invalid_fallback_behavior: Optional[pulumi.Input['RuleGroupBodyParsingFallbackBehavior']] = None,
                 oversize_handling: Optional[pulumi.Input['RuleGroupOversizeHandling']] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupJsonMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupJsonMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input['RuleGroupJsonMatchScope']:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input['RuleGroupJsonMatchScope']):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input['RuleGroupBodyParsingFallbackBehavior']]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input['RuleGroupBodyParsingFallbackBehavior']]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input['RuleGroupOversizeHandling']]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input['RuleGroupOversizeHandling']]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupJsonMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The pattern to look for in the JSON body.
        :param Any all: Inspect all parts of the web request's JSON body.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request's JSON body.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[Any]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input['RuleGroupLabelMatchScope']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input['RuleGroupLabelMatchScope']:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input['RuleGroupLabelMatchScope']):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class RuleGroupLabelSummaryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupNotStatementArgs:
    def __init__(__self__, *,
                 statement: pulumi.Input['RuleGroupStatementArgs']):
        pulumi.set(__self__, "statement", statement)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['RuleGroupStatementArgs']:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['RuleGroupStatementArgs']):
        pulumi.set(self, "statement", value)


@pulumi.input_type
class RuleGroupOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class RuleGroupRateBasedStatementCustomKeyArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['RuleGroupRateLimitCookieArgs']] = None,
                 forwarded_ip: Optional[pulumi.Input['RuleGroupRateLimitForwardedIPArgs']] = None,
                 h_ttp_method: Optional[pulumi.Input['RuleGroupRateLimitHTTPMethodArgs']] = None,
                 header: Optional[pulumi.Input['RuleGroupRateLimitHeaderArgs']] = None,
                 i_p: Optional[pulumi.Input['RuleGroupRateLimitIPArgs']] = None,
                 label_namespace: Optional[pulumi.Input['RuleGroupRateLimitLabelNamespaceArgs']] = None,
                 query_argument: Optional[pulumi.Input['RuleGroupRateLimitQueryArgumentArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRateLimitQueryStringArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRateLimitUriPathArgs']] = None):
        """
        Specifies a single custom aggregate key for a rate-base rule.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if h_ttp_method is not None:
            pulumi.set(__self__, "h_ttp_method", h_ttp_method)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if i_p is not None:
            pulumi.set(__self__, "i_p", i_p)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['RuleGroupRateLimitCookieArgs']]:
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['RuleGroupRateLimitCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter(name="forwardedIP")
    def forwarded_ip(self) -> Optional[pulumi.Input['RuleGroupRateLimitForwardedIPArgs']]:
        return pulumi.get(self, "forwarded_ip")

    @forwarded_ip.setter
    def forwarded_ip(self, value: Optional[pulumi.Input['RuleGroupRateLimitForwardedIPArgs']]):
        pulumi.set(self, "forwarded_ip", value)

    @property
    @pulumi.getter(name="hTTPMethod")
    def h_ttp_method(self) -> Optional[pulumi.Input['RuleGroupRateLimitHTTPMethodArgs']]:
        return pulumi.get(self, "h_ttp_method")

    @h_ttp_method.setter
    def h_ttp_method(self, value: Optional[pulumi.Input['RuleGroupRateLimitHTTPMethodArgs']]):
        pulumi.set(self, "h_ttp_method", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['RuleGroupRateLimitHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['RuleGroupRateLimitHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="iP")
    def i_p(self) -> Optional[pulumi.Input['RuleGroupRateLimitIPArgs']]:
        return pulumi.get(self, "i_p")

    @i_p.setter
    def i_p(self, value: Optional[pulumi.Input['RuleGroupRateLimitIPArgs']]):
        pulumi.set(self, "i_p", value)

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional[pulumi.Input['RuleGroupRateLimitLabelNamespaceArgs']]:
        return pulumi.get(self, "label_namespace")

    @label_namespace.setter
    def label_namespace(self, value: Optional[pulumi.Input['RuleGroupRateLimitLabelNamespaceArgs']]):
        pulumi.set(self, "label_namespace", value)

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional[pulumi.Input['RuleGroupRateLimitQueryArgumentArgs']]:
        return pulumi.get(self, "query_argument")

    @query_argument.setter
    def query_argument(self, value: Optional[pulumi.Input['RuleGroupRateLimitQueryArgumentArgs']]):
        pulumi.set(self, "query_argument", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRateLimitQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRateLimitQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRateLimitUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRateLimitUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRateBasedStatementArgs:
    def __init__(__self__, *,
                 aggregate_key_type: pulumi.Input['RuleGroupRateBasedStatementAggregateKeyType'],
                 limit: pulumi.Input[int],
                 custom_keys: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRateBasedStatementCustomKeyArgs']]]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']] = None,
                 scope_down_statement: Optional[pulumi.Input['RuleGroupStatementArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRateBasedStatementCustomKeyArgs']]] custom_keys: Specifies the aggregate keys to use in a rate-base rule.
        """
        pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        pulumi.set(__self__, "limit", limit)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> pulumi.Input['RuleGroupRateBasedStatementAggregateKeyType']:
        return pulumi.get(self, "aggregate_key_type")

    @aggregate_key_type.setter
    def aggregate_key_type(self, value: pulumi.Input['RuleGroupRateBasedStatementAggregateKeyType']):
        pulumi.set(self, "aggregate_key_type", value)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRateBasedStatementCustomKeyArgs']]]]:
        """
        Specifies the aggregate keys to use in a rate-base rule.
        """
        return pulumi.get(self, "custom_keys")

    @custom_keys.setter
    def custom_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRateBasedStatementCustomKeyArgs']]]]):
        pulumi.set(self, "custom_keys", value)

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupForwardedIPConfigurationArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['RuleGroupStatementArgs']]:
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['RuleGroupStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)


@pulumi.input_type
class RuleGroupRateLimitCookieArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        """
        Specifies a cookie as an aggregate key for a rate-based rule.
        :param pulumi.Input[str] name: The name of the cookie to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the cookie to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRateLimitForwardedIPArgs:
    def __init__(__self__):
        """
        Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.input_type
class RuleGroupRateLimitHTTPMethodArgs:
    def __init__(__self__):
        """
        Specifies the request's HTTP method as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.input_type
class RuleGroupRateLimitHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        """
        Specifies a header as an aggregate key for a rate-based rule.
        :param pulumi.Input[str] name: The name of the header to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRateLimitIPArgs:
    def __init__(__self__):
        """
        Specifies the IP address in the web request as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.input_type
class RuleGroupRateLimitLabelNamespaceArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[str]):
        """
        Specifies a label namespace to use as an aggregate key for a rate-based rule.
        :param pulumi.Input[str] namespace: The namespace to use for aggregation.
        """
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        The namespace to use for aggregation.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class RuleGroupRateLimitQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        """
        Specifies a query argument in the request as an aggregate key for a rate-based rule.
        :param pulumi.Input[str] name: The name of the query argument to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query argument to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRateLimitQueryStringArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        """
        Specifies the request's query string as an aggregate key for a rate-based rule.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRateLimitUriPathArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        """
        Specifies the request's URI Path as an aggregate key for a rate-based rule.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRegexMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['RuleGroupAllowActionArgs']] = None,
                 block: Optional[pulumi.Input['RuleGroupBlockActionArgs']] = None,
                 captcha: Optional[pulumi.Input['RuleGroupCaptchaActionArgs']] = None,
                 challenge: Optional[pulumi.Input['RuleGroupChallengeActionArgs']] = None,
                 count: Optional[pulumi.Input['RuleGroupCountActionArgs']] = None):
        """
        Action taken when Rule matches its condition.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['RuleGroupAllowActionArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['RuleGroupAllowActionArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['RuleGroupBlockActionArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['RuleGroupBlockActionArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['RuleGroupCaptchaActionArgs']]:
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['RuleGroupCaptchaActionArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['RuleGroupChallengeActionArgs']]:
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['RuleGroupChallengeActionArgs']]):
        pulumi.set(self, "challenge", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['RuleGroupCountActionArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['RuleGroupCountActionArgs']]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class RuleGroupRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 statement: pulumi.Input['RuleGroupStatementArgs'],
                 visibility_config: pulumi.Input['RuleGroupVisibilityConfigArgs'],
                 action: Optional[pulumi.Input['RuleGroupRuleActionArgs']] = None,
                 captcha_config: Optional[pulumi.Input['RuleGroupCaptchaConfigArgs']] = None,
                 challenge_config: Optional[pulumi.Input['RuleGroupChallengeConfigArgs']] = None,
                 rule_labels: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupLabelArgs']]]] = None):
        """
        Rule of RuleGroup that contains condition and action.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupLabelArgs']]] rule_labels: Collection of Rule Labels.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if challenge_config is not None:
            pulumi.set(__self__, "challenge_config", challenge_config)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['RuleGroupStatementArgs']:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['RuleGroupStatementArgs']):
        pulumi.set(self, "statement", value)

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> pulumi.Input['RuleGroupVisibilityConfigArgs']:
        return pulumi.get(self, "visibility_config")

    @visibility_config.setter
    def visibility_config(self, value: pulumi.Input['RuleGroupVisibilityConfigArgs']):
        pulumi.set(self, "visibility_config", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['RuleGroupRuleActionArgs']]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['RuleGroupRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional[pulumi.Input['RuleGroupCaptchaConfigArgs']]:
        return pulumi.get(self, "captcha_config")

    @captcha_config.setter
    def captcha_config(self, value: Optional[pulumi.Input['RuleGroupCaptchaConfigArgs']]):
        pulumi.set(self, "captcha_config", value)

    @property
    @pulumi.getter(name="challengeConfig")
    def challenge_config(self) -> Optional[pulumi.Input['RuleGroupChallengeConfigArgs']]:
        return pulumi.get(self, "challenge_config")

    @challenge_config.setter
    def challenge_config(self, value: Optional[pulumi.Input['RuleGroupChallengeConfigArgs']]):
        pulumi.set(self, "challenge_config", value)

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupLabelArgs']]]]:
        """
        Collection of Rule Labels.
        """
        return pulumi.get(self, "rule_labels")

    @rule_labels.setter
    def rule_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupLabelArgs']]]]):
        pulumi.set(self, "rule_labels", value)


@pulumi.input_type
class RuleGroupSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input['RuleGroupSizeConstraintStatementComparisonOperator'],
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 size: pulumi.Input[float],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        """
        Size Constraint statement.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input['RuleGroupSizeConstraintStatementComparisonOperator']:
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input['RuleGroupSizeConstraintStatementComparisonOperator']):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[float]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[float]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupSqliMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]],
                 sensitivity_level: Optional[pulumi.Input['RuleGroupSensitivityLevel']] = None):
        """
        Sqli Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input['RuleGroupSensitivityLevel']]:
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input['RuleGroupSensitivityLevel']]):
        pulumi.set(self, "sensitivity_level", value)


@pulumi.input_type
class RuleGroupStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['RuleGroupAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['RuleGroupByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['RuleGroupGeoMatchStatementArgs']] = None,
                 i_p_set_reference_statement: Optional[pulumi.Input['RuleGroupIPSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['RuleGroupLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['RuleGroupNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['RuleGroupOrStatementArgs']] = None,
                 rate_based_statement: Optional[pulumi.Input['RuleGroupRateBasedStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['RuleGroupRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['RuleGroupRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['RuleGroupSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['RuleGroupSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['RuleGroupXssMatchStatementArgs']] = None):
        """
        First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if i_p_set_reference_statement is not None:
            pulumi.set(__self__, "i_p_set_reference_statement", i_p_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['RuleGroupAndStatementArgs']]:
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['RuleGroupAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['RuleGroupByteMatchStatementArgs']]:
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['RuleGroupByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['RuleGroupGeoMatchStatementArgs']]:
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['RuleGroupGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="iPSetReferenceStatement")
    def i_p_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupIPSetReferenceStatementArgs']]:
        return pulumi.get(self, "i_p_set_reference_statement")

    @i_p_set_reference_statement.setter
    def i_p_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupIPSetReferenceStatementArgs']]):
        pulumi.set(self, "i_p_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['RuleGroupLabelMatchStatementArgs']]:
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['RuleGroupLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['RuleGroupNotStatementArgs']]:
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['RuleGroupNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['RuleGroupOrStatementArgs']]:
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['RuleGroupOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional[pulumi.Input['RuleGroupRateBasedStatementArgs']]:
        return pulumi.get(self, "rate_based_statement")

    @rate_based_statement.setter
    def rate_based_statement(self, value: Optional[pulumi.Input['RuleGroupRateBasedStatementArgs']]):
        pulumi.set(self, "rate_based_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['RuleGroupRegexMatchStatementArgs']]:
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['RuleGroupRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRegexPatternSetReferenceStatementArgs']]:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['RuleGroupSizeConstraintStatementArgs']]:
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['RuleGroupSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['RuleGroupSqliMatchStatementArgs']]:
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['RuleGroupSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['RuleGroupXssMatchStatementArgs']]:
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['RuleGroupXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


@pulumi.input_type
class RuleGroupTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input['RuleGroupTextTransformationType']):
        """
        Text Transformation on the Search String before match.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['RuleGroupTextTransformationType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['RuleGroupTextTransformationType']):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloud_watch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        Visibility Metric of the RuleGroup.
        """
        pulumi.set(__self__, "cloud_watch_metrics_enabled", cloud_watch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudWatchMetricsEnabled")
    def cloud_watch_metrics_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "cloud_watch_metrics_enabled")

    @cloud_watch_metrics_enabled.setter
    def cloud_watch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloud_watch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


@pulumi.input_type
class RuleGroupXssMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['RuleGroupFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        """
        Xss Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['RuleGroupFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['RuleGroupFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLAWSManagedRulesATPRuleSetArgs:
    def __init__(__self__, *,
                 login_path: pulumi.Input[str],
                 request_inspection: Optional[pulumi.Input['WebACLRequestInspectionArgs']] = None,
                 response_inspection: Optional[pulumi.Input['WebACLResponseInspectionArgs']] = None):
        """
        Configures how to use the Account Takeover Prevention managed rule group in the web ACL
        """
        pulumi.set(__self__, "login_path", login_path)
        if request_inspection is not None:
            pulumi.set(__self__, "request_inspection", request_inspection)
        if response_inspection is not None:
            pulumi.set(__self__, "response_inspection", response_inspection)

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "login_path")

    @login_path.setter
    def login_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "login_path", value)

    @property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> Optional[pulumi.Input['WebACLRequestInspectionArgs']]:
        return pulumi.get(self, "request_inspection")

    @request_inspection.setter
    def request_inspection(self, value: Optional[pulumi.Input['WebACLRequestInspectionArgs']]):
        pulumi.set(self, "request_inspection", value)

    @property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional[pulumi.Input['WebACLResponseInspectionArgs']]:
        return pulumi.get(self, "response_inspection")

    @response_inspection.setter
    def response_inspection(self, value: Optional[pulumi.Input['WebACLResponseInspectionArgs']]):
        pulumi.set(self, "response_inspection", value)


@pulumi.input_type
class WebACLAWSManagedRulesBotControlRuleSetArgs:
    def __init__(__self__, *,
                 inspection_level: pulumi.Input['WebACLAWSManagedRulesBotControlRuleSetInspectionLevel']):
        """
        Configures how to use the Bot Control managed rule group in the web ACL
        """
        pulumi.set(__self__, "inspection_level", inspection_level)

    @property
    @pulumi.getter(name="inspectionLevel")
    def inspection_level(self) -> pulumi.Input['WebACLAWSManagedRulesBotControlRuleSetInspectionLevel']:
        return pulumi.get(self, "inspection_level")

    @inspection_level.setter
    def inspection_level(self, value: pulumi.Input['WebACLAWSManagedRulesBotControlRuleSetInspectionLevel']):
        pulumi.set(self, "inspection_level", value)


@pulumi.input_type
class WebACLAllowActionArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebACLAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebACLAssociationConfigArgs:
    def __init__(__self__, *,
                 request_body: Optional[pulumi.Input['WebACLRequestBodyArgs']] = None):
        """
        AssociationConfig for body inspection
        """
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)

    @property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional[pulumi.Input['WebACLRequestBodyArgs']]:
        return pulumi.get(self, "request_body")

    @request_body.setter
    def request_body(self, value: Optional[pulumi.Input['WebACLRequestBodyArgs']]):
        pulumi.set(self, "request_body", value)


@pulumi.input_type
class WebACLBlockActionArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebACLCustomResponseArgs']] = None):
        """
        Block traffic towards application.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebACLCustomResponseArgs']]:
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebACLCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


@pulumi.input_type
class WebACLBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input['WebACLOversizeHandling']] = None):
        """
        The body of a web request. This immediately follows the request headers.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input['WebACLOversizeHandling']]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input['WebACLOversizeHandling']]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebACLByteMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 positional_constraint: pulumi.Input['WebACLPositionalConstraint'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]],
                 search_string: Optional[pulumi.Input[str]] = None,
                 search_string_base64: Optional[pulumi.Input[str]] = None):
        """
        Byte Match statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if search_string is not None:
            pulumi.set(__self__, "search_string", search_string)
        if search_string_base64 is not None:
            pulumi.set(__self__, "search_string_base64", search_string_base64)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input['WebACLPositionalConstraint']:
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input['WebACLPositionalConstraint']):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="searchStringBase64")
    def search_string_base64(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_string_base64")

    @search_string_base64.setter
    def search_string_base64(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_string_base64", value)


@pulumi.input_type
class WebACLCaptchaActionArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']] = None):
        """
        Checks valid token exists with request.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebACLCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebACLImmunityTimePropertyArgs']] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebACLImmunityTimePropertyArgs']]:
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebACLImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


@pulumi.input_type
class WebACLChallengeActionArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']] = None):
        """
        Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebACLChallengeConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebACLImmunityTimePropertyArgs']] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebACLImmunityTimePropertyArgs']]:
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebACLImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


@pulumi.input_type
class WebACLCookieMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The pattern to look for in the request cookies.
        :param Any all: Inspect all parts of the web request cookies.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request cookies.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[Any]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebACLCookiesArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebACLCookieMatchPatternArgs'],
                 match_scope: pulumi.Input['WebACLMapMatchScope'],
                 oversize_handling: pulumi.Input['WebACLOversizeHandling']):
        """
        Includes headers of a web request.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebACLCookieMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebACLCookieMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input['WebACLMapMatchScope']:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input['WebACLMapMatchScope']):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input['WebACLOversizeHandling']:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input['WebACLOversizeHandling']):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebACLCountActionArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebACLCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebACLCustomHTTPHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebACLCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]):
        """
        Custom request handling.
        :param pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]] insert_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebACLCustomResponseBodiesArgs:
    def __init__(__self__):
        """
        Custom response key and body map.
        """
        pass


@pulumi.input_type
class WebACLCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]] = None):
        """
        Custom response.
        :param pulumi.Input[str] custom_response_body_key: Custom response body key.
        :param pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]] response_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        Custom response body key.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLCustomHTTPHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


@pulumi.input_type
class WebACLDefaultActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebACLAllowActionArgs']] = None,
                 block: Optional[pulumi.Input['WebACLBlockActionArgs']] = None):
        """
        Default Action WebACL will take against ingress traffic when there is no matching Rule.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebACLAllowActionArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebACLAllowActionArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebACLBlockActionArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebACLBlockActionArgs']]):
        pulumi.set(self, "block", value)


@pulumi.input_type
class WebACLExcludedRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebACLFieldIdentifierArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


@pulumi.input_type
class WebACLFieldToMatchSingleHeaderPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebACLFieldToMatchSingleQueryArgumentPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebACLFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[Any] = None,
                 body: Optional[pulumi.Input['WebACLBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebACLCookiesArgs']] = None,
                 headers: Optional[pulumi.Input['WebACLHeadersArgs']] = None,
                 json_body: Optional[pulumi.Input['WebACLJsonBodyArgs']] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional[pulumi.Input['WebACLFieldToMatchSingleHeaderPropertiesArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebACLFieldToMatchSingleQueryArgumentPropertiesArgs']] = None,
                 uri_path: Optional[Any] = None):
        """
        Field of the request to match.
        :param Any all_query_arguments: All query arguments of a web request.
        :param Any method: The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        :param Any query_string: The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        :param pulumi.Input['WebACLFieldToMatchSingleQueryArgumentPropertiesArgs'] single_query_argument: One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        :param Any uri_path: The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[Any]:
        """
        All query arguments of a web request.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[Any]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebACLBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebACLBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebACLCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebACLCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['WebACLHeadersArgs']]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['WebACLHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebACLJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebACLJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[Any]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[Any]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebACLFieldToMatchSingleHeaderPropertiesArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebACLFieldToMatchSingleHeaderPropertiesArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebACLFieldToMatchSingleQueryArgumentPropertiesArgs']]:
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebACLFieldToMatchSingleQueryArgumentPropertiesArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[Any]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebACLForwardedIPConfigurationArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input['WebACLForwardedIPConfigurationFallbackBehavior'],
                 header_name: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input['WebACLForwardedIPConfigurationFallbackBehavior']:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input['WebACLForwardedIPConfigurationFallbackBehavior']):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


@pulumi.input_type
class WebACLGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']] = None):
        if country_codes is not None:
            pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


@pulumi.input_type
class WebACLHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The pattern to look for in the request headers.
        :param Any all: Inspect all parts of the web request headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[Any]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebACLHeadersArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebACLHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input['WebACLMapMatchScope'],
                 oversize_handling: pulumi.Input['WebACLOversizeHandling']):
        """
        Includes headers of a web request.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebACLHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebACLHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input['WebACLMapMatchScope']:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input['WebACLMapMatchScope']):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input['WebACLOversizeHandling']:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input['WebACLOversizeHandling']):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebACLIPSetForwardedIPConfigurationArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input['WebACLIPSetForwardedIPConfigurationFallbackBehavior'],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input['WebACLIPSetForwardedIPConfigurationPosition']):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input['WebACLIPSetForwardedIPConfigurationFallbackBehavior']:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input['WebACLIPSetForwardedIPConfigurationFallbackBehavior']):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input['WebACLIPSetForwardedIPConfigurationPosition']:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input['WebACLIPSetForwardedIPConfigurationPosition']):
        pulumi.set(self, "position", value)


@pulumi.input_type
class WebACLIPSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 i_p_set_forwarded_ip_config: Optional[pulumi.Input['WebACLIPSetForwardedIPConfigurationArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        if i_p_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "i_p_set_forwarded_ip_config", i_p_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="iPSetForwardedIPConfig")
    def i_p_set_forwarded_ip_config(self) -> Optional[pulumi.Input['WebACLIPSetForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "i_p_set_forwarded_ip_config")

    @i_p_set_forwarded_ip_config.setter
    def i_p_set_forwarded_ip_config(self, value: Optional[pulumi.Input['WebACLIPSetForwardedIPConfigurationArgs']]):
        pulumi.set(self, "i_p_set_forwarded_ip_config", value)


@pulumi.input_type
class WebACLImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: pulumi.Input[int]):
        pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> pulumi.Input[int]:
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: pulumi.Input[int]):
        pulumi.set(self, "immunity_time", value)


@pulumi.input_type
class WebACLJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebACLJsonMatchPatternArgs'],
                 match_scope: pulumi.Input['WebACLJsonMatchScope'],
                 invalid_fallback_behavior: Optional[pulumi.Input['WebACLBodyParsingFallbackBehavior']] = None,
                 oversize_handling: Optional[pulumi.Input['WebACLOversizeHandling']] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebACLJsonMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebACLJsonMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input['WebACLJsonMatchScope']:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input['WebACLJsonMatchScope']):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input['WebACLBodyParsingFallbackBehavior']]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input['WebACLBodyParsingFallbackBehavior']]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input['WebACLOversizeHandling']]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input['WebACLOversizeHandling']]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebACLJsonMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The pattern to look for in the JSON body.
        :param Any all: Inspect all parts of the web request's JSON body.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request's JSON body.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[Any]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebACLLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input['WebACLLabelMatchScope']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input['WebACLLabelMatchScope']:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input['WebACLLabelMatchScope']):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class WebACLLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebACLManagedRuleGroupConfigArgs:
    def __init__(__self__, *,
                 a_ws_managed_rules_atp_rule_set: Optional[pulumi.Input['WebACLAWSManagedRulesATPRuleSetArgs']] = None,
                 a_ws_managed_rules_bot_control_rule_set: Optional[pulumi.Input['WebACLAWSManagedRulesBotControlRuleSetArgs']] = None,
                 login_path: Optional[pulumi.Input[str]] = None,
                 password_field: Optional[pulumi.Input['WebACLFieldIdentifierArgs']] = None,
                 payload_type: Optional[pulumi.Input['WebACLManagedRuleGroupConfigPayloadType']] = None,
                 username_field: Optional[pulumi.Input['WebACLFieldIdentifierArgs']] = None):
        """
        ManagedRuleGroupConfig.
        """
        if a_ws_managed_rules_atp_rule_set is not None:
            pulumi.set(__self__, "a_ws_managed_rules_atp_rule_set", a_ws_managed_rules_atp_rule_set)
        if a_ws_managed_rules_bot_control_rule_set is not None:
            pulumi.set(__self__, "a_ws_managed_rules_bot_control_rule_set", a_ws_managed_rules_bot_control_rule_set)
        if login_path is not None:
            pulumi.set(__self__, "login_path", login_path)
        if password_field is not None:
            pulumi.set(__self__, "password_field", password_field)
        if payload_type is not None:
            pulumi.set(__self__, "payload_type", payload_type)
        if username_field is not None:
            pulumi.set(__self__, "username_field", username_field)

    @property
    @pulumi.getter(name="aWSManagedRulesATPRuleSet")
    def a_ws_managed_rules_atp_rule_set(self) -> Optional[pulumi.Input['WebACLAWSManagedRulesATPRuleSetArgs']]:
        return pulumi.get(self, "a_ws_managed_rules_atp_rule_set")

    @a_ws_managed_rules_atp_rule_set.setter
    def a_ws_managed_rules_atp_rule_set(self, value: Optional[pulumi.Input['WebACLAWSManagedRulesATPRuleSetArgs']]):
        pulumi.set(self, "a_ws_managed_rules_atp_rule_set", value)

    @property
    @pulumi.getter(name="aWSManagedRulesBotControlRuleSet")
    def a_ws_managed_rules_bot_control_rule_set(self) -> Optional[pulumi.Input['WebACLAWSManagedRulesBotControlRuleSetArgs']]:
        return pulumi.get(self, "a_ws_managed_rules_bot_control_rule_set")

    @a_ws_managed_rules_bot_control_rule_set.setter
    def a_ws_managed_rules_bot_control_rule_set(self, value: Optional[pulumi.Input['WebACLAWSManagedRulesBotControlRuleSetArgs']]):
        pulumi.set(self, "a_ws_managed_rules_bot_control_rule_set", value)

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "login_path")

    @login_path.setter
    def login_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_path", value)

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional[pulumi.Input['WebACLFieldIdentifierArgs']]:
        return pulumi.get(self, "password_field")

    @password_field.setter
    def password_field(self, value: Optional[pulumi.Input['WebACLFieldIdentifierArgs']]):
        pulumi.set(self, "password_field", value)

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> Optional[pulumi.Input['WebACLManagedRuleGroupConfigPayloadType']]:
        return pulumi.get(self, "payload_type")

    @payload_type.setter
    def payload_type(self, value: Optional[pulumi.Input['WebACLManagedRuleGroupConfigPayloadType']]):
        pulumi.set(self, "payload_type", value)

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional[pulumi.Input['WebACLFieldIdentifierArgs']]:
        return pulumi.get(self, "username_field")

    @username_field.setter
    def username_field(self, value: Optional[pulumi.Input['WebACLFieldIdentifierArgs']]):
        pulumi.set(self, "username_field", value)


@pulumi.input_type
class WebACLManagedRuleGroupStatementArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 vendor_name: pulumi.Input[str],
                 excluded_rules: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]] = None,
                 managed_rule_group_configs: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLManagedRuleGroupConfigArgs']]]] = None,
                 rule_action_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLRuleActionOverrideArgs']]]] = None,
                 scope_down_statement: Optional[pulumi.Input['WebACLStatementArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebACLManagedRuleGroupConfigArgs']]] managed_rule_group_configs: Collection of ManagedRuleGroupConfig.
        :param pulumi.Input[Sequence[pulumi.Input['WebACLRuleActionOverrideArgs']]] rule_action_overrides: Action overrides for rules in the rule group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vendor_name", vendor_name)
        if excluded_rules is not None:
            pulumi.set(__self__, "excluded_rules", excluded_rules)
        if managed_rule_group_configs is not None:
            pulumi.set(__self__, "managed_rule_group_configs", managed_rule_group_configs)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "vendor_name")

    @vendor_name.setter
    def vendor_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vendor_name", value)

    @property
    @pulumi.getter(name="excludedRules")
    def excluded_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]]:
        return pulumi.get(self, "excluded_rules")

    @excluded_rules.setter
    def excluded_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]]):
        pulumi.set(self, "excluded_rules", value)

    @property
    @pulumi.getter(name="managedRuleGroupConfigs")
    def managed_rule_group_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLManagedRuleGroupConfigArgs']]]]:
        """
        Collection of ManagedRuleGroupConfig.
        """
        return pulumi.get(self, "managed_rule_group_configs")

    @managed_rule_group_configs.setter
    def managed_rule_group_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLManagedRuleGroupConfigArgs']]]]):
        pulumi.set(self, "managed_rule_group_configs", value)

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLRuleActionOverrideArgs']]]]:
        """
        Action overrides for rules in the rule group.
        """
        return pulumi.get(self, "rule_action_overrides")

    @rule_action_overrides.setter
    def rule_action_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLRuleActionOverrideArgs']]]]):
        pulumi.set(self, "rule_action_overrides", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['WebACLStatementArgs']]:
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['WebACLStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class WebACLNotStatementArgs:
    def __init__(__self__, *,
                 statement: pulumi.Input['WebACLStatementArgs']):
        pulumi.set(__self__, "statement", statement)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['WebACLStatementArgs']:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['WebACLStatementArgs']):
        pulumi.set(self, "statement", value)


@pulumi.input_type
class WebACLOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebACLOverrideActionArgs:
    def __init__(__self__, *,
                 count: Optional[Any] = None,
                 none: Optional[Any] = None):
        """
        Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
        :param Any count: Count traffic towards application.
        :param Any none: Keep the RuleGroup or ManagedRuleGroup behavior as is.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @property
    @pulumi.getter
    def count(self) -> Optional[Any]:
        """
        Count traffic towards application.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[Any]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def none(self) -> Optional[Any]:
        """
        Keep the RuleGroup or ManagedRuleGroup behavior as is.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[Any]):
        pulumi.set(self, "none", value)


@pulumi.input_type
class WebACLRateBasedStatementCustomKeyArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['WebACLRateLimitCookieArgs']] = None,
                 forwarded_ip: Optional[pulumi.Input['WebACLRateLimitForwardedIPArgs']] = None,
                 h_ttp_method: Optional[pulumi.Input['WebACLRateLimitHTTPMethodArgs']] = None,
                 header: Optional[pulumi.Input['WebACLRateLimitHeaderArgs']] = None,
                 i_p: Optional[pulumi.Input['WebACLRateLimitIPArgs']] = None,
                 label_namespace: Optional[pulumi.Input['WebACLRateLimitLabelNamespaceArgs']] = None,
                 query_argument: Optional[pulumi.Input['WebACLRateLimitQueryArgumentArgs']] = None,
                 query_string: Optional[pulumi.Input['WebACLRateLimitQueryStringArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebACLRateLimitUriPathArgs']] = None):
        """
        Specifies a single custom aggregate key for a rate-base rule.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if h_ttp_method is not None:
            pulumi.set(__self__, "h_ttp_method", h_ttp_method)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if i_p is not None:
            pulumi.set(__self__, "i_p", i_p)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['WebACLRateLimitCookieArgs']]:
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['WebACLRateLimitCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter(name="forwardedIP")
    def forwarded_ip(self) -> Optional[pulumi.Input['WebACLRateLimitForwardedIPArgs']]:
        return pulumi.get(self, "forwarded_ip")

    @forwarded_ip.setter
    def forwarded_ip(self, value: Optional[pulumi.Input['WebACLRateLimitForwardedIPArgs']]):
        pulumi.set(self, "forwarded_ip", value)

    @property
    @pulumi.getter(name="hTTPMethod")
    def h_ttp_method(self) -> Optional[pulumi.Input['WebACLRateLimitHTTPMethodArgs']]:
        return pulumi.get(self, "h_ttp_method")

    @h_ttp_method.setter
    def h_ttp_method(self, value: Optional[pulumi.Input['WebACLRateLimitHTTPMethodArgs']]):
        pulumi.set(self, "h_ttp_method", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WebACLRateLimitHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WebACLRateLimitHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="iP")
    def i_p(self) -> Optional[pulumi.Input['WebACLRateLimitIPArgs']]:
        return pulumi.get(self, "i_p")

    @i_p.setter
    def i_p(self, value: Optional[pulumi.Input['WebACLRateLimitIPArgs']]):
        pulumi.set(self, "i_p", value)

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional[pulumi.Input['WebACLRateLimitLabelNamespaceArgs']]:
        return pulumi.get(self, "label_namespace")

    @label_namespace.setter
    def label_namespace(self, value: Optional[pulumi.Input['WebACLRateLimitLabelNamespaceArgs']]):
        pulumi.set(self, "label_namespace", value)

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional[pulumi.Input['WebACLRateLimitQueryArgumentArgs']]:
        return pulumi.get(self, "query_argument")

    @query_argument.setter
    def query_argument(self, value: Optional[pulumi.Input['WebACLRateLimitQueryArgumentArgs']]):
        pulumi.set(self, "query_argument", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebACLRateLimitQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebACLRateLimitQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebACLRateLimitUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebACLRateLimitUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebACLRateBasedStatementArgs:
    def __init__(__self__, *,
                 aggregate_key_type: pulumi.Input['WebACLRateBasedStatementAggregateKeyType'],
                 limit: pulumi.Input[int],
                 custom_keys: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLRateBasedStatementCustomKeyArgs']]]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']] = None,
                 scope_down_statement: Optional[pulumi.Input['WebACLStatementArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebACLRateBasedStatementCustomKeyArgs']]] custom_keys: Specifies the aggregate keys to use in a rate-base rule.
        """
        pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        pulumi.set(__self__, "limit", limit)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> pulumi.Input['WebACLRateBasedStatementAggregateKeyType']:
        return pulumi.get(self, "aggregate_key_type")

    @aggregate_key_type.setter
    def aggregate_key_type(self, value: pulumi.Input['WebACLRateBasedStatementAggregateKeyType']):
        pulumi.set(self, "aggregate_key_type", value)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLRateBasedStatementCustomKeyArgs']]]]:
        """
        Specifies the aggregate keys to use in a rate-base rule.
        """
        return pulumi.get(self, "custom_keys")

    @custom_keys.setter
    def custom_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLRateBasedStatementCustomKeyArgs']]]]):
        pulumi.set(self, "custom_keys", value)

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebACLForwardedIPConfigurationArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['WebACLStatementArgs']]:
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['WebACLStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)


@pulumi.input_type
class WebACLRateLimitCookieArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        """
        Specifies a cookie as an aggregate key for a rate-based rule.
        :param pulumi.Input[str] name: The name of the cookie to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the cookie to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLRateLimitForwardedIPArgs:
    def __init__(__self__):
        """
        Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.input_type
class WebACLRateLimitHTTPMethodArgs:
    def __init__(__self__):
        """
        Specifies the request's HTTP method as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.input_type
class WebACLRateLimitHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        """
        Specifies a header as an aggregate key for a rate-based rule.
        :param pulumi.Input[str] name: The name of the header to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLRateLimitIPArgs:
    def __init__(__self__):
        """
        Specifies the IP address in the web request as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.input_type
class WebACLRateLimitLabelNamespaceArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[str]):
        """
        Specifies a label namespace to use as an aggregate key for a rate-based rule.
        :param pulumi.Input[str] namespace: The namespace to use for aggregation.
        """
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        The namespace to use for aggregation.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class WebACLRateLimitQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        """
        Specifies a query argument in the request as an aggregate key for a rate-based rule.
        :param pulumi.Input[str] name: The name of the query argument to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query argument to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLRateLimitQueryStringArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        """
        Specifies the request's query string as an aggregate key for a rate-based rule.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLRateLimitUriPathArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        """
        Specifies the request's URI Path as an aggregate key for a rate-based rule.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLRegexMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLRequestBodyArgs:
    def __init__(__self__):
        """
        Map of AssociatedResourceType and RequestBodyAssociatedResourceTypeConfig
        """
        pass


@pulumi.input_type
class WebACLRequestInspectionArgs:
    def __init__(__self__, *,
                 password_field: pulumi.Input['WebACLFieldIdentifierArgs'],
                 payload_type: pulumi.Input['WebACLRequestInspectionPayloadType'],
                 username_field: pulumi.Input['WebACLFieldIdentifierArgs']):
        """
        Configures the inspection of login requests
        """
        pulumi.set(__self__, "password_field", password_field)
        pulumi.set(__self__, "payload_type", payload_type)
        pulumi.set(__self__, "username_field", username_field)

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> pulumi.Input['WebACLFieldIdentifierArgs']:
        return pulumi.get(self, "password_field")

    @password_field.setter
    def password_field(self, value: pulumi.Input['WebACLFieldIdentifierArgs']):
        pulumi.set(self, "password_field", value)

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> pulumi.Input['WebACLRequestInspectionPayloadType']:
        return pulumi.get(self, "payload_type")

    @payload_type.setter
    def payload_type(self, value: pulumi.Input['WebACLRequestInspectionPayloadType']):
        pulumi.set(self, "payload_type", value)

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> pulumi.Input['WebACLFieldIdentifierArgs']:
        return pulumi.get(self, "username_field")

    @username_field.setter
    def username_field(self, value: pulumi.Input['WebACLFieldIdentifierArgs']):
        pulumi.set(self, "username_field", value)


@pulumi.input_type
class WebACLResponseInspectionBodyContainsArgs:
    def __init__(__self__, *,
                 failure_strings: pulumi.Input[Sequence[pulumi.Input[str]]],
                 success_strings: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Response body contents that indicate success or failure of a login request
        """
        pulumi.set(__self__, "failure_strings", failure_strings)
        pulumi.set(__self__, "success_strings", success_strings)

    @property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "failure_strings")

    @failure_strings.setter
    def failure_strings(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_strings", value)

    @property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "success_strings")

    @success_strings.setter
    def success_strings(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_strings", value)


@pulumi.input_type
class WebACLResponseInspectionHeaderArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Response headers that indicate success or failure of a login request
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_values", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_values", value)


@pulumi.input_type
class WebACLResponseInspectionJsonArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identifier: pulumi.Input[str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Response JSON that indicate success or failure of a login request
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_values", value)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_values", value)


@pulumi.input_type
class WebACLResponseInspectionStatusCodeArgs:
    def __init__(__self__, *,
                 failure_codes: pulumi.Input[Sequence[pulumi.Input[int]]],
                 success_codes: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        Response status codes that indicate success or failure of a login request
        """
        pulumi.set(__self__, "failure_codes", failure_codes)
        pulumi.set(__self__, "success_codes", success_codes)

    @property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        return pulumi.get(self, "failure_codes")

    @failure_codes.setter
    def failure_codes(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "failure_codes", value)

    @property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        return pulumi.get(self, "success_codes")

    @success_codes.setter
    def success_codes(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "success_codes", value)


@pulumi.input_type
class WebACLResponseInspectionArgs:
    def __init__(__self__, *,
                 body_contains: Optional[pulumi.Input['WebACLResponseInspectionBodyContainsArgs']] = None,
                 header: Optional[pulumi.Input['WebACLResponseInspectionHeaderArgs']] = None,
                 json: Optional[pulumi.Input['WebACLResponseInspectionJsonArgs']] = None,
                 status_code: Optional[pulumi.Input['WebACLResponseInspectionStatusCodeArgs']] = None):
        """
        Configures the inspection of login responses
        """
        if body_contains is not None:
            pulumi.set(__self__, "body_contains", body_contains)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional[pulumi.Input['WebACLResponseInspectionBodyContainsArgs']]:
        return pulumi.get(self, "body_contains")

    @body_contains.setter
    def body_contains(self, value: Optional[pulumi.Input['WebACLResponseInspectionBodyContainsArgs']]):
        pulumi.set(self, "body_contains", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WebACLResponseInspectionHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WebACLResponseInspectionHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['WebACLResponseInspectionJsonArgs']]:
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['WebACLResponseInspectionJsonArgs']]):
        pulumi.set(self, "json", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input['WebACLResponseInspectionStatusCodeArgs']]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input['WebACLResponseInspectionStatusCodeArgs']]):
        pulumi.set(self, "status_code", value)


@pulumi.input_type
class WebACLRuleActionOverrideArgs:
    def __init__(__self__, *,
                 action_to_use: pulumi.Input['WebACLRuleActionArgs'],
                 name: pulumi.Input[str]):
        """
        Action override for rules in the rule group.
        """
        pulumi.set(__self__, "action_to_use", action_to_use)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> pulumi.Input['WebACLRuleActionArgs']:
        return pulumi.get(self, "action_to_use")

    @action_to_use.setter
    def action_to_use(self, value: pulumi.Input['WebACLRuleActionArgs']):
        pulumi.set(self, "action_to_use", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebACLRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebACLAllowActionArgs']] = None,
                 block: Optional[pulumi.Input['WebACLBlockActionArgs']] = None,
                 captcha: Optional[pulumi.Input['WebACLCaptchaActionArgs']] = None,
                 challenge: Optional[pulumi.Input['WebACLChallengeActionArgs']] = None,
                 count: Optional[pulumi.Input['WebACLCountActionArgs']] = None):
        """
        Action taken when Rule matches its condition.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebACLAllowActionArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebACLAllowActionArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebACLBlockActionArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebACLBlockActionArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebACLCaptchaActionArgs']]:
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebACLCaptchaActionArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebACLChallengeActionArgs']]:
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebACLChallengeActionArgs']]):
        pulumi.set(self, "challenge", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebACLCountActionArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebACLCountActionArgs']]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class WebACLRuleGroupReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 excluded_rules: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]] = None,
                 rule_action_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLRuleActionOverrideArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebACLRuleActionOverrideArgs']]] rule_action_overrides: Action overrides for rules in the rule group.
        """
        pulumi.set(__self__, "arn", arn)
        if excluded_rules is not None:
            pulumi.set(__self__, "excluded_rules", excluded_rules)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="excludedRules")
    def excluded_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]]:
        return pulumi.get(self, "excluded_rules")

    @excluded_rules.setter
    def excluded_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLExcludedRuleArgs']]]]):
        pulumi.set(self, "excluded_rules", value)

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLRuleActionOverrideArgs']]]]:
        """
        Action overrides for rules in the rule group.
        """
        return pulumi.get(self, "rule_action_overrides")

    @rule_action_overrides.setter
    def rule_action_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLRuleActionOverrideArgs']]]]):
        pulumi.set(self, "rule_action_overrides", value)


@pulumi.input_type
class WebACLRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 statement: pulumi.Input['WebACLStatementArgs'],
                 visibility_config: pulumi.Input['WebACLVisibilityConfigArgs'],
                 action: Optional[pulumi.Input['WebACLRuleActionArgs']] = None,
                 captcha_config: Optional[pulumi.Input['WebACLCaptchaConfigArgs']] = None,
                 challenge_config: Optional[pulumi.Input['WebACLChallengeConfigArgs']] = None,
                 override_action: Optional[pulumi.Input['WebACLOverrideActionArgs']] = None,
                 rule_labels: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLLabelArgs']]]] = None):
        """
        Rule of WebACL that contains condition and action.
        :param pulumi.Input[Sequence[pulumi.Input['WebACLLabelArgs']]] rule_labels: Collection of Rule Labels.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if challenge_config is not None:
            pulumi.set(__self__, "challenge_config", challenge_config)
        if override_action is not None:
            pulumi.set(__self__, "override_action", override_action)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['WebACLStatementArgs']:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['WebACLStatementArgs']):
        pulumi.set(self, "statement", value)

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> pulumi.Input['WebACLVisibilityConfigArgs']:
        return pulumi.get(self, "visibility_config")

    @visibility_config.setter
    def visibility_config(self, value: pulumi.Input['WebACLVisibilityConfigArgs']):
        pulumi.set(self, "visibility_config", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['WebACLRuleActionArgs']]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['WebACLRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional[pulumi.Input['WebACLCaptchaConfigArgs']]:
        return pulumi.get(self, "captcha_config")

    @captcha_config.setter
    def captcha_config(self, value: Optional[pulumi.Input['WebACLCaptchaConfigArgs']]):
        pulumi.set(self, "captcha_config", value)

    @property
    @pulumi.getter(name="challengeConfig")
    def challenge_config(self) -> Optional[pulumi.Input['WebACLChallengeConfigArgs']]:
        return pulumi.get(self, "challenge_config")

    @challenge_config.setter
    def challenge_config(self, value: Optional[pulumi.Input['WebACLChallengeConfigArgs']]):
        pulumi.set(self, "challenge_config", value)

    @property
    @pulumi.getter(name="overrideAction")
    def override_action(self) -> Optional[pulumi.Input['WebACLOverrideActionArgs']]:
        return pulumi.get(self, "override_action")

    @override_action.setter
    def override_action(self, value: Optional[pulumi.Input['WebACLOverrideActionArgs']]):
        pulumi.set(self, "override_action", value)

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebACLLabelArgs']]]]:
        """
        Collection of Rule Labels.
        """
        return pulumi.get(self, "rule_labels")

    @rule_labels.setter
    def rule_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebACLLabelArgs']]]]):
        pulumi.set(self, "rule_labels", value)


@pulumi.input_type
class WebACLSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input['WebACLSizeConstraintStatementComparisonOperator'],
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 size: pulumi.Input[float],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        """
        Size Constraint statement.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input['WebACLSizeConstraintStatementComparisonOperator']:
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input['WebACLSizeConstraintStatementComparisonOperator']):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[float]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[float]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebACLSqliMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]],
                 sensitivity_level: Optional[pulumi.Input['WebACLSensitivityLevel']] = None):
        """
        Sqli Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input['WebACLSensitivityLevel']]:
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input['WebACLSensitivityLevel']]):
        pulumi.set(self, "sensitivity_level", value)


@pulumi.input_type
class WebACLStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['WebACLAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['WebACLByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['WebACLGeoMatchStatementArgs']] = None,
                 i_p_set_reference_statement: Optional[pulumi.Input['WebACLIPSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['WebACLLabelMatchStatementArgs']] = None,
                 managed_rule_group_statement: Optional[pulumi.Input['WebACLManagedRuleGroupStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['WebACLNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['WebACLOrStatementArgs']] = None,
                 rate_based_statement: Optional[pulumi.Input['WebACLRateBasedStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['WebACLRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['WebACLRegexPatternSetReferenceStatementArgs']] = None,
                 rule_group_reference_statement: Optional[pulumi.Input['WebACLRuleGroupReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['WebACLSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['WebACLSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['WebACLXssMatchStatementArgs']] = None):
        """
        First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if i_p_set_reference_statement is not None:
            pulumi.set(__self__, "i_p_set_reference_statement", i_p_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if managed_rule_group_statement is not None:
            pulumi.set(__self__, "managed_rule_group_statement", managed_rule_group_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if rule_group_reference_statement is not None:
            pulumi.set(__self__, "rule_group_reference_statement", rule_group_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['WebACLAndStatementArgs']]:
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['WebACLAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['WebACLByteMatchStatementArgs']]:
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['WebACLByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['WebACLGeoMatchStatementArgs']]:
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['WebACLGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="iPSetReferenceStatement")
    def i_p_set_reference_statement(self) -> Optional[pulumi.Input['WebACLIPSetReferenceStatementArgs']]:
        return pulumi.get(self, "i_p_set_reference_statement")

    @i_p_set_reference_statement.setter
    def i_p_set_reference_statement(self, value: Optional[pulumi.Input['WebACLIPSetReferenceStatementArgs']]):
        pulumi.set(self, "i_p_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['WebACLLabelMatchStatementArgs']]:
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['WebACLLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="managedRuleGroupStatement")
    def managed_rule_group_statement(self) -> Optional[pulumi.Input['WebACLManagedRuleGroupStatementArgs']]:
        return pulumi.get(self, "managed_rule_group_statement")

    @managed_rule_group_statement.setter
    def managed_rule_group_statement(self, value: Optional[pulumi.Input['WebACLManagedRuleGroupStatementArgs']]):
        pulumi.set(self, "managed_rule_group_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['WebACLNotStatementArgs']]:
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['WebACLNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['WebACLOrStatementArgs']]:
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['WebACLOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional[pulumi.Input['WebACLRateBasedStatementArgs']]:
        return pulumi.get(self, "rate_based_statement")

    @rate_based_statement.setter
    def rate_based_statement(self, value: Optional[pulumi.Input['WebACLRateBasedStatementArgs']]):
        pulumi.set(self, "rate_based_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['WebACLRegexMatchStatementArgs']]:
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['WebACLRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['WebACLRegexPatternSetReferenceStatementArgs']]:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['WebACLRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="ruleGroupReferenceStatement")
    def rule_group_reference_statement(self) -> Optional[pulumi.Input['WebACLRuleGroupReferenceStatementArgs']]:
        return pulumi.get(self, "rule_group_reference_statement")

    @rule_group_reference_statement.setter
    def rule_group_reference_statement(self, value: Optional[pulumi.Input['WebACLRuleGroupReferenceStatementArgs']]):
        pulumi.set(self, "rule_group_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['WebACLSizeConstraintStatementArgs']]:
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['WebACLSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['WebACLSqliMatchStatementArgs']]:
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['WebACLSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['WebACLXssMatchStatementArgs']]:
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['WebACLXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


@pulumi.input_type
class WebACLTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebACLTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input['WebACLTextTransformationType']):
        """
        Text Transformation on the Search String before match.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['WebACLTextTransformationType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['WebACLTextTransformationType']):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebACLVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloud_watch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        Visibility Metric of the WebACL.
        """
        pulumi.set(__self__, "cloud_watch_metrics_enabled", cloud_watch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudWatchMetricsEnabled")
    def cloud_watch_metrics_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "cloud_watch_metrics_enabled")

    @cloud_watch_metrics_enabled.setter
    def cloud_watch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloud_watch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


@pulumi.input_type
class WebACLXssMatchStatementArgs:
    def __init__(__self__, *,
                 field_to_match: pulumi.Input['WebACLFieldToMatchArgs'],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        """
        Xss Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> pulumi.Input['WebACLFieldToMatchArgs']:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: pulumi.Input['WebACLFieldToMatchArgs']):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebACLTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


