# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'IPSetTag',
    'LoggingConfigurationCondition',
    'LoggingConfigurationConditionActionConditionProperties',
    'LoggingConfigurationConditionLabelNameConditionProperties',
    'LoggingConfigurationFieldToMatch',
    'LoggingConfigurationFieldToMatchJsonBodyProperties',
    'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties',
    'LoggingConfigurationFieldToMatchSingleHeaderProperties',
    'LoggingConfigurationFilter',
    'LoggingFilterProperties',
    'RegexPatternSetTag',
    'RuleGroupAllowAction',
    'RuleGroupAndStatement',
    'RuleGroupBlockAction',
    'RuleGroupBody',
    'RuleGroupByteMatchStatement',
    'RuleGroupCaptchaAction',
    'RuleGroupCaptchaConfig',
    'RuleGroupChallengeAction',
    'RuleGroupChallengeConfig',
    'RuleGroupCookieMatchPattern',
    'RuleGroupCookies',
    'RuleGroupCountAction',
    'RuleGroupCustomHTTPHeader',
    'RuleGroupCustomRequestHandling',
    'RuleGroupCustomResponse',
    'RuleGroupCustomResponseBodies',
    'RuleGroupFieldToMatch',
    'RuleGroupFieldToMatchSingleHeaderProperties',
    'RuleGroupFieldToMatchSingleQueryArgumentProperties',
    'RuleGroupForwardedIPConfiguration',
    'RuleGroupGeoMatchStatement',
    'RuleGroupHeaderMatchPattern',
    'RuleGroupHeaders',
    'RuleGroupIPSetForwardedIPConfiguration',
    'RuleGroupIPSetReferenceStatement',
    'RuleGroupImmunityTimeProperty',
    'RuleGroupJsonBody',
    'RuleGroupJsonMatchPattern',
    'RuleGroupLabel',
    'RuleGroupLabelMatchStatement',
    'RuleGroupLabelSummary',
    'RuleGroupNotStatement',
    'RuleGroupOrStatement',
    'RuleGroupRateBasedStatement',
    'RuleGroupRateBasedStatementCustomKey',
    'RuleGroupRateLimitCookie',
    'RuleGroupRateLimitForwardedIP',
    'RuleGroupRateLimitHTTPMethod',
    'RuleGroupRateLimitHeader',
    'RuleGroupRateLimitIP',
    'RuleGroupRateLimitLabelNamespace',
    'RuleGroupRateLimitQueryArgument',
    'RuleGroupRateLimitQueryString',
    'RuleGroupRateLimitUriPath',
    'RuleGroupRegexMatchStatement',
    'RuleGroupRegexPatternSetReferenceStatement',
    'RuleGroupRule',
    'RuleGroupRuleAction',
    'RuleGroupSizeConstraintStatement',
    'RuleGroupSqliMatchStatement',
    'RuleGroupStatement',
    'RuleGroupTag',
    'RuleGroupTextTransformation',
    'RuleGroupVisibilityConfig',
    'RuleGroupXssMatchStatement',
    'WebACLAWSManagedRulesATPRuleSet',
    'WebACLAWSManagedRulesBotControlRuleSet',
    'WebACLAllowAction',
    'WebACLAndStatement',
    'WebACLAssociationConfig',
    'WebACLBlockAction',
    'WebACLBody',
    'WebACLByteMatchStatement',
    'WebACLCaptchaAction',
    'WebACLCaptchaConfig',
    'WebACLChallengeAction',
    'WebACLChallengeConfig',
    'WebACLCookieMatchPattern',
    'WebACLCookies',
    'WebACLCountAction',
    'WebACLCustomHTTPHeader',
    'WebACLCustomRequestHandling',
    'WebACLCustomResponse',
    'WebACLCustomResponseBodies',
    'WebACLDefaultAction',
    'WebACLExcludedRule',
    'WebACLFieldIdentifier',
    'WebACLFieldToMatch',
    'WebACLFieldToMatchSingleHeaderProperties',
    'WebACLFieldToMatchSingleQueryArgumentProperties',
    'WebACLForwardedIPConfiguration',
    'WebACLGeoMatchStatement',
    'WebACLHeaderMatchPattern',
    'WebACLHeaders',
    'WebACLIPSetForwardedIPConfiguration',
    'WebACLIPSetReferenceStatement',
    'WebACLImmunityTimeProperty',
    'WebACLJsonBody',
    'WebACLJsonMatchPattern',
    'WebACLLabel',
    'WebACLLabelMatchStatement',
    'WebACLManagedRuleGroupConfig',
    'WebACLManagedRuleGroupStatement',
    'WebACLNotStatement',
    'WebACLOrStatement',
    'WebACLOverrideAction',
    'WebACLRateBasedStatement',
    'WebACLRateBasedStatementCustomKey',
    'WebACLRateLimitCookie',
    'WebACLRateLimitForwardedIP',
    'WebACLRateLimitHTTPMethod',
    'WebACLRateLimitHeader',
    'WebACLRateLimitIP',
    'WebACLRateLimitLabelNamespace',
    'WebACLRateLimitQueryArgument',
    'WebACLRateLimitQueryString',
    'WebACLRateLimitUriPath',
    'WebACLRegexMatchStatement',
    'WebACLRegexPatternSetReferenceStatement',
    'WebACLRequestBody',
    'WebACLRequestInspection',
    'WebACLResponseInspection',
    'WebACLResponseInspectionBodyContains',
    'WebACLResponseInspectionHeader',
    'WebACLResponseInspectionJson',
    'WebACLResponseInspectionStatusCode',
    'WebACLRule',
    'WebACLRuleAction',
    'WebACLRuleActionOverride',
    'WebACLRuleGroupReferenceStatement',
    'WebACLSizeConstraintStatement',
    'WebACLSqliMatchStatement',
    'WebACLStatement',
    'WebACLTag',
    'WebACLTextTransformation',
    'WebACLVisibilityConfig',
    'WebACLXssMatchStatement',
]

@pulumi.output_type
class IPSetTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class LoggingConfigurationCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionCondition":
            suggest = "action_condition"
        elif key == "labelNameCondition":
            suggest = "label_name_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_condition: Optional['outputs.LoggingConfigurationConditionActionConditionProperties'] = None,
                 label_name_condition: Optional['outputs.LoggingConfigurationConditionLabelNameConditionProperties'] = None):
        """
        :param 'LoggingConfigurationConditionActionConditionProperties' action_condition: A single action condition.
        :param 'LoggingConfigurationConditionLabelNameConditionProperties' label_name_condition: A single label name condition.
        """
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional['outputs.LoggingConfigurationConditionActionConditionProperties']:
        """
        A single action condition.
        """
        return pulumi.get(self, "action_condition")

    @property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional['outputs.LoggingConfigurationConditionLabelNameConditionProperties']:
        """
        A single label name condition.
        """
        return pulumi.get(self, "label_name_condition")


@pulumi.output_type
class LoggingConfigurationConditionActionConditionProperties(dict):
    """
    A single action condition.
    """
    def __init__(__self__, *,
                 action: 'LoggingConfigurationConditionActionConditionPropertiesAction'):
        """
        A single action condition.
        :param 'LoggingConfigurationConditionActionConditionPropertiesAction' action: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> 'LoggingConfigurationConditionActionConditionPropertiesAction':
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class LoggingConfigurationConditionLabelNameConditionProperties(dict):
    """
    A single label name condition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelName":
            suggest = "label_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationConditionLabelNameConditionProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationConditionLabelNameConditionProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationConditionLabelNameConditionProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_name: str):
        """
        A single label name condition.
        :param str label_name: The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
        """
        pulumi.set(__self__, "label_name", label_name)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> str:
        """
        The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
        """
        return pulumi.get(self, "label_name")


@pulumi.output_type
class LoggingConfigurationFieldToMatch(dict):
    """
    A key-value pair to associate with a resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_body: Optional['outputs.LoggingConfigurationFieldToMatchJsonBodyProperties'] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional['outputs.LoggingConfigurationFieldToMatchSingleHeaderProperties'] = None,
                 uri_path: Optional[Any] = None):
        """
        A key-value pair to associate with a resource.
        :param 'LoggingConfigurationFieldToMatchJsonBodyProperties' json_body: Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        :param Any method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
        :param Any query_string: Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
        :param 'LoggingConfigurationFieldToMatchSingleHeaderProperties' single_header: Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        :param Any uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
        """
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.LoggingConfigurationFieldToMatchJsonBodyProperties']:
        """
        Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.LoggingConfigurationFieldToMatchSingleHeaderProperties']:
        """
        Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class LoggingConfigurationFieldToMatchJsonBodyProperties(dict):
    """
    Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationFieldToMatchJsonBodyProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties',
                 match_scope: 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope',
                 invalid_fallback_behavior: Optional['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior'] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        :param 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties' match_pattern: The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        :param 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope' match_scope: The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
        :param 'LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior' invalid_fallback_behavior: What AWS WAF should do if it fails to completely parse the JSON body.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties':
        """
        The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope':
        """
        The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior']:
        """
        What AWS WAF should do if it fails to completely parse the JSON body.
        """
        return pulumi.get(self, "invalid_fallback_behavior")


@pulumi.output_type
class LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties(dict):
    """
    The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        :param Any all: Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
        :param Sequence[str] included_paths: Match only the specified include paths. See also MatchScope in JsonBody.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        """
        Match only the specified include paths. See also MatchScope in JsonBody.
        """
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class LoggingConfigurationFieldToMatchSingleHeaderProperties(dict):
    """
    Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
    """
    def __init__(__self__, *,
                 name: str):
        """
        Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        :param str name: The name of the query header to inspect.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LoggingConfigurationFilter(dict):
    def __init__(__self__, *,
                 behavior: 'LoggingConfigurationFilterBehavior',
                 conditions: Sequence['outputs.LoggingConfigurationCondition'],
                 requirement: 'LoggingConfigurationFilterRequirement'):
        """
        :param 'LoggingConfigurationFilterBehavior' behavior: How to handle logs that satisfy the filter's conditions and requirement. 
        :param Sequence['LoggingConfigurationCondition'] conditions: Match conditions for the filter.
        :param 'LoggingConfigurationFilterRequirement' requirement: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "requirement", requirement)

    @property
    @pulumi.getter
    def behavior(self) -> 'LoggingConfigurationFilterBehavior':
        """
        How to handle logs that satisfy the filter's conditions and requirement. 
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.LoggingConfigurationCondition']:
        """
        Match conditions for the filter.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def requirement(self) -> 'LoggingConfigurationFilterRequirement':
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "requirement")


@pulumi.output_type
class LoggingFilterProperties(dict):
    """
    Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBehavior":
            suggest = "default_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingFilterProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingFilterProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingFilterProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_behavior: 'LoggingConfigurationLoggingFilterPropertiesDefaultBehavior',
                 filters: Sequence['outputs.LoggingConfigurationFilter']):
        """
        Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
        :param 'LoggingConfigurationLoggingFilterPropertiesDefaultBehavior' default_behavior: Default handling for logs that don't match any of the specified filtering conditions.
        :param Sequence['LoggingConfigurationFilter'] filters: The filters that you want to apply to the logs.
        """
        pulumi.set(__self__, "default_behavior", default_behavior)
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> 'LoggingConfigurationLoggingFilterPropertiesDefaultBehavior':
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        """
        return pulumi.get(self, "default_behavior")

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.LoggingConfigurationFilter']:
        """
        The filters that you want to apply to the logs.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class RegexPatternSetTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupAllowAction(dict):
    """
    Allow traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupAllowAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupAllowAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupAllowAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupStatement']):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupBlockAction(dict):
    """
    Block traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupBlockAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupBlockAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupBlockAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.RuleGroupCustomResponse'] = None):
        """
        Block traffic towards application.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.RuleGroupCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class RuleGroupBody(dict):
    """
    The body of a web request. This immediately follows the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional['RuleGroupOversizeHandling'] = None):
        """
        The body of a web request. This immediately follows the request headers.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional['RuleGroupOversizeHandling']:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupByteMatchStatement(dict):
    """
    Byte Match statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "searchStringBase64":
            suggest = "search_string_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 positional_constraint: 'RuleGroupPositionalConstraint',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation'],
                 search_string: Optional[str] = None,
                 search_string_base64: Optional[str] = None):
        """
        Byte Match statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if search_string is not None:
            pulumi.set(__self__, "search_string", search_string)
        if search_string_base64 is not None:
            pulumi.set(__self__, "search_string_base64", search_string_base64)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> 'RuleGroupPositionalConstraint':
        return pulumi.get(self, "positional_constraint")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> Optional[str]:
        return pulumi.get(self, "search_string")

    @property
    @pulumi.getter(name="searchStringBase64")
    def search_string_base64(self) -> Optional[str]:
        return pulumi.get(self, "search_string_base64")


@pulumi.output_type
class RuleGroupCaptchaAction(dict):
    """
    Checks valid token exists with request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCaptchaAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCaptchaAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCaptchaAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None):
        """
        Checks valid token exists with request.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.RuleGroupImmunityTimeProperty'] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.RuleGroupImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class RuleGroupChallengeAction(dict):
    """
    Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupChallengeAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupChallengeAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupChallengeAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None):
        """
        Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupChallengeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupChallengeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupChallengeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupChallengeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.RuleGroupImmunityTimeProperty'] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.RuleGroupImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class RuleGroupCookieMatchPattern(dict):
    """
    The pattern to look for in the request cookies.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCookieMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCookieMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCookieMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the request cookies.
        :param Any all: Inspect all parts of the web request cookies.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request cookies.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupCookies(dict):
    """
    Includes headers of a web request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupCookieMatchPattern',
                 match_scope: 'RuleGroupMapMatchScope',
                 oversize_handling: 'RuleGroupOversizeHandling'):
        """
        Includes headers of a web request.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupCookieMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'RuleGroupMapMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> 'RuleGroupOversizeHandling':
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupCountAction(dict):
    """
    Count traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCountAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCountAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCountAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None):
        """
        Count traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupCustomHTTPHeader(dict):
    """
    HTTP header.
    """
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupCustomRequestHandling(dict):
    """
    Custom request handling.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.RuleGroupCustomHTTPHeader']):
        """
        Custom request handling.
        :param Sequence['RuleGroupCustomHTTPHeader'] insert_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.RuleGroupCustomHTTPHeader']:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class RuleGroupCustomResponse(dict):
    """
    Custom response.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: int,
                 custom_response_body_key: Optional[str] = None,
                 response_headers: Optional[Sequence['outputs.RuleGroupCustomHTTPHeader']] = None):
        """
        Custom response.
        :param str custom_response_body_key: Custom response body key.
        :param Sequence['RuleGroupCustomHTTPHeader'] response_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> int:
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[str]:
        """
        Custom response body key.
        """
        return pulumi.get(self, "custom_response_body_key")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.RuleGroupCustomHTTPHeader']]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class RuleGroupCustomResponseBodies(dict):
    """
    Custom response key and body map.
    """
    def __init__(__self__):
        """
        Custom response key and body map.
        """
        pass


@pulumi.output_type
class RuleGroupFieldToMatch(dict):
    """
    Field of the request to match.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional[Any] = None,
                 body: Optional['outputs.RuleGroupBody'] = None,
                 cookies: Optional['outputs.RuleGroupCookies'] = None,
                 headers: Optional['outputs.RuleGroupHeaders'] = None,
                 json_body: Optional['outputs.RuleGroupJsonBody'] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional['outputs.RuleGroupFieldToMatchSingleHeaderProperties'] = None,
                 single_query_argument: Optional['outputs.RuleGroupFieldToMatchSingleQueryArgumentProperties'] = None,
                 uri_path: Optional[Any] = None):
        """
        Field of the request to match.
        :param Any all_query_arguments: All query arguments of a web request.
        :param Any method: The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        :param Any query_string: The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        :param 'RuleGroupFieldToMatchSingleQueryArgumentProperties' single_query_argument: One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        :param Any uri_path: The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[Any]:
        """
        All query arguments of a web request.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupBody']:
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupCookies']:
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.RuleGroupHeaders']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupJsonBody']:
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupFieldToMatchSingleHeaderProperties']:
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupFieldToMatchSingleQueryArgumentProperties']:
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupFieldToMatchSingleHeaderProperties(dict):
    def __init__(__self__, *,
                 name: str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupFieldToMatchSingleQueryArgumentProperties(dict):
    """
    One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
    """
    def __init__(__self__, *,
                 name: str):
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupForwardedIPConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupForwardedIPConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupForwardedIPConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupForwardedIPConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'RuleGroupForwardedIPConfigurationFallbackBehavior',
                 header_name: str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'RuleGroupForwardedIPConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class RuleGroupGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIPConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Optional[Sequence[str]] = None,
                 forwarded_ip_config: Optional['outputs.RuleGroupForwardedIPConfiguration'] = None):
        if country_codes is not None:
            pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupForwardedIPConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class RuleGroupHeaderMatchPattern(dict):
    """
    The pattern to look for in the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the request headers.
        :param Any all: Inspect all parts of the web request headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupHeaders(dict):
    """
    Includes headers of a web request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupHeaderMatchPattern',
                 match_scope: 'RuleGroupMapMatchScope',
                 oversize_handling: 'RuleGroupOversizeHandling'):
        """
        Includes headers of a web request.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'RuleGroupMapMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> 'RuleGroupOversizeHandling':
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupIPSetForwardedIPConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupIPSetForwardedIPConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupIPSetForwardedIPConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupIPSetForwardedIPConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'RuleGroupIPSetForwardedIPConfigurationFallbackBehavior',
                 header_name: str,
                 position: 'RuleGroupIPSetForwardedIPConfigurationPosition'):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'RuleGroupIPSetForwardedIPConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def position(self) -> 'RuleGroupIPSetForwardedIPConfigurationPosition':
        return pulumi.get(self, "position")


@pulumi.output_type
class RuleGroupIPSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iPSetForwardedIPConfig":
            suggest = "i_p_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupIPSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupIPSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupIPSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 i_p_set_forwarded_ip_config: Optional['outputs.RuleGroupIPSetForwardedIPConfiguration'] = None):
        pulumi.set(__self__, "arn", arn)
        if i_p_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "i_p_set_forwarded_ip_config", i_p_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="iPSetForwardedIPConfig")
    def i_p_set_forwarded_ip_config(self) -> Optional['outputs.RuleGroupIPSetForwardedIPConfiguration']:
        return pulumi.get(self, "i_p_set_forwarded_ip_config")


@pulumi.output_type
class RuleGroupImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: int):
        pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> int:
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class RuleGroupJsonBody(dict):
    """
    Inspect the request body as JSON. The request body immediately follows the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupJsonMatchPattern',
                 match_scope: 'RuleGroupJsonMatchScope',
                 invalid_fallback_behavior: Optional['RuleGroupBodyParsingFallbackBehavior'] = None,
                 oversize_handling: Optional['RuleGroupOversizeHandling'] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupJsonMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'RuleGroupJsonMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional['RuleGroupBodyParsingFallbackBehavior']:
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional['RuleGroupOversizeHandling']:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupJsonMatchPattern(dict):
    """
    The pattern to look for in the JSON body.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupJsonMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupJsonMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupJsonMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the JSON body.
        :param Any all: Inspect all parts of the web request's JSON body.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request's JSON body.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupLabel(dict):
    def __init__(__self__, *,
                 name: str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: str,
                 scope: 'RuleGroupLabelMatchScope'):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def scope(self) -> 'RuleGroupLabelMatchScope':
        return pulumi.get(self, "scope")


@pulumi.output_type
class RuleGroupLabelSummary(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupNotStatement(dict):
    def __init__(__self__, *,
                 statement: 'outputs.RuleGroupStatement'):
        pulumi.set(__self__, "statement", statement)

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.RuleGroupStatement':
        return pulumi.get(self, "statement")


@pulumi.output_type
class RuleGroupOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupStatement']):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRateBasedStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateKeyType":
            suggest = "aggregate_key_type"
        elif key == "customKeys":
            suggest = "custom_keys"
        elif key == "forwardedIPConfig":
            suggest = "forwarded_ip_config"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateBasedStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateBasedStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateBasedStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregate_key_type: 'RuleGroupRateBasedStatementAggregateKeyType',
                 limit: int,
                 custom_keys: Optional[Sequence['outputs.RuleGroupRateBasedStatementCustomKey']] = None,
                 forwarded_ip_config: Optional['outputs.RuleGroupForwardedIPConfiguration'] = None,
                 scope_down_statement: Optional['outputs.RuleGroupStatement'] = None):
        """
        :param Sequence['RuleGroupRateBasedStatementCustomKey'] custom_keys: Specifies the aggregate keys to use in a rate-base rule.
        """
        pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        pulumi.set(__self__, "limit", limit)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> 'RuleGroupRateBasedStatementAggregateKeyType':
        return pulumi.get(self, "aggregate_key_type")

    @property
    @pulumi.getter
    def limit(self) -> int:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[Sequence['outputs.RuleGroupRateBasedStatementCustomKey']]:
        """
        Specifies the aggregate keys to use in a rate-base rule.
        """
        return pulumi.get(self, "custom_keys")

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupForwardedIPConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.RuleGroupStatement']:
        return pulumi.get(self, "scope_down_statement")


@pulumi.output_type
class RuleGroupRateBasedStatementCustomKey(dict):
    """
    Specifies a single custom aggregate key for a rate-base rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardedIP":
            suggest = "forwarded_ip"
        elif key == "hTTPMethod":
            suggest = "h_ttp_method"
        elif key == "iP":
            suggest = "i_p"
        elif key == "labelNamespace":
            suggest = "label_namespace"
        elif key == "queryArgument":
            suggest = "query_argument"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateBasedStatementCustomKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateBasedStatementCustomKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateBasedStatementCustomKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional['outputs.RuleGroupRateLimitCookie'] = None,
                 forwarded_ip: Optional['outputs.RuleGroupRateLimitForwardedIP'] = None,
                 h_ttp_method: Optional['outputs.RuleGroupRateLimitHTTPMethod'] = None,
                 header: Optional['outputs.RuleGroupRateLimitHeader'] = None,
                 i_p: Optional['outputs.RuleGroupRateLimitIP'] = None,
                 label_namespace: Optional['outputs.RuleGroupRateLimitLabelNamespace'] = None,
                 query_argument: Optional['outputs.RuleGroupRateLimitQueryArgument'] = None,
                 query_string: Optional['outputs.RuleGroupRateLimitQueryString'] = None,
                 uri_path: Optional['outputs.RuleGroupRateLimitUriPath'] = None):
        """
        Specifies a single custom aggregate key for a rate-base rule.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if h_ttp_method is not None:
            pulumi.set(__self__, "h_ttp_method", h_ttp_method)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if i_p is not None:
            pulumi.set(__self__, "i_p", i_p)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.RuleGroupRateLimitCookie']:
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="forwardedIP")
    def forwarded_ip(self) -> Optional['outputs.RuleGroupRateLimitForwardedIP']:
        return pulumi.get(self, "forwarded_ip")

    @property
    @pulumi.getter(name="hTTPMethod")
    def h_ttp_method(self) -> Optional['outputs.RuleGroupRateLimitHTTPMethod']:
        return pulumi.get(self, "h_ttp_method")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.RuleGroupRateLimitHeader']:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter(name="iP")
    def i_p(self) -> Optional['outputs.RuleGroupRateLimitIP']:
        return pulumi.get(self, "i_p")

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional['outputs.RuleGroupRateLimitLabelNamespace']:
        return pulumi.get(self, "label_namespace")

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional['outputs.RuleGroupRateLimitQueryArgument']:
        return pulumi.get(self, "query_argument")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRateLimitQueryString']:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRateLimitUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRateLimitCookie(dict):
    """
    Specifies a cookie as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateLimitCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateLimitCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateLimitCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Specifies a cookie as an aggregate key for a rate-based rule.
        :param str name: The name of the cookie to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the cookie to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRateLimitForwardedIP(dict):
    """
    Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.output_type
class RuleGroupRateLimitHTTPMethod(dict):
    """
    Specifies the request's HTTP method as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the request's HTTP method as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.output_type
class RuleGroupRateLimitHeader(dict):
    """
    Specifies a header as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateLimitHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateLimitHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateLimitHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Specifies a header as an aggregate key for a rate-based rule.
        :param str name: The name of the header to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRateLimitIP(dict):
    """
    Specifies the IP address in the web request as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the IP address in the web request as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.output_type
class RuleGroupRateLimitLabelNamespace(dict):
    """
    Specifies a label namespace to use as an aggregate key for a rate-based rule.
    """
    def __init__(__self__, *,
                 namespace: str):
        """
        Specifies a label namespace to use as an aggregate key for a rate-based rule.
        :param str namespace: The namespace to use for aggregation.
        """
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace to use for aggregation.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class RuleGroupRateLimitQueryArgument(dict):
    """
    Specifies a query argument in the request as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateLimitQueryArgument. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateLimitQueryArgument.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateLimitQueryArgument.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Specifies a query argument in the request as an aggregate key for a rate-based rule.
        :param str name: The name of the query argument to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query argument to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRateLimitQueryString(dict):
    """
    Specifies the request's query string as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateLimitQueryString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateLimitQueryString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateLimitQueryString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Specifies the request's query string as an aggregate key for a rate-based rule.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRateLimitUriPath(dict):
    """
    Specifies the request's URI Path as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateLimitUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateLimitUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateLimitUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Specifies the request's URI Path as an aggregate key for a rate-based rule.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 regex_string: str,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        return pulumi.get(self, "regex_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRule(dict):
    """
    Rule of RuleGroup that contains condition and action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityConfig":
            suggest = "visibility_config"
        elif key == "captchaConfig":
            suggest = "captcha_config"
        elif key == "challengeConfig":
            suggest = "challenge_config"
        elif key == "ruleLabels":
            suggest = "rule_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 priority: int,
                 statement: 'outputs.RuleGroupStatement',
                 visibility_config: 'outputs.RuleGroupVisibilityConfig',
                 action: Optional['outputs.RuleGroupRuleAction'] = None,
                 captcha_config: Optional['outputs.RuleGroupCaptchaConfig'] = None,
                 challenge_config: Optional['outputs.RuleGroupChallengeConfig'] = None,
                 rule_labels: Optional[Sequence['outputs.RuleGroupLabel']] = None):
        """
        Rule of RuleGroup that contains condition and action.
        :param Sequence['RuleGroupLabel'] rule_labels: Collection of Rule Labels.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if challenge_config is not None:
            pulumi.set(__self__, "challenge_config", challenge_config)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.RuleGroupStatement':
        return pulumi.get(self, "statement")

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> 'outputs.RuleGroupVisibilityConfig':
        return pulumi.get(self, "visibility_config")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.RuleGroupRuleAction']:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional['outputs.RuleGroupCaptchaConfig']:
        return pulumi.get(self, "captcha_config")

    @property
    @pulumi.getter(name="challengeConfig")
    def challenge_config(self) -> Optional['outputs.RuleGroupChallengeConfig']:
        return pulumi.get(self, "challenge_config")

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[Sequence['outputs.RuleGroupLabel']]:
        """
        Collection of Rule Labels.
        """
        return pulumi.get(self, "rule_labels")


@pulumi.output_type
class RuleGroupRuleAction(dict):
    """
    Action taken when Rule matches its condition.
    """
    def __init__(__self__, *,
                 allow: Optional['outputs.RuleGroupAllowAction'] = None,
                 block: Optional['outputs.RuleGroupBlockAction'] = None,
                 captcha: Optional['outputs.RuleGroupCaptchaAction'] = None,
                 challenge: Optional['outputs.RuleGroupChallengeAction'] = None,
                 count: Optional['outputs.RuleGroupCountAction'] = None):
        """
        Action taken when Rule matches its condition.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.RuleGroupAllowAction']:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.RuleGroupBlockAction']:
        return pulumi.get(self, "block")

    @property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.RuleGroupCaptchaAction']:
        return pulumi.get(self, "captcha")

    @property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.RuleGroupChallengeAction']:
        return pulumi.get(self, "challenge")

    @property
    @pulumi.getter
    def count(self) -> Optional['outputs.RuleGroupCountAction']:
        return pulumi.get(self, "count")


@pulumi.output_type
class RuleGroupSizeConstraintStatement(dict):
    """
    Size Constraint statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: 'RuleGroupSizeConstraintStatementComparisonOperator',
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 size: float,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Size Constraint statement.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> 'RuleGroupSizeConstraintStatementComparisonOperator':
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter
    def size(self) -> float:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupSqliMatchStatement(dict):
    """
    Sqli Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation'],
                 sensitivity_level: Optional['RuleGroupSensitivityLevel'] = None):
        """
        Sqli Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional['RuleGroupSensitivityLevel']:
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RuleGroupStatement(dict):
    """
    First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "iPSetReferenceStatement":
            suggest = "i_p_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "rateBasedStatement":
            suggest = "rate_based_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.RuleGroupAndStatement'] = None,
                 byte_match_statement: Optional['outputs.RuleGroupByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.RuleGroupGeoMatchStatement'] = None,
                 i_p_set_reference_statement: Optional['outputs.RuleGroupIPSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.RuleGroupLabelMatchStatement'] = None,
                 not_statement: Optional['outputs.RuleGroupNotStatement'] = None,
                 or_statement: Optional['outputs.RuleGroupOrStatement'] = None,
                 rate_based_statement: Optional['outputs.RuleGroupRateBasedStatement'] = None,
                 regex_match_statement: Optional['outputs.RuleGroupRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.RuleGroupRegexPatternSetReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.RuleGroupSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.RuleGroupSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.RuleGroupXssMatchStatement'] = None):
        """
        First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if i_p_set_reference_statement is not None:
            pulumi.set(__self__, "i_p_set_reference_statement", i_p_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.RuleGroupAndStatement']:
        return pulumi.get(self, "and_statement")

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.RuleGroupByteMatchStatement']:
        return pulumi.get(self, "byte_match_statement")

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.RuleGroupGeoMatchStatement']:
        return pulumi.get(self, "geo_match_statement")

    @property
    @pulumi.getter(name="iPSetReferenceStatement")
    def i_p_set_reference_statement(self) -> Optional['outputs.RuleGroupIPSetReferenceStatement']:
        return pulumi.get(self, "i_p_set_reference_statement")

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.RuleGroupLabelMatchStatement']:
        return pulumi.get(self, "label_match_statement")

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.RuleGroupNotStatement']:
        return pulumi.get(self, "not_statement")

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.RuleGroupOrStatement']:
        return pulumi.get(self, "or_statement")

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional['outputs.RuleGroupRateBasedStatement']:
        return pulumi.get(self, "rate_based_statement")

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.RuleGroupRegexMatchStatement']:
        return pulumi.get(self, "regex_match_statement")

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.RuleGroupRegexPatternSetReferenceStatement']:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.RuleGroupSizeConstraintStatement']:
        return pulumi.get(self, "size_constraint_statement")

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.RuleGroupSqliMatchStatement']:
        return pulumi.get(self, "sqli_match_statement")

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.RuleGroupXssMatchStatement']:
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class RuleGroupTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupTextTransformation(dict):
    """
    Text Transformation on the Search String before match.
    """
    def __init__(__self__, *,
                 priority: int,
                 type: 'RuleGroupTextTransformationType'):
        """
        Text Transformation on the Search String before match.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> 'RuleGroupTextTransformationType':
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupVisibilityConfig(dict):
    """
    Visibility Metric of the RuleGroup.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchMetricsEnabled":
            suggest = "cloud_watch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_metrics_enabled: bool,
                 metric_name: str,
                 sampled_requests_enabled: bool):
        """
        Visibility Metric of the RuleGroup.
        """
        pulumi.set(__self__, "cloud_watch_metrics_enabled", cloud_watch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudWatchMetricsEnabled")
    def cloud_watch_metrics_enabled(self) -> bool:
        return pulumi.get(self, "cloud_watch_metrics_enabled")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> bool:
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class RuleGroupXssMatchStatement(dict):
    """
    Xss Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Xss Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLAWSManagedRulesATPRuleSet(dict):
    """
    Configures how to use the Account Takeover Prevention managed rule group in the web ACL
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginPath":
            suggest = "login_path"
        elif key == "requestInspection":
            suggest = "request_inspection"
        elif key == "responseInspection":
            suggest = "response_inspection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLAWSManagedRulesATPRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLAWSManagedRulesATPRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLAWSManagedRulesATPRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_path: str,
                 request_inspection: Optional['outputs.WebACLRequestInspection'] = None,
                 response_inspection: Optional['outputs.WebACLResponseInspection'] = None):
        """
        Configures how to use the Account Takeover Prevention managed rule group in the web ACL
        """
        pulumi.set(__self__, "login_path", login_path)
        if request_inspection is not None:
            pulumi.set(__self__, "request_inspection", request_inspection)
        if response_inspection is not None:
            pulumi.set(__self__, "response_inspection", response_inspection)

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> str:
        return pulumi.get(self, "login_path")

    @property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> Optional['outputs.WebACLRequestInspection']:
        return pulumi.get(self, "request_inspection")

    @property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional['outputs.WebACLResponseInspection']:
        return pulumi.get(self, "response_inspection")


@pulumi.output_type
class WebACLAWSManagedRulesBotControlRuleSet(dict):
    """
    Configures how to use the Bot Control managed rule group in the web ACL
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectionLevel":
            suggest = "inspection_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLAWSManagedRulesBotControlRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLAWSManagedRulesBotControlRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLAWSManagedRulesBotControlRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspection_level: 'WebACLAWSManagedRulesBotControlRuleSetInspectionLevel'):
        """
        Configures how to use the Bot Control managed rule group in the web ACL
        """
        pulumi.set(__self__, "inspection_level", inspection_level)

    @property
    @pulumi.getter(name="inspectionLevel")
    def inspection_level(self) -> 'WebACLAWSManagedRulesBotControlRuleSetInspectionLevel':
        return pulumi.get(self, "inspection_level")


@pulumi.output_type
class WebACLAllowAction(dict):
    """
    Allow traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLAllowAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLAllowAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLAllowAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebACLCustomRequestHandling'] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebACLCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebACLAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebACLStatement']):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebACLStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebACLAssociationConfig(dict):
    """
    AssociationConfig for body inspection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestBody":
            suggest = "request_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLAssociationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLAssociationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLAssociationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_body: Optional['outputs.WebACLRequestBody'] = None):
        """
        AssociationConfig for body inspection
        """
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)

    @property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional['outputs.WebACLRequestBody']:
        return pulumi.get(self, "request_body")


@pulumi.output_type
class WebACLBlockAction(dict):
    """
    Block traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLBlockAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLBlockAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLBlockAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebACLCustomResponse'] = None):
        """
        Block traffic towards application.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebACLCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebACLBody(dict):
    """
    The body of a web request. This immediately follows the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional['WebACLOversizeHandling'] = None):
        """
        The body of a web request. This immediately follows the request headers.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional['WebACLOversizeHandling']:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebACLByteMatchStatement(dict):
    """
    Byte Match statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "searchStringBase64":
            suggest = "search_string_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 positional_constraint: 'WebACLPositionalConstraint',
                 text_transformations: Sequence['outputs.WebACLTextTransformation'],
                 search_string: Optional[str] = None,
                 search_string_base64: Optional[str] = None):
        """
        Byte Match statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if search_string is not None:
            pulumi.set(__self__, "search_string", search_string)
        if search_string_base64 is not None:
            pulumi.set(__self__, "search_string_base64", search_string_base64)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> 'WebACLPositionalConstraint':
        return pulumi.get(self, "positional_constraint")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> Optional[str]:
        return pulumi.get(self, "search_string")

    @property
    @pulumi.getter(name="searchStringBase64")
    def search_string_base64(self) -> Optional[str]:
        return pulumi.get(self, "search_string_base64")


@pulumi.output_type
class WebACLCaptchaAction(dict):
    """
    Checks valid token exists with request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCaptchaAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCaptchaAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCaptchaAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebACLCustomRequestHandling'] = None):
        """
        Checks valid token exists with request.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebACLCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebACLCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.WebACLImmunityTimeProperty'] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.WebACLImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class WebACLChallengeAction(dict):
    """
    Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLChallengeAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLChallengeAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLChallengeAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebACLCustomRequestHandling'] = None):
        """
        Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebACLCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebACLChallengeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLChallengeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLChallengeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLChallengeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.WebACLImmunityTimeProperty'] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.WebACLImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class WebACLCookieMatchPattern(dict):
    """
    The pattern to look for in the request cookies.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCookieMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCookieMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCookieMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the request cookies.
        :param Any all: Inspect all parts of the web request cookies.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request cookies.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebACLCookies(dict):
    """
    Includes headers of a web request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebACLCookieMatchPattern',
                 match_scope: 'WebACLMapMatchScope',
                 oversize_handling: 'WebACLOversizeHandling'):
        """
        Includes headers of a web request.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebACLCookieMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'WebACLMapMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> 'WebACLOversizeHandling':
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebACLCountAction(dict):
    """
    Allow traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCountAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCountAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCountAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebACLCustomRequestHandling'] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebACLCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebACLCustomHTTPHeader(dict):
    """
    HTTP header.
    """
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebACLCustomRequestHandling(dict):
    """
    Custom request handling.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebACLCustomHTTPHeader']):
        """
        Custom request handling.
        :param Sequence['WebACLCustomHTTPHeader'] insert_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebACLCustomHTTPHeader']:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebACLCustomResponse(dict):
    """
    Custom response.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: int,
                 custom_response_body_key: Optional[str] = None,
                 response_headers: Optional[Sequence['outputs.WebACLCustomHTTPHeader']] = None):
        """
        Custom response.
        :param str custom_response_body_key: Custom response body key.
        :param Sequence['WebACLCustomHTTPHeader'] response_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> int:
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[str]:
        """
        Custom response body key.
        """
        return pulumi.get(self, "custom_response_body_key")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebACLCustomHTTPHeader']]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebACLCustomResponseBodies(dict):
    """
    Custom response key and body map.
    """
    def __init__(__self__):
        """
        Custom response key and body map.
        """
        pass


@pulumi.output_type
class WebACLDefaultAction(dict):
    """
    Default Action WebACL will take against ingress traffic when there is no matching Rule.
    """
    def __init__(__self__, *,
                 allow: Optional['outputs.WebACLAllowAction'] = None,
                 block: Optional['outputs.WebACLBlockAction'] = None):
        """
        Default Action WebACL will take against ingress traffic when there is no matching Rule.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebACLAllowAction']:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebACLBlockAction']:
        return pulumi.get(self, "block")


@pulumi.output_type
class WebACLExcludedRule(dict):
    """
    Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
    """
    def __init__(__self__, *,
                 name: str):
        """
        Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebACLFieldIdentifier(dict):
    def __init__(__self__, *,
                 identifier: str):
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebACLFieldToMatch(dict):
    """
    Field of the request to match.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional[Any] = None,
                 body: Optional['outputs.WebACLBody'] = None,
                 cookies: Optional['outputs.WebACLCookies'] = None,
                 headers: Optional['outputs.WebACLHeaders'] = None,
                 json_body: Optional['outputs.WebACLJsonBody'] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional['outputs.WebACLFieldToMatchSingleHeaderProperties'] = None,
                 single_query_argument: Optional['outputs.WebACLFieldToMatchSingleQueryArgumentProperties'] = None,
                 uri_path: Optional[Any] = None):
        """
        Field of the request to match.
        :param Any all_query_arguments: All query arguments of a web request.
        :param Any method: The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        :param Any query_string: The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        :param 'WebACLFieldToMatchSingleQueryArgumentProperties' single_query_argument: One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        :param Any uri_path: The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[Any]:
        """
        All query arguments of a web request.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebACLBody']:
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebACLCookies']:
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WebACLHeaders']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebACLJsonBody']:
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebACLFieldToMatchSingleHeaderProperties']:
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebACLFieldToMatchSingleQueryArgumentProperties']:
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebACLFieldToMatchSingleHeaderProperties(dict):
    def __init__(__self__, *,
                 name: str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebACLFieldToMatchSingleQueryArgumentProperties(dict):
    """
    One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
    """
    def __init__(__self__, *,
                 name: str):
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebACLForwardedIPConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLForwardedIPConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLForwardedIPConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLForwardedIPConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'WebACLForwardedIPConfigurationFallbackBehavior',
                 header_name: str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'WebACLForwardedIPConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebACLGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIPConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Optional[Sequence[str]] = None,
                 forwarded_ip_config: Optional['outputs.WebACLForwardedIPConfiguration'] = None):
        if country_codes is not None:
            pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebACLForwardedIPConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebACLHeaderMatchPattern(dict):
    """
    The pattern to look for in the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the request headers.
        :param Any all: Inspect all parts of the web request headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebACLHeaders(dict):
    """
    Includes headers of a web request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebACLHeaderMatchPattern',
                 match_scope: 'WebACLMapMatchScope',
                 oversize_handling: 'WebACLOversizeHandling'):
        """
        Includes headers of a web request.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebACLHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'WebACLMapMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> 'WebACLOversizeHandling':
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebACLIPSetForwardedIPConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLIPSetForwardedIPConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLIPSetForwardedIPConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLIPSetForwardedIPConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'WebACLIPSetForwardedIPConfigurationFallbackBehavior',
                 header_name: str,
                 position: 'WebACLIPSetForwardedIPConfigurationPosition'):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'WebACLIPSetForwardedIPConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def position(self) -> 'WebACLIPSetForwardedIPConfigurationPosition':
        return pulumi.get(self, "position")


@pulumi.output_type
class WebACLIPSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iPSetForwardedIPConfig":
            suggest = "i_p_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLIPSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLIPSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLIPSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 i_p_set_forwarded_ip_config: Optional['outputs.WebACLIPSetForwardedIPConfiguration'] = None):
        pulumi.set(__self__, "arn", arn)
        if i_p_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "i_p_set_forwarded_ip_config", i_p_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="iPSetForwardedIPConfig")
    def i_p_set_forwarded_ip_config(self) -> Optional['outputs.WebACLIPSetForwardedIPConfiguration']:
        return pulumi.get(self, "i_p_set_forwarded_ip_config")


@pulumi.output_type
class WebACLImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: int):
        pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> int:
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class WebACLJsonBody(dict):
    """
    Inspect the request body as JSON. The request body immediately follows the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebACLJsonMatchPattern',
                 match_scope: 'WebACLJsonMatchScope',
                 invalid_fallback_behavior: Optional['WebACLBodyParsingFallbackBehavior'] = None,
                 oversize_handling: Optional['WebACLOversizeHandling'] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebACLJsonMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'WebACLJsonMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional['WebACLBodyParsingFallbackBehavior']:
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional['WebACLOversizeHandling']:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebACLJsonMatchPattern(dict):
    """
    The pattern to look for in the JSON body.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLJsonMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLJsonMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLJsonMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the JSON body.
        :param Any all: Inspect all parts of the web request's JSON body.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request's JSON body.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebACLLabel(dict):
    def __init__(__self__, *,
                 name: str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebACLLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: str,
                 scope: 'WebACLLabelMatchScope'):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def scope(self) -> 'WebACLLabelMatchScope':
        return pulumi.get(self, "scope")


@pulumi.output_type
class WebACLManagedRuleGroupConfig(dict):
    """
    ManagedRuleGroupConfig.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aWSManagedRulesATPRuleSet":
            suggest = "a_ws_managed_rules_atp_rule_set"
        elif key == "aWSManagedRulesBotControlRuleSet":
            suggest = "a_ws_managed_rules_bot_control_rule_set"
        elif key == "loginPath":
            suggest = "login_path"
        elif key == "passwordField":
            suggest = "password_field"
        elif key == "payloadType":
            suggest = "payload_type"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLManagedRuleGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLManagedRuleGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLManagedRuleGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 a_ws_managed_rules_atp_rule_set: Optional['outputs.WebACLAWSManagedRulesATPRuleSet'] = None,
                 a_ws_managed_rules_bot_control_rule_set: Optional['outputs.WebACLAWSManagedRulesBotControlRuleSet'] = None,
                 login_path: Optional[str] = None,
                 password_field: Optional['outputs.WebACLFieldIdentifier'] = None,
                 payload_type: Optional['WebACLManagedRuleGroupConfigPayloadType'] = None,
                 username_field: Optional['outputs.WebACLFieldIdentifier'] = None):
        """
        ManagedRuleGroupConfig.
        """
        if a_ws_managed_rules_atp_rule_set is not None:
            pulumi.set(__self__, "a_ws_managed_rules_atp_rule_set", a_ws_managed_rules_atp_rule_set)
        if a_ws_managed_rules_bot_control_rule_set is not None:
            pulumi.set(__self__, "a_ws_managed_rules_bot_control_rule_set", a_ws_managed_rules_bot_control_rule_set)
        if login_path is not None:
            pulumi.set(__self__, "login_path", login_path)
        if password_field is not None:
            pulumi.set(__self__, "password_field", password_field)
        if payload_type is not None:
            pulumi.set(__self__, "payload_type", payload_type)
        if username_field is not None:
            pulumi.set(__self__, "username_field", username_field)

    @property
    @pulumi.getter(name="aWSManagedRulesATPRuleSet")
    def a_ws_managed_rules_atp_rule_set(self) -> Optional['outputs.WebACLAWSManagedRulesATPRuleSet']:
        return pulumi.get(self, "a_ws_managed_rules_atp_rule_set")

    @property
    @pulumi.getter(name="aWSManagedRulesBotControlRuleSet")
    def a_ws_managed_rules_bot_control_rule_set(self) -> Optional['outputs.WebACLAWSManagedRulesBotControlRuleSet']:
        return pulumi.get(self, "a_ws_managed_rules_bot_control_rule_set")

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> Optional[str]:
        return pulumi.get(self, "login_path")

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional['outputs.WebACLFieldIdentifier']:
        return pulumi.get(self, "password_field")

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> Optional['WebACLManagedRuleGroupConfigPayloadType']:
        return pulumi.get(self, "payload_type")

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional['outputs.WebACLFieldIdentifier']:
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebACLManagedRuleGroupStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vendorName":
            suggest = "vendor_name"
        elif key == "excludedRules":
            suggest = "excluded_rules"
        elif key == "managedRuleGroupConfigs":
            suggest = "managed_rule_group_configs"
        elif key == "ruleActionOverrides":
            suggest = "rule_action_overrides"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLManagedRuleGroupStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLManagedRuleGroupStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLManagedRuleGroupStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 vendor_name: str,
                 excluded_rules: Optional[Sequence['outputs.WebACLExcludedRule']] = None,
                 managed_rule_group_configs: Optional[Sequence['outputs.WebACLManagedRuleGroupConfig']] = None,
                 rule_action_overrides: Optional[Sequence['outputs.WebACLRuleActionOverride']] = None,
                 scope_down_statement: Optional['outputs.WebACLStatement'] = None,
                 version: Optional[str] = None):
        """
        :param Sequence['WebACLManagedRuleGroupConfig'] managed_rule_group_configs: Collection of ManagedRuleGroupConfig.
        :param Sequence['WebACLRuleActionOverride'] rule_action_overrides: Action overrides for rules in the rule group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vendor_name", vendor_name)
        if excluded_rules is not None:
            pulumi.set(__self__, "excluded_rules", excluded_rules)
        if managed_rule_group_configs is not None:
            pulumi.set(__self__, "managed_rule_group_configs", managed_rule_group_configs)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> str:
        return pulumi.get(self, "vendor_name")

    @property
    @pulumi.getter(name="excludedRules")
    def excluded_rules(self) -> Optional[Sequence['outputs.WebACLExcludedRule']]:
        return pulumi.get(self, "excluded_rules")

    @property
    @pulumi.getter(name="managedRuleGroupConfigs")
    def managed_rule_group_configs(self) -> Optional[Sequence['outputs.WebACLManagedRuleGroupConfig']]:
        """
        Collection of ManagedRuleGroupConfig.
        """
        return pulumi.get(self, "managed_rule_group_configs")

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[Sequence['outputs.WebACLRuleActionOverride']]:
        """
        Action overrides for rules in the rule group.
        """
        return pulumi.get(self, "rule_action_overrides")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.WebACLStatement']:
        return pulumi.get(self, "scope_down_statement")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class WebACLNotStatement(dict):
    def __init__(__self__, *,
                 statement: 'outputs.WebACLStatement'):
        pulumi.set(__self__, "statement", statement)

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.WebACLStatement':
        return pulumi.get(self, "statement")


@pulumi.output_type
class WebACLOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebACLStatement']):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebACLStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebACLOverrideAction(dict):
    """
    Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
    """
    def __init__(__self__, *,
                 count: Optional[Any] = None,
                 none: Optional[Any] = None):
        """
        Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
        :param Any count: Count traffic towards application.
        :param Any none: Keep the RuleGroup or ManagedRuleGroup behavior as is.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @property
    @pulumi.getter
    def count(self) -> Optional[Any]:
        """
        Count traffic towards application.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def none(self) -> Optional[Any]:
        """
        Keep the RuleGroup or ManagedRuleGroup behavior as is.
        """
        return pulumi.get(self, "none")


@pulumi.output_type
class WebACLRateBasedStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateKeyType":
            suggest = "aggregate_key_type"
        elif key == "customKeys":
            suggest = "custom_keys"
        elif key == "forwardedIPConfig":
            suggest = "forwarded_ip_config"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRateBasedStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRateBasedStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRateBasedStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregate_key_type: 'WebACLRateBasedStatementAggregateKeyType',
                 limit: int,
                 custom_keys: Optional[Sequence['outputs.WebACLRateBasedStatementCustomKey']] = None,
                 forwarded_ip_config: Optional['outputs.WebACLForwardedIPConfiguration'] = None,
                 scope_down_statement: Optional['outputs.WebACLStatement'] = None):
        """
        :param Sequence['WebACLRateBasedStatementCustomKey'] custom_keys: Specifies the aggregate keys to use in a rate-base rule.
        """
        pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        pulumi.set(__self__, "limit", limit)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> 'WebACLRateBasedStatementAggregateKeyType':
        return pulumi.get(self, "aggregate_key_type")

    @property
    @pulumi.getter
    def limit(self) -> int:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[Sequence['outputs.WebACLRateBasedStatementCustomKey']]:
        """
        Specifies the aggregate keys to use in a rate-base rule.
        """
        return pulumi.get(self, "custom_keys")

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebACLForwardedIPConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.WebACLStatement']:
        return pulumi.get(self, "scope_down_statement")


@pulumi.output_type
class WebACLRateBasedStatementCustomKey(dict):
    """
    Specifies a single custom aggregate key for a rate-base rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardedIP":
            suggest = "forwarded_ip"
        elif key == "hTTPMethod":
            suggest = "h_ttp_method"
        elif key == "iP":
            suggest = "i_p"
        elif key == "labelNamespace":
            suggest = "label_namespace"
        elif key == "queryArgument":
            suggest = "query_argument"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRateBasedStatementCustomKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRateBasedStatementCustomKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRateBasedStatementCustomKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional['outputs.WebACLRateLimitCookie'] = None,
                 forwarded_ip: Optional['outputs.WebACLRateLimitForwardedIP'] = None,
                 h_ttp_method: Optional['outputs.WebACLRateLimitHTTPMethod'] = None,
                 header: Optional['outputs.WebACLRateLimitHeader'] = None,
                 i_p: Optional['outputs.WebACLRateLimitIP'] = None,
                 label_namespace: Optional['outputs.WebACLRateLimitLabelNamespace'] = None,
                 query_argument: Optional['outputs.WebACLRateLimitQueryArgument'] = None,
                 query_string: Optional['outputs.WebACLRateLimitQueryString'] = None,
                 uri_path: Optional['outputs.WebACLRateLimitUriPath'] = None):
        """
        Specifies a single custom aggregate key for a rate-base rule.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if h_ttp_method is not None:
            pulumi.set(__self__, "h_ttp_method", h_ttp_method)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if i_p is not None:
            pulumi.set(__self__, "i_p", i_p)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.WebACLRateLimitCookie']:
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="forwardedIP")
    def forwarded_ip(self) -> Optional['outputs.WebACLRateLimitForwardedIP']:
        return pulumi.get(self, "forwarded_ip")

    @property
    @pulumi.getter(name="hTTPMethod")
    def h_ttp_method(self) -> Optional['outputs.WebACLRateLimitHTTPMethod']:
        return pulumi.get(self, "h_ttp_method")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.WebACLRateLimitHeader']:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter(name="iP")
    def i_p(self) -> Optional['outputs.WebACLRateLimitIP']:
        return pulumi.get(self, "i_p")

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional['outputs.WebACLRateLimitLabelNamespace']:
        return pulumi.get(self, "label_namespace")

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional['outputs.WebACLRateLimitQueryArgument']:
        return pulumi.get(self, "query_argument")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebACLRateLimitQueryString']:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebACLRateLimitUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebACLRateLimitCookie(dict):
    """
    Specifies a cookie as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRateLimitCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRateLimitCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRateLimitCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        """
        Specifies a cookie as an aggregate key for a rate-based rule.
        :param str name: The name of the cookie to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the cookie to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLRateLimitForwardedIP(dict):
    """
    Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.output_type
class WebACLRateLimitHTTPMethod(dict):
    """
    Specifies the request's HTTP method as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the request's HTTP method as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.output_type
class WebACLRateLimitHeader(dict):
    """
    Specifies a header as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRateLimitHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRateLimitHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRateLimitHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        """
        Specifies a header as an aggregate key for a rate-based rule.
        :param str name: The name of the header to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLRateLimitIP(dict):
    """
    Specifies the IP address in the web request as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the IP address in the web request as an aggregate key for a rate-based rule.
        """
        pass


@pulumi.output_type
class WebACLRateLimitLabelNamespace(dict):
    """
    Specifies a label namespace to use as an aggregate key for a rate-based rule.
    """
    def __init__(__self__, *,
                 namespace: str):
        """
        Specifies a label namespace to use as an aggregate key for a rate-based rule.
        :param str namespace: The namespace to use for aggregation.
        """
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace to use for aggregation.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class WebACLRateLimitQueryArgument(dict):
    """
    Specifies a query argument in the request as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRateLimitQueryArgument. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRateLimitQueryArgument.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRateLimitQueryArgument.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        """
        Specifies a query argument in the request as an aggregate key for a rate-based rule.
        :param str name: The name of the query argument to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query argument to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLRateLimitQueryString(dict):
    """
    Specifies the request's query string as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRateLimitQueryString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRateLimitQueryString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRateLimitQueryString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        """
        Specifies the request's query string as an aggregate key for a rate-based rule.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLRateLimitUriPath(dict):
    """
    Specifies the request's URI Path as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRateLimitUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRateLimitUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRateLimitUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        """
        Specifies the request's URI Path as an aggregate key for a rate-based rule.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 regex_string: str,
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        return pulumi.get(self, "regex_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLRequestBody(dict):
    """
    Map of AssociatedResourceType and RequestBodyAssociatedResourceTypeConfig
    """
    def __init__(__self__):
        """
        Map of AssociatedResourceType and RequestBodyAssociatedResourceTypeConfig
        """
        pass


@pulumi.output_type
class WebACLRequestInspection(dict):
    """
    Configures the inspection of login requests
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordField":
            suggest = "password_field"
        elif key == "payloadType":
            suggest = "payload_type"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRequestInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRequestInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRequestInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_field: 'outputs.WebACLFieldIdentifier',
                 payload_type: 'WebACLRequestInspectionPayloadType',
                 username_field: 'outputs.WebACLFieldIdentifier'):
        """
        Configures the inspection of login requests
        """
        pulumi.set(__self__, "password_field", password_field)
        pulumi.set(__self__, "payload_type", payload_type)
        pulumi.set(__self__, "username_field", username_field)

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> 'outputs.WebACLFieldIdentifier':
        return pulumi.get(self, "password_field")

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> 'WebACLRequestInspectionPayloadType':
        return pulumi.get(self, "payload_type")

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> 'outputs.WebACLFieldIdentifier':
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebACLResponseInspection(dict):
    """
    Configures the inspection of login responses
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyContains":
            suggest = "body_contains"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLResponseInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLResponseInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLResponseInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_contains: Optional['outputs.WebACLResponseInspectionBodyContains'] = None,
                 header: Optional['outputs.WebACLResponseInspectionHeader'] = None,
                 json: Optional['outputs.WebACLResponseInspectionJson'] = None,
                 status_code: Optional['outputs.WebACLResponseInspectionStatusCode'] = None):
        """
        Configures the inspection of login responses
        """
        if body_contains is not None:
            pulumi.set(__self__, "body_contains", body_contains)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional['outputs.WebACLResponseInspectionBodyContains']:
        return pulumi.get(self, "body_contains")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.WebACLResponseInspectionHeader']:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def json(self) -> Optional['outputs.WebACLResponseInspectionJson']:
        return pulumi.get(self, "json")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional['outputs.WebACLResponseInspectionStatusCode']:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class WebACLResponseInspectionBodyContains(dict):
    """
    Response body contents that indicate success or failure of a login request
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureStrings":
            suggest = "failure_strings"
        elif key == "successStrings":
            suggest = "success_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLResponseInspectionBodyContains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLResponseInspectionBodyContains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLResponseInspectionBodyContains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_strings: Sequence[str],
                 success_strings: Sequence[str]):
        """
        Response body contents that indicate success or failure of a login request
        """
        pulumi.set(__self__, "failure_strings", failure_strings)
        pulumi.set(__self__, "success_strings", success_strings)

    @property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> Sequence[str]:
        return pulumi.get(self, "failure_strings")

    @property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> Sequence[str]:
        return pulumi.get(self, "success_strings")


@pulumi.output_type
class WebACLResponseInspectionHeader(dict):
    """
    Response headers that indicate success or failure of a login request
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLResponseInspectionHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLResponseInspectionHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLResponseInspectionHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[str],
                 name: str,
                 success_values: Sequence[str]):
        """
        Response headers that indicate success or failure of a login request
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[str]:
        return pulumi.get(self, "failure_values")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[str]:
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebACLResponseInspectionJson(dict):
    """
    Response JSON that indicate success or failure of a login request
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLResponseInspectionJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLResponseInspectionJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLResponseInspectionJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[str],
                 identifier: str,
                 success_values: Sequence[str]):
        """
        Response JSON that indicate success or failure of a login request
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[str]:
        return pulumi.get(self, "failure_values")

    @property
    @pulumi.getter
    def identifier(self) -> str:
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[str]:
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebACLResponseInspectionStatusCode(dict):
    """
    Response status codes that indicate success or failure of a login request
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureCodes":
            suggest = "failure_codes"
        elif key == "successCodes":
            suggest = "success_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLResponseInspectionStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLResponseInspectionStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLResponseInspectionStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_codes: Sequence[int],
                 success_codes: Sequence[int]):
        """
        Response status codes that indicate success or failure of a login request
        """
        pulumi.set(__self__, "failure_codes", failure_codes)
        pulumi.set(__self__, "success_codes", success_codes)

    @property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> Sequence[int]:
        return pulumi.get(self, "failure_codes")

    @property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> Sequence[int]:
        return pulumi.get(self, "success_codes")


@pulumi.output_type
class WebACLRule(dict):
    """
    Rule of WebACL that contains condition and action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityConfig":
            suggest = "visibility_config"
        elif key == "captchaConfig":
            suggest = "captcha_config"
        elif key == "challengeConfig":
            suggest = "challenge_config"
        elif key == "overrideAction":
            suggest = "override_action"
        elif key == "ruleLabels":
            suggest = "rule_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 priority: int,
                 statement: 'outputs.WebACLStatement',
                 visibility_config: 'outputs.WebACLVisibilityConfig',
                 action: Optional['outputs.WebACLRuleAction'] = None,
                 captcha_config: Optional['outputs.WebACLCaptchaConfig'] = None,
                 challenge_config: Optional['outputs.WebACLChallengeConfig'] = None,
                 override_action: Optional['outputs.WebACLOverrideAction'] = None,
                 rule_labels: Optional[Sequence['outputs.WebACLLabel']] = None):
        """
        Rule of WebACL that contains condition and action.
        :param Sequence['WebACLLabel'] rule_labels: Collection of Rule Labels.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if challenge_config is not None:
            pulumi.set(__self__, "challenge_config", challenge_config)
        if override_action is not None:
            pulumi.set(__self__, "override_action", override_action)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.WebACLStatement':
        return pulumi.get(self, "statement")

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> 'outputs.WebACLVisibilityConfig':
        return pulumi.get(self, "visibility_config")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.WebACLRuleAction']:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional['outputs.WebACLCaptchaConfig']:
        return pulumi.get(self, "captcha_config")

    @property
    @pulumi.getter(name="challengeConfig")
    def challenge_config(self) -> Optional['outputs.WebACLChallengeConfig']:
        return pulumi.get(self, "challenge_config")

    @property
    @pulumi.getter(name="overrideAction")
    def override_action(self) -> Optional['outputs.WebACLOverrideAction']:
        return pulumi.get(self, "override_action")

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[Sequence['outputs.WebACLLabel']]:
        """
        Collection of Rule Labels.
        """
        return pulumi.get(self, "rule_labels")


@pulumi.output_type
class WebACLRuleAction(dict):
    """
    Action taken when Rule matches its condition.
    """
    def __init__(__self__, *,
                 allow: Optional['outputs.WebACLAllowAction'] = None,
                 block: Optional['outputs.WebACLBlockAction'] = None,
                 captcha: Optional['outputs.WebACLCaptchaAction'] = None,
                 challenge: Optional['outputs.WebACLChallengeAction'] = None,
                 count: Optional['outputs.WebACLCountAction'] = None):
        """
        Action taken when Rule matches its condition.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebACLAllowAction']:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebACLBlockAction']:
        return pulumi.get(self, "block")

    @property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.WebACLCaptchaAction']:
        return pulumi.get(self, "captcha")

    @property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.WebACLChallengeAction']:
        return pulumi.get(self, "challenge")

    @property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebACLCountAction']:
        return pulumi.get(self, "count")


@pulumi.output_type
class WebACLRuleActionOverride(dict):
    """
    Action override for rules in the rule group.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionToUse":
            suggest = "action_to_use"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRuleActionOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRuleActionOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRuleActionOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_to_use: 'outputs.WebACLRuleAction',
                 name: str):
        """
        Action override for rules in the rule group.
        """
        pulumi.set(__self__, "action_to_use", action_to_use)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> 'outputs.WebACLRuleAction':
        return pulumi.get(self, "action_to_use")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebACLRuleGroupReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedRules":
            suggest = "excluded_rules"
        elif key == "ruleActionOverrides":
            suggest = "rule_action_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRuleGroupReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRuleGroupReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRuleGroupReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 excluded_rules: Optional[Sequence['outputs.WebACLExcludedRule']] = None,
                 rule_action_overrides: Optional[Sequence['outputs.WebACLRuleActionOverride']] = None):
        """
        :param Sequence['WebACLRuleActionOverride'] rule_action_overrides: Action overrides for rules in the rule group.
        """
        pulumi.set(__self__, "arn", arn)
        if excluded_rules is not None:
            pulumi.set(__self__, "excluded_rules", excluded_rules)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="excludedRules")
    def excluded_rules(self) -> Optional[Sequence['outputs.WebACLExcludedRule']]:
        return pulumi.get(self, "excluded_rules")

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[Sequence['outputs.WebACLRuleActionOverride']]:
        """
        Action overrides for rules in the rule group.
        """
        return pulumi.get(self, "rule_action_overrides")


@pulumi.output_type
class WebACLSizeConstraintStatement(dict):
    """
    Size Constraint statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: 'WebACLSizeConstraintStatementComparisonOperator',
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 size: float,
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        """
        Size Constraint statement.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> 'WebACLSizeConstraintStatementComparisonOperator':
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter
    def size(self) -> float:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLSqliMatchStatement(dict):
    """
    Sqli Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 text_transformations: Sequence['outputs.WebACLTextTransformation'],
                 sensitivity_level: Optional['WebACLSensitivityLevel'] = None):
        """
        Sqli Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional['WebACLSensitivityLevel']:
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class WebACLStatement(dict):
    """
    First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "iPSetReferenceStatement":
            suggest = "i_p_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "managedRuleGroupStatement":
            suggest = "managed_rule_group_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "rateBasedStatement":
            suggest = "rate_based_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "ruleGroupReferenceStatement":
            suggest = "rule_group_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.WebACLAndStatement'] = None,
                 byte_match_statement: Optional['outputs.WebACLByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.WebACLGeoMatchStatement'] = None,
                 i_p_set_reference_statement: Optional['outputs.WebACLIPSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.WebACLLabelMatchStatement'] = None,
                 managed_rule_group_statement: Optional['outputs.WebACLManagedRuleGroupStatement'] = None,
                 not_statement: Optional['outputs.WebACLNotStatement'] = None,
                 or_statement: Optional['outputs.WebACLOrStatement'] = None,
                 rate_based_statement: Optional['outputs.WebACLRateBasedStatement'] = None,
                 regex_match_statement: Optional['outputs.WebACLRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.WebACLRegexPatternSetReferenceStatement'] = None,
                 rule_group_reference_statement: Optional['outputs.WebACLRuleGroupReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.WebACLSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.WebACLSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.WebACLXssMatchStatement'] = None):
        """
        First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if i_p_set_reference_statement is not None:
            pulumi.set(__self__, "i_p_set_reference_statement", i_p_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if managed_rule_group_statement is not None:
            pulumi.set(__self__, "managed_rule_group_statement", managed_rule_group_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if rule_group_reference_statement is not None:
            pulumi.set(__self__, "rule_group_reference_statement", rule_group_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.WebACLAndStatement']:
        return pulumi.get(self, "and_statement")

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.WebACLByteMatchStatement']:
        return pulumi.get(self, "byte_match_statement")

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.WebACLGeoMatchStatement']:
        return pulumi.get(self, "geo_match_statement")

    @property
    @pulumi.getter(name="iPSetReferenceStatement")
    def i_p_set_reference_statement(self) -> Optional['outputs.WebACLIPSetReferenceStatement']:
        return pulumi.get(self, "i_p_set_reference_statement")

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.WebACLLabelMatchStatement']:
        return pulumi.get(self, "label_match_statement")

    @property
    @pulumi.getter(name="managedRuleGroupStatement")
    def managed_rule_group_statement(self) -> Optional['outputs.WebACLManagedRuleGroupStatement']:
        return pulumi.get(self, "managed_rule_group_statement")

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.WebACLNotStatement']:
        return pulumi.get(self, "not_statement")

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.WebACLOrStatement']:
        return pulumi.get(self, "or_statement")

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional['outputs.WebACLRateBasedStatement']:
        return pulumi.get(self, "rate_based_statement")

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.WebACLRegexMatchStatement']:
        return pulumi.get(self, "regex_match_statement")

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.WebACLRegexPatternSetReferenceStatement']:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @property
    @pulumi.getter(name="ruleGroupReferenceStatement")
    def rule_group_reference_statement(self) -> Optional['outputs.WebACLRuleGroupReferenceStatement']:
        return pulumi.get(self, "rule_group_reference_statement")

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.WebACLSizeConstraintStatement']:
        return pulumi.get(self, "size_constraint_statement")

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.WebACLSqliMatchStatement']:
        return pulumi.get(self, "sqli_match_statement")

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.WebACLXssMatchStatement']:
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class WebACLTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebACLTextTransformation(dict):
    """
    Text Transformation on the Search String before match.
    """
    def __init__(__self__, *,
                 priority: int,
                 type: 'WebACLTextTransformationType'):
        """
        Text Transformation on the Search String before match.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> 'WebACLTextTransformationType':
        return pulumi.get(self, "type")


@pulumi.output_type
class WebACLVisibilityConfig(dict):
    """
    Visibility Metric of the WebACL.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchMetricsEnabled":
            suggest = "cloud_watch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_metrics_enabled: bool,
                 metric_name: str,
                 sampled_requests_enabled: bool):
        """
        Visibility Metric of the WebACL.
        """
        pulumi.set(__self__, "cloud_watch_metrics_enabled", cloud_watch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudWatchMetricsEnabled")
    def cloud_watch_metrics_enabled(self) -> bool:
        return pulumi.get(self, "cloud_watch_metrics_enabled")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> bool:
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class WebACLXssMatchStatement(dict):
    """
    Xss Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        """
        Xss Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


