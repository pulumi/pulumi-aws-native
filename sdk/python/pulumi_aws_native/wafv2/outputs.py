# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'IpSetTag',
    'LoggingConfigurationCondition',
    'LoggingConfigurationConditionActionConditionProperties',
    'LoggingConfigurationConditionLabelNameConditionProperties',
    'LoggingConfigurationFieldToMatch',
    'LoggingConfigurationFieldToMatchJsonBodyProperties',
    'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties',
    'LoggingConfigurationFieldToMatchSingleHeaderProperties',
    'LoggingConfigurationFilter',
    'LoggingFilterProperties',
    'RegexPatternSetTag',
    'RuleGroupAllowAction',
    'RuleGroupAndStatement',
    'RuleGroupBlockAction',
    'RuleGroupBody',
    'RuleGroupByteMatchStatement',
    'RuleGroupCaptchaAction',
    'RuleGroupCaptchaConfig',
    'RuleGroupChallengeAction',
    'RuleGroupChallengeConfig',
    'RuleGroupCookieMatchPattern',
    'RuleGroupCookies',
    'RuleGroupCountAction',
    'RuleGroupCustomHttpHeader',
    'RuleGroupCustomRequestHandling',
    'RuleGroupCustomResponse',
    'RuleGroupCustomResponseBodies',
    'RuleGroupFieldToMatch',
    'RuleGroupFieldToMatchSingleHeaderProperties',
    'RuleGroupFieldToMatchSingleQueryArgumentProperties',
    'RuleGroupForwardedIpConfiguration',
    'RuleGroupGeoMatchStatement',
    'RuleGroupHeaderMatchPattern',
    'RuleGroupHeaders',
    'RuleGroupImmunityTimeProperty',
    'RuleGroupIpSetForwardedIpConfiguration',
    'RuleGroupIpSetReferenceStatement',
    'RuleGroupJsonBody',
    'RuleGroupJsonMatchPattern',
    'RuleGroupLabel',
    'RuleGroupLabelMatchStatement',
    'RuleGroupLabelSummary',
    'RuleGroupNotStatement',
    'RuleGroupOrStatement',
    'RuleGroupRateBasedStatement',
    'RuleGroupRateBasedStatementCustomKey',
    'RuleGroupRateLimitCookie',
    'RuleGroupRateLimitForwardedIp',
    'RuleGroupRateLimitHeader',
    'RuleGroupRateLimitHttpMethod',
    'RuleGroupRateLimitIp',
    'RuleGroupRateLimitLabelNamespace',
    'RuleGroupRateLimitQueryArgument',
    'RuleGroupRateLimitQueryString',
    'RuleGroupRateLimitUriPath',
    'RuleGroupRegexMatchStatement',
    'RuleGroupRegexPatternSetReferenceStatement',
    'RuleGroupRule',
    'RuleGroupRuleAction',
    'RuleGroupSizeConstraintStatement',
    'RuleGroupSqliMatchStatement',
    'RuleGroupStatement',
    'RuleGroupTag',
    'RuleGroupTextTransformation',
    'RuleGroupVisibilityConfig',
    'RuleGroupXssMatchStatement',
    'WebAclAllowAction',
    'WebAclAndStatement',
    'WebAclAssociationConfig',
    'WebAclAwsManagedRulesAcfpRuleSet',
    'WebAclAwsManagedRulesAtpRuleSet',
    'WebAclAwsManagedRulesBotControlRuleSet',
    'WebAclBlockAction',
    'WebAclBody',
    'WebAclByteMatchStatement',
    'WebAclCaptchaAction',
    'WebAclCaptchaConfig',
    'WebAclChallengeAction',
    'WebAclChallengeConfig',
    'WebAclCookieMatchPattern',
    'WebAclCookies',
    'WebAclCountAction',
    'WebAclCustomHttpHeader',
    'WebAclCustomRequestHandling',
    'WebAclCustomResponse',
    'WebAclCustomResponseBodies',
    'WebAclDefaultAction',
    'WebAclExcludedRule',
    'WebAclFieldIdentifier',
    'WebAclFieldToMatch',
    'WebAclFieldToMatchSingleHeaderProperties',
    'WebAclFieldToMatchSingleQueryArgumentProperties',
    'WebAclForwardedIpConfiguration',
    'WebAclGeoMatchStatement',
    'WebAclHeaderMatchPattern',
    'WebAclHeaders',
    'WebAclImmunityTimeProperty',
    'WebAclIpSetForwardedIpConfiguration',
    'WebAclIpSetReferenceStatement',
    'WebAclJsonBody',
    'WebAclJsonMatchPattern',
    'WebAclLabel',
    'WebAclLabelMatchStatement',
    'WebAclManagedRuleGroupConfig',
    'WebAclManagedRuleGroupStatement',
    'WebAclNotStatement',
    'WebAclOrStatement',
    'WebAclOverrideAction',
    'WebAclRateBasedStatement',
    'WebAclRateBasedStatementCustomKey',
    'WebAclRateLimitCookie',
    'WebAclRateLimitForwardedIp',
    'WebAclRateLimitHeader',
    'WebAclRateLimitHttpMethod',
    'WebAclRateLimitIp',
    'WebAclRateLimitLabelNamespace',
    'WebAclRateLimitQueryArgument',
    'WebAclRateLimitQueryString',
    'WebAclRateLimitUriPath',
    'WebAclRegexMatchStatement',
    'WebAclRegexPatternSetReferenceStatement',
    'WebAclRequestBody',
    'WebAclRequestInspection',
    'WebAclRequestInspectionAcfp',
    'WebAclResponseInspection',
    'WebAclResponseInspectionBodyContains',
    'WebAclResponseInspectionHeader',
    'WebAclResponseInspectionJson',
    'WebAclResponseInspectionStatusCode',
    'WebAclRule',
    'WebAclRuleAction',
    'WebAclRuleActionOverride',
    'WebAclRuleGroupReferenceStatement',
    'WebAclSizeConstraintStatement',
    'WebAclSqliMatchStatement',
    'WebAclStatement',
    'WebAclTag',
    'WebAclTextTransformation',
    'WebAclVisibilityConfig',
    'WebAclXssMatchStatement',
]

@pulumi.output_type
class IpSetTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        IpSetTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class LoggingConfigurationCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionCondition":
            suggest = "action_condition"
        elif key == "labelNameCondition":
            suggest = "label_name_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_condition: Optional['outputs.LoggingConfigurationConditionActionConditionProperties'] = None,
                 label_name_condition: Optional['outputs.LoggingConfigurationConditionLabelNameConditionProperties'] = None):
        """
        :param 'LoggingConfigurationConditionActionConditionProperties' action_condition: A single action condition.
        :param 'LoggingConfigurationConditionLabelNameConditionProperties' label_name_condition: A single label name condition.
        """
        LoggingConfigurationCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_condition=action_condition,
            label_name_condition=label_name_condition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_condition: Optional['outputs.LoggingConfigurationConditionActionConditionProperties'] = None,
             label_name_condition: Optional['outputs.LoggingConfigurationConditionLabelNameConditionProperties'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_condition is None and 'actionCondition' in kwargs:
            action_condition = kwargs['actionCondition']
        if label_name_condition is None and 'labelNameCondition' in kwargs:
            label_name_condition = kwargs['labelNameCondition']

        if action_condition is not None:
            _setter("action_condition", action_condition)
        if label_name_condition is not None:
            _setter("label_name_condition", label_name_condition)

    @property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional['outputs.LoggingConfigurationConditionActionConditionProperties']:
        """
        A single action condition.
        """
        return pulumi.get(self, "action_condition")

    @property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional['outputs.LoggingConfigurationConditionLabelNameConditionProperties']:
        """
        A single label name condition.
        """
        return pulumi.get(self, "label_name_condition")


@pulumi.output_type
class LoggingConfigurationConditionActionConditionProperties(dict):
    """
    A single action condition.
    """
    def __init__(__self__, *,
                 action: 'LoggingConfigurationConditionActionConditionPropertiesAction'):
        """
        A single action condition.
        :param 'LoggingConfigurationConditionActionConditionPropertiesAction' action: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        LoggingConfigurationConditionActionConditionProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional['LoggingConfigurationConditionActionConditionPropertiesAction'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")

        _setter("action", action)

    @property
    @pulumi.getter
    def action(self) -> 'LoggingConfigurationConditionActionConditionPropertiesAction':
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class LoggingConfigurationConditionLabelNameConditionProperties(dict):
    """
    A single label name condition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelName":
            suggest = "label_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationConditionLabelNameConditionProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationConditionLabelNameConditionProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationConditionLabelNameConditionProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_name: str):
        """
        A single label name condition.
        :param str label_name: The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
        """
        LoggingConfigurationConditionLabelNameConditionProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_name=label_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if label_name is None and 'labelName' in kwargs:
            label_name = kwargs['labelName']
        if label_name is None:
            raise TypeError("Missing 'label_name' argument")

        _setter("label_name", label_name)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> str:
        """
        The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
        """
        return pulumi.get(self, "label_name")


@pulumi.output_type
class LoggingConfigurationFieldToMatch(dict):
    """
    A key-value pair to associate with a resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_body: Optional['outputs.LoggingConfigurationFieldToMatchJsonBodyProperties'] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional['outputs.LoggingConfigurationFieldToMatchSingleHeaderProperties'] = None,
                 uri_path: Optional[Any] = None):
        """
        A key-value pair to associate with a resource.
        :param 'LoggingConfigurationFieldToMatchJsonBodyProperties' json_body: Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        :param Any method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
        :param Any query_string: Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
        :param 'LoggingConfigurationFieldToMatchSingleHeaderProperties' single_header: Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        :param Any uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
        """
        LoggingConfigurationFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             json_body: Optional['outputs.LoggingConfigurationFieldToMatchJsonBodyProperties'] = None,
             method: Optional[Any] = None,
             query_string: Optional[Any] = None,
             single_header: Optional['outputs.LoggingConfigurationFieldToMatchSingleHeaderProperties'] = None,
             uri_path: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.LoggingConfigurationFieldToMatchJsonBodyProperties']:
        """
        Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.LoggingConfigurationFieldToMatchSingleHeaderProperties']:
        """
        Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class LoggingConfigurationFieldToMatchJsonBodyProperties(dict):
    """
    Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationFieldToMatchJsonBodyProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties',
                 match_scope: 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope',
                 invalid_fallback_behavior: Optional['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior'] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        :param 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties' match_pattern: The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        :param 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope' match_scope: The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
        :param 'LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior' invalid_fallback_behavior: What AWS WAF should do if it fails to completely parse the JSON body.
        """
        LoggingConfigurationFieldToMatchJsonBodyProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties'] = None,
             match_scope: Optional['LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope'] = None,
             invalid_fallback_behavior: Optional['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties':
        """
        The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope':
        """
        The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior']:
        """
        What AWS WAF should do if it fails to completely parse the JSON body.
        """
        return pulumi.get(self, "invalid_fallback_behavior")


@pulumi.output_type
class LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties(dict):
    """
    The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        :param Any all: Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
        :param Sequence[str] included_paths: Match only the specified include paths. See also MatchScope in JsonBody.
        """
        LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional[Any] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        """
        Match only the specified include paths. See also MatchScope in JsonBody.
        """
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class LoggingConfigurationFieldToMatchSingleHeaderProperties(dict):
    """
    Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
    """
    def __init__(__self__, *,
                 name: str):
        """
        Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        :param str name: The name of the query header to inspect.
        """
        LoggingConfigurationFieldToMatchSingleHeaderProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LoggingConfigurationFilter(dict):
    def __init__(__self__, *,
                 behavior: 'LoggingConfigurationFilterBehavior',
                 conditions: Sequence['outputs.LoggingConfigurationCondition'],
                 requirement: 'LoggingConfigurationFilterRequirement'):
        """
        :param 'LoggingConfigurationFilterBehavior' behavior: How to handle logs that satisfy the filter's conditions and requirement. 
        :param Sequence['LoggingConfigurationCondition'] conditions: Match conditions for the filter.
        :param 'LoggingConfigurationFilterRequirement' requirement: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        LoggingConfigurationFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            behavior=behavior,
            conditions=conditions,
            requirement=requirement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             behavior: Optional['LoggingConfigurationFilterBehavior'] = None,
             conditions: Optional[Sequence['outputs.LoggingConfigurationCondition']] = None,
             requirement: Optional['LoggingConfigurationFilterRequirement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if behavior is None:
            raise TypeError("Missing 'behavior' argument")
        if conditions is None:
            raise TypeError("Missing 'conditions' argument")
        if requirement is None:
            raise TypeError("Missing 'requirement' argument")

        _setter("behavior", behavior)
        _setter("conditions", conditions)
        _setter("requirement", requirement)

    @property
    @pulumi.getter
    def behavior(self) -> 'LoggingConfigurationFilterBehavior':
        """
        How to handle logs that satisfy the filter's conditions and requirement. 
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.LoggingConfigurationCondition']:
        """
        Match conditions for the filter.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def requirement(self) -> 'LoggingConfigurationFilterRequirement':
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "requirement")


@pulumi.output_type
class LoggingFilterProperties(dict):
    """
    Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBehavior":
            suggest = "default_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingFilterProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingFilterProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingFilterProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_behavior: 'LoggingConfigurationLoggingFilterPropertiesDefaultBehavior',
                 filters: Sequence['outputs.LoggingConfigurationFilter']):
        """
        Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
        :param 'LoggingConfigurationLoggingFilterPropertiesDefaultBehavior' default_behavior: Default handling for logs that don't match any of the specified filtering conditions.
        :param Sequence['LoggingConfigurationFilter'] filters: The filters that you want to apply to the logs.
        """
        LoggingFilterProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_behavior=default_behavior,
            filters=filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_behavior: Optional['LoggingConfigurationLoggingFilterPropertiesDefaultBehavior'] = None,
             filters: Optional[Sequence['outputs.LoggingConfigurationFilter']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_behavior is None and 'defaultBehavior' in kwargs:
            default_behavior = kwargs['defaultBehavior']
        if default_behavior is None:
            raise TypeError("Missing 'default_behavior' argument")
        if filters is None:
            raise TypeError("Missing 'filters' argument")

        _setter("default_behavior", default_behavior)
        _setter("filters", filters)

    @property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> 'LoggingConfigurationLoggingFilterPropertiesDefaultBehavior':
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        """
        return pulumi.get(self, "default_behavior")

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.LoggingConfigurationFilter']:
        """
        The filters that you want to apply to the logs.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class RegexPatternSetTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        RegexPatternSetTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupAllowAction(dict):
    """
    Allow traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupAllowAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupAllowAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupAllowAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None):
        """
        Allow traffic towards application.
        """
        RuleGroupAllowAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupStatement']):
        RuleGroupAndStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.RuleGroupStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupBlockAction(dict):
    """
    Block traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupBlockAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupBlockAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupBlockAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.RuleGroupCustomResponse'] = None):
        """
        Block traffic towards application.
        """
        RuleGroupBlockAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_response=custom_response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_response: Optional['outputs.RuleGroupCustomResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_response is None and 'customResponse' in kwargs:
            custom_response = kwargs['customResponse']

        if custom_response is not None:
            _setter("custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.RuleGroupCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class RuleGroupBody(dict):
    """
    The body of a web request. This immediately follows the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional['RuleGroupOversizeHandling'] = None):
        """
        The body of a web request. This immediately follows the request headers.
        """
        RuleGroupBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional['RuleGroupOversizeHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional['RuleGroupOversizeHandling']:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupByteMatchStatement(dict):
    """
    Byte Match statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "searchStringBase64":
            suggest = "search_string_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 positional_constraint: 'RuleGroupPositionalConstraint',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation'],
                 search_string: Optional[str] = None,
                 search_string_base64: Optional[str] = None):
        """
        Byte Match statement.
        """
        RuleGroupByteMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_to_match=field_to_match,
            positional_constraint=positional_constraint,
            text_transformations=text_transformations,
            search_string=search_string,
            search_string_base64=search_string_base64,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_to_match: Optional['outputs.RuleGroupFieldToMatch'] = None,
             positional_constraint: Optional['RuleGroupPositionalConstraint'] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupTextTransformation']] = None,
             search_string: Optional[str] = None,
             search_string_base64: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if positional_constraint is None and 'positionalConstraint' in kwargs:
            positional_constraint = kwargs['positionalConstraint']
        if positional_constraint is None:
            raise TypeError("Missing 'positional_constraint' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if search_string is None and 'searchString' in kwargs:
            search_string = kwargs['searchString']
        if search_string_base64 is None and 'searchStringBase64' in kwargs:
            search_string_base64 = kwargs['searchStringBase64']

        _setter("field_to_match", field_to_match)
        _setter("positional_constraint", positional_constraint)
        _setter("text_transformations", text_transformations)
        if search_string is not None:
            _setter("search_string", search_string)
        if search_string_base64 is not None:
            _setter("search_string_base64", search_string_base64)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> 'RuleGroupPositionalConstraint':
        return pulumi.get(self, "positional_constraint")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> Optional[str]:
        return pulumi.get(self, "search_string")

    @property
    @pulumi.getter(name="searchStringBase64")
    def search_string_base64(self) -> Optional[str]:
        return pulumi.get(self, "search_string_base64")


@pulumi.output_type
class RuleGroupCaptchaAction(dict):
    """
    Checks valid token exists with request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCaptchaAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCaptchaAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCaptchaAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None):
        """
        Checks valid token exists with request.
        """
        RuleGroupCaptchaAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.RuleGroupImmunityTimeProperty'] = None):
        RuleGroupCaptchaConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time_property=immunity_time_property,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time_property: Optional['outputs.RuleGroupImmunityTimeProperty'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time_property is None and 'immunityTimeProperty' in kwargs:
            immunity_time_property = kwargs['immunityTimeProperty']

        if immunity_time_property is not None:
            _setter("immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.RuleGroupImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class RuleGroupChallengeAction(dict):
    """
    Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupChallengeAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupChallengeAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupChallengeAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None):
        """
        Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
        """
        RuleGroupChallengeAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupChallengeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupChallengeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupChallengeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupChallengeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.RuleGroupImmunityTimeProperty'] = None):
        RuleGroupChallengeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time_property=immunity_time_property,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time_property: Optional['outputs.RuleGroupImmunityTimeProperty'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time_property is None and 'immunityTimeProperty' in kwargs:
            immunity_time_property = kwargs['immunityTimeProperty']

        if immunity_time_property is not None:
            _setter("immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.RuleGroupImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class RuleGroupCookieMatchPattern(dict):
    """
    The pattern to look for in the request cookies.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCookieMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCookieMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCookieMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the request cookies.
        :param Any all: Inspect all parts of the web request cookies.
        """
        RuleGroupCookieMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional[Any] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request cookies.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupCookies(dict):
    """
    Includes headers of a web request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupCookieMatchPattern',
                 match_scope: 'RuleGroupMapMatchScope',
                 oversize_handling: 'RuleGroupOversizeHandling'):
        """
        Includes headers of a web request.
        """
        RuleGroupCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupCookieMatchPattern'] = None,
             match_scope: Optional['RuleGroupMapMatchScope'] = None,
             oversize_handling: Optional['RuleGroupOversizeHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupCookieMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'RuleGroupMapMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> 'RuleGroupOversizeHandling':
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupCountAction(dict):
    """
    Count traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCountAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCountAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCountAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None):
        """
        Count traffic towards application.
        """
        RuleGroupCountAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupCustomHttpHeader(dict):
    """
    HTTP header.
    """
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        HTTP header.
        """
        RuleGroupCustomHttpHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupCustomRequestHandling(dict):
    """
    Custom request handling.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.RuleGroupCustomHttpHeader']):
        """
        Custom request handling.
        :param Sequence['RuleGroupCustomHttpHeader'] insert_headers: Collection of HTTP headers.
        """
        RuleGroupCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.RuleGroupCustomHttpHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.RuleGroupCustomHttpHeader']:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class RuleGroupCustomResponse(dict):
    """
    Custom response.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: int,
                 custom_response_body_key: Optional[str] = None,
                 response_headers: Optional[Sequence['outputs.RuleGroupCustomHttpHeader']] = None):
        """
        Custom response.
        :param str custom_response_body_key: Custom response body key.
        :param Sequence['RuleGroupCustomHttpHeader'] response_headers: Collection of HTTP headers.
        """
        RuleGroupCustomResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            response_code=response_code,
            custom_response_body_key=custom_response_body_key,
            response_headers=response_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             response_code: Optional[int] = None,
             custom_response_body_key: Optional[str] = None,
             response_headers: Optional[Sequence['outputs.RuleGroupCustomHttpHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if response_code is None and 'responseCode' in kwargs:
            response_code = kwargs['responseCode']
        if response_code is None:
            raise TypeError("Missing 'response_code' argument")
        if custom_response_body_key is None and 'customResponseBodyKey' in kwargs:
            custom_response_body_key = kwargs['customResponseBodyKey']
        if response_headers is None and 'responseHeaders' in kwargs:
            response_headers = kwargs['responseHeaders']

        _setter("response_code", response_code)
        if custom_response_body_key is not None:
            _setter("custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            _setter("response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> int:
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[str]:
        """
        Custom response body key.
        """
        return pulumi.get(self, "custom_response_body_key")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.RuleGroupCustomHttpHeader']]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class RuleGroupCustomResponseBodies(dict):
    """
    Custom response key and body map.
    """
    def __init__(__self__):
        """
        Custom response key and body map.
        """
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupFieldToMatch(dict):
    """
    Field of the request to match.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional[Any] = None,
                 body: Optional['outputs.RuleGroupBody'] = None,
                 cookies: Optional['outputs.RuleGroupCookies'] = None,
                 headers: Optional['outputs.RuleGroupHeaders'] = None,
                 json_body: Optional['outputs.RuleGroupJsonBody'] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional['outputs.RuleGroupFieldToMatchSingleHeaderProperties'] = None,
                 single_query_argument: Optional['outputs.RuleGroupFieldToMatchSingleQueryArgumentProperties'] = None,
                 uri_path: Optional[Any] = None):
        """
        Field of the request to match.
        :param Any all_query_arguments: All query arguments of a web request.
        :param Any method: The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        :param Any query_string: The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        :param 'RuleGroupFieldToMatchSingleQueryArgumentProperties' single_query_argument: One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        :param Any uri_path: The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        RuleGroupFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional[Any] = None,
             body: Optional['outputs.RuleGroupBody'] = None,
             cookies: Optional['outputs.RuleGroupCookies'] = None,
             headers: Optional['outputs.RuleGroupHeaders'] = None,
             json_body: Optional['outputs.RuleGroupJsonBody'] = None,
             method: Optional[Any] = None,
             query_string: Optional[Any] = None,
             single_header: Optional['outputs.RuleGroupFieldToMatchSingleHeaderProperties'] = None,
             single_query_argument: Optional['outputs.RuleGroupFieldToMatchSingleQueryArgumentProperties'] = None,
             uri_path: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[Any]:
        """
        All query arguments of a web request.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupBody']:
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupCookies']:
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.RuleGroupHeaders']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupJsonBody']:
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupFieldToMatchSingleHeaderProperties']:
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupFieldToMatchSingleQueryArgumentProperties']:
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupFieldToMatchSingleHeaderProperties(dict):
    def __init__(__self__, *,
                 name: str):
        RuleGroupFieldToMatchSingleHeaderProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupFieldToMatchSingleQueryArgumentProperties(dict):
    """
    One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
    """
    def __init__(__self__, *,
                 name: str):
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        RuleGroupFieldToMatchSingleQueryArgumentProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupForwardedIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupForwardedIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupForwardedIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupForwardedIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'RuleGroupForwardedIpConfigurationFallbackBehavior',
                 header_name: str):
        RuleGroupForwardedIpConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional['RuleGroupForwardedIpConfigurationFallbackBehavior'] = None,
             header_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'RuleGroupForwardedIpConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class RuleGroupGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Optional[Sequence[str]] = None,
                 forwarded_ip_config: Optional['outputs.RuleGroupForwardedIpConfiguration'] = None):
        RuleGroupGeoMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country_codes=country_codes,
            forwarded_ip_config=forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country_codes: Optional[Sequence[str]] = None,
             forwarded_ip_config: Optional['outputs.RuleGroupForwardedIpConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if country_codes is None and 'countryCodes' in kwargs:
            country_codes = kwargs['countryCodes']
        if forwarded_ip_config is None and 'forwardedIpConfig' in kwargs:
            forwarded_ip_config = kwargs['forwardedIpConfig']

        if country_codes is not None:
            _setter("country_codes", country_codes)
        if forwarded_ip_config is not None:
            _setter("forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupForwardedIpConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class RuleGroupHeaderMatchPattern(dict):
    """
    The pattern to look for in the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the request headers.
        :param Any all: Inspect all parts of the web request headers.
        """
        RuleGroupHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional[Any] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupHeaders(dict):
    """
    Includes headers of a web request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupHeaderMatchPattern',
                 match_scope: 'RuleGroupMapMatchScope',
                 oversize_handling: 'RuleGroupOversizeHandling'):
        """
        Includes headers of a web request.
        """
        RuleGroupHeaders._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupHeaderMatchPattern'] = None,
             match_scope: Optional['RuleGroupMapMatchScope'] = None,
             oversize_handling: Optional['RuleGroupOversizeHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'RuleGroupMapMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> 'RuleGroupOversizeHandling':
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: int):
        RuleGroupImmunityTimeProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time=immunity_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time is None and 'immunityTime' in kwargs:
            immunity_time = kwargs['immunityTime']
        if immunity_time is None:
            raise TypeError("Missing 'immunity_time' argument")

        _setter("immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> int:
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class RuleGroupIpSetForwardedIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupIpSetForwardedIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupIpSetForwardedIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupIpSetForwardedIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'RuleGroupIpSetForwardedIpConfigurationFallbackBehavior',
                 header_name: str,
                 position: 'RuleGroupIpSetForwardedIpConfigurationPosition'):
        RuleGroupIpSetForwardedIpConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
            position=position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional['RuleGroupIpSetForwardedIpConfigurationFallbackBehavior'] = None,
             header_name: Optional[str] = None,
             position: Optional['RuleGroupIpSetForwardedIpConfigurationPosition'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")
        if position is None:
            raise TypeError("Missing 'position' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)
        _setter("position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'RuleGroupIpSetForwardedIpConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def position(self) -> 'RuleGroupIpSetForwardedIpConfigurationPosition':
        return pulumi.get(self, "position")


@pulumi.output_type
class RuleGroupIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 ip_set_forwarded_ip_config: Optional['outputs.RuleGroupIpSetForwardedIpConfiguration'] = None):
        RuleGroupIpSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            ip_set_forwarded_ip_config=ip_set_forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             ip_set_forwarded_ip_config: Optional['outputs.RuleGroupIpSetForwardedIpConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if ip_set_forwarded_ip_config is None and 'ipSetForwardedIpConfig' in kwargs:
            ip_set_forwarded_ip_config = kwargs['ipSetForwardedIpConfig']

        _setter("arn", arn)
        if ip_set_forwarded_ip_config is not None:
            _setter("ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.RuleGroupIpSetForwardedIpConfiguration']:
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class RuleGroupJsonBody(dict):
    """
    Inspect the request body as JSON. The request body immediately follows the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupJsonMatchPattern',
                 match_scope: 'RuleGroupJsonMatchScope',
                 invalid_fallback_behavior: Optional['RuleGroupBodyParsingFallbackBehavior'] = None,
                 oversize_handling: Optional['RuleGroupOversizeHandling'] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers.
        """
        RuleGroupJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupJsonMatchPattern'] = None,
             match_scope: Optional['RuleGroupJsonMatchScope'] = None,
             invalid_fallback_behavior: Optional['RuleGroupBodyParsingFallbackBehavior'] = None,
             oversize_handling: Optional['RuleGroupOversizeHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupJsonMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'RuleGroupJsonMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional['RuleGroupBodyParsingFallbackBehavior']:
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional['RuleGroupOversizeHandling']:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupJsonMatchPattern(dict):
    """
    The pattern to look for in the JSON body.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupJsonMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupJsonMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupJsonMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the JSON body.
        :param Any all: Inspect all parts of the web request's JSON body.
        """
        RuleGroupJsonMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional[Any] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request's JSON body.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupLabel(dict):
    def __init__(__self__, *,
                 name: str):
        RuleGroupLabel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: str,
                 scope: 'RuleGroupLabelMatchScope'):
        RuleGroupLabelMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             scope: Optional['RuleGroupLabelMatchScope'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if scope is None:
            raise TypeError("Missing 'scope' argument")

        _setter("key", key)
        _setter("scope", scope)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def scope(self) -> 'RuleGroupLabelMatchScope':
        return pulumi.get(self, "scope")


@pulumi.output_type
class RuleGroupLabelSummary(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        RuleGroupLabelSummary._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupNotStatement(dict):
    def __init__(__self__, *,
                 statement: 'outputs.RuleGroupStatement'):
        RuleGroupNotStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statement=statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statement: Optional['outputs.RuleGroupStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statement is None:
            raise TypeError("Missing 'statement' argument")

        _setter("statement", statement)

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.RuleGroupStatement':
        return pulumi.get(self, "statement")


@pulumi.output_type
class RuleGroupOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupStatement']):
        RuleGroupOrStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.RuleGroupStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRateBasedStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateKeyType":
            suggest = "aggregate_key_type"
        elif key == "customKeys":
            suggest = "custom_keys"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateBasedStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateBasedStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateBasedStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregate_key_type: 'RuleGroupRateBasedStatementAggregateKeyType',
                 limit: int,
                 custom_keys: Optional[Sequence['outputs.RuleGroupRateBasedStatementCustomKey']] = None,
                 forwarded_ip_config: Optional['outputs.RuleGroupForwardedIpConfiguration'] = None,
                 scope_down_statement: Optional['outputs.RuleGroupStatement'] = None):
        """
        :param Sequence['RuleGroupRateBasedStatementCustomKey'] custom_keys: Specifies the aggregate keys to use in a rate-base rule.
        """
        RuleGroupRateBasedStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregate_key_type=aggregate_key_type,
            limit=limit,
            custom_keys=custom_keys,
            forwarded_ip_config=forwarded_ip_config,
            scope_down_statement=scope_down_statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregate_key_type: Optional['RuleGroupRateBasedStatementAggregateKeyType'] = None,
             limit: Optional[int] = None,
             custom_keys: Optional[Sequence['outputs.RuleGroupRateBasedStatementCustomKey']] = None,
             forwarded_ip_config: Optional['outputs.RuleGroupForwardedIpConfiguration'] = None,
             scope_down_statement: Optional['outputs.RuleGroupStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aggregate_key_type is None and 'aggregateKeyType' in kwargs:
            aggregate_key_type = kwargs['aggregateKeyType']
        if aggregate_key_type is None:
            raise TypeError("Missing 'aggregate_key_type' argument")
        if limit is None:
            raise TypeError("Missing 'limit' argument")
        if custom_keys is None and 'customKeys' in kwargs:
            custom_keys = kwargs['customKeys']
        if forwarded_ip_config is None and 'forwardedIpConfig' in kwargs:
            forwarded_ip_config = kwargs['forwardedIpConfig']
        if scope_down_statement is None and 'scopeDownStatement' in kwargs:
            scope_down_statement = kwargs['scopeDownStatement']

        _setter("aggregate_key_type", aggregate_key_type)
        _setter("limit", limit)
        if custom_keys is not None:
            _setter("custom_keys", custom_keys)
        if forwarded_ip_config is not None:
            _setter("forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            _setter("scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> 'RuleGroupRateBasedStatementAggregateKeyType':
        return pulumi.get(self, "aggregate_key_type")

    @property
    @pulumi.getter
    def limit(self) -> int:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[Sequence['outputs.RuleGroupRateBasedStatementCustomKey']]:
        """
        Specifies the aggregate keys to use in a rate-base rule.
        """
        return pulumi.get(self, "custom_keys")

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupForwardedIpConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.RuleGroupStatement']:
        return pulumi.get(self, "scope_down_statement")


@pulumi.output_type
class RuleGroupRateBasedStatementCustomKey(dict):
    """
    Specifies a single custom aggregate key for a rate-base rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardedIp":
            suggest = "forwarded_ip"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "labelNamespace":
            suggest = "label_namespace"
        elif key == "queryArgument":
            suggest = "query_argument"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateBasedStatementCustomKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateBasedStatementCustomKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateBasedStatementCustomKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional['outputs.RuleGroupRateLimitCookie'] = None,
                 forwarded_ip: Optional['outputs.RuleGroupRateLimitForwardedIp'] = None,
                 header: Optional['outputs.RuleGroupRateLimitHeader'] = None,
                 http_method: Optional['outputs.RuleGroupRateLimitHttpMethod'] = None,
                 ip: Optional['outputs.RuleGroupRateLimitIp'] = None,
                 label_namespace: Optional['outputs.RuleGroupRateLimitLabelNamespace'] = None,
                 query_argument: Optional['outputs.RuleGroupRateLimitQueryArgument'] = None,
                 query_string: Optional['outputs.RuleGroupRateLimitQueryString'] = None,
                 uri_path: Optional['outputs.RuleGroupRateLimitUriPath'] = None):
        """
        Specifies a single custom aggregate key for a rate-base rule.
        """
        RuleGroupRateBasedStatementCustomKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cookie=cookie,
            forwarded_ip=forwarded_ip,
            header=header,
            http_method=http_method,
            ip=ip,
            label_namespace=label_namespace,
            query_argument=query_argument,
            query_string=query_string,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cookie: Optional['outputs.RuleGroupRateLimitCookie'] = None,
             forwarded_ip: Optional['outputs.RuleGroupRateLimitForwardedIp'] = None,
             header: Optional['outputs.RuleGroupRateLimitHeader'] = None,
             http_method: Optional['outputs.RuleGroupRateLimitHttpMethod'] = None,
             ip: Optional['outputs.RuleGroupRateLimitIp'] = None,
             label_namespace: Optional['outputs.RuleGroupRateLimitLabelNamespace'] = None,
             query_argument: Optional['outputs.RuleGroupRateLimitQueryArgument'] = None,
             query_string: Optional['outputs.RuleGroupRateLimitQueryString'] = None,
             uri_path: Optional['outputs.RuleGroupRateLimitUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if forwarded_ip is None and 'forwardedIp' in kwargs:
            forwarded_ip = kwargs['forwardedIp']
        if http_method is None and 'httpMethod' in kwargs:
            http_method = kwargs['httpMethod']
        if label_namespace is None and 'labelNamespace' in kwargs:
            label_namespace = kwargs['labelNamespace']
        if query_argument is None and 'queryArgument' in kwargs:
            query_argument = kwargs['queryArgument']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if cookie is not None:
            _setter("cookie", cookie)
        if forwarded_ip is not None:
            _setter("forwarded_ip", forwarded_ip)
        if header is not None:
            _setter("header", header)
        if http_method is not None:
            _setter("http_method", http_method)
        if ip is not None:
            _setter("ip", ip)
        if label_namespace is not None:
            _setter("label_namespace", label_namespace)
        if query_argument is not None:
            _setter("query_argument", query_argument)
        if query_string is not None:
            _setter("query_string", query_string)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.RuleGroupRateLimitCookie']:
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional['outputs.RuleGroupRateLimitForwardedIp']:
        return pulumi.get(self, "forwarded_ip")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.RuleGroupRateLimitHeader']:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.RuleGroupRateLimitHttpMethod']:
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.RuleGroupRateLimitIp']:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional['outputs.RuleGroupRateLimitLabelNamespace']:
        return pulumi.get(self, "label_namespace")

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional['outputs.RuleGroupRateLimitQueryArgument']:
        return pulumi.get(self, "query_argument")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRateLimitQueryString']:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRateLimitUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRateLimitCookie(dict):
    """
    Specifies a cookie as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateLimitCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateLimitCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateLimitCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Specifies a cookie as an aggregate key for a rate-based rule.
        :param str name: The name of the cookie to use.
        """
        RuleGroupRateLimitCookie._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the cookie to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRateLimitForwardedIp(dict):
    """
    Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
        """
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRateLimitHeader(dict):
    """
    Specifies a header as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateLimitHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateLimitHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateLimitHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Specifies a header as an aggregate key for a rate-based rule.
        :param str name: The name of the header to use.
        """
        RuleGroupRateLimitHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRateLimitHttpMethod(dict):
    """
    Specifies the request's HTTP method as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the request's HTTP method as an aggregate key for a rate-based rule.
        """
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRateLimitIp(dict):
    """
    Specifies the IP address in the web request as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the IP address in the web request as an aggregate key for a rate-based rule.
        """
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRateLimitLabelNamespace(dict):
    """
    Specifies a label namespace to use as an aggregate key for a rate-based rule.
    """
    def __init__(__self__, *,
                 namespace: str):
        """
        Specifies a label namespace to use as an aggregate key for a rate-based rule.
        :param str namespace: The namespace to use for aggregation.
        """
        RuleGroupRateLimitLabelNamespace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            namespace=namespace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             namespace: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")

        _setter("namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace to use for aggregation.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class RuleGroupRateLimitQueryArgument(dict):
    """
    Specifies a query argument in the request as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateLimitQueryArgument. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateLimitQueryArgument.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateLimitQueryArgument.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Specifies a query argument in the request as an aggregate key for a rate-based rule.
        :param str name: The name of the query argument to use.
        """
        RuleGroupRateLimitQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query argument to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRateLimitQueryString(dict):
    """
    Specifies the request's query string as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateLimitQueryString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateLimitQueryString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateLimitQueryString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Specifies the request's query string as an aggregate key for a rate-based rule.
        """
        RuleGroupRateLimitQueryString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.RuleGroupTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRateLimitUriPath(dict):
    """
    Specifies the request's URI Path as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateLimitUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateLimitUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateLimitUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Specifies the request's URI Path as an aggregate key for a rate-based rule.
        """
        RuleGroupRateLimitUriPath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.RuleGroupTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 regex_string: str,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        RuleGroupRegexMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_to_match=field_to_match,
            regex_string=regex_string,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_to_match: Optional['outputs.RuleGroupFieldToMatch'] = None,
             regex_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if regex_string is None and 'regexString' in kwargs:
            regex_string = kwargs['regexString']
        if regex_string is None:
            raise TypeError("Missing 'regex_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("field_to_match", field_to_match)
        _setter("regex_string", regex_string)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        return pulumi.get(self, "regex_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        RuleGroupRegexPatternSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            field_to_match=field_to_match,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             field_to_match: Optional['outputs.RuleGroupFieldToMatch'] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("arn", arn)
        _setter("field_to_match", field_to_match)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRule(dict):
    """
    Rule of RuleGroup that contains condition and action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityConfig":
            suggest = "visibility_config"
        elif key == "captchaConfig":
            suggest = "captcha_config"
        elif key == "challengeConfig":
            suggest = "challenge_config"
        elif key == "ruleLabels":
            suggest = "rule_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 priority: int,
                 statement: 'outputs.RuleGroupStatement',
                 visibility_config: 'outputs.RuleGroupVisibilityConfig',
                 action: Optional['outputs.RuleGroupRuleAction'] = None,
                 captcha_config: Optional['outputs.RuleGroupCaptchaConfig'] = None,
                 challenge_config: Optional['outputs.RuleGroupChallengeConfig'] = None,
                 rule_labels: Optional[Sequence['outputs.RuleGroupLabel']] = None):
        """
        Rule of RuleGroup that contains condition and action.
        :param Sequence['RuleGroupLabel'] rule_labels: Collection of Rule Labels.
        """
        RuleGroupRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            priority=priority,
            statement=statement,
            visibility_config=visibility_config,
            action=action,
            captcha_config=captcha_config,
            challenge_config=challenge_config,
            rule_labels=rule_labels,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             priority: Optional[int] = None,
             statement: Optional['outputs.RuleGroupStatement'] = None,
             visibility_config: Optional['outputs.RuleGroupVisibilityConfig'] = None,
             action: Optional['outputs.RuleGroupRuleAction'] = None,
             captcha_config: Optional['outputs.RuleGroupCaptchaConfig'] = None,
             challenge_config: Optional['outputs.RuleGroupChallengeConfig'] = None,
             rule_labels: Optional[Sequence['outputs.RuleGroupLabel']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if statement is None:
            raise TypeError("Missing 'statement' argument")
        if visibility_config is None and 'visibilityConfig' in kwargs:
            visibility_config = kwargs['visibilityConfig']
        if visibility_config is None:
            raise TypeError("Missing 'visibility_config' argument")
        if captcha_config is None and 'captchaConfig' in kwargs:
            captcha_config = kwargs['captchaConfig']
        if challenge_config is None and 'challengeConfig' in kwargs:
            challenge_config = kwargs['challengeConfig']
        if rule_labels is None and 'ruleLabels' in kwargs:
            rule_labels = kwargs['ruleLabels']

        _setter("name", name)
        _setter("priority", priority)
        _setter("statement", statement)
        _setter("visibility_config", visibility_config)
        if action is not None:
            _setter("action", action)
        if captcha_config is not None:
            _setter("captcha_config", captcha_config)
        if challenge_config is not None:
            _setter("challenge_config", challenge_config)
        if rule_labels is not None:
            _setter("rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.RuleGroupStatement':
        return pulumi.get(self, "statement")

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> 'outputs.RuleGroupVisibilityConfig':
        return pulumi.get(self, "visibility_config")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.RuleGroupRuleAction']:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional['outputs.RuleGroupCaptchaConfig']:
        return pulumi.get(self, "captcha_config")

    @property
    @pulumi.getter(name="challengeConfig")
    def challenge_config(self) -> Optional['outputs.RuleGroupChallengeConfig']:
        return pulumi.get(self, "challenge_config")

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[Sequence['outputs.RuleGroupLabel']]:
        """
        Collection of Rule Labels.
        """
        return pulumi.get(self, "rule_labels")


@pulumi.output_type
class RuleGroupRuleAction(dict):
    """
    Action taken when Rule matches its condition.
    """
    def __init__(__self__, *,
                 allow: Optional['outputs.RuleGroupAllowAction'] = None,
                 block: Optional['outputs.RuleGroupBlockAction'] = None,
                 captcha: Optional['outputs.RuleGroupCaptchaAction'] = None,
                 challenge: Optional['outputs.RuleGroupChallengeAction'] = None,
                 count: Optional['outputs.RuleGroupCountAction'] = None):
        """
        Action taken when Rule matches its condition.
        """
        RuleGroupRuleAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow=allow,
            block=block,
            captcha=captcha,
            challenge=challenge,
            count=count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow: Optional['outputs.RuleGroupAllowAction'] = None,
             block: Optional['outputs.RuleGroupBlockAction'] = None,
             captcha: Optional['outputs.RuleGroupCaptchaAction'] = None,
             challenge: Optional['outputs.RuleGroupChallengeAction'] = None,
             count: Optional['outputs.RuleGroupCountAction'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if allow is not None:
            _setter("allow", allow)
        if block is not None:
            _setter("block", block)
        if captcha is not None:
            _setter("captcha", captcha)
        if challenge is not None:
            _setter("challenge", challenge)
        if count is not None:
            _setter("count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.RuleGroupAllowAction']:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.RuleGroupBlockAction']:
        return pulumi.get(self, "block")

    @property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.RuleGroupCaptchaAction']:
        return pulumi.get(self, "captcha")

    @property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.RuleGroupChallengeAction']:
        return pulumi.get(self, "challenge")

    @property
    @pulumi.getter
    def count(self) -> Optional['outputs.RuleGroupCountAction']:
        return pulumi.get(self, "count")


@pulumi.output_type
class RuleGroupSizeConstraintStatement(dict):
    """
    Size Constraint statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: 'RuleGroupSizeConstraintStatementComparisonOperator',
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 size: float,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Size Constraint statement.
        """
        RuleGroupSizeConstraintStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            field_to_match=field_to_match,
            size=size,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional['RuleGroupSizeConstraintStatementComparisonOperator'] = None,
             field_to_match: Optional['outputs.RuleGroupFieldToMatch'] = None,
             size: Optional[float] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("comparison_operator", comparison_operator)
        _setter("field_to_match", field_to_match)
        _setter("size", size)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> 'RuleGroupSizeConstraintStatementComparisonOperator':
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter
    def size(self) -> float:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupSqliMatchStatement(dict):
    """
    Sqli Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation'],
                 sensitivity_level: Optional['RuleGroupSensitivityLevel'] = None):
        """
        Sqli Match Statement.
        """
        RuleGroupSqliMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_to_match=field_to_match,
            text_transformations=text_transformations,
            sensitivity_level=sensitivity_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_to_match: Optional['outputs.RuleGroupFieldToMatch'] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupTextTransformation']] = None,
             sensitivity_level: Optional['RuleGroupSensitivityLevel'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if sensitivity_level is None and 'sensitivityLevel' in kwargs:
            sensitivity_level = kwargs['sensitivityLevel']

        _setter("field_to_match", field_to_match)
        _setter("text_transformations", text_transformations)
        if sensitivity_level is not None:
            _setter("sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional['RuleGroupSensitivityLevel']:
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RuleGroupStatement(dict):
    """
    First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "rateBasedStatement":
            suggest = "rate_based_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.RuleGroupAndStatement'] = None,
                 byte_match_statement: Optional['outputs.RuleGroupByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.RuleGroupGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.RuleGroupIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.RuleGroupLabelMatchStatement'] = None,
                 not_statement: Optional['outputs.RuleGroupNotStatement'] = None,
                 or_statement: Optional['outputs.RuleGroupOrStatement'] = None,
                 rate_based_statement: Optional['outputs.RuleGroupRateBasedStatement'] = None,
                 regex_match_statement: Optional['outputs.RuleGroupRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.RuleGroupRegexPatternSetReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.RuleGroupSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.RuleGroupSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.RuleGroupXssMatchStatement'] = None):
        """
        First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
        """
        RuleGroupStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            and_statement=and_statement,
            byte_match_statement=byte_match_statement,
            geo_match_statement=geo_match_statement,
            ip_set_reference_statement=ip_set_reference_statement,
            label_match_statement=label_match_statement,
            not_statement=not_statement,
            or_statement=or_statement,
            rate_based_statement=rate_based_statement,
            regex_match_statement=regex_match_statement,
            regex_pattern_set_reference_statement=regex_pattern_set_reference_statement,
            size_constraint_statement=size_constraint_statement,
            sqli_match_statement=sqli_match_statement,
            xss_match_statement=xss_match_statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             and_statement: Optional['outputs.RuleGroupAndStatement'] = None,
             byte_match_statement: Optional['outputs.RuleGroupByteMatchStatement'] = None,
             geo_match_statement: Optional['outputs.RuleGroupGeoMatchStatement'] = None,
             ip_set_reference_statement: Optional['outputs.RuleGroupIpSetReferenceStatement'] = None,
             label_match_statement: Optional['outputs.RuleGroupLabelMatchStatement'] = None,
             not_statement: Optional['outputs.RuleGroupNotStatement'] = None,
             or_statement: Optional['outputs.RuleGroupOrStatement'] = None,
             rate_based_statement: Optional['outputs.RuleGroupRateBasedStatement'] = None,
             regex_match_statement: Optional['outputs.RuleGroupRegexMatchStatement'] = None,
             regex_pattern_set_reference_statement: Optional['outputs.RuleGroupRegexPatternSetReferenceStatement'] = None,
             size_constraint_statement: Optional['outputs.RuleGroupSizeConstraintStatement'] = None,
             sqli_match_statement: Optional['outputs.RuleGroupSqliMatchStatement'] = None,
             xss_match_statement: Optional['outputs.RuleGroupXssMatchStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if and_statement is None and 'andStatement' in kwargs:
            and_statement = kwargs['andStatement']
        if byte_match_statement is None and 'byteMatchStatement' in kwargs:
            byte_match_statement = kwargs['byteMatchStatement']
        if geo_match_statement is None and 'geoMatchStatement' in kwargs:
            geo_match_statement = kwargs['geoMatchStatement']
        if ip_set_reference_statement is None and 'ipSetReferenceStatement' in kwargs:
            ip_set_reference_statement = kwargs['ipSetReferenceStatement']
        if label_match_statement is None and 'labelMatchStatement' in kwargs:
            label_match_statement = kwargs['labelMatchStatement']
        if not_statement is None and 'notStatement' in kwargs:
            not_statement = kwargs['notStatement']
        if or_statement is None and 'orStatement' in kwargs:
            or_statement = kwargs['orStatement']
        if rate_based_statement is None and 'rateBasedStatement' in kwargs:
            rate_based_statement = kwargs['rateBasedStatement']
        if regex_match_statement is None and 'regexMatchStatement' in kwargs:
            regex_match_statement = kwargs['regexMatchStatement']
        if regex_pattern_set_reference_statement is None and 'regexPatternSetReferenceStatement' in kwargs:
            regex_pattern_set_reference_statement = kwargs['regexPatternSetReferenceStatement']
        if size_constraint_statement is None and 'sizeConstraintStatement' in kwargs:
            size_constraint_statement = kwargs['sizeConstraintStatement']
        if sqli_match_statement is None and 'sqliMatchStatement' in kwargs:
            sqli_match_statement = kwargs['sqliMatchStatement']
        if xss_match_statement is None and 'xssMatchStatement' in kwargs:
            xss_match_statement = kwargs['xssMatchStatement']

        if and_statement is not None:
            _setter("and_statement", and_statement)
        if byte_match_statement is not None:
            _setter("byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            _setter("geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            _setter("ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            _setter("label_match_statement", label_match_statement)
        if not_statement is not None:
            _setter("not_statement", not_statement)
        if or_statement is not None:
            _setter("or_statement", or_statement)
        if rate_based_statement is not None:
            _setter("rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            _setter("regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            _setter("regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            _setter("size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            _setter("sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            _setter("xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.RuleGroupAndStatement']:
        return pulumi.get(self, "and_statement")

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.RuleGroupByteMatchStatement']:
        return pulumi.get(self, "byte_match_statement")

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.RuleGroupGeoMatchStatement']:
        return pulumi.get(self, "geo_match_statement")

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.RuleGroupIpSetReferenceStatement']:
        return pulumi.get(self, "ip_set_reference_statement")

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.RuleGroupLabelMatchStatement']:
        return pulumi.get(self, "label_match_statement")

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.RuleGroupNotStatement']:
        return pulumi.get(self, "not_statement")

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.RuleGroupOrStatement']:
        return pulumi.get(self, "or_statement")

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional['outputs.RuleGroupRateBasedStatement']:
        return pulumi.get(self, "rate_based_statement")

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.RuleGroupRegexMatchStatement']:
        return pulumi.get(self, "regex_match_statement")

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.RuleGroupRegexPatternSetReferenceStatement']:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.RuleGroupSizeConstraintStatement']:
        return pulumi.get(self, "size_constraint_statement")

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.RuleGroupSqliMatchStatement']:
        return pulumi.get(self, "sqli_match_statement")

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.RuleGroupXssMatchStatement']:
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class RuleGroupTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        RuleGroupTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupTextTransformation(dict):
    """
    Text Transformation on the Search String before match.
    """
    def __init__(__self__, *,
                 priority: int,
                 type: 'RuleGroupTextTransformationType'):
        """
        Text Transformation on the Search String before match.
        """
        RuleGroupTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional['RuleGroupTextTransformationType'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> 'RuleGroupTextTransformationType':
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupVisibilityConfig(dict):
    """
    Visibility Metric of the RuleGroup.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchMetricsEnabled":
            suggest = "cloud_watch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_metrics_enabled: bool,
                 metric_name: str,
                 sampled_requests_enabled: bool):
        """
        Visibility Metric of the RuleGroup.
        """
        RuleGroupVisibilityConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_watch_metrics_enabled=cloud_watch_metrics_enabled,
            metric_name=metric_name,
            sampled_requests_enabled=sampled_requests_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_watch_metrics_enabled: Optional[bool] = None,
             metric_name: Optional[str] = None,
             sampled_requests_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_watch_metrics_enabled is None and 'cloudWatchMetricsEnabled' in kwargs:
            cloud_watch_metrics_enabled = kwargs['cloudWatchMetricsEnabled']
        if cloud_watch_metrics_enabled is None:
            raise TypeError("Missing 'cloud_watch_metrics_enabled' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if sampled_requests_enabled is None and 'sampledRequestsEnabled' in kwargs:
            sampled_requests_enabled = kwargs['sampledRequestsEnabled']
        if sampled_requests_enabled is None:
            raise TypeError("Missing 'sampled_requests_enabled' argument")

        _setter("cloud_watch_metrics_enabled", cloud_watch_metrics_enabled)
        _setter("metric_name", metric_name)
        _setter("sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudWatchMetricsEnabled")
    def cloud_watch_metrics_enabled(self) -> bool:
        return pulumi.get(self, "cloud_watch_metrics_enabled")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> bool:
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class RuleGroupXssMatchStatement(dict):
    """
    Xss Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Xss Match Statement.
        """
        RuleGroupXssMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_to_match=field_to_match,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_to_match: Optional['outputs.RuleGroupFieldToMatch'] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("field_to_match", field_to_match)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclAllowAction(dict):
    """
    Allow traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAllowAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAllowAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAllowAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclCustomRequestHandling'] = None):
        """
        Allow traffic towards application.
        """
        WebAclAllowAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclStatement']):
        WebAclAndStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.WebAclStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclAssociationConfig(dict):
    """
    AssociationConfig for body inspection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestBody":
            suggest = "request_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAssociationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAssociationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAssociationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_body: Optional['outputs.WebAclRequestBody'] = None):
        """
        AssociationConfig for body inspection
        """
        WebAclAssociationConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            request_body=request_body,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             request_body: Optional['outputs.WebAclRequestBody'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if request_body is None and 'requestBody' in kwargs:
            request_body = kwargs['requestBody']

        if request_body is not None:
            _setter("request_body", request_body)

    @property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional['outputs.WebAclRequestBody']:
        return pulumi.get(self, "request_body")


@pulumi.output_type
class WebAclAwsManagedRulesAcfpRuleSet(dict):
    """
    Configures how to use the Account creation fraud prevention managed rule group in the web ACL
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationPath":
            suggest = "creation_path"
        elif key == "registrationPagePath":
            suggest = "registration_page_path"
        elif key == "requestInspection":
            suggest = "request_inspection"
        elif key == "enableRegexInPath":
            suggest = "enable_regex_in_path"
        elif key == "responseInspection":
            suggest = "response_inspection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAwsManagedRulesAcfpRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAwsManagedRulesAcfpRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAwsManagedRulesAcfpRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_path: str,
                 registration_page_path: str,
                 request_inspection: 'outputs.WebAclRequestInspectionAcfp',
                 enable_regex_in_path: Optional[bool] = None,
                 response_inspection: Optional['outputs.WebAclResponseInspection'] = None):
        """
        Configures how to use the Account creation fraud prevention managed rule group in the web ACL
        """
        WebAclAwsManagedRulesAcfpRuleSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            creation_path=creation_path,
            registration_page_path=registration_page_path,
            request_inspection=request_inspection,
            enable_regex_in_path=enable_regex_in_path,
            response_inspection=response_inspection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             creation_path: Optional[str] = None,
             registration_page_path: Optional[str] = None,
             request_inspection: Optional['outputs.WebAclRequestInspectionAcfp'] = None,
             enable_regex_in_path: Optional[bool] = None,
             response_inspection: Optional['outputs.WebAclResponseInspection'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if creation_path is None and 'creationPath' in kwargs:
            creation_path = kwargs['creationPath']
        if creation_path is None:
            raise TypeError("Missing 'creation_path' argument")
        if registration_page_path is None and 'registrationPagePath' in kwargs:
            registration_page_path = kwargs['registrationPagePath']
        if registration_page_path is None:
            raise TypeError("Missing 'registration_page_path' argument")
        if request_inspection is None and 'requestInspection' in kwargs:
            request_inspection = kwargs['requestInspection']
        if request_inspection is None:
            raise TypeError("Missing 'request_inspection' argument")
        if enable_regex_in_path is None and 'enableRegexInPath' in kwargs:
            enable_regex_in_path = kwargs['enableRegexInPath']
        if response_inspection is None and 'responseInspection' in kwargs:
            response_inspection = kwargs['responseInspection']

        _setter("creation_path", creation_path)
        _setter("registration_page_path", registration_page_path)
        _setter("request_inspection", request_inspection)
        if enable_regex_in_path is not None:
            _setter("enable_regex_in_path", enable_regex_in_path)
        if response_inspection is not None:
            _setter("response_inspection", response_inspection)

    @property
    @pulumi.getter(name="creationPath")
    def creation_path(self) -> str:
        return pulumi.get(self, "creation_path")

    @property
    @pulumi.getter(name="registrationPagePath")
    def registration_page_path(self) -> str:
        return pulumi.get(self, "registration_page_path")

    @property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> 'outputs.WebAclRequestInspectionAcfp':
        return pulumi.get(self, "request_inspection")

    @property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[bool]:
        return pulumi.get(self, "enable_regex_in_path")

    @property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional['outputs.WebAclResponseInspection']:
        return pulumi.get(self, "response_inspection")


@pulumi.output_type
class WebAclAwsManagedRulesAtpRuleSet(dict):
    """
    Configures how to use the Account Takeover Prevention managed rule group in the web ACL
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginPath":
            suggest = "login_path"
        elif key == "enableRegexInPath":
            suggest = "enable_regex_in_path"
        elif key == "requestInspection":
            suggest = "request_inspection"
        elif key == "responseInspection":
            suggest = "response_inspection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAwsManagedRulesAtpRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAwsManagedRulesAtpRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAwsManagedRulesAtpRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_path: str,
                 enable_regex_in_path: Optional[bool] = None,
                 request_inspection: Optional['outputs.WebAclRequestInspection'] = None,
                 response_inspection: Optional['outputs.WebAclResponseInspection'] = None):
        """
        Configures how to use the Account Takeover Prevention managed rule group in the web ACL
        """
        WebAclAwsManagedRulesAtpRuleSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            login_path=login_path,
            enable_regex_in_path=enable_regex_in_path,
            request_inspection=request_inspection,
            response_inspection=response_inspection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             login_path: Optional[str] = None,
             enable_regex_in_path: Optional[bool] = None,
             request_inspection: Optional['outputs.WebAclRequestInspection'] = None,
             response_inspection: Optional['outputs.WebAclResponseInspection'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if login_path is None and 'loginPath' in kwargs:
            login_path = kwargs['loginPath']
        if login_path is None:
            raise TypeError("Missing 'login_path' argument")
        if enable_regex_in_path is None and 'enableRegexInPath' in kwargs:
            enable_regex_in_path = kwargs['enableRegexInPath']
        if request_inspection is None and 'requestInspection' in kwargs:
            request_inspection = kwargs['requestInspection']
        if response_inspection is None and 'responseInspection' in kwargs:
            response_inspection = kwargs['responseInspection']

        _setter("login_path", login_path)
        if enable_regex_in_path is not None:
            _setter("enable_regex_in_path", enable_regex_in_path)
        if request_inspection is not None:
            _setter("request_inspection", request_inspection)
        if response_inspection is not None:
            _setter("response_inspection", response_inspection)

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> str:
        return pulumi.get(self, "login_path")

    @property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[bool]:
        return pulumi.get(self, "enable_regex_in_path")

    @property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> Optional['outputs.WebAclRequestInspection']:
        return pulumi.get(self, "request_inspection")

    @property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional['outputs.WebAclResponseInspection']:
        return pulumi.get(self, "response_inspection")


@pulumi.output_type
class WebAclAwsManagedRulesBotControlRuleSet(dict):
    """
    Configures how to use the Bot Control managed rule group in the web ACL
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectionLevel":
            suggest = "inspection_level"
        elif key == "enableMachineLearning":
            suggest = "enable_machine_learning"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAwsManagedRulesBotControlRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAwsManagedRulesBotControlRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAwsManagedRulesBotControlRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspection_level: 'WebAclAwsManagedRulesBotControlRuleSetInspectionLevel',
                 enable_machine_learning: Optional[bool] = None):
        """
        Configures how to use the Bot Control managed rule group in the web ACL
        """
        WebAclAwsManagedRulesBotControlRuleSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            inspection_level=inspection_level,
            enable_machine_learning=enable_machine_learning,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             inspection_level: Optional['WebAclAwsManagedRulesBotControlRuleSetInspectionLevel'] = None,
             enable_machine_learning: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if inspection_level is None and 'inspectionLevel' in kwargs:
            inspection_level = kwargs['inspectionLevel']
        if inspection_level is None:
            raise TypeError("Missing 'inspection_level' argument")
        if enable_machine_learning is None and 'enableMachineLearning' in kwargs:
            enable_machine_learning = kwargs['enableMachineLearning']

        _setter("inspection_level", inspection_level)
        if enable_machine_learning is not None:
            _setter("enable_machine_learning", enable_machine_learning)

    @property
    @pulumi.getter(name="inspectionLevel")
    def inspection_level(self) -> 'WebAclAwsManagedRulesBotControlRuleSetInspectionLevel':
        return pulumi.get(self, "inspection_level")

    @property
    @pulumi.getter(name="enableMachineLearning")
    def enable_machine_learning(self) -> Optional[bool]:
        return pulumi.get(self, "enable_machine_learning")


@pulumi.output_type
class WebAclBlockAction(dict):
    """
    Block traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclBlockAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclBlockAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclBlockAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebAclCustomResponse'] = None):
        """
        Block traffic towards application.
        """
        WebAclBlockAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_response=custom_response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_response: Optional['outputs.WebAclCustomResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_response is None and 'customResponse' in kwargs:
            custom_response = kwargs['customResponse']

        if custom_response is not None:
            _setter("custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebAclCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebAclBody(dict):
    """
    The body of a web request. This immediately follows the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional['WebAclOversizeHandling'] = None):
        """
        The body of a web request. This immediately follows the request headers.
        """
        WebAclBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional['WebAclOversizeHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional['WebAclOversizeHandling']:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclByteMatchStatement(dict):
    """
    Byte Match statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "searchStringBase64":
            suggest = "search_string_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebAclFieldToMatch',
                 positional_constraint: 'WebAclPositionalConstraint',
                 text_transformations: Sequence['outputs.WebAclTextTransformation'],
                 search_string: Optional[str] = None,
                 search_string_base64: Optional[str] = None):
        """
        Byte Match statement.
        """
        WebAclByteMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_to_match=field_to_match,
            positional_constraint=positional_constraint,
            text_transformations=text_transformations,
            search_string=search_string,
            search_string_base64=search_string_base64,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_to_match: Optional['outputs.WebAclFieldToMatch'] = None,
             positional_constraint: Optional['WebAclPositionalConstraint'] = None,
             text_transformations: Optional[Sequence['outputs.WebAclTextTransformation']] = None,
             search_string: Optional[str] = None,
             search_string_base64: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if positional_constraint is None and 'positionalConstraint' in kwargs:
            positional_constraint = kwargs['positionalConstraint']
        if positional_constraint is None:
            raise TypeError("Missing 'positional_constraint' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if search_string is None and 'searchString' in kwargs:
            search_string = kwargs['searchString']
        if search_string_base64 is None and 'searchStringBase64' in kwargs:
            search_string_base64 = kwargs['searchStringBase64']

        _setter("field_to_match", field_to_match)
        _setter("positional_constraint", positional_constraint)
        _setter("text_transformations", text_transformations)
        if search_string is not None:
            _setter("search_string", search_string)
        if search_string_base64 is not None:
            _setter("search_string_base64", search_string_base64)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebAclFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> 'WebAclPositionalConstraint':
        return pulumi.get(self, "positional_constraint")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> Optional[str]:
        return pulumi.get(self, "search_string")

    @property
    @pulumi.getter(name="searchStringBase64")
    def search_string_base64(self) -> Optional[str]:
        return pulumi.get(self, "search_string_base64")


@pulumi.output_type
class WebAclCaptchaAction(dict):
    """
    Checks valid token exists with request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCaptchaAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCaptchaAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCaptchaAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclCustomRequestHandling'] = None):
        """
        Checks valid token exists with request.
        """
        WebAclCaptchaAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.WebAclImmunityTimeProperty'] = None):
        WebAclCaptchaConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time_property=immunity_time_property,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time_property: Optional['outputs.WebAclImmunityTimeProperty'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time_property is None and 'immunityTimeProperty' in kwargs:
            immunity_time_property = kwargs['immunityTimeProperty']

        if immunity_time_property is not None:
            _setter("immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.WebAclImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class WebAclChallengeAction(dict):
    """
    Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclChallengeAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclChallengeAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclChallengeAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclCustomRequestHandling'] = None):
        """
        Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
        """
        WebAclChallengeAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclChallengeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclChallengeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclChallengeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclChallengeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.WebAclImmunityTimeProperty'] = None):
        WebAclChallengeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time_property=immunity_time_property,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time_property: Optional['outputs.WebAclImmunityTimeProperty'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time_property is None and 'immunityTimeProperty' in kwargs:
            immunity_time_property = kwargs['immunityTimeProperty']

        if immunity_time_property is not None:
            _setter("immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.WebAclImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class WebAclCookieMatchPattern(dict):
    """
    The pattern to look for in the request cookies.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCookieMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCookieMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCookieMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the request cookies.
        :param Any all: Inspect all parts of the web request cookies.
        """
        WebAclCookieMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional[Any] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request cookies.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclCookies(dict):
    """
    Includes headers of a web request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclCookieMatchPattern',
                 match_scope: 'WebAclMapMatchScope',
                 oversize_handling: 'WebAclOversizeHandling'):
        """
        Includes headers of a web request.
        """
        WebAclCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclCookieMatchPattern'] = None,
             match_scope: Optional['WebAclMapMatchScope'] = None,
             oversize_handling: Optional['WebAclOversizeHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclCookieMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'WebAclMapMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> 'WebAclOversizeHandling':
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclCountAction(dict):
    """
    Allow traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCountAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCountAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCountAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclCustomRequestHandling'] = None):
        """
        Allow traffic towards application.
        """
        WebAclCountAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclCustomHttpHeader(dict):
    """
    HTTP header.
    """
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        HTTP header.
        """
        WebAclCustomHttpHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclCustomRequestHandling(dict):
    """
    Custom request handling.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclCustomHttpHeader']):
        """
        Custom request handling.
        :param Sequence['WebAclCustomHttpHeader'] insert_headers: Collection of HTTP headers.
        """
        WebAclCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclCustomHttpHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclCustomHttpHeader']:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclCustomResponse(dict):
    """
    Custom response.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: int,
                 custom_response_body_key: Optional[str] = None,
                 response_headers: Optional[Sequence['outputs.WebAclCustomHttpHeader']] = None):
        """
        Custom response.
        :param str custom_response_body_key: Custom response body key.
        :param Sequence['WebAclCustomHttpHeader'] response_headers: Collection of HTTP headers.
        """
        WebAclCustomResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            response_code=response_code,
            custom_response_body_key=custom_response_body_key,
            response_headers=response_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             response_code: Optional[int] = None,
             custom_response_body_key: Optional[str] = None,
             response_headers: Optional[Sequence['outputs.WebAclCustomHttpHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if response_code is None and 'responseCode' in kwargs:
            response_code = kwargs['responseCode']
        if response_code is None:
            raise TypeError("Missing 'response_code' argument")
        if custom_response_body_key is None and 'customResponseBodyKey' in kwargs:
            custom_response_body_key = kwargs['customResponseBodyKey']
        if response_headers is None and 'responseHeaders' in kwargs:
            response_headers = kwargs['responseHeaders']

        _setter("response_code", response_code)
        if custom_response_body_key is not None:
            _setter("custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            _setter("response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> int:
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[str]:
        """
        Custom response body key.
        """
        return pulumi.get(self, "custom_response_body_key")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebAclCustomHttpHeader']]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebAclCustomResponseBodies(dict):
    """
    Custom response key and body map.
    """
    def __init__(__self__):
        """
        Custom response key and body map.
        """
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclDefaultAction(dict):
    """
    Default Action WebACL will take against ingress traffic when there is no matching Rule.
    """
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclAllowAction'] = None,
                 block: Optional['outputs.WebAclBlockAction'] = None):
        """
        Default Action WebACL will take against ingress traffic when there is no matching Rule.
        """
        WebAclDefaultAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow=allow,
            block=block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow: Optional['outputs.WebAclAllowAction'] = None,
             block: Optional['outputs.WebAclBlockAction'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if allow is not None:
            _setter("allow", allow)
        if block is not None:
            _setter("block", block)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclAllowAction']:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclBlockAction']:
        return pulumi.get(self, "block")


@pulumi.output_type
class WebAclExcludedRule(dict):
    """
    Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
    """
    def __init__(__self__, *,
                 name: str):
        """
        Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
        """
        WebAclExcludedRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclFieldIdentifier(dict):
    def __init__(__self__, *,
                 identifier: str):
        WebAclFieldIdentifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identifier is None:
            raise TypeError("Missing 'identifier' argument")

        _setter("identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclFieldToMatch(dict):
    """
    Field of the request to match.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional[Any] = None,
                 body: Optional['outputs.WebAclBody'] = None,
                 cookies: Optional['outputs.WebAclCookies'] = None,
                 headers: Optional['outputs.WebAclHeaders'] = None,
                 json_body: Optional['outputs.WebAclJsonBody'] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional['outputs.WebAclFieldToMatchSingleHeaderProperties'] = None,
                 single_query_argument: Optional['outputs.WebAclFieldToMatchSingleQueryArgumentProperties'] = None,
                 uri_path: Optional[Any] = None):
        """
        Field of the request to match.
        :param Any all_query_arguments: All query arguments of a web request.
        :param Any method: The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        :param Any query_string: The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        :param 'WebAclFieldToMatchSingleQueryArgumentProperties' single_query_argument: One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        :param Any uri_path: The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        WebAclFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional[Any] = None,
             body: Optional['outputs.WebAclBody'] = None,
             cookies: Optional['outputs.WebAclCookies'] = None,
             headers: Optional['outputs.WebAclHeaders'] = None,
             json_body: Optional['outputs.WebAclJsonBody'] = None,
             method: Optional[Any] = None,
             query_string: Optional[Any] = None,
             single_header: Optional['outputs.WebAclFieldToMatchSingleHeaderProperties'] = None,
             single_query_argument: Optional['outputs.WebAclFieldToMatchSingleQueryArgumentProperties'] = None,
             uri_path: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[Any]:
        """
        All query arguments of a web request.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclBody']:
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclCookies']:
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WebAclHeaders']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclJsonBody']:
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclFieldToMatchSingleHeaderProperties']:
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclFieldToMatchSingleQueryArgumentProperties']:
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclFieldToMatchSingleHeaderProperties(dict):
    def __init__(__self__, *,
                 name: str):
        WebAclFieldToMatchSingleHeaderProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclFieldToMatchSingleQueryArgumentProperties(dict):
    """
    One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
    """
    def __init__(__self__, *,
                 name: str):
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        WebAclFieldToMatchSingleQueryArgumentProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclForwardedIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclForwardedIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclForwardedIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclForwardedIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'WebAclForwardedIpConfigurationFallbackBehavior',
                 header_name: str):
        WebAclForwardedIpConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional['WebAclForwardedIpConfigurationFallbackBehavior'] = None,
             header_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'WebAclForwardedIpConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Optional[Sequence[str]] = None,
                 forwarded_ip_config: Optional['outputs.WebAclForwardedIpConfiguration'] = None):
        WebAclGeoMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country_codes=country_codes,
            forwarded_ip_config=forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country_codes: Optional[Sequence[str]] = None,
             forwarded_ip_config: Optional['outputs.WebAclForwardedIpConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if country_codes is None and 'countryCodes' in kwargs:
            country_codes = kwargs['countryCodes']
        if forwarded_ip_config is None and 'forwardedIpConfig' in kwargs:
            forwarded_ip_config = kwargs['forwardedIpConfig']

        if country_codes is not None:
            _setter("country_codes", country_codes)
        if forwarded_ip_config is not None:
            _setter("forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclForwardedIpConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebAclHeaderMatchPattern(dict):
    """
    The pattern to look for in the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the request headers.
        :param Any all: Inspect all parts of the web request headers.
        """
        WebAclHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional[Any] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclHeaders(dict):
    """
    Includes headers of a web request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclHeaderMatchPattern',
                 match_scope: 'WebAclMapMatchScope',
                 oversize_handling: 'WebAclOversizeHandling'):
        """
        Includes headers of a web request.
        """
        WebAclHeaders._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclHeaderMatchPattern'] = None,
             match_scope: Optional['WebAclMapMatchScope'] = None,
             oversize_handling: Optional['WebAclOversizeHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'WebAclMapMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> 'WebAclOversizeHandling':
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: int):
        WebAclImmunityTimeProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time=immunity_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time is None and 'immunityTime' in kwargs:
            immunity_time = kwargs['immunityTime']
        if immunity_time is None:
            raise TypeError("Missing 'immunity_time' argument")

        _setter("immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> int:
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class WebAclIpSetForwardedIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclIpSetForwardedIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclIpSetForwardedIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclIpSetForwardedIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'WebAclIpSetForwardedIpConfigurationFallbackBehavior',
                 header_name: str,
                 position: 'WebAclIpSetForwardedIpConfigurationPosition'):
        WebAclIpSetForwardedIpConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
            position=position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional['WebAclIpSetForwardedIpConfigurationFallbackBehavior'] = None,
             header_name: Optional[str] = None,
             position: Optional['WebAclIpSetForwardedIpConfigurationPosition'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")
        if position is None:
            raise TypeError("Missing 'position' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)
        _setter("position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'WebAclIpSetForwardedIpConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def position(self) -> 'WebAclIpSetForwardedIpConfigurationPosition':
        return pulumi.get(self, "position")


@pulumi.output_type
class WebAclIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 ip_set_forwarded_ip_config: Optional['outputs.WebAclIpSetForwardedIpConfiguration'] = None):
        WebAclIpSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            ip_set_forwarded_ip_config=ip_set_forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             ip_set_forwarded_ip_config: Optional['outputs.WebAclIpSetForwardedIpConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if ip_set_forwarded_ip_config is None and 'ipSetForwardedIpConfig' in kwargs:
            ip_set_forwarded_ip_config = kwargs['ipSetForwardedIpConfig']

        _setter("arn", arn)
        if ip_set_forwarded_ip_config is not None:
            _setter("ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.WebAclIpSetForwardedIpConfiguration']:
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class WebAclJsonBody(dict):
    """
    Inspect the request body as JSON. The request body immediately follows the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclJsonMatchPattern',
                 match_scope: 'WebAclJsonMatchScope',
                 invalid_fallback_behavior: Optional['WebAclBodyParsingFallbackBehavior'] = None,
                 oversize_handling: Optional['WebAclOversizeHandling'] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers.
        """
        WebAclJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclJsonMatchPattern'] = None,
             match_scope: Optional['WebAclJsonMatchScope'] = None,
             invalid_fallback_behavior: Optional['WebAclBodyParsingFallbackBehavior'] = None,
             oversize_handling: Optional['WebAclOversizeHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclJsonMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'WebAclJsonMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional['WebAclBodyParsingFallbackBehavior']:
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional['WebAclOversizeHandling']:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclJsonMatchPattern(dict):
    """
    The pattern to look for in the JSON body.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclJsonMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclJsonMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclJsonMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the JSON body.
        :param Any all: Inspect all parts of the web request's JSON body.
        """
        WebAclJsonMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional[Any] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request's JSON body.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclLabel(dict):
    def __init__(__self__, *,
                 name: str):
        WebAclLabel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: str,
                 scope: 'WebAclLabelMatchScope'):
        WebAclLabelMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             scope: Optional['WebAclLabelMatchScope'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if scope is None:
            raise TypeError("Missing 'scope' argument")

        _setter("key", key)
        _setter("scope", scope)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def scope(self) -> 'WebAclLabelMatchScope':
        return pulumi.get(self, "scope")


@pulumi.output_type
class WebAclManagedRuleGroupConfig(dict):
    """
    ManagedRuleGroupConfig.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsManagedRulesAcfpRuleSet":
            suggest = "aws_managed_rules_acfp_rule_set"
        elif key == "awsManagedRulesAtpRuleSet":
            suggest = "aws_managed_rules_atp_rule_set"
        elif key == "awsManagedRulesBotControlRuleSet":
            suggest = "aws_managed_rules_bot_control_rule_set"
        elif key == "loginPath":
            suggest = "login_path"
        elif key == "passwordField":
            suggest = "password_field"
        elif key == "payloadType":
            suggest = "payload_type"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclManagedRuleGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclManagedRuleGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclManagedRuleGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_managed_rules_acfp_rule_set: Optional['outputs.WebAclAwsManagedRulesAcfpRuleSet'] = None,
                 aws_managed_rules_atp_rule_set: Optional['outputs.WebAclAwsManagedRulesAtpRuleSet'] = None,
                 aws_managed_rules_bot_control_rule_set: Optional['outputs.WebAclAwsManagedRulesBotControlRuleSet'] = None,
                 login_path: Optional[str] = None,
                 password_field: Optional['outputs.WebAclFieldIdentifier'] = None,
                 payload_type: Optional['WebAclManagedRuleGroupConfigPayloadType'] = None,
                 username_field: Optional['outputs.WebAclFieldIdentifier'] = None):
        """
        ManagedRuleGroupConfig.
        """
        WebAclManagedRuleGroupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_managed_rules_acfp_rule_set=aws_managed_rules_acfp_rule_set,
            aws_managed_rules_atp_rule_set=aws_managed_rules_atp_rule_set,
            aws_managed_rules_bot_control_rule_set=aws_managed_rules_bot_control_rule_set,
            login_path=login_path,
            password_field=password_field,
            payload_type=payload_type,
            username_field=username_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_managed_rules_acfp_rule_set: Optional['outputs.WebAclAwsManagedRulesAcfpRuleSet'] = None,
             aws_managed_rules_atp_rule_set: Optional['outputs.WebAclAwsManagedRulesAtpRuleSet'] = None,
             aws_managed_rules_bot_control_rule_set: Optional['outputs.WebAclAwsManagedRulesBotControlRuleSet'] = None,
             login_path: Optional[str] = None,
             password_field: Optional['outputs.WebAclFieldIdentifier'] = None,
             payload_type: Optional['WebAclManagedRuleGroupConfigPayloadType'] = None,
             username_field: Optional['outputs.WebAclFieldIdentifier'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aws_managed_rules_acfp_rule_set is None and 'awsManagedRulesAcfpRuleSet' in kwargs:
            aws_managed_rules_acfp_rule_set = kwargs['awsManagedRulesAcfpRuleSet']
        if aws_managed_rules_atp_rule_set is None and 'awsManagedRulesAtpRuleSet' in kwargs:
            aws_managed_rules_atp_rule_set = kwargs['awsManagedRulesAtpRuleSet']
        if aws_managed_rules_bot_control_rule_set is None and 'awsManagedRulesBotControlRuleSet' in kwargs:
            aws_managed_rules_bot_control_rule_set = kwargs['awsManagedRulesBotControlRuleSet']
        if login_path is None and 'loginPath' in kwargs:
            login_path = kwargs['loginPath']
        if password_field is None and 'passwordField' in kwargs:
            password_field = kwargs['passwordField']
        if payload_type is None and 'payloadType' in kwargs:
            payload_type = kwargs['payloadType']
        if username_field is None and 'usernameField' in kwargs:
            username_field = kwargs['usernameField']

        if aws_managed_rules_acfp_rule_set is not None:
            _setter("aws_managed_rules_acfp_rule_set", aws_managed_rules_acfp_rule_set)
        if aws_managed_rules_atp_rule_set is not None:
            _setter("aws_managed_rules_atp_rule_set", aws_managed_rules_atp_rule_set)
        if aws_managed_rules_bot_control_rule_set is not None:
            _setter("aws_managed_rules_bot_control_rule_set", aws_managed_rules_bot_control_rule_set)
        if login_path is not None:
            _setter("login_path", login_path)
        if password_field is not None:
            _setter("password_field", password_field)
        if payload_type is not None:
            _setter("payload_type", payload_type)
        if username_field is not None:
            _setter("username_field", username_field)

    @property
    @pulumi.getter(name="awsManagedRulesAcfpRuleSet")
    def aws_managed_rules_acfp_rule_set(self) -> Optional['outputs.WebAclAwsManagedRulesAcfpRuleSet']:
        return pulumi.get(self, "aws_managed_rules_acfp_rule_set")

    @property
    @pulumi.getter(name="awsManagedRulesAtpRuleSet")
    def aws_managed_rules_atp_rule_set(self) -> Optional['outputs.WebAclAwsManagedRulesAtpRuleSet']:
        return pulumi.get(self, "aws_managed_rules_atp_rule_set")

    @property
    @pulumi.getter(name="awsManagedRulesBotControlRuleSet")
    def aws_managed_rules_bot_control_rule_set(self) -> Optional['outputs.WebAclAwsManagedRulesBotControlRuleSet']:
        return pulumi.get(self, "aws_managed_rules_bot_control_rule_set")

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> Optional[str]:
        return pulumi.get(self, "login_path")

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional['outputs.WebAclFieldIdentifier']:
        return pulumi.get(self, "password_field")

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> Optional['WebAclManagedRuleGroupConfigPayloadType']:
        return pulumi.get(self, "payload_type")

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional['outputs.WebAclFieldIdentifier']:
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebAclManagedRuleGroupStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vendorName":
            suggest = "vendor_name"
        elif key == "excludedRules":
            suggest = "excluded_rules"
        elif key == "managedRuleGroupConfigs":
            suggest = "managed_rule_group_configs"
        elif key == "ruleActionOverrides":
            suggest = "rule_action_overrides"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclManagedRuleGroupStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclManagedRuleGroupStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclManagedRuleGroupStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 vendor_name: str,
                 excluded_rules: Optional[Sequence['outputs.WebAclExcludedRule']] = None,
                 managed_rule_group_configs: Optional[Sequence['outputs.WebAclManagedRuleGroupConfig']] = None,
                 rule_action_overrides: Optional[Sequence['outputs.WebAclRuleActionOverride']] = None,
                 scope_down_statement: Optional['outputs.WebAclStatement'] = None,
                 version: Optional[str] = None):
        """
        :param Sequence['WebAclManagedRuleGroupConfig'] managed_rule_group_configs: Collection of ManagedRuleGroupConfig.
        :param Sequence['WebAclRuleActionOverride'] rule_action_overrides: Action overrides for rules in the rule group.
        """
        WebAclManagedRuleGroupStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            vendor_name=vendor_name,
            excluded_rules=excluded_rules,
            managed_rule_group_configs=managed_rule_group_configs,
            rule_action_overrides=rule_action_overrides,
            scope_down_statement=scope_down_statement,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             vendor_name: Optional[str] = None,
             excluded_rules: Optional[Sequence['outputs.WebAclExcludedRule']] = None,
             managed_rule_group_configs: Optional[Sequence['outputs.WebAclManagedRuleGroupConfig']] = None,
             rule_action_overrides: Optional[Sequence['outputs.WebAclRuleActionOverride']] = None,
             scope_down_statement: Optional['outputs.WebAclStatement'] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if vendor_name is None and 'vendorName' in kwargs:
            vendor_name = kwargs['vendorName']
        if vendor_name is None:
            raise TypeError("Missing 'vendor_name' argument")
        if excluded_rules is None and 'excludedRules' in kwargs:
            excluded_rules = kwargs['excludedRules']
        if managed_rule_group_configs is None and 'managedRuleGroupConfigs' in kwargs:
            managed_rule_group_configs = kwargs['managedRuleGroupConfigs']
        if rule_action_overrides is None and 'ruleActionOverrides' in kwargs:
            rule_action_overrides = kwargs['ruleActionOverrides']
        if scope_down_statement is None and 'scopeDownStatement' in kwargs:
            scope_down_statement = kwargs['scopeDownStatement']

        _setter("name", name)
        _setter("vendor_name", vendor_name)
        if excluded_rules is not None:
            _setter("excluded_rules", excluded_rules)
        if managed_rule_group_configs is not None:
            _setter("managed_rule_group_configs", managed_rule_group_configs)
        if rule_action_overrides is not None:
            _setter("rule_action_overrides", rule_action_overrides)
        if scope_down_statement is not None:
            _setter("scope_down_statement", scope_down_statement)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> str:
        return pulumi.get(self, "vendor_name")

    @property
    @pulumi.getter(name="excludedRules")
    def excluded_rules(self) -> Optional[Sequence['outputs.WebAclExcludedRule']]:
        return pulumi.get(self, "excluded_rules")

    @property
    @pulumi.getter(name="managedRuleGroupConfigs")
    def managed_rule_group_configs(self) -> Optional[Sequence['outputs.WebAclManagedRuleGroupConfig']]:
        """
        Collection of ManagedRuleGroupConfig.
        """
        return pulumi.get(self, "managed_rule_group_configs")

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[Sequence['outputs.WebAclRuleActionOverride']]:
        """
        Action overrides for rules in the rule group.
        """
        return pulumi.get(self, "rule_action_overrides")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.WebAclStatement']:
        return pulumi.get(self, "scope_down_statement")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class WebAclNotStatement(dict):
    def __init__(__self__, *,
                 statement: 'outputs.WebAclStatement'):
        WebAclNotStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statement=statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statement: Optional['outputs.WebAclStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statement is None:
            raise TypeError("Missing 'statement' argument")

        _setter("statement", statement)

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.WebAclStatement':
        return pulumi.get(self, "statement")


@pulumi.output_type
class WebAclOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclStatement']):
        WebAclOrStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.WebAclStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclOverrideAction(dict):
    """
    Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
    """
    def __init__(__self__, *,
                 count: Optional[Any] = None,
                 none: Optional[Any] = None):
        """
        Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
        :param Any count: Count traffic towards application.
        :param Any none: Keep the RuleGroup or ManagedRuleGroup behavior as is.
        """
        WebAclOverrideAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            none=none,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[Any] = None,
             none: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if count is not None:
            _setter("count", count)
        if none is not None:
            _setter("none", none)

    @property
    @pulumi.getter
    def count(self) -> Optional[Any]:
        """
        Count traffic towards application.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def none(self) -> Optional[Any]:
        """
        Keep the RuleGroup or ManagedRuleGroup behavior as is.
        """
        return pulumi.get(self, "none")


@pulumi.output_type
class WebAclRateBasedStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateKeyType":
            suggest = "aggregate_key_type"
        elif key == "customKeys":
            suggest = "custom_keys"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRateBasedStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRateBasedStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRateBasedStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregate_key_type: 'WebAclRateBasedStatementAggregateKeyType',
                 limit: int,
                 custom_keys: Optional[Sequence['outputs.WebAclRateBasedStatementCustomKey']] = None,
                 forwarded_ip_config: Optional['outputs.WebAclForwardedIpConfiguration'] = None,
                 scope_down_statement: Optional['outputs.WebAclStatement'] = None):
        """
        :param Sequence['WebAclRateBasedStatementCustomKey'] custom_keys: Specifies the aggregate keys to use in a rate-base rule.
        """
        WebAclRateBasedStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregate_key_type=aggregate_key_type,
            limit=limit,
            custom_keys=custom_keys,
            forwarded_ip_config=forwarded_ip_config,
            scope_down_statement=scope_down_statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregate_key_type: Optional['WebAclRateBasedStatementAggregateKeyType'] = None,
             limit: Optional[int] = None,
             custom_keys: Optional[Sequence['outputs.WebAclRateBasedStatementCustomKey']] = None,
             forwarded_ip_config: Optional['outputs.WebAclForwardedIpConfiguration'] = None,
             scope_down_statement: Optional['outputs.WebAclStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aggregate_key_type is None and 'aggregateKeyType' in kwargs:
            aggregate_key_type = kwargs['aggregateKeyType']
        if aggregate_key_type is None:
            raise TypeError("Missing 'aggregate_key_type' argument")
        if limit is None:
            raise TypeError("Missing 'limit' argument")
        if custom_keys is None and 'customKeys' in kwargs:
            custom_keys = kwargs['customKeys']
        if forwarded_ip_config is None and 'forwardedIpConfig' in kwargs:
            forwarded_ip_config = kwargs['forwardedIpConfig']
        if scope_down_statement is None and 'scopeDownStatement' in kwargs:
            scope_down_statement = kwargs['scopeDownStatement']

        _setter("aggregate_key_type", aggregate_key_type)
        _setter("limit", limit)
        if custom_keys is not None:
            _setter("custom_keys", custom_keys)
        if forwarded_ip_config is not None:
            _setter("forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            _setter("scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> 'WebAclRateBasedStatementAggregateKeyType':
        return pulumi.get(self, "aggregate_key_type")

    @property
    @pulumi.getter
    def limit(self) -> int:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[Sequence['outputs.WebAclRateBasedStatementCustomKey']]:
        """
        Specifies the aggregate keys to use in a rate-base rule.
        """
        return pulumi.get(self, "custom_keys")

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclForwardedIpConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.WebAclStatement']:
        return pulumi.get(self, "scope_down_statement")


@pulumi.output_type
class WebAclRateBasedStatementCustomKey(dict):
    """
    Specifies a single custom aggregate key for a rate-base rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardedIp":
            suggest = "forwarded_ip"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "labelNamespace":
            suggest = "label_namespace"
        elif key == "queryArgument":
            suggest = "query_argument"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRateBasedStatementCustomKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRateBasedStatementCustomKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRateBasedStatementCustomKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional['outputs.WebAclRateLimitCookie'] = None,
                 forwarded_ip: Optional['outputs.WebAclRateLimitForwardedIp'] = None,
                 header: Optional['outputs.WebAclRateLimitHeader'] = None,
                 http_method: Optional['outputs.WebAclRateLimitHttpMethod'] = None,
                 ip: Optional['outputs.WebAclRateLimitIp'] = None,
                 label_namespace: Optional['outputs.WebAclRateLimitLabelNamespace'] = None,
                 query_argument: Optional['outputs.WebAclRateLimitQueryArgument'] = None,
                 query_string: Optional['outputs.WebAclRateLimitQueryString'] = None,
                 uri_path: Optional['outputs.WebAclRateLimitUriPath'] = None):
        """
        Specifies a single custom aggregate key for a rate-base rule.
        """
        WebAclRateBasedStatementCustomKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cookie=cookie,
            forwarded_ip=forwarded_ip,
            header=header,
            http_method=http_method,
            ip=ip,
            label_namespace=label_namespace,
            query_argument=query_argument,
            query_string=query_string,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cookie: Optional['outputs.WebAclRateLimitCookie'] = None,
             forwarded_ip: Optional['outputs.WebAclRateLimitForwardedIp'] = None,
             header: Optional['outputs.WebAclRateLimitHeader'] = None,
             http_method: Optional['outputs.WebAclRateLimitHttpMethod'] = None,
             ip: Optional['outputs.WebAclRateLimitIp'] = None,
             label_namespace: Optional['outputs.WebAclRateLimitLabelNamespace'] = None,
             query_argument: Optional['outputs.WebAclRateLimitQueryArgument'] = None,
             query_string: Optional['outputs.WebAclRateLimitQueryString'] = None,
             uri_path: Optional['outputs.WebAclRateLimitUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if forwarded_ip is None and 'forwardedIp' in kwargs:
            forwarded_ip = kwargs['forwardedIp']
        if http_method is None and 'httpMethod' in kwargs:
            http_method = kwargs['httpMethod']
        if label_namespace is None and 'labelNamespace' in kwargs:
            label_namespace = kwargs['labelNamespace']
        if query_argument is None and 'queryArgument' in kwargs:
            query_argument = kwargs['queryArgument']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if cookie is not None:
            _setter("cookie", cookie)
        if forwarded_ip is not None:
            _setter("forwarded_ip", forwarded_ip)
        if header is not None:
            _setter("header", header)
        if http_method is not None:
            _setter("http_method", http_method)
        if ip is not None:
            _setter("ip", ip)
        if label_namespace is not None:
            _setter("label_namespace", label_namespace)
        if query_argument is not None:
            _setter("query_argument", query_argument)
        if query_string is not None:
            _setter("query_string", query_string)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.WebAclRateLimitCookie']:
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional['outputs.WebAclRateLimitForwardedIp']:
        return pulumi.get(self, "forwarded_ip")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.WebAclRateLimitHeader']:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.WebAclRateLimitHttpMethod']:
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.WebAclRateLimitIp']:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional['outputs.WebAclRateLimitLabelNamespace']:
        return pulumi.get(self, "label_namespace")

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional['outputs.WebAclRateLimitQueryArgument']:
        return pulumi.get(self, "query_argument")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRateLimitQueryString']:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRateLimitUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRateLimitCookie(dict):
    """
    Specifies a cookie as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRateLimitCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRateLimitCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRateLimitCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.WebAclTextTransformation']):
        """
        Specifies a cookie as an aggregate key for a rate-based rule.
        :param str name: The name of the cookie to use.
        """
        WebAclRateLimitCookie._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the cookie to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRateLimitForwardedIp(dict):
    """
    Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
        """
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRateLimitHeader(dict):
    """
    Specifies a header as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRateLimitHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRateLimitHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRateLimitHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.WebAclTextTransformation']):
        """
        Specifies a header as an aggregate key for a rate-based rule.
        :param str name: The name of the header to use.
        """
        WebAclRateLimitHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRateLimitHttpMethod(dict):
    """
    Specifies the request's HTTP method as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the request's HTTP method as an aggregate key for a rate-based rule.
        """
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRateLimitIp(dict):
    """
    Specifies the IP address in the web request as an aggregate key for a rate-based rule.
    """
    def __init__(__self__):
        """
        Specifies the IP address in the web request as an aggregate key for a rate-based rule.
        """
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRateLimitLabelNamespace(dict):
    """
    Specifies a label namespace to use as an aggregate key for a rate-based rule.
    """
    def __init__(__self__, *,
                 namespace: str):
        """
        Specifies a label namespace to use as an aggregate key for a rate-based rule.
        :param str namespace: The namespace to use for aggregation.
        """
        WebAclRateLimitLabelNamespace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            namespace=namespace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             namespace: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")

        _setter("namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace to use for aggregation.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class WebAclRateLimitQueryArgument(dict):
    """
    Specifies a query argument in the request as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRateLimitQueryArgument. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRateLimitQueryArgument.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRateLimitQueryArgument.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.WebAclTextTransformation']):
        """
        Specifies a query argument in the request as an aggregate key for a rate-based rule.
        :param str name: The name of the query argument to use.
        """
        WebAclRateLimitQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query argument to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRateLimitQueryString(dict):
    """
    Specifies the request's query string as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRateLimitQueryString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRateLimitQueryString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRateLimitQueryString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclTextTransformation']):
        """
        Specifies the request's query string as an aggregate key for a rate-based rule.
        """
        WebAclRateLimitQueryString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.WebAclTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRateLimitUriPath(dict):
    """
    Specifies the request's URI Path as an aggregate key for a rate-based rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRateLimitUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRateLimitUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRateLimitUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclTextTransformation']):
        """
        Specifies the request's URI Path as an aggregate key for a rate-based rule.
        """
        WebAclRateLimitUriPath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.WebAclTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebAclFieldToMatch',
                 regex_string: str,
                 text_transformations: Sequence['outputs.WebAclTextTransformation']):
        WebAclRegexMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_to_match=field_to_match,
            regex_string=regex_string,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_to_match: Optional['outputs.WebAclFieldToMatch'] = None,
             regex_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if regex_string is None and 'regexString' in kwargs:
            regex_string = kwargs['regexString']
        if regex_string is None:
            raise TypeError("Missing 'regex_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("field_to_match", field_to_match)
        _setter("regex_string", regex_string)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebAclFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        return pulumi.get(self, "regex_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 field_to_match: 'outputs.WebAclFieldToMatch',
                 text_transformations: Sequence['outputs.WebAclTextTransformation']):
        WebAclRegexPatternSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            field_to_match=field_to_match,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             field_to_match: Optional['outputs.WebAclFieldToMatch'] = None,
             text_transformations: Optional[Sequence['outputs.WebAclTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("arn", arn)
        _setter("field_to_match", field_to_match)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebAclFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRequestBody(dict):
    """
    Map of AssociatedResourceType and RequestBodyAssociatedResourceTypeConfig
    """
    def __init__(__self__):
        """
        Map of AssociatedResourceType and RequestBodyAssociatedResourceTypeConfig
        """
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRequestInspection(dict):
    """
    Configures the inspection of login requests
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordField":
            suggest = "password_field"
        elif key == "payloadType":
            suggest = "payload_type"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRequestInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRequestInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRequestInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_field: 'outputs.WebAclFieldIdentifier',
                 payload_type: 'WebAclRequestInspectionPayloadType',
                 username_field: 'outputs.WebAclFieldIdentifier'):
        """
        Configures the inspection of login requests
        """
        WebAclRequestInspection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_field=password_field,
            payload_type=payload_type,
            username_field=username_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_field: Optional['outputs.WebAclFieldIdentifier'] = None,
             payload_type: Optional['WebAclRequestInspectionPayloadType'] = None,
             username_field: Optional['outputs.WebAclFieldIdentifier'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password_field is None and 'passwordField' in kwargs:
            password_field = kwargs['passwordField']
        if password_field is None:
            raise TypeError("Missing 'password_field' argument")
        if payload_type is None and 'payloadType' in kwargs:
            payload_type = kwargs['payloadType']
        if payload_type is None:
            raise TypeError("Missing 'payload_type' argument")
        if username_field is None and 'usernameField' in kwargs:
            username_field = kwargs['usernameField']
        if username_field is None:
            raise TypeError("Missing 'username_field' argument")

        _setter("password_field", password_field)
        _setter("payload_type", payload_type)
        _setter("username_field", username_field)

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> 'outputs.WebAclFieldIdentifier':
        return pulumi.get(self, "password_field")

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> 'WebAclRequestInspectionPayloadType':
        return pulumi.get(self, "payload_type")

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> 'outputs.WebAclFieldIdentifier':
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebAclRequestInspectionAcfp(dict):
    """
    Configures the inspection of sign-up requests
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "payloadType":
            suggest = "payload_type"
        elif key == "addressFields":
            suggest = "address_fields"
        elif key == "emailField":
            suggest = "email_field"
        elif key == "passwordField":
            suggest = "password_field"
        elif key == "phoneNumberFields":
            suggest = "phone_number_fields"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRequestInspectionAcfp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRequestInspectionAcfp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRequestInspectionAcfp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 payload_type: 'WebAclRequestInspectionAcfpPayloadType',
                 address_fields: Optional[Sequence['outputs.WebAclFieldIdentifier']] = None,
                 email_field: Optional['outputs.WebAclFieldIdentifier'] = None,
                 password_field: Optional['outputs.WebAclFieldIdentifier'] = None,
                 phone_number_fields: Optional[Sequence['outputs.WebAclFieldIdentifier']] = None,
                 username_field: Optional['outputs.WebAclFieldIdentifier'] = None):
        """
        Configures the inspection of sign-up requests
        """
        WebAclRequestInspectionAcfp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            payload_type=payload_type,
            address_fields=address_fields,
            email_field=email_field,
            password_field=password_field,
            phone_number_fields=phone_number_fields,
            username_field=username_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             payload_type: Optional['WebAclRequestInspectionAcfpPayloadType'] = None,
             address_fields: Optional[Sequence['outputs.WebAclFieldIdentifier']] = None,
             email_field: Optional['outputs.WebAclFieldIdentifier'] = None,
             password_field: Optional['outputs.WebAclFieldIdentifier'] = None,
             phone_number_fields: Optional[Sequence['outputs.WebAclFieldIdentifier']] = None,
             username_field: Optional['outputs.WebAclFieldIdentifier'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if payload_type is None and 'payloadType' in kwargs:
            payload_type = kwargs['payloadType']
        if payload_type is None:
            raise TypeError("Missing 'payload_type' argument")
        if address_fields is None and 'addressFields' in kwargs:
            address_fields = kwargs['addressFields']
        if email_field is None and 'emailField' in kwargs:
            email_field = kwargs['emailField']
        if password_field is None and 'passwordField' in kwargs:
            password_field = kwargs['passwordField']
        if phone_number_fields is None and 'phoneNumberFields' in kwargs:
            phone_number_fields = kwargs['phoneNumberFields']
        if username_field is None and 'usernameField' in kwargs:
            username_field = kwargs['usernameField']

        _setter("payload_type", payload_type)
        if address_fields is not None:
            _setter("address_fields", address_fields)
        if email_field is not None:
            _setter("email_field", email_field)
        if password_field is not None:
            _setter("password_field", password_field)
        if phone_number_fields is not None:
            _setter("phone_number_fields", phone_number_fields)
        if username_field is not None:
            _setter("username_field", username_field)

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> 'WebAclRequestInspectionAcfpPayloadType':
        return pulumi.get(self, "payload_type")

    @property
    @pulumi.getter(name="addressFields")
    def address_fields(self) -> Optional[Sequence['outputs.WebAclFieldIdentifier']]:
        return pulumi.get(self, "address_fields")

    @property
    @pulumi.getter(name="emailField")
    def email_field(self) -> Optional['outputs.WebAclFieldIdentifier']:
        return pulumi.get(self, "email_field")

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional['outputs.WebAclFieldIdentifier']:
        return pulumi.get(self, "password_field")

    @property
    @pulumi.getter(name="phoneNumberFields")
    def phone_number_fields(self) -> Optional[Sequence['outputs.WebAclFieldIdentifier']]:
        return pulumi.get(self, "phone_number_fields")

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional['outputs.WebAclFieldIdentifier']:
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebAclResponseInspection(dict):
    """
    Configures the inspection of login responses
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyContains":
            suggest = "body_contains"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclResponseInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclResponseInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclResponseInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_contains: Optional['outputs.WebAclResponseInspectionBodyContains'] = None,
                 header: Optional['outputs.WebAclResponseInspectionHeader'] = None,
                 json: Optional['outputs.WebAclResponseInspectionJson'] = None,
                 status_code: Optional['outputs.WebAclResponseInspectionStatusCode'] = None):
        """
        Configures the inspection of login responses
        """
        WebAclResponseInspection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            body_contains=body_contains,
            header=header,
            json=json,
            status_code=status_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             body_contains: Optional['outputs.WebAclResponseInspectionBodyContains'] = None,
             header: Optional['outputs.WebAclResponseInspectionHeader'] = None,
             json: Optional['outputs.WebAclResponseInspectionJson'] = None,
             status_code: Optional['outputs.WebAclResponseInspectionStatusCode'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if body_contains is None and 'bodyContains' in kwargs:
            body_contains = kwargs['bodyContains']
        if status_code is None and 'statusCode' in kwargs:
            status_code = kwargs['statusCode']

        if body_contains is not None:
            _setter("body_contains", body_contains)
        if header is not None:
            _setter("header", header)
        if json is not None:
            _setter("json", json)
        if status_code is not None:
            _setter("status_code", status_code)

    @property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional['outputs.WebAclResponseInspectionBodyContains']:
        return pulumi.get(self, "body_contains")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.WebAclResponseInspectionHeader']:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def json(self) -> Optional['outputs.WebAclResponseInspectionJson']:
        return pulumi.get(self, "json")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional['outputs.WebAclResponseInspectionStatusCode']:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class WebAclResponseInspectionBodyContains(dict):
    """
    Response body contents that indicate success or failure of a login request
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureStrings":
            suggest = "failure_strings"
        elif key == "successStrings":
            suggest = "success_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclResponseInspectionBodyContains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclResponseInspectionBodyContains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclResponseInspectionBodyContains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_strings: Sequence[str],
                 success_strings: Sequence[str]):
        """
        Response body contents that indicate success or failure of a login request
        """
        WebAclResponseInspectionBodyContains._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_strings=failure_strings,
            success_strings=success_strings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_strings: Optional[Sequence[str]] = None,
             success_strings: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_strings is None and 'failureStrings' in kwargs:
            failure_strings = kwargs['failureStrings']
        if failure_strings is None:
            raise TypeError("Missing 'failure_strings' argument")
        if success_strings is None and 'successStrings' in kwargs:
            success_strings = kwargs['successStrings']
        if success_strings is None:
            raise TypeError("Missing 'success_strings' argument")

        _setter("failure_strings", failure_strings)
        _setter("success_strings", success_strings)

    @property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> Sequence[str]:
        return pulumi.get(self, "failure_strings")

    @property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> Sequence[str]:
        return pulumi.get(self, "success_strings")


@pulumi.output_type
class WebAclResponseInspectionHeader(dict):
    """
    Response headers that indicate success or failure of a login request
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclResponseInspectionHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclResponseInspectionHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclResponseInspectionHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[str],
                 name: str,
                 success_values: Sequence[str]):
        """
        Response headers that indicate success or failure of a login request
        """
        WebAclResponseInspectionHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_values=failure_values,
            name=name,
            success_values=success_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_values: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             success_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_values is None and 'failureValues' in kwargs:
            failure_values = kwargs['failureValues']
        if failure_values is None:
            raise TypeError("Missing 'failure_values' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if success_values is None and 'successValues' in kwargs:
            success_values = kwargs['successValues']
        if success_values is None:
            raise TypeError("Missing 'success_values' argument")

        _setter("failure_values", failure_values)
        _setter("name", name)
        _setter("success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[str]:
        return pulumi.get(self, "failure_values")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[str]:
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebAclResponseInspectionJson(dict):
    """
    Response JSON that indicate success or failure of a login request
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclResponseInspectionJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclResponseInspectionJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclResponseInspectionJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[str],
                 identifier: str,
                 success_values: Sequence[str]):
        """
        Response JSON that indicate success or failure of a login request
        """
        WebAclResponseInspectionJson._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_values=failure_values,
            identifier=identifier,
            success_values=success_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_values: Optional[Sequence[str]] = None,
             identifier: Optional[str] = None,
             success_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_values is None and 'failureValues' in kwargs:
            failure_values = kwargs['failureValues']
        if failure_values is None:
            raise TypeError("Missing 'failure_values' argument")
        if identifier is None:
            raise TypeError("Missing 'identifier' argument")
        if success_values is None and 'successValues' in kwargs:
            success_values = kwargs['successValues']
        if success_values is None:
            raise TypeError("Missing 'success_values' argument")

        _setter("failure_values", failure_values)
        _setter("identifier", identifier)
        _setter("success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[str]:
        return pulumi.get(self, "failure_values")

    @property
    @pulumi.getter
    def identifier(self) -> str:
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[str]:
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebAclResponseInspectionStatusCode(dict):
    """
    Response status codes that indicate success or failure of a login request
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureCodes":
            suggest = "failure_codes"
        elif key == "successCodes":
            suggest = "success_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclResponseInspectionStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclResponseInspectionStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclResponseInspectionStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_codes: Sequence[int],
                 success_codes: Sequence[int]):
        """
        Response status codes that indicate success or failure of a login request
        """
        WebAclResponseInspectionStatusCode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_codes=failure_codes,
            success_codes=success_codes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_codes: Optional[Sequence[int]] = None,
             success_codes: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_codes is None and 'failureCodes' in kwargs:
            failure_codes = kwargs['failureCodes']
        if failure_codes is None:
            raise TypeError("Missing 'failure_codes' argument")
        if success_codes is None and 'successCodes' in kwargs:
            success_codes = kwargs['successCodes']
        if success_codes is None:
            raise TypeError("Missing 'success_codes' argument")

        _setter("failure_codes", failure_codes)
        _setter("success_codes", success_codes)

    @property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> Sequence[int]:
        return pulumi.get(self, "failure_codes")

    @property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> Sequence[int]:
        return pulumi.get(self, "success_codes")


@pulumi.output_type
class WebAclRule(dict):
    """
    Rule of WebACL that contains condition and action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityConfig":
            suggest = "visibility_config"
        elif key == "captchaConfig":
            suggest = "captcha_config"
        elif key == "challengeConfig":
            suggest = "challenge_config"
        elif key == "overrideAction":
            suggest = "override_action"
        elif key == "ruleLabels":
            suggest = "rule_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 priority: int,
                 statement: 'outputs.WebAclStatement',
                 visibility_config: 'outputs.WebAclVisibilityConfig',
                 action: Optional['outputs.WebAclRuleAction'] = None,
                 captcha_config: Optional['outputs.WebAclCaptchaConfig'] = None,
                 challenge_config: Optional['outputs.WebAclChallengeConfig'] = None,
                 override_action: Optional['outputs.WebAclOverrideAction'] = None,
                 rule_labels: Optional[Sequence['outputs.WebAclLabel']] = None):
        """
        Rule of WebACL that contains condition and action.
        :param Sequence['WebAclLabel'] rule_labels: Collection of Rule Labels.
        """
        WebAclRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            priority=priority,
            statement=statement,
            visibility_config=visibility_config,
            action=action,
            captcha_config=captcha_config,
            challenge_config=challenge_config,
            override_action=override_action,
            rule_labels=rule_labels,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             priority: Optional[int] = None,
             statement: Optional['outputs.WebAclStatement'] = None,
             visibility_config: Optional['outputs.WebAclVisibilityConfig'] = None,
             action: Optional['outputs.WebAclRuleAction'] = None,
             captcha_config: Optional['outputs.WebAclCaptchaConfig'] = None,
             challenge_config: Optional['outputs.WebAclChallengeConfig'] = None,
             override_action: Optional['outputs.WebAclOverrideAction'] = None,
             rule_labels: Optional[Sequence['outputs.WebAclLabel']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if statement is None:
            raise TypeError("Missing 'statement' argument")
        if visibility_config is None and 'visibilityConfig' in kwargs:
            visibility_config = kwargs['visibilityConfig']
        if visibility_config is None:
            raise TypeError("Missing 'visibility_config' argument")
        if captcha_config is None and 'captchaConfig' in kwargs:
            captcha_config = kwargs['captchaConfig']
        if challenge_config is None and 'challengeConfig' in kwargs:
            challenge_config = kwargs['challengeConfig']
        if override_action is None and 'overrideAction' in kwargs:
            override_action = kwargs['overrideAction']
        if rule_labels is None and 'ruleLabels' in kwargs:
            rule_labels = kwargs['ruleLabels']

        _setter("name", name)
        _setter("priority", priority)
        _setter("statement", statement)
        _setter("visibility_config", visibility_config)
        if action is not None:
            _setter("action", action)
        if captcha_config is not None:
            _setter("captcha_config", captcha_config)
        if challenge_config is not None:
            _setter("challenge_config", challenge_config)
        if override_action is not None:
            _setter("override_action", override_action)
        if rule_labels is not None:
            _setter("rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.WebAclStatement':
        return pulumi.get(self, "statement")

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> 'outputs.WebAclVisibilityConfig':
        return pulumi.get(self, "visibility_config")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.WebAclRuleAction']:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional['outputs.WebAclCaptchaConfig']:
        return pulumi.get(self, "captcha_config")

    @property
    @pulumi.getter(name="challengeConfig")
    def challenge_config(self) -> Optional['outputs.WebAclChallengeConfig']:
        return pulumi.get(self, "challenge_config")

    @property
    @pulumi.getter(name="overrideAction")
    def override_action(self) -> Optional['outputs.WebAclOverrideAction']:
        return pulumi.get(self, "override_action")

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[Sequence['outputs.WebAclLabel']]:
        """
        Collection of Rule Labels.
        """
        return pulumi.get(self, "rule_labels")


@pulumi.output_type
class WebAclRuleAction(dict):
    """
    Action taken when Rule matches its condition.
    """
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclAllowAction'] = None,
                 block: Optional['outputs.WebAclBlockAction'] = None,
                 captcha: Optional['outputs.WebAclCaptchaAction'] = None,
                 challenge: Optional['outputs.WebAclChallengeAction'] = None,
                 count: Optional['outputs.WebAclCountAction'] = None):
        """
        Action taken when Rule matches its condition.
        """
        WebAclRuleAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow=allow,
            block=block,
            captcha=captcha,
            challenge=challenge,
            count=count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow: Optional['outputs.WebAclAllowAction'] = None,
             block: Optional['outputs.WebAclBlockAction'] = None,
             captcha: Optional['outputs.WebAclCaptchaAction'] = None,
             challenge: Optional['outputs.WebAclChallengeAction'] = None,
             count: Optional['outputs.WebAclCountAction'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if allow is not None:
            _setter("allow", allow)
        if block is not None:
            _setter("block", block)
        if captcha is not None:
            _setter("captcha", captcha)
        if challenge is not None:
            _setter("challenge", challenge)
        if count is not None:
            _setter("count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclAllowAction']:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclBlockAction']:
        return pulumi.get(self, "block")

    @property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.WebAclCaptchaAction']:
        return pulumi.get(self, "captcha")

    @property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.WebAclChallengeAction']:
        return pulumi.get(self, "challenge")

    @property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebAclCountAction']:
        return pulumi.get(self, "count")


@pulumi.output_type
class WebAclRuleActionOverride(dict):
    """
    Action override for rules in the rule group.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionToUse":
            suggest = "action_to_use"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_to_use: 'outputs.WebAclRuleAction',
                 name: str):
        """
        Action override for rules in the rule group.
        """
        WebAclRuleActionOverride._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_to_use=action_to_use,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_to_use: Optional['outputs.WebAclRuleAction'] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_to_use is None and 'actionToUse' in kwargs:
            action_to_use = kwargs['actionToUse']
        if action_to_use is None:
            raise TypeError("Missing 'action_to_use' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("action_to_use", action_to_use)
        _setter("name", name)

    @property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> 'outputs.WebAclRuleAction':
        return pulumi.get(self, "action_to_use")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleGroupReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedRules":
            suggest = "excluded_rules"
        elif key == "ruleActionOverrides":
            suggest = "rule_action_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 excluded_rules: Optional[Sequence['outputs.WebAclExcludedRule']] = None,
                 rule_action_overrides: Optional[Sequence['outputs.WebAclRuleActionOverride']] = None):
        """
        :param Sequence['WebAclRuleActionOverride'] rule_action_overrides: Action overrides for rules in the rule group.
        """
        WebAclRuleGroupReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            excluded_rules=excluded_rules,
            rule_action_overrides=rule_action_overrides,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             excluded_rules: Optional[Sequence['outputs.WebAclExcludedRule']] = None,
             rule_action_overrides: Optional[Sequence['outputs.WebAclRuleActionOverride']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if excluded_rules is None and 'excludedRules' in kwargs:
            excluded_rules = kwargs['excludedRules']
        if rule_action_overrides is None and 'ruleActionOverrides' in kwargs:
            rule_action_overrides = kwargs['ruleActionOverrides']

        _setter("arn", arn)
        if excluded_rules is not None:
            _setter("excluded_rules", excluded_rules)
        if rule_action_overrides is not None:
            _setter("rule_action_overrides", rule_action_overrides)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="excludedRules")
    def excluded_rules(self) -> Optional[Sequence['outputs.WebAclExcludedRule']]:
        return pulumi.get(self, "excluded_rules")

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[Sequence['outputs.WebAclRuleActionOverride']]:
        """
        Action overrides for rules in the rule group.
        """
        return pulumi.get(self, "rule_action_overrides")


@pulumi.output_type
class WebAclSizeConstraintStatement(dict):
    """
    Size Constraint statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: 'WebAclSizeConstraintStatementComparisonOperator',
                 field_to_match: 'outputs.WebAclFieldToMatch',
                 size: float,
                 text_transformations: Sequence['outputs.WebAclTextTransformation']):
        """
        Size Constraint statement.
        """
        WebAclSizeConstraintStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            field_to_match=field_to_match,
            size=size,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional['WebAclSizeConstraintStatementComparisonOperator'] = None,
             field_to_match: Optional['outputs.WebAclFieldToMatch'] = None,
             size: Optional[float] = None,
             text_transformations: Optional[Sequence['outputs.WebAclTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("comparison_operator", comparison_operator)
        _setter("field_to_match", field_to_match)
        _setter("size", size)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> 'WebAclSizeConstraintStatementComparisonOperator':
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebAclFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter
    def size(self) -> float:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclSqliMatchStatement(dict):
    """
    Sqli Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebAclFieldToMatch',
                 text_transformations: Sequence['outputs.WebAclTextTransformation'],
                 sensitivity_level: Optional['WebAclSensitivityLevel'] = None):
        """
        Sqli Match Statement.
        """
        WebAclSqliMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_to_match=field_to_match,
            text_transformations=text_transformations,
            sensitivity_level=sensitivity_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_to_match: Optional['outputs.WebAclFieldToMatch'] = None,
             text_transformations: Optional[Sequence['outputs.WebAclTextTransformation']] = None,
             sensitivity_level: Optional['WebAclSensitivityLevel'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if sensitivity_level is None and 'sensitivityLevel' in kwargs:
            sensitivity_level = kwargs['sensitivityLevel']

        _setter("field_to_match", field_to_match)
        _setter("text_transformations", text_transformations)
        if sensitivity_level is not None:
            _setter("sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebAclFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional['WebAclSensitivityLevel']:
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class WebAclStatement(dict):
    """
    First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "managedRuleGroupStatement":
            suggest = "managed_rule_group_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "rateBasedStatement":
            suggest = "rate_based_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "ruleGroupReferenceStatement":
            suggest = "rule_group_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.WebAclAndStatement'] = None,
                 byte_match_statement: Optional['outputs.WebAclByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.WebAclGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.WebAclIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.WebAclLabelMatchStatement'] = None,
                 managed_rule_group_statement: Optional['outputs.WebAclManagedRuleGroupStatement'] = None,
                 not_statement: Optional['outputs.WebAclNotStatement'] = None,
                 or_statement: Optional['outputs.WebAclOrStatement'] = None,
                 rate_based_statement: Optional['outputs.WebAclRateBasedStatement'] = None,
                 regex_match_statement: Optional['outputs.WebAclRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.WebAclRegexPatternSetReferenceStatement'] = None,
                 rule_group_reference_statement: Optional['outputs.WebAclRuleGroupReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.WebAclSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.WebAclSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.WebAclXssMatchStatement'] = None):
        """
        First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
        """
        WebAclStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            and_statement=and_statement,
            byte_match_statement=byte_match_statement,
            geo_match_statement=geo_match_statement,
            ip_set_reference_statement=ip_set_reference_statement,
            label_match_statement=label_match_statement,
            managed_rule_group_statement=managed_rule_group_statement,
            not_statement=not_statement,
            or_statement=or_statement,
            rate_based_statement=rate_based_statement,
            regex_match_statement=regex_match_statement,
            regex_pattern_set_reference_statement=regex_pattern_set_reference_statement,
            rule_group_reference_statement=rule_group_reference_statement,
            size_constraint_statement=size_constraint_statement,
            sqli_match_statement=sqli_match_statement,
            xss_match_statement=xss_match_statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             and_statement: Optional['outputs.WebAclAndStatement'] = None,
             byte_match_statement: Optional['outputs.WebAclByteMatchStatement'] = None,
             geo_match_statement: Optional['outputs.WebAclGeoMatchStatement'] = None,
             ip_set_reference_statement: Optional['outputs.WebAclIpSetReferenceStatement'] = None,
             label_match_statement: Optional['outputs.WebAclLabelMatchStatement'] = None,
             managed_rule_group_statement: Optional['outputs.WebAclManagedRuleGroupStatement'] = None,
             not_statement: Optional['outputs.WebAclNotStatement'] = None,
             or_statement: Optional['outputs.WebAclOrStatement'] = None,
             rate_based_statement: Optional['outputs.WebAclRateBasedStatement'] = None,
             regex_match_statement: Optional['outputs.WebAclRegexMatchStatement'] = None,
             regex_pattern_set_reference_statement: Optional['outputs.WebAclRegexPatternSetReferenceStatement'] = None,
             rule_group_reference_statement: Optional['outputs.WebAclRuleGroupReferenceStatement'] = None,
             size_constraint_statement: Optional['outputs.WebAclSizeConstraintStatement'] = None,
             sqli_match_statement: Optional['outputs.WebAclSqliMatchStatement'] = None,
             xss_match_statement: Optional['outputs.WebAclXssMatchStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if and_statement is None and 'andStatement' in kwargs:
            and_statement = kwargs['andStatement']
        if byte_match_statement is None and 'byteMatchStatement' in kwargs:
            byte_match_statement = kwargs['byteMatchStatement']
        if geo_match_statement is None and 'geoMatchStatement' in kwargs:
            geo_match_statement = kwargs['geoMatchStatement']
        if ip_set_reference_statement is None and 'ipSetReferenceStatement' in kwargs:
            ip_set_reference_statement = kwargs['ipSetReferenceStatement']
        if label_match_statement is None and 'labelMatchStatement' in kwargs:
            label_match_statement = kwargs['labelMatchStatement']
        if managed_rule_group_statement is None and 'managedRuleGroupStatement' in kwargs:
            managed_rule_group_statement = kwargs['managedRuleGroupStatement']
        if not_statement is None and 'notStatement' in kwargs:
            not_statement = kwargs['notStatement']
        if or_statement is None and 'orStatement' in kwargs:
            or_statement = kwargs['orStatement']
        if rate_based_statement is None and 'rateBasedStatement' in kwargs:
            rate_based_statement = kwargs['rateBasedStatement']
        if regex_match_statement is None and 'regexMatchStatement' in kwargs:
            regex_match_statement = kwargs['regexMatchStatement']
        if regex_pattern_set_reference_statement is None and 'regexPatternSetReferenceStatement' in kwargs:
            regex_pattern_set_reference_statement = kwargs['regexPatternSetReferenceStatement']
        if rule_group_reference_statement is None and 'ruleGroupReferenceStatement' in kwargs:
            rule_group_reference_statement = kwargs['ruleGroupReferenceStatement']
        if size_constraint_statement is None and 'sizeConstraintStatement' in kwargs:
            size_constraint_statement = kwargs['sizeConstraintStatement']
        if sqli_match_statement is None and 'sqliMatchStatement' in kwargs:
            sqli_match_statement = kwargs['sqliMatchStatement']
        if xss_match_statement is None and 'xssMatchStatement' in kwargs:
            xss_match_statement = kwargs['xssMatchStatement']

        if and_statement is not None:
            _setter("and_statement", and_statement)
        if byte_match_statement is not None:
            _setter("byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            _setter("geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            _setter("ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            _setter("label_match_statement", label_match_statement)
        if managed_rule_group_statement is not None:
            _setter("managed_rule_group_statement", managed_rule_group_statement)
        if not_statement is not None:
            _setter("not_statement", not_statement)
        if or_statement is not None:
            _setter("or_statement", or_statement)
        if rate_based_statement is not None:
            _setter("rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            _setter("regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            _setter("regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if rule_group_reference_statement is not None:
            _setter("rule_group_reference_statement", rule_group_reference_statement)
        if size_constraint_statement is not None:
            _setter("size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            _setter("sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            _setter("xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.WebAclAndStatement']:
        return pulumi.get(self, "and_statement")

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.WebAclByteMatchStatement']:
        return pulumi.get(self, "byte_match_statement")

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.WebAclGeoMatchStatement']:
        return pulumi.get(self, "geo_match_statement")

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.WebAclIpSetReferenceStatement']:
        return pulumi.get(self, "ip_set_reference_statement")

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.WebAclLabelMatchStatement']:
        return pulumi.get(self, "label_match_statement")

    @property
    @pulumi.getter(name="managedRuleGroupStatement")
    def managed_rule_group_statement(self) -> Optional['outputs.WebAclManagedRuleGroupStatement']:
        return pulumi.get(self, "managed_rule_group_statement")

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.WebAclNotStatement']:
        return pulumi.get(self, "not_statement")

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.WebAclOrStatement']:
        return pulumi.get(self, "or_statement")

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional['outputs.WebAclRateBasedStatement']:
        return pulumi.get(self, "rate_based_statement")

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.WebAclRegexMatchStatement']:
        return pulumi.get(self, "regex_match_statement")

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.WebAclRegexPatternSetReferenceStatement']:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @property
    @pulumi.getter(name="ruleGroupReferenceStatement")
    def rule_group_reference_statement(self) -> Optional['outputs.WebAclRuleGroupReferenceStatement']:
        return pulumi.get(self, "rule_group_reference_statement")

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.WebAclSizeConstraintStatement']:
        return pulumi.get(self, "size_constraint_statement")

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.WebAclSqliMatchStatement']:
        return pulumi.get(self, "sqli_match_statement")

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.WebAclXssMatchStatement']:
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class WebAclTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        WebAclTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclTextTransformation(dict):
    """
    Text Transformation on the Search String before match.
    """
    def __init__(__self__, *,
                 priority: int,
                 type: 'WebAclTextTransformationType'):
        """
        Text Transformation on the Search String before match.
        """
        WebAclTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional['WebAclTextTransformationType'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> 'WebAclTextTransformationType':
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclVisibilityConfig(dict):
    """
    Visibility Metric of the WebACL.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchMetricsEnabled":
            suggest = "cloud_watch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_metrics_enabled: bool,
                 metric_name: str,
                 sampled_requests_enabled: bool):
        """
        Visibility Metric of the WebACL.
        """
        WebAclVisibilityConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_watch_metrics_enabled=cloud_watch_metrics_enabled,
            metric_name=metric_name,
            sampled_requests_enabled=sampled_requests_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_watch_metrics_enabled: Optional[bool] = None,
             metric_name: Optional[str] = None,
             sampled_requests_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_watch_metrics_enabled is None and 'cloudWatchMetricsEnabled' in kwargs:
            cloud_watch_metrics_enabled = kwargs['cloudWatchMetricsEnabled']
        if cloud_watch_metrics_enabled is None:
            raise TypeError("Missing 'cloud_watch_metrics_enabled' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if sampled_requests_enabled is None and 'sampledRequestsEnabled' in kwargs:
            sampled_requests_enabled = kwargs['sampledRequestsEnabled']
        if sampled_requests_enabled is None:
            raise TypeError("Missing 'sampled_requests_enabled' argument")

        _setter("cloud_watch_metrics_enabled", cloud_watch_metrics_enabled)
        _setter("metric_name", metric_name)
        _setter("sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudWatchMetricsEnabled")
    def cloud_watch_metrics_enabled(self) -> bool:
        return pulumi.get(self, "cloud_watch_metrics_enabled")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> bool:
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class WebAclXssMatchStatement(dict):
    """
    Xss Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebAclFieldToMatch',
                 text_transformations: Sequence['outputs.WebAclTextTransformation']):
        """
        Xss Match Statement.
        """
        WebAclXssMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_to_match=field_to_match,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_to_match: Optional['outputs.WebAclFieldToMatch'] = None,
             text_transformations: Optional[Sequence['outputs.WebAclTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']
        if field_to_match is None:
            raise TypeError("Missing 'field_to_match' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("field_to_match", field_to_match)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebAclFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclTextTransformation']:
        return pulumi.get(self, "text_transformations")


