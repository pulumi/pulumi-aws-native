# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'IPSetTag',
    'LoggingConfigurationCondition',
    'LoggingConfigurationConditionActionConditionProperties',
    'LoggingConfigurationConditionLabelNameConditionProperties',
    'LoggingConfigurationFieldToMatch',
    'LoggingConfigurationFieldToMatchJsonBodyProperties',
    'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties',
    'LoggingConfigurationFieldToMatchSingleHeaderProperties',
    'LoggingConfigurationFilter',
    'LoggingFilterProperties',
    'RegexPatternSetTag',
    'RuleGroupAndStatement',
    'RuleGroupByteMatchStatement',
    'RuleGroupCaptchaConfig',
    'RuleGroupCustomHTTPHeader',
    'RuleGroupCustomRequestHandling',
    'RuleGroupCustomResponse',
    'RuleGroupCustomResponseBodies',
    'RuleGroupFieldToMatch',
    'RuleGroupFieldToMatchSingleHeaderProperties',
    'RuleGroupFieldToMatchSingleQueryArgumentProperties',
    'RuleGroupForwardedIPConfiguration',
    'RuleGroupGeoMatchStatement',
    'RuleGroupIPSetForwardedIPConfiguration',
    'RuleGroupIPSetReferenceStatement',
    'RuleGroupImmunityTimeProperty',
    'RuleGroupJsonBody',
    'RuleGroupJsonMatchPattern',
    'RuleGroupLabel',
    'RuleGroupLabelMatchStatement',
    'RuleGroupLabelSummary',
    'RuleGroupNotStatement',
    'RuleGroupOrStatement',
    'RuleGroupRateBasedStatement',
    'RuleGroupRegexMatchStatement',
    'RuleGroupRegexPatternSetReferenceStatement',
    'RuleGroupRule',
    'RuleGroupRuleAction',
    'RuleGroupRuleActionAllowProperties',
    'RuleGroupRuleActionBlockProperties',
    'RuleGroupRuleActionCaptchaProperties',
    'RuleGroupRuleActionCountProperties',
    'RuleGroupSizeConstraintStatement',
    'RuleGroupSqliMatchStatement',
    'RuleGroupStatement',
    'RuleGroupTag',
    'RuleGroupTextTransformation',
    'RuleGroupVisibilityConfig',
    'RuleGroupXssMatchStatement',
    'WebACLAllowAction',
    'WebACLAndStatement',
    'WebACLBlockAction',
    'WebACLByteMatchStatement',
    'WebACLCaptchaAction',
    'WebACLCaptchaConfig',
    'WebACLCountAction',
    'WebACLCustomHTTPHeader',
    'WebACLCustomRequestHandling',
    'WebACLCustomResponse',
    'WebACLCustomResponseBodies',
    'WebACLDefaultAction',
    'WebACLExcludedRule',
    'WebACLFieldIdentifier',
    'WebACLFieldToMatch',
    'WebACLFieldToMatchSingleHeaderProperties',
    'WebACLFieldToMatchSingleQueryArgumentProperties',
    'WebACLForwardedIPConfiguration',
    'WebACLGeoMatchStatement',
    'WebACLIPSetForwardedIPConfiguration',
    'WebACLIPSetReferenceStatement',
    'WebACLImmunityTimeProperty',
    'WebACLJsonBody',
    'WebACLJsonMatchPattern',
    'WebACLLabel',
    'WebACLLabelMatchStatement',
    'WebACLManagedRuleGroupConfig',
    'WebACLManagedRuleGroupStatement',
    'WebACLNotStatement',
    'WebACLOrStatement',
    'WebACLOverrideAction',
    'WebACLRateBasedStatement',
    'WebACLRegexMatchStatement',
    'WebACLRegexPatternSetReferenceStatement',
    'WebACLRule',
    'WebACLRuleAction',
    'WebACLRuleGroupReferenceStatement',
    'WebACLSizeConstraintStatement',
    'WebACLSqliMatchStatement',
    'WebACLStatement',
    'WebACLTag',
    'WebACLTextTransformation',
    'WebACLVisibilityConfig',
    'WebACLXssMatchStatement',
]

@pulumi.output_type
class IPSetTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class LoggingConfigurationCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionCondition":
            suggest = "action_condition"
        elif key == "labelNameCondition":
            suggest = "label_name_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_condition: Optional['outputs.LoggingConfigurationConditionActionConditionProperties'] = None,
                 label_name_condition: Optional['outputs.LoggingConfigurationConditionLabelNameConditionProperties'] = None):
        """
        :param 'LoggingConfigurationConditionActionConditionProperties' action_condition: A single action condition.
        :param 'LoggingConfigurationConditionLabelNameConditionProperties' label_name_condition: A single label name condition.
        """
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional['outputs.LoggingConfigurationConditionActionConditionProperties']:
        """
        A single action condition.
        """
        return pulumi.get(self, "action_condition")

    @property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional['outputs.LoggingConfigurationConditionLabelNameConditionProperties']:
        """
        A single label name condition.
        """
        return pulumi.get(self, "label_name_condition")


@pulumi.output_type
class LoggingConfigurationConditionActionConditionProperties(dict):
    """
    A single action condition.
    """
    def __init__(__self__, *,
                 action: 'LoggingConfigurationConditionActionConditionPropertiesAction'):
        """
        A single action condition.
        :param 'LoggingConfigurationConditionActionConditionPropertiesAction' action: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> 'LoggingConfigurationConditionActionConditionPropertiesAction':
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class LoggingConfigurationConditionLabelNameConditionProperties(dict):
    """
    A single label name condition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelName":
            suggest = "label_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationConditionLabelNameConditionProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationConditionLabelNameConditionProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationConditionLabelNameConditionProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_name: str):
        """
        A single label name condition.
        :param str label_name: The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
        """
        pulumi.set(__self__, "label_name", label_name)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> str:
        """
        The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
        """
        return pulumi.get(self, "label_name")


@pulumi.output_type
class LoggingConfigurationFieldToMatch(dict):
    """
    A key-value pair to associate with a resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_body: Optional['outputs.LoggingConfigurationFieldToMatchJsonBodyProperties'] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional['outputs.LoggingConfigurationFieldToMatchSingleHeaderProperties'] = None,
                 uri_path: Optional[Any] = None):
        """
        A key-value pair to associate with a resource.
        :param 'LoggingConfigurationFieldToMatchJsonBodyProperties' json_body: Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        :param Any method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
        :param Any query_string: Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
        :param 'LoggingConfigurationFieldToMatchSingleHeaderProperties' single_header: Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        :param Any uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
        """
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.LoggingConfigurationFieldToMatchJsonBodyProperties']:
        """
        Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.LoggingConfigurationFieldToMatchSingleHeaderProperties']:
        """
        Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class LoggingConfigurationFieldToMatchJsonBodyProperties(dict):
    """
    Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationFieldToMatchJsonBodyProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties',
                 match_scope: 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope',
                 invalid_fallback_behavior: Optional['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior'] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
        :param 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties' match_pattern: The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        :param 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope' match_scope: The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
        :param 'LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior' invalid_fallback_behavior: What AWS WAF should do if it fails to completely parse the JSON body.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties':
        """
        The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope':
        """
        The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional['LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior']:
        """
        What AWS WAF should do if it fails to completely parse the JSON body.
        """
        return pulumi.get(self, "invalid_fallback_behavior")


@pulumi.output_type
class LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties(dict):
    """
    The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
        :param Any all: Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
        :param Sequence[str] included_paths: Match only the specified include paths. See also MatchScope in JsonBody.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        """
        Match only the specified include paths. See also MatchScope in JsonBody.
        """
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class LoggingConfigurationFieldToMatchSingleHeaderProperties(dict):
    """
    Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
    """
    def __init__(__self__, *,
                 name: str):
        """
        Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        :param str name: The name of the query header to inspect.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LoggingConfigurationFilter(dict):
    def __init__(__self__, *,
                 behavior: 'LoggingConfigurationFilterBehavior',
                 conditions: Sequence['outputs.LoggingConfigurationCondition'],
                 requirement: 'LoggingConfigurationFilterRequirement'):
        """
        :param 'LoggingConfigurationFilterBehavior' behavior: How to handle logs that satisfy the filter's conditions and requirement. 
        :param Sequence['LoggingConfigurationCondition'] conditions: Match conditions for the filter.
        :param 'LoggingConfigurationFilterRequirement' requirement: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "requirement", requirement)

    @property
    @pulumi.getter
    def behavior(self) -> 'LoggingConfigurationFilterBehavior':
        """
        How to handle logs that satisfy the filter's conditions and requirement. 
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.LoggingConfigurationCondition']:
        """
        Match conditions for the filter.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def requirement(self) -> 'LoggingConfigurationFilterRequirement':
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "requirement")


@pulumi.output_type
class LoggingFilterProperties(dict):
    """
    Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBehavior":
            suggest = "default_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingFilterProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingFilterProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingFilterProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_behavior: 'LoggingConfigurationLoggingFilterPropertiesDefaultBehavior',
                 filters: Sequence['outputs.LoggingConfigurationFilter']):
        """
        Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
        :param 'LoggingConfigurationLoggingFilterPropertiesDefaultBehavior' default_behavior: Default handling for logs that don't match any of the specified filtering conditions.
        :param Sequence['LoggingConfigurationFilter'] filters: The filters that you want to apply to the logs.
        """
        pulumi.set(__self__, "default_behavior", default_behavior)
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> 'LoggingConfigurationLoggingFilterPropertiesDefaultBehavior':
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        """
        return pulumi.get(self, "default_behavior")

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.LoggingConfigurationFilter']:
        """
        The filters that you want to apply to the logs.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class RegexPatternSetTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupStatement']):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupByteMatchStatement(dict):
    """
    Byte Match statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "searchStringBase64":
            suggest = "search_string_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 positional_constraint: 'RuleGroupPositionalConstraint',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation'],
                 search_string: Optional[str] = None,
                 search_string_base64: Optional[str] = None):
        """
        Byte Match statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if search_string is not None:
            pulumi.set(__self__, "search_string", search_string)
        if search_string_base64 is not None:
            pulumi.set(__self__, "search_string_base64", search_string_base64)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> 'RuleGroupPositionalConstraint':
        return pulumi.get(self, "positional_constraint")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> Optional[str]:
        return pulumi.get(self, "search_string")

    @property
    @pulumi.getter(name="searchStringBase64")
    def search_string_base64(self) -> Optional[str]:
        return pulumi.get(self, "search_string_base64")


@pulumi.output_type
class RuleGroupCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.RuleGroupImmunityTimeProperty'] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.RuleGroupImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class RuleGroupCustomHTTPHeader(dict):
    """
    HTTP header.
    """
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupCustomRequestHandling(dict):
    """
    Custom request handling.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.RuleGroupCustomHTTPHeader']):
        """
        Custom request handling.
        :param Sequence['RuleGroupCustomHTTPHeader'] insert_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.RuleGroupCustomHTTPHeader']:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class RuleGroupCustomResponse(dict):
    """
    Custom response.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: int,
                 custom_response_body_key: Optional[str] = None,
                 response_headers: Optional[Sequence['outputs.RuleGroupCustomHTTPHeader']] = None):
        """
        Custom response.
        :param str custom_response_body_key: Custom response body key.
        :param Sequence['RuleGroupCustomHTTPHeader'] response_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> int:
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[str]:
        """
        Custom response body key.
        """
        return pulumi.get(self, "custom_response_body_key")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.RuleGroupCustomHTTPHeader']]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class RuleGroupCustomResponseBodies(dict):
    """
    Custom response key and body map.
    """
    def __init__(__self__):
        """
        Custom response key and body map.
        """
        pass


@pulumi.output_type
class RuleGroupFieldToMatch(dict):
    """
    Field of the request to match.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional[Any] = None,
                 body: Optional[Any] = None,
                 json_body: Optional['outputs.RuleGroupJsonBody'] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional['outputs.RuleGroupFieldToMatchSingleHeaderProperties'] = None,
                 single_query_argument: Optional['outputs.RuleGroupFieldToMatchSingleQueryArgumentProperties'] = None,
                 uri_path: Optional[Any] = None):
        """
        Field of the request to match.
        :param Any all_query_arguments: All query arguments of a web request.
        :param Any body: The body of a web request. This immediately follows the request headers.
        :param Any method: The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        :param Any query_string: The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        :param 'RuleGroupFieldToMatchSingleQueryArgumentProperties' single_query_argument: One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        :param Any uri_path: The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[Any]:
        """
        All query arguments of a web request.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional[Any]:
        """
        The body of a web request. This immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupJsonBody']:
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupFieldToMatchSingleHeaderProperties']:
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupFieldToMatchSingleQueryArgumentProperties']:
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupFieldToMatchSingleHeaderProperties(dict):
    def __init__(__self__, *,
                 name: str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupFieldToMatchSingleQueryArgumentProperties(dict):
    """
    One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
    """
    def __init__(__self__, *,
                 name: str):
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupForwardedIPConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupForwardedIPConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupForwardedIPConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupForwardedIPConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'RuleGroupForwardedIPConfigurationFallbackBehavior',
                 header_name: str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'RuleGroupForwardedIPConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class RuleGroupGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIPConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Optional[Sequence[str]] = None,
                 forwarded_ip_config: Optional['outputs.RuleGroupForwardedIPConfiguration'] = None):
        if country_codes is not None:
            pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupForwardedIPConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class RuleGroupIPSetForwardedIPConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupIPSetForwardedIPConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupIPSetForwardedIPConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupIPSetForwardedIPConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'RuleGroupIPSetForwardedIPConfigurationFallbackBehavior',
                 header_name: str,
                 position: 'RuleGroupIPSetForwardedIPConfigurationPosition'):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'RuleGroupIPSetForwardedIPConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def position(self) -> 'RuleGroupIPSetForwardedIPConfigurationPosition':
        return pulumi.get(self, "position")


@pulumi.output_type
class RuleGroupIPSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iPSetForwardedIPConfig":
            suggest = "i_p_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupIPSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupIPSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupIPSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 i_p_set_forwarded_ip_config: Optional['outputs.RuleGroupIPSetForwardedIPConfiguration'] = None):
        pulumi.set(__self__, "arn", arn)
        if i_p_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "i_p_set_forwarded_ip_config", i_p_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="iPSetForwardedIPConfig")
    def i_p_set_forwarded_ip_config(self) -> Optional['outputs.RuleGroupIPSetForwardedIPConfiguration']:
        return pulumi.get(self, "i_p_set_forwarded_ip_config")


@pulumi.output_type
class RuleGroupImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: int):
        pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> int:
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class RuleGroupJsonBody(dict):
    """
    Inspect the request body as JSON. The request body immediately follows the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupJsonMatchPattern',
                 match_scope: 'RuleGroupJsonMatchScope',
                 invalid_fallback_behavior: Optional['RuleGroupBodyParsingFallbackBehavior'] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupJsonMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'RuleGroupJsonMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional['RuleGroupBodyParsingFallbackBehavior']:
        return pulumi.get(self, "invalid_fallback_behavior")


@pulumi.output_type
class RuleGroupJsonMatchPattern(dict):
    """
    The pattern to look for in the JSON body.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupJsonMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupJsonMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupJsonMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the JSON body.
        :param Any all: Inspect all parts of the web request's JSON body.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request's JSON body.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupLabel(dict):
    def __init__(__self__, *,
                 name: str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: str,
                 scope: 'RuleGroupLabelMatchScope'):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def scope(self) -> 'RuleGroupLabelMatchScope':
        return pulumi.get(self, "scope")


@pulumi.output_type
class RuleGroupLabelSummary(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupNotStatement(dict):
    def __init__(__self__, *,
                 statement: 'outputs.RuleGroupStatement'):
        pulumi.set(__self__, "statement", statement)

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.RuleGroupStatement':
        return pulumi.get(self, "statement")


@pulumi.output_type
class RuleGroupOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupStatement']):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRateBasedStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateKeyType":
            suggest = "aggregate_key_type"
        elif key == "forwardedIPConfig":
            suggest = "forwarded_ip_config"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRateBasedStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRateBasedStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRateBasedStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregate_key_type: 'RuleGroupRateBasedStatementAggregateKeyType',
                 limit: int,
                 forwarded_ip_config: Optional['outputs.RuleGroupForwardedIPConfiguration'] = None,
                 scope_down_statement: Optional['outputs.RuleGroupStatement'] = None):
        pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        pulumi.set(__self__, "limit", limit)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> 'RuleGroupRateBasedStatementAggregateKeyType':
        return pulumi.get(self, "aggregate_key_type")

    @property
    @pulumi.getter
    def limit(self) -> int:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupForwardedIPConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.RuleGroupStatement']:
        return pulumi.get(self, "scope_down_statement")


@pulumi.output_type
class RuleGroupRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 regex_string: str,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        return pulumi.get(self, "regex_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRule(dict):
    """
    Rule of RuleGroup that contains condition and action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityConfig":
            suggest = "visibility_config"
        elif key == "captchaConfig":
            suggest = "captcha_config"
        elif key == "ruleLabels":
            suggest = "rule_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 priority: int,
                 statement: 'outputs.RuleGroupStatement',
                 visibility_config: 'outputs.RuleGroupVisibilityConfig',
                 action: Optional['outputs.RuleGroupRuleAction'] = None,
                 captcha_config: Optional['outputs.RuleGroupCaptchaConfig'] = None,
                 rule_labels: Optional[Sequence['outputs.RuleGroupLabel']] = None):
        """
        Rule of RuleGroup that contains condition and action.
        :param Sequence['RuleGroupLabel'] rule_labels: Collection of Rule Labels.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.RuleGroupStatement':
        return pulumi.get(self, "statement")

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> 'outputs.RuleGroupVisibilityConfig':
        return pulumi.get(self, "visibility_config")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.RuleGroupRuleAction']:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional['outputs.RuleGroupCaptchaConfig']:
        return pulumi.get(self, "captcha_config")

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[Sequence['outputs.RuleGroupLabel']]:
        """
        Collection of Rule Labels.
        """
        return pulumi.get(self, "rule_labels")


@pulumi.output_type
class RuleGroupRuleAction(dict):
    """
    Action taken when Rule matches its condition.
    """
    def __init__(__self__, *,
                 allow: Optional['outputs.RuleGroupRuleActionAllowProperties'] = None,
                 block: Optional['outputs.RuleGroupRuleActionBlockProperties'] = None,
                 captcha: Optional['outputs.RuleGroupRuleActionCaptchaProperties'] = None,
                 count: Optional['outputs.RuleGroupRuleActionCountProperties'] = None):
        """
        Action taken when Rule matches its condition.
        :param 'RuleGroupRuleActionAllowProperties' allow: Allow traffic towards application.
        :param 'RuleGroupRuleActionBlockProperties' block: Block traffic towards application.
        :param 'RuleGroupRuleActionCaptchaProperties' captcha: Checks valid token exists with request.
        :param 'RuleGroupRuleActionCountProperties' count: Count traffic towards application.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.RuleGroupRuleActionAllowProperties']:
        """
        Allow traffic towards application.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.RuleGroupRuleActionBlockProperties']:
        """
        Block traffic towards application.
        """
        return pulumi.get(self, "block")

    @property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.RuleGroupRuleActionCaptchaProperties']:
        """
        Checks valid token exists with request.
        """
        return pulumi.get(self, "captcha")

    @property
    @pulumi.getter
    def count(self) -> Optional['outputs.RuleGroupRuleActionCountProperties']:
        """
        Count traffic towards application.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class RuleGroupRuleActionAllowProperties(dict):
    """
    Allow traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionAllowProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionAllowProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionAllowProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupRuleActionBlockProperties(dict):
    """
    Block traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionBlockProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionBlockProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionBlockProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.RuleGroupCustomResponse'] = None):
        """
        Block traffic towards application.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.RuleGroupCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class RuleGroupRuleActionCaptchaProperties(dict):
    """
    Checks valid token exists with request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionCaptchaProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionCaptchaProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionCaptchaProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None):
        """
        Checks valid token exists with request.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupRuleActionCountProperties(dict):
    """
    Count traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionCountProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionCountProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionCountProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupCustomRequestHandling'] = None):
        """
        Count traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupSizeConstraintStatement(dict):
    """
    Size Constraint statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: 'RuleGroupSizeConstraintStatementComparisonOperator',
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 size: float,
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Size Constraint statement.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> 'RuleGroupSizeConstraintStatementComparisonOperator':
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter
    def size(self) -> float:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupSqliMatchStatement(dict):
    """
    Sqli Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Sqli Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupStatement(dict):
    """
    First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "iPSetReferenceStatement":
            suggest = "i_p_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "rateBasedStatement":
            suggest = "rate_based_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.RuleGroupAndStatement'] = None,
                 byte_match_statement: Optional['outputs.RuleGroupByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.RuleGroupGeoMatchStatement'] = None,
                 i_p_set_reference_statement: Optional['outputs.RuleGroupIPSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.RuleGroupLabelMatchStatement'] = None,
                 not_statement: Optional['outputs.RuleGroupNotStatement'] = None,
                 or_statement: Optional['outputs.RuleGroupOrStatement'] = None,
                 rate_based_statement: Optional['outputs.RuleGroupRateBasedStatement'] = None,
                 regex_match_statement: Optional['outputs.RuleGroupRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.RuleGroupRegexPatternSetReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.RuleGroupSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.RuleGroupSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.RuleGroupXssMatchStatement'] = None):
        """
        First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if i_p_set_reference_statement is not None:
            pulumi.set(__self__, "i_p_set_reference_statement", i_p_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.RuleGroupAndStatement']:
        return pulumi.get(self, "and_statement")

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.RuleGroupByteMatchStatement']:
        return pulumi.get(self, "byte_match_statement")

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.RuleGroupGeoMatchStatement']:
        return pulumi.get(self, "geo_match_statement")

    @property
    @pulumi.getter(name="iPSetReferenceStatement")
    def i_p_set_reference_statement(self) -> Optional['outputs.RuleGroupIPSetReferenceStatement']:
        return pulumi.get(self, "i_p_set_reference_statement")

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.RuleGroupLabelMatchStatement']:
        return pulumi.get(self, "label_match_statement")

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.RuleGroupNotStatement']:
        return pulumi.get(self, "not_statement")

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.RuleGroupOrStatement']:
        return pulumi.get(self, "or_statement")

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional['outputs.RuleGroupRateBasedStatement']:
        return pulumi.get(self, "rate_based_statement")

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.RuleGroupRegexMatchStatement']:
        return pulumi.get(self, "regex_match_statement")

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.RuleGroupRegexPatternSetReferenceStatement']:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.RuleGroupSizeConstraintStatement']:
        return pulumi.get(self, "size_constraint_statement")

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.RuleGroupSqliMatchStatement']:
        return pulumi.get(self, "sqli_match_statement")

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.RuleGroupXssMatchStatement']:
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class RuleGroupTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupTextTransformation(dict):
    """
    Text Transformation on the Search String before match.
    """
    def __init__(__self__, *,
                 priority: int,
                 type: 'RuleGroupTextTransformationType'):
        """
        Text Transformation on the Search String before match.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> 'RuleGroupTextTransformationType':
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupVisibilityConfig(dict):
    """
    Visibility Metric of the RuleGroup.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchMetricsEnabled":
            suggest = "cloud_watch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_metrics_enabled: bool,
                 metric_name: str,
                 sampled_requests_enabled: bool):
        """
        Visibility Metric of the RuleGroup.
        """
        pulumi.set(__self__, "cloud_watch_metrics_enabled", cloud_watch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudWatchMetricsEnabled")
    def cloud_watch_metrics_enabled(self) -> bool:
        return pulumi.get(self, "cloud_watch_metrics_enabled")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> bool:
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class RuleGroupXssMatchStatement(dict):
    """
    Xss Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.RuleGroupFieldToMatch',
                 text_transformations: Sequence['outputs.RuleGroupTextTransformation']):
        """
        Xss Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.RuleGroupFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLAllowAction(dict):
    """
    Allow traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLAllowAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLAllowAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLAllowAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebACLCustomRequestHandling'] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebACLCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebACLAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebACLStatement']):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebACLStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebACLBlockAction(dict):
    """
    Block traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLBlockAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLBlockAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLBlockAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebACLCustomResponse'] = None):
        """
        Block traffic towards application.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebACLCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebACLByteMatchStatement(dict):
    """
    Byte Match statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "searchStringBase64":
            suggest = "search_string_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 positional_constraint: 'WebACLPositionalConstraint',
                 text_transformations: Sequence['outputs.WebACLTextTransformation'],
                 search_string: Optional[str] = None,
                 search_string_base64: Optional[str] = None):
        """
        Byte Match statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if search_string is not None:
            pulumi.set(__self__, "search_string", search_string)
        if search_string_base64 is not None:
            pulumi.set(__self__, "search_string_base64", search_string_base64)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> 'WebACLPositionalConstraint':
        return pulumi.get(self, "positional_constraint")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> Optional[str]:
        return pulumi.get(self, "search_string")

    @property
    @pulumi.getter(name="searchStringBase64")
    def search_string_base64(self) -> Optional[str]:
        return pulumi.get(self, "search_string_base64")


@pulumi.output_type
class WebACLCaptchaAction(dict):
    """
    Checks valid token exists with request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCaptchaAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCaptchaAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCaptchaAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebACLCustomRequestHandling'] = None):
        """
        Checks valid token exists with request.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebACLCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebACLCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.WebACLImmunityTimeProperty'] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.WebACLImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class WebACLCountAction(dict):
    """
    Allow traffic towards application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCountAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCountAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCountAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebACLCustomRequestHandling'] = None):
        """
        Allow traffic towards application.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebACLCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebACLCustomHTTPHeader(dict):
    """
    HTTP header.
    """
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebACLCustomRequestHandling(dict):
    """
    Custom request handling.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebACLCustomHTTPHeader']):
        """
        Custom request handling.
        :param Sequence['WebACLCustomHTTPHeader'] insert_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebACLCustomHTTPHeader']:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebACLCustomResponse(dict):
    """
    Custom response.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: int,
                 custom_response_body_key: Optional[str] = None,
                 response_headers: Optional[Sequence['outputs.WebACLCustomHTTPHeader']] = None):
        """
        Custom response.
        :param str custom_response_body_key: Custom response body key.
        :param Sequence['WebACLCustomHTTPHeader'] response_headers: Collection of HTTP headers.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> int:
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[str]:
        """
        Custom response body key.
        """
        return pulumi.get(self, "custom_response_body_key")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebACLCustomHTTPHeader']]:
        """
        Collection of HTTP headers.
        """
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebACLCustomResponseBodies(dict):
    """
    Custom response key and body map.
    """
    def __init__(__self__):
        """
        Custom response key and body map.
        """
        pass


@pulumi.output_type
class WebACLDefaultAction(dict):
    """
    Default Action WebACL will take against ingress traffic when there is no matching Rule.
    """
    def __init__(__self__, *,
                 allow: Optional['outputs.WebACLAllowAction'] = None,
                 block: Optional['outputs.WebACLBlockAction'] = None):
        """
        Default Action WebACL will take against ingress traffic when there is no matching Rule.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebACLAllowAction']:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebACLBlockAction']:
        return pulumi.get(self, "block")


@pulumi.output_type
class WebACLExcludedRule(dict):
    """
    Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
    """
    def __init__(__self__, *,
                 name: str):
        """
        Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebACLFieldIdentifier(dict):
    def __init__(__self__, *,
                 identifier: str):
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebACLFieldToMatch(dict):
    """
    Field of the request to match.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional[Any] = None,
                 body: Optional[Any] = None,
                 json_body: Optional['outputs.WebACLJsonBody'] = None,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional['outputs.WebACLFieldToMatchSingleHeaderProperties'] = None,
                 single_query_argument: Optional['outputs.WebACLFieldToMatchSingleQueryArgumentProperties'] = None,
                 uri_path: Optional[Any] = None):
        """
        Field of the request to match.
        :param Any all_query_arguments: All query arguments of a web request.
        :param Any body: The body of a web request. This immediately follows the request headers.
        :param Any method: The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        :param Any query_string: The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        :param 'WebACLFieldToMatchSingleQueryArgumentProperties' single_query_argument: One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        :param Any uri_path: The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[Any]:
        """
        All query arguments of a web request.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional[Any]:
        """
        The body of a web request. This immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebACLJsonBody']:
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        The query string of a web request. This is the part of a URL that appears after a ? character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebACLFieldToMatchSingleHeaderProperties']:
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebACLFieldToMatchSingleQueryArgumentProperties']:
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebACLFieldToMatchSingleHeaderProperties(dict):
    def __init__(__self__, *,
                 name: str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebACLFieldToMatchSingleQueryArgumentProperties(dict):
    """
    One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
    """
    def __init__(__self__, *,
                 name: str):
        """
        One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebACLForwardedIPConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLForwardedIPConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLForwardedIPConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLForwardedIPConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'WebACLForwardedIPConfigurationFallbackBehavior',
                 header_name: str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'WebACLForwardedIPConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebACLGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIPConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Optional[Sequence[str]] = None,
                 forwarded_ip_config: Optional['outputs.WebACLForwardedIPConfiguration'] = None):
        if country_codes is not None:
            pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebACLForwardedIPConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebACLIPSetForwardedIPConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLIPSetForwardedIPConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLIPSetForwardedIPConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLIPSetForwardedIPConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: 'WebACLIPSetForwardedIPConfigurationFallbackBehavior',
                 header_name: str,
                 position: 'WebACLIPSetForwardedIPConfigurationPosition'):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> 'WebACLIPSetForwardedIPConfigurationFallbackBehavior':
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def position(self) -> 'WebACLIPSetForwardedIPConfigurationPosition':
        return pulumi.get(self, "position")


@pulumi.output_type
class WebACLIPSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iPSetForwardedIPConfig":
            suggest = "i_p_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLIPSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLIPSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLIPSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 i_p_set_forwarded_ip_config: Optional['outputs.WebACLIPSetForwardedIPConfiguration'] = None):
        pulumi.set(__self__, "arn", arn)
        if i_p_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "i_p_set_forwarded_ip_config", i_p_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="iPSetForwardedIPConfig")
    def i_p_set_forwarded_ip_config(self) -> Optional['outputs.WebACLIPSetForwardedIPConfiguration']:
        return pulumi.get(self, "i_p_set_forwarded_ip_config")


@pulumi.output_type
class WebACLImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: int):
        pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> int:
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class WebACLJsonBody(dict):
    """
    Inspect the request body as JSON. The request body immediately follows the request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebACLJsonMatchPattern',
                 match_scope: 'WebACLJsonMatchScope',
                 invalid_fallback_behavior: Optional['WebACLBodyParsingFallbackBehavior'] = None):
        """
        Inspect the request body as JSON. The request body immediately follows the request headers.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebACLJsonMatchPattern':
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> 'WebACLJsonMatchScope':
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional['WebACLBodyParsingFallbackBehavior']:
        return pulumi.get(self, "invalid_fallback_behavior")


@pulumi.output_type
class WebACLJsonMatchPattern(dict):
    """
    The pattern to look for in the JSON body.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLJsonMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLJsonMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLJsonMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[Any] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        The pattern to look for in the JSON body.
        :param Any all: Inspect all parts of the web request's JSON body.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[Any]:
        """
        Inspect all parts of the web request's JSON body.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebACLLabel(dict):
    def __init__(__self__, *,
                 name: str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebACLLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: str,
                 scope: 'WebACLLabelMatchScope'):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def scope(self) -> 'WebACLLabelMatchScope':
        return pulumi.get(self, "scope")


@pulumi.output_type
class WebACLManagedRuleGroupConfig(dict):
    """
    ManagedRuleGroupConfig.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginPath":
            suggest = "login_path"
        elif key == "passwordField":
            suggest = "password_field"
        elif key == "payloadType":
            suggest = "payload_type"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLManagedRuleGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLManagedRuleGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLManagedRuleGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_path: Optional[str] = None,
                 password_field: Optional['outputs.WebACLFieldIdentifier'] = None,
                 payload_type: Optional['WebACLManagedRuleGroupConfigPayloadType'] = None,
                 username_field: Optional['outputs.WebACLFieldIdentifier'] = None):
        """
        ManagedRuleGroupConfig.
        """
        if login_path is not None:
            pulumi.set(__self__, "login_path", login_path)
        if password_field is not None:
            pulumi.set(__self__, "password_field", password_field)
        if payload_type is not None:
            pulumi.set(__self__, "payload_type", payload_type)
        if username_field is not None:
            pulumi.set(__self__, "username_field", username_field)

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> Optional[str]:
        return pulumi.get(self, "login_path")

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional['outputs.WebACLFieldIdentifier']:
        return pulumi.get(self, "password_field")

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> Optional['WebACLManagedRuleGroupConfigPayloadType']:
        return pulumi.get(self, "payload_type")

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional['outputs.WebACLFieldIdentifier']:
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebACLManagedRuleGroupStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vendorName":
            suggest = "vendor_name"
        elif key == "excludedRules":
            suggest = "excluded_rules"
        elif key == "managedRuleGroupConfigs":
            suggest = "managed_rule_group_configs"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLManagedRuleGroupStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLManagedRuleGroupStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLManagedRuleGroupStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 vendor_name: str,
                 excluded_rules: Optional[Sequence['outputs.WebACLExcludedRule']] = None,
                 managed_rule_group_configs: Optional[Sequence['outputs.WebACLManagedRuleGroupConfig']] = None,
                 scope_down_statement: Optional['outputs.WebACLStatement'] = None,
                 version: Optional[str] = None):
        """
        :param Sequence['WebACLManagedRuleGroupConfig'] managed_rule_group_configs: Collection of ManagedRuleGroupConfig.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vendor_name", vendor_name)
        if excluded_rules is not None:
            pulumi.set(__self__, "excluded_rules", excluded_rules)
        if managed_rule_group_configs is not None:
            pulumi.set(__self__, "managed_rule_group_configs", managed_rule_group_configs)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> str:
        return pulumi.get(self, "vendor_name")

    @property
    @pulumi.getter(name="excludedRules")
    def excluded_rules(self) -> Optional[Sequence['outputs.WebACLExcludedRule']]:
        return pulumi.get(self, "excluded_rules")

    @property
    @pulumi.getter(name="managedRuleGroupConfigs")
    def managed_rule_group_configs(self) -> Optional[Sequence['outputs.WebACLManagedRuleGroupConfig']]:
        """
        Collection of ManagedRuleGroupConfig.
        """
        return pulumi.get(self, "managed_rule_group_configs")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.WebACLStatement']:
        return pulumi.get(self, "scope_down_statement")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class WebACLNotStatement(dict):
    def __init__(__self__, *,
                 statement: 'outputs.WebACLStatement'):
        pulumi.set(__self__, "statement", statement)

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.WebACLStatement':
        return pulumi.get(self, "statement")


@pulumi.output_type
class WebACLOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebACLStatement']):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebACLStatement']:
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebACLOverrideAction(dict):
    """
    Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
    """
    def __init__(__self__, *,
                 count: Optional[Any] = None,
                 none: Optional[Any] = None):
        """
        Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
        :param Any count: Count traffic towards application.
        :param Any none: Keep the RuleGroup or ManagedRuleGroup behavior as is.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @property
    @pulumi.getter
    def count(self) -> Optional[Any]:
        """
        Count traffic towards application.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def none(self) -> Optional[Any]:
        """
        Keep the RuleGroup or ManagedRuleGroup behavior as is.
        """
        return pulumi.get(self, "none")


@pulumi.output_type
class WebACLRateBasedStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateKeyType":
            suggest = "aggregate_key_type"
        elif key == "forwardedIPConfig":
            suggest = "forwarded_ip_config"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRateBasedStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRateBasedStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRateBasedStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregate_key_type: 'WebACLRateBasedStatementAggregateKeyType',
                 limit: int,
                 forwarded_ip_config: Optional['outputs.WebACLForwardedIPConfiguration'] = None,
                 scope_down_statement: Optional['outputs.WebACLStatement'] = None):
        pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        pulumi.set(__self__, "limit", limit)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> 'WebACLRateBasedStatementAggregateKeyType':
        return pulumi.get(self, "aggregate_key_type")

    @property
    @pulumi.getter
    def limit(self) -> int:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="forwardedIPConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebACLForwardedIPConfiguration']:
        return pulumi.get(self, "forwarded_ip_config")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.WebACLStatement']:
        return pulumi.get(self, "scope_down_statement")


@pulumi.output_type
class WebACLRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 regex_string: str,
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        return pulumi.get(self, "regex_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLRule(dict):
    """
    Rule of WebACL that contains condition and action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityConfig":
            suggest = "visibility_config"
        elif key == "captchaConfig":
            suggest = "captcha_config"
        elif key == "overrideAction":
            suggest = "override_action"
        elif key == "ruleLabels":
            suggest = "rule_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 priority: int,
                 statement: 'outputs.WebACLStatement',
                 visibility_config: 'outputs.WebACLVisibilityConfig',
                 action: Optional['outputs.WebACLRuleAction'] = None,
                 captcha_config: Optional['outputs.WebACLCaptchaConfig'] = None,
                 override_action: Optional['outputs.WebACLOverrideAction'] = None,
                 rule_labels: Optional[Sequence['outputs.WebACLLabel']] = None):
        """
        Rule of WebACL that contains condition and action.
        :param Sequence['WebACLLabel'] rule_labels: Collection of Rule Labels.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if override_action is not None:
            pulumi.set(__self__, "override_action", override_action)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.WebACLStatement':
        return pulumi.get(self, "statement")

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> 'outputs.WebACLVisibilityConfig':
        return pulumi.get(self, "visibility_config")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.WebACLRuleAction']:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional['outputs.WebACLCaptchaConfig']:
        return pulumi.get(self, "captcha_config")

    @property
    @pulumi.getter(name="overrideAction")
    def override_action(self) -> Optional['outputs.WebACLOverrideAction']:
        return pulumi.get(self, "override_action")

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[Sequence['outputs.WebACLLabel']]:
        """
        Collection of Rule Labels.
        """
        return pulumi.get(self, "rule_labels")


@pulumi.output_type
class WebACLRuleAction(dict):
    """
    Action taken when Rule matches its condition.
    """
    def __init__(__self__, *,
                 allow: Optional['outputs.WebACLAllowAction'] = None,
                 block: Optional['outputs.WebACLBlockAction'] = None,
                 captcha: Optional['outputs.WebACLCaptchaAction'] = None,
                 count: Optional['outputs.WebACLCountAction'] = None):
        """
        Action taken when Rule matches its condition.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebACLAllowAction']:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebACLBlockAction']:
        return pulumi.get(self, "block")

    @property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.WebACLCaptchaAction']:
        return pulumi.get(self, "captcha")

    @property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebACLCountAction']:
        return pulumi.get(self, "count")


@pulumi.output_type
class WebACLRuleGroupReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedRules":
            suggest = "excluded_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLRuleGroupReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLRuleGroupReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLRuleGroupReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 excluded_rules: Optional[Sequence['outputs.WebACLExcludedRule']] = None):
        pulumi.set(__self__, "arn", arn)
        if excluded_rules is not None:
            pulumi.set(__self__, "excluded_rules", excluded_rules)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="excludedRules")
    def excluded_rules(self) -> Optional[Sequence['outputs.WebACLExcludedRule']]:
        return pulumi.get(self, "excluded_rules")


@pulumi.output_type
class WebACLSizeConstraintStatement(dict):
    """
    Size Constraint statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: 'WebACLSizeConstraintStatementComparisonOperator',
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 size: float,
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        """
        Size Constraint statement.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> 'WebACLSizeConstraintStatementComparisonOperator':
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter
    def size(self) -> float:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLSqliMatchStatement(dict):
    """
    Sqli Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        """
        Sqli Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebACLStatement(dict):
    """
    First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "iPSetReferenceStatement":
            suggest = "i_p_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "managedRuleGroupStatement":
            suggest = "managed_rule_group_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "rateBasedStatement":
            suggest = "rate_based_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "ruleGroupReferenceStatement":
            suggest = "rule_group_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.WebACLAndStatement'] = None,
                 byte_match_statement: Optional['outputs.WebACLByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.WebACLGeoMatchStatement'] = None,
                 i_p_set_reference_statement: Optional['outputs.WebACLIPSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.WebACLLabelMatchStatement'] = None,
                 managed_rule_group_statement: Optional['outputs.WebACLManagedRuleGroupStatement'] = None,
                 not_statement: Optional['outputs.WebACLNotStatement'] = None,
                 or_statement: Optional['outputs.WebACLOrStatement'] = None,
                 rate_based_statement: Optional['outputs.WebACLRateBasedStatement'] = None,
                 regex_match_statement: Optional['outputs.WebACLRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.WebACLRegexPatternSetReferenceStatement'] = None,
                 rule_group_reference_statement: Optional['outputs.WebACLRuleGroupReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.WebACLSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.WebACLSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.WebACLXssMatchStatement'] = None):
        """
        First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if i_p_set_reference_statement is not None:
            pulumi.set(__self__, "i_p_set_reference_statement", i_p_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if managed_rule_group_statement is not None:
            pulumi.set(__self__, "managed_rule_group_statement", managed_rule_group_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if rule_group_reference_statement is not None:
            pulumi.set(__self__, "rule_group_reference_statement", rule_group_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.WebACLAndStatement']:
        return pulumi.get(self, "and_statement")

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.WebACLByteMatchStatement']:
        return pulumi.get(self, "byte_match_statement")

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.WebACLGeoMatchStatement']:
        return pulumi.get(self, "geo_match_statement")

    @property
    @pulumi.getter(name="iPSetReferenceStatement")
    def i_p_set_reference_statement(self) -> Optional['outputs.WebACLIPSetReferenceStatement']:
        return pulumi.get(self, "i_p_set_reference_statement")

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.WebACLLabelMatchStatement']:
        return pulumi.get(self, "label_match_statement")

    @property
    @pulumi.getter(name="managedRuleGroupStatement")
    def managed_rule_group_statement(self) -> Optional['outputs.WebACLManagedRuleGroupStatement']:
        return pulumi.get(self, "managed_rule_group_statement")

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.WebACLNotStatement']:
        return pulumi.get(self, "not_statement")

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.WebACLOrStatement']:
        return pulumi.get(self, "or_statement")

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional['outputs.WebACLRateBasedStatement']:
        return pulumi.get(self, "rate_based_statement")

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.WebACLRegexMatchStatement']:
        return pulumi.get(self, "regex_match_statement")

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.WebACLRegexPatternSetReferenceStatement']:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @property
    @pulumi.getter(name="ruleGroupReferenceStatement")
    def rule_group_reference_statement(self) -> Optional['outputs.WebACLRuleGroupReferenceStatement']:
        return pulumi.get(self, "rule_group_reference_statement")

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.WebACLSizeConstraintStatement']:
        return pulumi.get(self, "size_constraint_statement")

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.WebACLSqliMatchStatement']:
        return pulumi.get(self, "sqli_match_statement")

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.WebACLXssMatchStatement']:
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class WebACLTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebACLTextTransformation(dict):
    """
    Text Transformation on the Search String before match.
    """
    def __init__(__self__, *,
                 priority: int,
                 type: 'WebACLTextTransformationType'):
        """
        Text Transformation on the Search String before match.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> 'WebACLTextTransformationType':
        return pulumi.get(self, "type")


@pulumi.output_type
class WebACLVisibilityConfig(dict):
    """
    Visibility Metric of the WebACL.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchMetricsEnabled":
            suggest = "cloud_watch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_metrics_enabled: bool,
                 metric_name: str,
                 sampled_requests_enabled: bool):
        """
        Visibility Metric of the WebACL.
        """
        pulumi.set(__self__, "cloud_watch_metrics_enabled", cloud_watch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudWatchMetricsEnabled")
    def cloud_watch_metrics_enabled(self) -> bool:
        return pulumi.get(self, "cloud_watch_metrics_enabled")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> bool:
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class WebACLXssMatchStatement(dict):
    """
    Xss Match Statement.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebACLXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebACLXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebACLXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_to_match: 'outputs.WebACLFieldToMatch',
                 text_transformations: Sequence['outputs.WebACLTextTransformation']):
        """
        Xss Match Statement.
        """
        pulumi.set(__self__, "field_to_match", field_to_match)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> 'outputs.WebACLFieldToMatch':
        return pulumi.get(self, "field_to_match")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebACLTextTransformation']:
        return pulumi.get(self, "text_transformations")


