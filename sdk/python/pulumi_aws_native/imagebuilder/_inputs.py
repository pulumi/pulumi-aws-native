# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ContainerRecipeComponentConfigurationArgs',
    'ContainerRecipeComponentConfigurationArgsDict',
    'ContainerRecipeComponentParameterArgs',
    'ContainerRecipeComponentParameterArgsDict',
    'ContainerRecipeEbsInstanceBlockDeviceSpecificationArgs',
    'ContainerRecipeEbsInstanceBlockDeviceSpecificationArgsDict',
    'ContainerRecipeInstanceBlockDeviceMappingArgs',
    'ContainerRecipeInstanceBlockDeviceMappingArgsDict',
    'ContainerRecipeInstanceConfigurationArgs',
    'ContainerRecipeInstanceConfigurationArgsDict',
    'ContainerRecipeTargetContainerRepositoryArgs',
    'ContainerRecipeTargetContainerRepositoryArgsDict',
    'DistributionConfigurationAmiDistributionConfigurationArgs',
    'DistributionConfigurationAmiDistributionConfigurationArgsDict',
    'DistributionConfigurationContainerDistributionConfigurationArgs',
    'DistributionConfigurationContainerDistributionConfigurationArgsDict',
    'DistributionConfigurationDistributionArgs',
    'DistributionConfigurationDistributionArgsDict',
    'DistributionConfigurationFastLaunchConfigurationArgs',
    'DistributionConfigurationFastLaunchConfigurationArgsDict',
    'DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgs',
    'DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgsDict',
    'DistributionConfigurationFastLaunchSnapshotConfigurationArgs',
    'DistributionConfigurationFastLaunchSnapshotConfigurationArgsDict',
    'DistributionConfigurationLaunchPermissionConfigurationArgs',
    'DistributionConfigurationLaunchPermissionConfigurationArgsDict',
    'DistributionConfigurationLaunchTemplateConfigurationArgs',
    'DistributionConfigurationLaunchTemplateConfigurationArgsDict',
    'DistributionConfigurationTargetContainerRepositoryArgs',
    'DistributionConfigurationTargetContainerRepositoryArgsDict',
    'ImageEcrConfigurationArgs',
    'ImageEcrConfigurationArgsDict',
    'ImagePipelineEcrConfigurationArgs',
    'ImagePipelineEcrConfigurationArgsDict',
    'ImagePipelineImageScanningConfigurationArgs',
    'ImagePipelineImageScanningConfigurationArgsDict',
    'ImagePipelineImageTestsConfigurationArgs',
    'ImagePipelineImageTestsConfigurationArgsDict',
    'ImagePipelineScheduleArgs',
    'ImagePipelineScheduleArgsDict',
    'ImagePipelineWorkflowConfigurationArgs',
    'ImagePipelineWorkflowConfigurationArgsDict',
    'ImagePipelineWorkflowParameterArgs',
    'ImagePipelineWorkflowParameterArgsDict',
    'ImageRecipeAdditionalInstanceConfigurationArgs',
    'ImageRecipeAdditionalInstanceConfigurationArgsDict',
    'ImageRecipeComponentConfigurationArgs',
    'ImageRecipeComponentConfigurationArgsDict',
    'ImageRecipeComponentParameterArgs',
    'ImageRecipeComponentParameterArgsDict',
    'ImageRecipeEbsInstanceBlockDeviceSpecificationArgs',
    'ImageRecipeEbsInstanceBlockDeviceSpecificationArgsDict',
    'ImageRecipeInstanceBlockDeviceMappingArgs',
    'ImageRecipeInstanceBlockDeviceMappingArgsDict',
    'ImageRecipeSystemsManagerAgentArgs',
    'ImageRecipeSystemsManagerAgentArgsDict',
    'ImageScanningConfigurationArgs',
    'ImageScanningConfigurationArgsDict',
    'ImageTestsConfigurationArgs',
    'ImageTestsConfigurationArgsDict',
    'ImageWorkflowConfigurationArgs',
    'ImageWorkflowConfigurationArgsDict',
    'ImageWorkflowParameterArgs',
    'ImageWorkflowParameterArgsDict',
    'InfrastructureConfigurationInstanceMetadataOptionsArgs',
    'InfrastructureConfigurationInstanceMetadataOptionsArgsDict',
    'InfrastructureConfigurationLoggingArgs',
    'InfrastructureConfigurationLoggingArgsDict',
    'InfrastructureConfigurationPlacementArgs',
    'InfrastructureConfigurationPlacementArgsDict',
    'InfrastructureConfigurationS3LogsArgs',
    'InfrastructureConfigurationS3LogsArgsDict',
    'LifecyclePolicyActionArgs',
    'LifecyclePolicyActionArgsDict',
    'LifecyclePolicyAmiExclusionRulesArgs',
    'LifecyclePolicyAmiExclusionRulesArgsDict',
    'LifecyclePolicyExclusionRulesArgs',
    'LifecyclePolicyExclusionRulesArgsDict',
    'LifecyclePolicyFilterArgs',
    'LifecyclePolicyFilterArgsDict',
    'LifecyclePolicyIncludeResourcesArgs',
    'LifecyclePolicyIncludeResourcesArgsDict',
    'LifecyclePolicyLastLaunchedArgs',
    'LifecyclePolicyLastLaunchedArgsDict',
    'LifecyclePolicyPolicyDetailArgs',
    'LifecyclePolicyPolicyDetailArgsDict',
    'LifecyclePolicyRecipeSelectionArgs',
    'LifecyclePolicyRecipeSelectionArgsDict',
    'LifecyclePolicyResourceSelectionArgs',
    'LifecyclePolicyResourceSelectionArgsDict',
]

MYPY = False

if not MYPY:
    class ContainerRecipeComponentConfigurationArgsDict(TypedDict):
        """
        Configuration details of the component.
        """
        component_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the component.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerRecipeComponentParameterArgsDict']]]]
        """
        A group of parameter settings that are used to configure the component for a specific recipe.
        """
elif False:
    ContainerRecipeComponentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRecipeComponentConfigurationArgs:
    def __init__(__self__, *,
                 component_arn: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRecipeComponentParameterArgs']]]] = None):
        """
        Configuration details of the component.
        :param pulumi.Input[str] component_arn: The Amazon Resource Name (ARN) of the component.
        :param pulumi.Input[Sequence[pulumi.Input['ContainerRecipeComponentParameterArgs']]] parameters: A group of parameter settings that are used to configure the component for a specific recipe.
        """
        if component_arn is not None:
            pulumi.set(__self__, "component_arn", component_arn)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="componentArn")
    def component_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the component.
        """
        return pulumi.get(self, "component_arn")

    @component_arn.setter
    def component_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "component_arn", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRecipeComponentParameterArgs']]]]:
        """
        A group of parameter settings that are used to configure the component for a specific recipe.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRecipeComponentParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class ContainerRecipeComponentParameterArgsDict(TypedDict):
        """
        Contains a key/value pair that sets the named component parameter.
        """
        name: pulumi.Input[str]
        """
        The name of the component parameter to set.
        """
        value: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Sets the value for the named component parameter.
        """
elif False:
    ContainerRecipeComponentParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRecipeComponentParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Contains a key/value pair that sets the named component parameter.
        :param pulumi.Input[str] name: The name of the component parameter to set.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] value: Sets the value for the named component parameter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the component parameter to set.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Sets the value for the named component parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ContainerRecipeEbsInstanceBlockDeviceSpecificationArgsDict(TypedDict):
        """
        Amazon EBS-specific block device mapping specifications. 
        """
        delete_on_termination: NotRequired[pulumi.Input[bool]]
        """
        Use to configure delete on termination of the associated device.
        """
        encrypted: NotRequired[pulumi.Input[bool]]
        """
        Use to configure device encryption.
        """
        iops: NotRequired[pulumi.Input[int]]
        """
        Use to configure device IOPS.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        Use to configure the KMS key to use when encrypting the device.
        """
        snapshot_id: NotRequired[pulumi.Input[str]]
        """
        The snapshot that defines the device contents.
        """
        throughput: NotRequired[pulumi.Input[int]]
        """
        For GP3 volumes only - The throughput in MiB/s that the volume supports.
        """
        volume_size: NotRequired[pulumi.Input[int]]
        """
        Use to override the device's volume size.
        """
        volume_type: NotRequired[pulumi.Input['ContainerRecipeEbsInstanceBlockDeviceSpecificationVolumeType']]
        """
        Use to override the device's volume type.
        """
elif False:
    ContainerRecipeEbsInstanceBlockDeviceSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRecipeEbsInstanceBlockDeviceSpecificationArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input['ContainerRecipeEbsInstanceBlockDeviceSpecificationVolumeType']] = None):
        """
        Amazon EBS-specific block device mapping specifications. 
        :param pulumi.Input[bool] delete_on_termination: Use to configure delete on termination of the associated device.
        :param pulumi.Input[bool] encrypted: Use to configure device encryption.
        :param pulumi.Input[int] iops: Use to configure device IOPS.
        :param pulumi.Input[str] kms_key_id: Use to configure the KMS key to use when encrypting the device.
        :param pulumi.Input[str] snapshot_id: The snapshot that defines the device contents.
        :param pulumi.Input[int] throughput: For GP3 volumes only - The throughput in MiB/s that the volume supports.
        :param pulumi.Input[int] volume_size: Use to override the device's volume size.
        :param pulumi.Input['ContainerRecipeEbsInstanceBlockDeviceSpecificationVolumeType'] volume_type: Use to override the device's volume type.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Use to configure delete on termination of the associated device.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Use to configure device encryption.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Use to configure device IOPS.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Use to configure the KMS key to use when encrypting the device.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The snapshot that defines the device contents.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        For GP3 volumes only - The throughput in MiB/s that the volume supports.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        Use to override the device's volume size.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input['ContainerRecipeEbsInstanceBlockDeviceSpecificationVolumeType']]:
        """
        Use to override the device's volume type.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input['ContainerRecipeEbsInstanceBlockDeviceSpecificationVolumeType']]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ContainerRecipeInstanceBlockDeviceMappingArgsDict(TypedDict):
        """
        Defines block device mappings for the instance used to configure your image. 
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        The device to which these mappings apply.
        """
        ebs: NotRequired[pulumi.Input['ContainerRecipeEbsInstanceBlockDeviceSpecificationArgsDict']]
        """
        Use to manage Amazon EBS-specific configuration for this mapping.
        """
        no_device: NotRequired[pulumi.Input[str]]
        """
        Use to remove a mapping from the parent image.
        """
        virtual_name: NotRequired[pulumi.Input[str]]
        """
        Use to manage instance ephemeral devices.
        """
elif False:
    ContainerRecipeInstanceBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRecipeInstanceBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 ebs: Optional[pulumi.Input['ContainerRecipeEbsInstanceBlockDeviceSpecificationArgs']] = None,
                 no_device: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        Defines block device mappings for the instance used to configure your image. 
        :param pulumi.Input[str] device_name: The device to which these mappings apply.
        :param pulumi.Input['ContainerRecipeEbsInstanceBlockDeviceSpecificationArgs'] ebs: Use to manage Amazon EBS-specific configuration for this mapping.
        :param pulumi.Input[str] no_device: Use to remove a mapping from the parent image.
        :param pulumi.Input[str] virtual_name: Use to manage instance ephemeral devices.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The device to which these mappings apply.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['ContainerRecipeEbsInstanceBlockDeviceSpecificationArgs']]:
        """
        Use to manage Amazon EBS-specific configuration for this mapping.
        """
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['ContainerRecipeEbsInstanceBlockDeviceSpecificationArgs']]):
        pulumi.set(self, "ebs", value)

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[str]]:
        """
        Use to remove a mapping from the parent image.
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_device", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        Use to manage instance ephemeral devices.
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


if not MYPY:
    class ContainerRecipeInstanceConfigurationArgsDict(TypedDict):
        """
        A group of options that can be used to configure an instance for building and testing container images.
        """
        block_device_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerRecipeInstanceBlockDeviceMappingArgsDict']]]]
        """
        Defines the block devices to attach for building an instance from this Image Builder AMI.
        """
        image: NotRequired[pulumi.Input[str]]
        """
        The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
        """
elif False:
    ContainerRecipeInstanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRecipeInstanceConfigurationArgs:
    def __init__(__self__, *,
                 block_device_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRecipeInstanceBlockDeviceMappingArgs']]]] = None,
                 image: Optional[pulumi.Input[str]] = None):
        """
        A group of options that can be used to configure an instance for building and testing container images.
        :param pulumi.Input[Sequence[pulumi.Input['ContainerRecipeInstanceBlockDeviceMappingArgs']]] block_device_mappings: Defines the block devices to attach for building an instance from this Image Builder AMI.
        :param pulumi.Input[str] image: The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
        """
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRecipeInstanceBlockDeviceMappingArgs']]]]:
        """
        Defines the block devices to attach for building an instance from this Image Builder AMI.
        """
        return pulumi.get(self, "block_device_mappings")

    @block_device_mappings.setter
    def block_device_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerRecipeInstanceBlockDeviceMappingArgs']]]]):
        pulumi.set(self, "block_device_mappings", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)


if not MYPY:
    class ContainerRecipeTargetContainerRepositoryArgsDict(TypedDict):
        """
        The container repository where the output container image is stored.
        """
        repository_name: NotRequired[pulumi.Input[str]]
        """
        The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
        """
        service: NotRequired[pulumi.Input['ContainerRecipeTargetContainerRepositoryService']]
        """
        Specifies the service in which this image was registered.
        """
elif False:
    ContainerRecipeTargetContainerRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRecipeTargetContainerRepositoryArgs:
    def __init__(__self__, *,
                 repository_name: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input['ContainerRecipeTargetContainerRepositoryService']] = None):
        """
        The container repository where the output container image is stored.
        :param pulumi.Input[str] repository_name: The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
        :param pulumi.Input['ContainerRecipeTargetContainerRepositoryService'] service: Specifies the service in which this image was registered.
        """
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_name", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['ContainerRecipeTargetContainerRepositoryService']]:
        """
        Specifies the service in which this image was registered.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['ContainerRecipeTargetContainerRepositoryService']]):
        pulumi.set(self, "service", value)


if not MYPY:
    class DistributionConfigurationAmiDistributionConfigurationArgsDict(TypedDict):
        """
        The specific AMI settings (for example, launch permissions, AMI tags).
        """
        ami_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The tags to apply to AMIs distributed to this Region.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the AMI distribution configuration.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The KMS key identifier used to encrypt the distributed image.
        """
        launch_permission_configuration: NotRequired[pulumi.Input['DistributionConfigurationLaunchPermissionConfigurationArgsDict']]
        """
        Launch permissions can be used to configure which AWS account s can use the AMI to launch instances.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the AMI distribution configuration.
        """
        target_account_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of accounts to which you want to distribute an image.
        """
elif False:
    DistributionConfigurationAmiDistributionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionConfigurationAmiDistributionConfigurationArgs:
    def __init__(__self__, *,
                 ami_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 launch_permission_configuration: Optional[pulumi.Input['DistributionConfigurationLaunchPermissionConfigurationArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 target_account_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The specific AMI settings (for example, launch permissions, AMI tags).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] ami_tags: The tags to apply to AMIs distributed to this Region.
        :param pulumi.Input[str] description: The description of the AMI distribution configuration.
        :param pulumi.Input[str] kms_key_id: The KMS key identifier used to encrypt the distributed image.
        :param pulumi.Input['DistributionConfigurationLaunchPermissionConfigurationArgs'] launch_permission_configuration: Launch permissions can be used to configure which AWS account s can use the AMI to launch instances.
        :param pulumi.Input[str] name: The name of the AMI distribution configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_account_ids: The ID of accounts to which you want to distribute an image.
        """
        if ami_tags is not None:
            pulumi.set(__self__, "ami_tags", ami_tags)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if launch_permission_configuration is not None:
            pulumi.set(__self__, "launch_permission_configuration", launch_permission_configuration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_account_ids is not None:
            pulumi.set(__self__, "target_account_ids", target_account_ids)

    @property
    @pulumi.getter(name="amiTags")
    def ami_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The tags to apply to AMIs distributed to this Region.
        """
        return pulumi.get(self, "ami_tags")

    @ami_tags.setter
    def ami_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "ami_tags", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the AMI distribution configuration.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The KMS key identifier used to encrypt the distributed image.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="launchPermissionConfiguration")
    def launch_permission_configuration(self) -> Optional[pulumi.Input['DistributionConfigurationLaunchPermissionConfigurationArgs']]:
        """
        Launch permissions can be used to configure which AWS account s can use the AMI to launch instances.
        """
        return pulumi.get(self, "launch_permission_configuration")

    @launch_permission_configuration.setter
    def launch_permission_configuration(self, value: Optional[pulumi.Input['DistributionConfigurationLaunchPermissionConfigurationArgs']]):
        pulumi.set(self, "launch_permission_configuration", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the AMI distribution configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="targetAccountIds")
    def target_account_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of accounts to which you want to distribute an image.
        """
        return pulumi.get(self, "target_account_ids")

    @target_account_ids.setter
    def target_account_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_account_ids", value)


if not MYPY:
    class DistributionConfigurationContainerDistributionConfigurationArgsDict(TypedDict):
        """
        Container distribution settings for encryption, licensing, and sharing in a specific Region.
        """
        container_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Tags that are attached to the container distribution configuration.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the container distribution configuration.
        """
        target_repository: NotRequired[pulumi.Input['DistributionConfigurationTargetContainerRepositoryArgsDict']]
        """
        The destination repository for the container distribution configuration.
        """
elif False:
    DistributionConfigurationContainerDistributionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionConfigurationContainerDistributionConfigurationArgs:
    def __init__(__self__, *,
                 container_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 target_repository: Optional[pulumi.Input['DistributionConfigurationTargetContainerRepositoryArgs']] = None):
        """
        Container distribution settings for encryption, licensing, and sharing in a specific Region.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_tags: Tags that are attached to the container distribution configuration.
        :param pulumi.Input[str] description: The description of the container distribution configuration.
        :param pulumi.Input['DistributionConfigurationTargetContainerRepositoryArgs'] target_repository: The destination repository for the container distribution configuration.
        """
        if container_tags is not None:
            pulumi.set(__self__, "container_tags", container_tags)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if target_repository is not None:
            pulumi.set(__self__, "target_repository", target_repository)

    @property
    @pulumi.getter(name="containerTags")
    def container_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Tags that are attached to the container distribution configuration.
        """
        return pulumi.get(self, "container_tags")

    @container_tags.setter
    def container_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_tags", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the container distribution configuration.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="targetRepository")
    def target_repository(self) -> Optional[pulumi.Input['DistributionConfigurationTargetContainerRepositoryArgs']]:
        """
        The destination repository for the container distribution configuration.
        """
        return pulumi.get(self, "target_repository")

    @target_repository.setter
    def target_repository(self, value: Optional[pulumi.Input['DistributionConfigurationTargetContainerRepositoryArgs']]):
        pulumi.set(self, "target_repository", value)


if not MYPY:
    class DistributionConfigurationDistributionArgsDict(TypedDict):
        """
        The distributions of the distribution configuration.
        """
        region: pulumi.Input[str]
        """
        region
        """
        ami_distribution_configuration: NotRequired[pulumi.Input['DistributionConfigurationAmiDistributionConfigurationArgsDict']]
        """
        The specific AMI settings, such as launch permissions and AMI tags. For details, see example schema below.
        """
        container_distribution_configuration: NotRequired[pulumi.Input['DistributionConfigurationContainerDistributionConfigurationArgsDict']]
        """
        Container distribution settings for encryption, licensing, and sharing in a specific Region. For details, see example schema below.
        """
        fast_launch_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DistributionConfigurationFastLaunchConfigurationArgsDict']]]]
        """
        The Windows faster-launching configurations to use for AMI distribution.
        """
        launch_template_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DistributionConfigurationLaunchTemplateConfigurationArgsDict']]]]
        """
        A group of launchTemplateConfiguration settings that apply to image distribution.
        """
        license_configuration_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The License Manager Configuration to associate with the AMI in the specified Region.
        """
elif False:
    DistributionConfigurationDistributionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionConfigurationDistributionArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[str],
                 ami_distribution_configuration: Optional[pulumi.Input['DistributionConfigurationAmiDistributionConfigurationArgs']] = None,
                 container_distribution_configuration: Optional[pulumi.Input['DistributionConfigurationContainerDistributionConfigurationArgs']] = None,
                 fast_launch_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionConfigurationFastLaunchConfigurationArgs']]]] = None,
                 launch_template_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionConfigurationLaunchTemplateConfigurationArgs']]]] = None,
                 license_configuration_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The distributions of the distribution configuration.
        :param pulumi.Input[str] region: region
        :param pulumi.Input['DistributionConfigurationAmiDistributionConfigurationArgs'] ami_distribution_configuration: The specific AMI settings, such as launch permissions and AMI tags. For details, see example schema below.
        :param pulumi.Input['DistributionConfigurationContainerDistributionConfigurationArgs'] container_distribution_configuration: Container distribution settings for encryption, licensing, and sharing in a specific Region. For details, see example schema below.
        :param pulumi.Input[Sequence[pulumi.Input['DistributionConfigurationFastLaunchConfigurationArgs']]] fast_launch_configurations: The Windows faster-launching configurations to use for AMI distribution.
        :param pulumi.Input[Sequence[pulumi.Input['DistributionConfigurationLaunchTemplateConfigurationArgs']]] launch_template_configurations: A group of launchTemplateConfiguration settings that apply to image distribution.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] license_configuration_arns: The License Manager Configuration to associate with the AMI in the specified Region.
        """
        pulumi.set(__self__, "region", region)
        if ami_distribution_configuration is not None:
            pulumi.set(__self__, "ami_distribution_configuration", ami_distribution_configuration)
        if container_distribution_configuration is not None:
            pulumi.set(__self__, "container_distribution_configuration", container_distribution_configuration)
        if fast_launch_configurations is not None:
            pulumi.set(__self__, "fast_launch_configurations", fast_launch_configurations)
        if launch_template_configurations is not None:
            pulumi.set(__self__, "launch_template_configurations", launch_template_configurations)
        if license_configuration_arns is not None:
            pulumi.set(__self__, "license_configuration_arns", license_configuration_arns)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="amiDistributionConfiguration")
    def ami_distribution_configuration(self) -> Optional[pulumi.Input['DistributionConfigurationAmiDistributionConfigurationArgs']]:
        """
        The specific AMI settings, such as launch permissions and AMI tags. For details, see example schema below.
        """
        return pulumi.get(self, "ami_distribution_configuration")

    @ami_distribution_configuration.setter
    def ami_distribution_configuration(self, value: Optional[pulumi.Input['DistributionConfigurationAmiDistributionConfigurationArgs']]):
        pulumi.set(self, "ami_distribution_configuration", value)

    @property
    @pulumi.getter(name="containerDistributionConfiguration")
    def container_distribution_configuration(self) -> Optional[pulumi.Input['DistributionConfigurationContainerDistributionConfigurationArgs']]:
        """
        Container distribution settings for encryption, licensing, and sharing in a specific Region. For details, see example schema below.
        """
        return pulumi.get(self, "container_distribution_configuration")

    @container_distribution_configuration.setter
    def container_distribution_configuration(self, value: Optional[pulumi.Input['DistributionConfigurationContainerDistributionConfigurationArgs']]):
        pulumi.set(self, "container_distribution_configuration", value)

    @property
    @pulumi.getter(name="fastLaunchConfigurations")
    def fast_launch_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DistributionConfigurationFastLaunchConfigurationArgs']]]]:
        """
        The Windows faster-launching configurations to use for AMI distribution.
        """
        return pulumi.get(self, "fast_launch_configurations")

    @fast_launch_configurations.setter
    def fast_launch_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionConfigurationFastLaunchConfigurationArgs']]]]):
        pulumi.set(self, "fast_launch_configurations", value)

    @property
    @pulumi.getter(name="launchTemplateConfigurations")
    def launch_template_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DistributionConfigurationLaunchTemplateConfigurationArgs']]]]:
        """
        A group of launchTemplateConfiguration settings that apply to image distribution.
        """
        return pulumi.get(self, "launch_template_configurations")

    @launch_template_configurations.setter
    def launch_template_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionConfigurationLaunchTemplateConfigurationArgs']]]]):
        pulumi.set(self, "launch_template_configurations", value)

    @property
    @pulumi.getter(name="licenseConfigurationArns")
    def license_configuration_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The License Manager Configuration to associate with the AMI in the specified Region.
        """
        return pulumi.get(self, "license_configuration_arns")

    @license_configuration_arns.setter
    def license_configuration_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "license_configuration_arns", value)


if not MYPY:
    class DistributionConfigurationFastLaunchConfigurationArgsDict(TypedDict):
        """
        The Windows faster-launching configuration to use for AMI distribution.
        """
        account_id: NotRequired[pulumi.Input[str]]
        """
        The owner account ID for the fast-launch enabled Windows AMI.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        A Boolean that represents the current state of faster launching for the Windows AMI. Set to true to start using Windows faster launching, or false to stop using it.
        """
        launch_template: NotRequired[pulumi.Input['DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgsDict']]
        """
        The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
        """
        max_parallel_launches: NotRequired[pulumi.Input[int]]
        """
        The maximum number of parallel instances that are launched for creating resources.
        """
        snapshot_configuration: NotRequired[pulumi.Input['DistributionConfigurationFastLaunchSnapshotConfigurationArgsDict']]
        """
        Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
        """
elif False:
    DistributionConfigurationFastLaunchConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionConfigurationFastLaunchConfigurationArgs:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 launch_template: Optional[pulumi.Input['DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgs']] = None,
                 max_parallel_launches: Optional[pulumi.Input[int]] = None,
                 snapshot_configuration: Optional[pulumi.Input['DistributionConfigurationFastLaunchSnapshotConfigurationArgs']] = None):
        """
        The Windows faster-launching configuration to use for AMI distribution.
        :param pulumi.Input[str] account_id: The owner account ID for the fast-launch enabled Windows AMI.
        :param pulumi.Input[bool] enabled: A Boolean that represents the current state of faster launching for the Windows AMI. Set to true to start using Windows faster launching, or false to stop using it.
        :param pulumi.Input['DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgs'] launch_template: The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
        :param pulumi.Input[int] max_parallel_launches: The maximum number of parallel instances that are launched for creating resources.
        :param pulumi.Input['DistributionConfigurationFastLaunchSnapshotConfigurationArgs'] snapshot_configuration: Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if launch_template is not None:
            pulumi.set(__self__, "launch_template", launch_template)
        if max_parallel_launches is not None:
            pulumi.set(__self__, "max_parallel_launches", max_parallel_launches)
        if snapshot_configuration is not None:
            pulumi.set(__self__, "snapshot_configuration", snapshot_configuration)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[str]]:
        """
        The owner account ID for the fast-launch enabled Windows AMI.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean that represents the current state of faster launching for the Windows AMI. Set to true to start using Windows faster launching, or false to stop using it.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="launchTemplate")
    def launch_template(self) -> Optional[pulumi.Input['DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgs']]:
        """
        The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
        """
        return pulumi.get(self, "launch_template")

    @launch_template.setter
    def launch_template(self, value: Optional[pulumi.Input['DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgs']]):
        pulumi.set(self, "launch_template", value)

    @property
    @pulumi.getter(name="maxParallelLaunches")
    def max_parallel_launches(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of parallel instances that are launched for creating resources.
        """
        return pulumi.get(self, "max_parallel_launches")

    @max_parallel_launches.setter
    def max_parallel_launches(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_parallel_launches", value)

    @property
    @pulumi.getter(name="snapshotConfiguration")
    def snapshot_configuration(self) -> Optional[pulumi.Input['DistributionConfigurationFastLaunchSnapshotConfigurationArgs']]:
        """
        Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
        """
        return pulumi.get(self, "snapshot_configuration")

    @snapshot_configuration.setter
    def snapshot_configuration(self, value: Optional[pulumi.Input['DistributionConfigurationFastLaunchSnapshotConfigurationArgs']]):
        pulumi.set(self, "snapshot_configuration", value)


if not MYPY:
    class DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgsDict(TypedDict):
        """
        The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
        """
        launch_template_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the launch template to use for faster launching for a Windows AMI.
        """
        launch_template_name: NotRequired[pulumi.Input[str]]
        """
        The name of the launch template to use for faster launching for a Windows AMI.
        """
        launch_template_version: NotRequired[pulumi.Input[str]]
        """
        The version of the launch template to use for faster launching for a Windows AMI.
        """
elif False:
    DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgs:
    def __init__(__self__, *,
                 launch_template_id: Optional[pulumi.Input[str]] = None,
                 launch_template_name: Optional[pulumi.Input[str]] = None,
                 launch_template_version: Optional[pulumi.Input[str]] = None):
        """
        The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
        :param pulumi.Input[str] launch_template_id: The ID of the launch template to use for faster launching for a Windows AMI.
        :param pulumi.Input[str] launch_template_name: The name of the launch template to use for faster launching for a Windows AMI.
        :param pulumi.Input[str] launch_template_version: The version of the launch template to use for faster launching for a Windows AMI.
        """
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)
        if launch_template_version is not None:
            pulumi.set(__self__, "launch_template_version", launch_template_version)

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the launch template to use for faster launching for a Windows AMI.
        """
        return pulumi.get(self, "launch_template_id")

    @launch_template_id.setter
    def launch_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "launch_template_id", value)

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the launch template to use for faster launching for a Windows AMI.
        """
        return pulumi.get(self, "launch_template_name")

    @launch_template_name.setter
    def launch_template_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "launch_template_name", value)

    @property
    @pulumi.getter(name="launchTemplateVersion")
    def launch_template_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the launch template to use for faster launching for a Windows AMI.
        """
        return pulumi.get(self, "launch_template_version")

    @launch_template_version.setter
    def launch_template_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "launch_template_version", value)


if not MYPY:
    class DistributionConfigurationFastLaunchSnapshotConfigurationArgsDict(TypedDict):
        """
        Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
        """
        target_resource_count: NotRequired[pulumi.Input[int]]
        """
        The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
        """
elif False:
    DistributionConfigurationFastLaunchSnapshotConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionConfigurationFastLaunchSnapshotConfigurationArgs:
    def __init__(__self__, *,
                 target_resource_count: Optional[pulumi.Input[int]] = None):
        """
        Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
        :param pulumi.Input[int] target_resource_count: The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
        """
        if target_resource_count is not None:
            pulumi.set(__self__, "target_resource_count", target_resource_count)

    @property
    @pulumi.getter(name="targetResourceCount")
    def target_resource_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
        """
        return pulumi.get(self, "target_resource_count")

    @target_resource_count.setter
    def target_resource_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_resource_count", value)


if not MYPY:
    class DistributionConfigurationLaunchPermissionConfigurationArgsDict(TypedDict):
        """
        Launch permissions can be used to configure which AWS accounts can use the AMI to launch instances.
        """
        organization_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ARN for an Amazon Web Services Organization that you want to share your AMI with.
        """
        organizational_unit_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ARN for an Organizations organizational unit (OU) that you want to share your AMI with.
        """
        user_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The name of the group.
        """
        user_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The AWS account ID.
        """
elif False:
    DistributionConfigurationLaunchPermissionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionConfigurationLaunchPermissionConfigurationArgs:
    def __init__(__self__, *,
                 organization_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 organizational_unit_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Launch permissions can be used to configure which AWS accounts can use the AMI to launch instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] organization_arns: The ARN for an Amazon Web Services Organization that you want to share your AMI with.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] organizational_unit_arns: The ARN for an Organizations organizational unit (OU) that you want to share your AMI with.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_groups: The name of the group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_ids: The AWS account ID.
        """
        if organization_arns is not None:
            pulumi.set(__self__, "organization_arns", organization_arns)
        if organizational_unit_arns is not None:
            pulumi.set(__self__, "organizational_unit_arns", organizational_unit_arns)
        if user_groups is not None:
            pulumi.set(__self__, "user_groups", user_groups)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter(name="organizationArns")
    def organization_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ARN for an Amazon Web Services Organization that you want to share your AMI with.
        """
        return pulumi.get(self, "organization_arns")

    @organization_arns.setter
    def organization_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "organization_arns", value)

    @property
    @pulumi.getter(name="organizationalUnitArns")
    def organizational_unit_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ARN for an Organizations organizational unit (OU) that you want to share your AMI with.
        """
        return pulumi.get(self, "organizational_unit_arns")

    @organizational_unit_arns.setter
    def organizational_unit_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "organizational_unit_arns", value)

    @property
    @pulumi.getter(name="userGroups")
    def user_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name of the group.
        """
        return pulumi.get(self, "user_groups")

    @user_groups.setter
    def user_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_groups", value)

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The AWS account ID.
        """
        return pulumi.get(self, "user_ids")

    @user_ids.setter
    def user_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_ids", value)


if not MYPY:
    class DistributionConfigurationLaunchTemplateConfigurationArgsDict(TypedDict):
        """
        launchTemplateConfiguration settings that apply to image distribution.
        """
        account_id: NotRequired[pulumi.Input[str]]
        """
        The account ID that this configuration applies to.
        """
        launch_template_id: NotRequired[pulumi.Input[str]]
        """
        Identifies the EC2 launch template to use.
        """
        set_default_version: NotRequired[pulumi.Input[bool]]
        """
        Set the specified EC2 launch template as the default launch template for the specified account.
        """
elif False:
    DistributionConfigurationLaunchTemplateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionConfigurationLaunchTemplateConfigurationArgs:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[str]] = None,
                 launch_template_id: Optional[pulumi.Input[str]] = None,
                 set_default_version: Optional[pulumi.Input[bool]] = None):
        """
        launchTemplateConfiguration settings that apply to image distribution.
        :param pulumi.Input[str] account_id: The account ID that this configuration applies to.
        :param pulumi.Input[str] launch_template_id: Identifies the EC2 launch template to use.
        :param pulumi.Input[bool] set_default_version: Set the specified EC2 launch template as the default launch template for the specified account.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if set_default_version is not None:
            pulumi.set(__self__, "set_default_version", set_default_version)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[str]]:
        """
        The account ID that this configuration applies to.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifies the EC2 launch template to use.
        """
        return pulumi.get(self, "launch_template_id")

    @launch_template_id.setter
    def launch_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "launch_template_id", value)

    @property
    @pulumi.getter(name="setDefaultVersion")
    def set_default_version(self) -> Optional[pulumi.Input[bool]]:
        """
        Set the specified EC2 launch template as the default launch template for the specified account.
        """
        return pulumi.get(self, "set_default_version")

    @set_default_version.setter
    def set_default_version(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "set_default_version", value)


if not MYPY:
    class DistributionConfigurationTargetContainerRepositoryArgsDict(TypedDict):
        """
        The destination repository for the container image.
        """
        repository_name: NotRequired[pulumi.Input[str]]
        """
        The repository name of target container repository.
        """
        service: NotRequired[pulumi.Input['DistributionConfigurationTargetContainerRepositoryService']]
        """
        The service of target container repository.
        """
elif False:
    DistributionConfigurationTargetContainerRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionConfigurationTargetContainerRepositoryArgs:
    def __init__(__self__, *,
                 repository_name: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input['DistributionConfigurationTargetContainerRepositoryService']] = None):
        """
        The destination repository for the container image.
        :param pulumi.Input[str] repository_name: The repository name of target container repository.
        :param pulumi.Input['DistributionConfigurationTargetContainerRepositoryService'] service: The service of target container repository.
        """
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[pulumi.Input[str]]:
        """
        The repository name of target container repository.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_name", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['DistributionConfigurationTargetContainerRepositoryService']]:
        """
        The service of target container repository.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['DistributionConfigurationTargetContainerRepositoryService']]):
        pulumi.set(self, "service", value)


if not MYPY:
    class ImageEcrConfigurationArgsDict(TypedDict):
        """
        Settings for Image Builder to configure the ECR repository and output container images that are scanned.
        """
        container_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Tags for Image Builder to apply the output container image that is scanned. Tags can help you identify and manage your scanned images.
        """
        repository_name: NotRequired[pulumi.Input[str]]
        """
        The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you dont provide this information, Image Builder creates a repository in your account named image-builder-image-scanning-repository to use for vulnerability scans for your output container images.
        """
elif False:
    ImageEcrConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageEcrConfigurationArgs:
    def __init__(__self__, *,
                 container_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repository_name: Optional[pulumi.Input[str]] = None):
        """
        Settings for Image Builder to configure the ECR repository and output container images that are scanned.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_tags: Tags for Image Builder to apply the output container image that is scanned. Tags can help you identify and manage your scanned images.
        :param pulumi.Input[str] repository_name: The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you dont provide this information, Image Builder creates a repository in your account named image-builder-image-scanning-repository to use for vulnerability scans for your output container images.
        """
        if container_tags is not None:
            pulumi.set(__self__, "container_tags", container_tags)
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)

    @property
    @pulumi.getter(name="containerTags")
    def container_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Tags for Image Builder to apply the output container image that is scanned. Tags can help you identify and manage your scanned images.
        """
        return pulumi.get(self, "container_tags")

    @container_tags.setter
    def container_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_tags", value)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you dont provide this information, Image Builder creates a repository in your account named image-builder-image-scanning-repository to use for vulnerability scans for your output container images.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_name", value)


if not MYPY:
    class ImagePipelineEcrConfigurationArgsDict(TypedDict):
        """
        Settings for Image Builder to configure the ECR repository and output container images that are scanned.
        """
        container_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Tags for Image Builder to apply the output container image that is scanned. Tags can help you identify and manage your scanned images.
        """
        repository_name: NotRequired[pulumi.Input[str]]
        """
        The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you don't provide this information, Image Builder creates a repository in your account named image-builder-image-scanning-repository to use for vulnerability scans for your output container images.
        """
elif False:
    ImagePipelineEcrConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagePipelineEcrConfigurationArgs:
    def __init__(__self__, *,
                 container_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repository_name: Optional[pulumi.Input[str]] = None):
        """
        Settings for Image Builder to configure the ECR repository and output container images that are scanned.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_tags: Tags for Image Builder to apply the output container image that is scanned. Tags can help you identify and manage your scanned images.
        :param pulumi.Input[str] repository_name: The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you don't provide this information, Image Builder creates a repository in your account named image-builder-image-scanning-repository to use for vulnerability scans for your output container images.
        """
        if container_tags is not None:
            pulumi.set(__self__, "container_tags", container_tags)
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)

    @property
    @pulumi.getter(name="containerTags")
    def container_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Tags for Image Builder to apply the output container image that is scanned. Tags can help you identify and manage your scanned images.
        """
        return pulumi.get(self, "container_tags")

    @container_tags.setter
    def container_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_tags", value)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you don't provide this information, Image Builder creates a repository in your account named image-builder-image-scanning-repository to use for vulnerability scans for your output container images.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_name", value)


if not MYPY:
    class ImagePipelineImageScanningConfigurationArgsDict(TypedDict):
        """
        Determines if tests should run after building the image. Image Builder defaults to enable tests to run following the image build, before image distribution.
        """
        ecr_configuration: NotRequired[pulumi.Input['ImagePipelineEcrConfigurationArgsDict']]
        """
        Contains ECR settings for vulnerability scans.
        """
        image_scanning_enabled: NotRequired[pulumi.Input[bool]]
        """
        This sets whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.
        """
elif False:
    ImagePipelineImageScanningConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagePipelineImageScanningConfigurationArgs:
    def __init__(__self__, *,
                 ecr_configuration: Optional[pulumi.Input['ImagePipelineEcrConfigurationArgs']] = None,
                 image_scanning_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Determines if tests should run after building the image. Image Builder defaults to enable tests to run following the image build, before image distribution.
        :param pulumi.Input['ImagePipelineEcrConfigurationArgs'] ecr_configuration: Contains ECR settings for vulnerability scans.
        :param pulumi.Input[bool] image_scanning_enabled: This sets whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.
        """
        if ecr_configuration is not None:
            pulumi.set(__self__, "ecr_configuration", ecr_configuration)
        if image_scanning_enabled is not None:
            pulumi.set(__self__, "image_scanning_enabled", image_scanning_enabled)

    @property
    @pulumi.getter(name="ecrConfiguration")
    def ecr_configuration(self) -> Optional[pulumi.Input['ImagePipelineEcrConfigurationArgs']]:
        """
        Contains ECR settings for vulnerability scans.
        """
        return pulumi.get(self, "ecr_configuration")

    @ecr_configuration.setter
    def ecr_configuration(self, value: Optional[pulumi.Input['ImagePipelineEcrConfigurationArgs']]):
        pulumi.set(self, "ecr_configuration", value)

    @property
    @pulumi.getter(name="imageScanningEnabled")
    def image_scanning_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        This sets whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.
        """
        return pulumi.get(self, "image_scanning_enabled")

    @image_scanning_enabled.setter
    def image_scanning_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "image_scanning_enabled", value)


if not MYPY:
    class ImagePipelineImageTestsConfigurationArgsDict(TypedDict):
        """
        Image tests configuration.
        """
        image_tests_enabled: NotRequired[pulumi.Input[bool]]
        """
        Defines if tests should be executed when building this image.
        """
        timeout_minutes: NotRequired[pulumi.Input[int]]
        """
        The maximum time in minutes that tests are permitted to run.
        """
elif False:
    ImagePipelineImageTestsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagePipelineImageTestsConfigurationArgs:
    def __init__(__self__, *,
                 image_tests_enabled: Optional[pulumi.Input[bool]] = None,
                 timeout_minutes: Optional[pulumi.Input[int]] = None):
        """
        Image tests configuration.
        :param pulumi.Input[bool] image_tests_enabled: Defines if tests should be executed when building this image.
        :param pulumi.Input[int] timeout_minutes: The maximum time in minutes that tests are permitted to run.
        """
        if image_tests_enabled is not None:
            pulumi.set(__self__, "image_tests_enabled", image_tests_enabled)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @property
    @pulumi.getter(name="imageTestsEnabled")
    def image_tests_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if tests should be executed when building this image.
        """
        return pulumi.get(self, "image_tests_enabled")

    @image_tests_enabled.setter
    def image_tests_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "image_tests_enabled", value)

    @property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum time in minutes that tests are permitted to run.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_minutes", value)


if not MYPY:
    class ImagePipelineScheduleArgsDict(TypedDict):
        """
        The schedule of the image pipeline.
        """
        pipeline_execution_start_condition: NotRequired[pulumi.Input['ImagePipelineSchedulePipelineExecutionStartCondition']]
        """
        The condition configures when the pipeline should trigger a new image build.
        """
        schedule_expression: NotRequired[pulumi.Input[str]]
        """
        The expression determines how often EC2 Image Builder evaluates your pipelineExecutionStartCondition.
        """
elif False:
    ImagePipelineScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagePipelineScheduleArgs:
    def __init__(__self__, *,
                 pipeline_execution_start_condition: Optional[pulumi.Input['ImagePipelineSchedulePipelineExecutionStartCondition']] = None,
                 schedule_expression: Optional[pulumi.Input[str]] = None):
        """
        The schedule of the image pipeline.
        :param pulumi.Input['ImagePipelineSchedulePipelineExecutionStartCondition'] pipeline_execution_start_condition: The condition configures when the pipeline should trigger a new image build.
        :param pulumi.Input[str] schedule_expression: The expression determines how often EC2 Image Builder evaluates your pipelineExecutionStartCondition.
        """
        if pipeline_execution_start_condition is not None:
            pulumi.set(__self__, "pipeline_execution_start_condition", pipeline_execution_start_condition)
        if schedule_expression is not None:
            pulumi.set(__self__, "schedule_expression", schedule_expression)

    @property
    @pulumi.getter(name="pipelineExecutionStartCondition")
    def pipeline_execution_start_condition(self) -> Optional[pulumi.Input['ImagePipelineSchedulePipelineExecutionStartCondition']]:
        """
        The condition configures when the pipeline should trigger a new image build.
        """
        return pulumi.get(self, "pipeline_execution_start_condition")

    @pipeline_execution_start_condition.setter
    def pipeline_execution_start_condition(self, value: Optional[pulumi.Input['ImagePipelineSchedulePipelineExecutionStartCondition']]):
        pulumi.set(self, "pipeline_execution_start_condition", value)

    @property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The expression determines how often EC2 Image Builder evaluates your pipelineExecutionStartCondition.
        """
        return pulumi.get(self, "schedule_expression")

    @schedule_expression.setter
    def schedule_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_expression", value)


if not MYPY:
    class ImagePipelineWorkflowConfigurationArgsDict(TypedDict):
        """
        The workflow configuration of the image
        """
        on_failure: NotRequired[pulumi.Input['ImagePipelineWorkflowConfigurationOnFailure']]
        """
        Define execution decision in case of workflow failure
        """
        parallel_group: NotRequired[pulumi.Input[str]]
        """
        The parallel group name
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ImagePipelineWorkflowParameterArgsDict']]]]
        """
        The parameters associated with the workflow
        """
        workflow_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the workflow
        """
elif False:
    ImagePipelineWorkflowConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagePipelineWorkflowConfigurationArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['ImagePipelineWorkflowConfigurationOnFailure']] = None,
                 parallel_group: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ImagePipelineWorkflowParameterArgs']]]] = None,
                 workflow_arn: Optional[pulumi.Input[str]] = None):
        """
        The workflow configuration of the image
        :param pulumi.Input['ImagePipelineWorkflowConfigurationOnFailure'] on_failure: Define execution decision in case of workflow failure
        :param pulumi.Input[str] parallel_group: The parallel group name
        :param pulumi.Input[Sequence[pulumi.Input['ImagePipelineWorkflowParameterArgs']]] parameters: The parameters associated with the workflow
        :param pulumi.Input[str] workflow_arn: The Amazon Resource Name (ARN) of the workflow
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if parallel_group is not None:
            pulumi.set(__self__, "parallel_group", parallel_group)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if workflow_arn is not None:
            pulumi.set(__self__, "workflow_arn", workflow_arn)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['ImagePipelineWorkflowConfigurationOnFailure']]:
        """
        Define execution decision in case of workflow failure
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['ImagePipelineWorkflowConfigurationOnFailure']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="parallelGroup")
    def parallel_group(self) -> Optional[pulumi.Input[str]]:
        """
        The parallel group name
        """
        return pulumi.get(self, "parallel_group")

    @parallel_group.setter
    def parallel_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parallel_group", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ImagePipelineWorkflowParameterArgs']]]]:
        """
        The parameters associated with the workflow
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ImagePipelineWorkflowParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="workflowArn")
    def workflow_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the workflow
        """
        return pulumi.get(self, "workflow_arn")

    @workflow_arn.setter
    def workflow_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workflow_arn", value)


if not MYPY:
    class ImagePipelineWorkflowParameterArgsDict(TypedDict):
        """
        A parameter associated with the workflow
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the workflow parameter to set.
        """
        value: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Sets the value for the named workflow parameter.
        """
elif False:
    ImagePipelineWorkflowParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagePipelineWorkflowParameterArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A parameter associated with the workflow
        :param pulumi.Input[str] name: The name of the workflow parameter to set.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] value: Sets the value for the named workflow parameter.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the workflow parameter to set.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Sets the value for the named workflow parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ImageRecipeAdditionalInstanceConfigurationArgsDict(TypedDict):
        """
        Specify additional settings and launch scripts for your build instances.
        """
        systems_manager_agent: NotRequired[pulumi.Input['ImageRecipeSystemsManagerAgentArgsDict']]
        """
        Contains settings for the SSM agent on your build instance.
        """
        user_data_override: NotRequired[pulumi.Input[str]]
        """
        Use this property to provide commands or a command script to run when you launch your build instance.
        """
elif False:
    ImageRecipeAdditionalInstanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageRecipeAdditionalInstanceConfigurationArgs:
    def __init__(__self__, *,
                 systems_manager_agent: Optional[pulumi.Input['ImageRecipeSystemsManagerAgentArgs']] = None,
                 user_data_override: Optional[pulumi.Input[str]] = None):
        """
        Specify additional settings and launch scripts for your build instances.
        :param pulumi.Input['ImageRecipeSystemsManagerAgentArgs'] systems_manager_agent: Contains settings for the SSM agent on your build instance.
        :param pulumi.Input[str] user_data_override: Use this property to provide commands or a command script to run when you launch your build instance.
        """
        if systems_manager_agent is not None:
            pulumi.set(__self__, "systems_manager_agent", systems_manager_agent)
        if user_data_override is not None:
            pulumi.set(__self__, "user_data_override", user_data_override)

    @property
    @pulumi.getter(name="systemsManagerAgent")
    def systems_manager_agent(self) -> Optional[pulumi.Input['ImageRecipeSystemsManagerAgentArgs']]:
        """
        Contains settings for the SSM agent on your build instance.
        """
        return pulumi.get(self, "systems_manager_agent")

    @systems_manager_agent.setter
    def systems_manager_agent(self, value: Optional[pulumi.Input['ImageRecipeSystemsManagerAgentArgs']]):
        pulumi.set(self, "systems_manager_agent", value)

    @property
    @pulumi.getter(name="userDataOverride")
    def user_data_override(self) -> Optional[pulumi.Input[str]]:
        """
        Use this property to provide commands or a command script to run when you launch your build instance.
        """
        return pulumi.get(self, "user_data_override")

    @user_data_override.setter
    def user_data_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data_override", value)


if not MYPY:
    class ImageRecipeComponentConfigurationArgsDict(TypedDict):
        """
        Configuration details of the component.
        """
        component_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the component.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ImageRecipeComponentParameterArgsDict']]]]
        """
        A group of parameter settings that are used to configure the component for a specific recipe.
        """
elif False:
    ImageRecipeComponentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageRecipeComponentConfigurationArgs:
    def __init__(__self__, *,
                 component_arn: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ImageRecipeComponentParameterArgs']]]] = None):
        """
        Configuration details of the component.
        :param pulumi.Input[str] component_arn: The Amazon Resource Name (ARN) of the component.
        :param pulumi.Input[Sequence[pulumi.Input['ImageRecipeComponentParameterArgs']]] parameters: A group of parameter settings that are used to configure the component for a specific recipe.
        """
        if component_arn is not None:
            pulumi.set(__self__, "component_arn", component_arn)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="componentArn")
    def component_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the component.
        """
        return pulumi.get(self, "component_arn")

    @component_arn.setter
    def component_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "component_arn", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ImageRecipeComponentParameterArgs']]]]:
        """
        A group of parameter settings that are used to configure the component for a specific recipe.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ImageRecipeComponentParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class ImageRecipeComponentParameterArgsDict(TypedDict):
        """
        Contains a key/value pair that sets the named component parameter.
        """
        name: pulumi.Input[str]
        """
        The name of the component parameter to set.
        """
        value: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Sets the value for the named component parameter.
        """
elif False:
    ImageRecipeComponentParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageRecipeComponentParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Contains a key/value pair that sets the named component parameter.
        :param pulumi.Input[str] name: The name of the component parameter to set.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] value: Sets the value for the named component parameter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the component parameter to set.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Sets the value for the named component parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ImageRecipeEbsInstanceBlockDeviceSpecificationArgsDict(TypedDict):
        """
        Amazon EBS-specific block device mapping specifications. 
        """
        delete_on_termination: NotRequired[pulumi.Input[bool]]
        """
        Use to configure delete on termination of the associated device.
        """
        encrypted: NotRequired[pulumi.Input[bool]]
        """
        Use to configure device encryption.
        """
        iops: NotRequired[pulumi.Input[int]]
        """
        Use to configure device IOPS.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        Use to configure the KMS key to use when encrypting the device.
        """
        snapshot_id: NotRequired[pulumi.Input[str]]
        """
        The snapshot that defines the device contents.
        """
        throughput: NotRequired[pulumi.Input[int]]
        """
        For GP3 volumes only - The throughput in MiB/s that the volume supports.
        """
        volume_size: NotRequired[pulumi.Input[int]]
        """
        Use to override the device's volume size.
        """
        volume_type: NotRequired[pulumi.Input['ImageRecipeEbsInstanceBlockDeviceSpecificationVolumeType']]
        """
        Use to override the device's volume type.
        """
elif False:
    ImageRecipeEbsInstanceBlockDeviceSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageRecipeEbsInstanceBlockDeviceSpecificationArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input['ImageRecipeEbsInstanceBlockDeviceSpecificationVolumeType']] = None):
        """
        Amazon EBS-specific block device mapping specifications. 
        :param pulumi.Input[bool] delete_on_termination: Use to configure delete on termination of the associated device.
        :param pulumi.Input[bool] encrypted: Use to configure device encryption.
        :param pulumi.Input[int] iops: Use to configure device IOPS.
        :param pulumi.Input[str] kms_key_id: Use to configure the KMS key to use when encrypting the device.
        :param pulumi.Input[str] snapshot_id: The snapshot that defines the device contents.
        :param pulumi.Input[int] throughput: For GP3 volumes only - The throughput in MiB/s that the volume supports.
        :param pulumi.Input[int] volume_size: Use to override the device's volume size.
        :param pulumi.Input['ImageRecipeEbsInstanceBlockDeviceSpecificationVolumeType'] volume_type: Use to override the device's volume type.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Use to configure delete on termination of the associated device.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Use to configure device encryption.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Use to configure device IOPS.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Use to configure the KMS key to use when encrypting the device.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The snapshot that defines the device contents.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        For GP3 volumes only - The throughput in MiB/s that the volume supports.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        Use to override the device's volume size.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input['ImageRecipeEbsInstanceBlockDeviceSpecificationVolumeType']]:
        """
        Use to override the device's volume type.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input['ImageRecipeEbsInstanceBlockDeviceSpecificationVolumeType']]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ImageRecipeInstanceBlockDeviceMappingArgsDict(TypedDict):
        """
        Defines block device mappings for the instance used to configure your image. 
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        The device to which these mappings apply.
        """
        ebs: NotRequired[pulumi.Input['ImageRecipeEbsInstanceBlockDeviceSpecificationArgsDict']]
        """
        Use to manage Amazon EBS-specific configuration for this mapping.
        """
        no_device: NotRequired[pulumi.Input[str]]
        """
        Use to remove a mapping from the parent image.
        """
        virtual_name: NotRequired[pulumi.Input[str]]
        """
        Use to manage instance ephemeral devices.
        """
elif False:
    ImageRecipeInstanceBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageRecipeInstanceBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 ebs: Optional[pulumi.Input['ImageRecipeEbsInstanceBlockDeviceSpecificationArgs']] = None,
                 no_device: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        Defines block device mappings for the instance used to configure your image. 
        :param pulumi.Input[str] device_name: The device to which these mappings apply.
        :param pulumi.Input['ImageRecipeEbsInstanceBlockDeviceSpecificationArgs'] ebs: Use to manage Amazon EBS-specific configuration for this mapping.
        :param pulumi.Input[str] no_device: Use to remove a mapping from the parent image.
        :param pulumi.Input[str] virtual_name: Use to manage instance ephemeral devices.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The device to which these mappings apply.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['ImageRecipeEbsInstanceBlockDeviceSpecificationArgs']]:
        """
        Use to manage Amazon EBS-specific configuration for this mapping.
        """
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['ImageRecipeEbsInstanceBlockDeviceSpecificationArgs']]):
        pulumi.set(self, "ebs", value)

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[str]]:
        """
        Use to remove a mapping from the parent image.
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_device", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        Use to manage instance ephemeral devices.
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


if not MYPY:
    class ImageRecipeSystemsManagerAgentArgsDict(TypedDict):
        """
        Contains settings for the SSM agent on your build instance.
        """
        uninstall_after_build: NotRequired[pulumi.Input[bool]]
        """
        Controls whether the SSM agent is removed from your final build image, prior to creating the new AMI. If this is set to true, then the agent is removed from the final image. If it's set to false, then the agent is left in, so that it is included in the new AMI. The default value is false.
        """
elif False:
    ImageRecipeSystemsManagerAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageRecipeSystemsManagerAgentArgs:
    def __init__(__self__, *,
                 uninstall_after_build: Optional[pulumi.Input[bool]] = None):
        """
        Contains settings for the SSM agent on your build instance.
        :param pulumi.Input[bool] uninstall_after_build: Controls whether the SSM agent is removed from your final build image, prior to creating the new AMI. If this is set to true, then the agent is removed from the final image. If it's set to false, then the agent is left in, so that it is included in the new AMI. The default value is false.
        """
        if uninstall_after_build is not None:
            pulumi.set(__self__, "uninstall_after_build", uninstall_after_build)

    @property
    @pulumi.getter(name="uninstallAfterBuild")
    def uninstall_after_build(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether the SSM agent is removed from your final build image, prior to creating the new AMI. If this is set to true, then the agent is removed from the final image. If it's set to false, then the agent is left in, so that it is included in the new AMI. The default value is false.
        """
        return pulumi.get(self, "uninstall_after_build")

    @uninstall_after_build.setter
    def uninstall_after_build(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "uninstall_after_build", value)


if not MYPY:
    class ImageScanningConfigurationArgsDict(TypedDict):
        """
        Contains settings for Image Builder image resource and container image scans.
        """
        ecr_configuration: NotRequired[pulumi.Input['ImageEcrConfigurationArgsDict']]
        """
        Contains ECR settings for vulnerability scans.
        """
        image_scanning_enabled: NotRequired[pulumi.Input[bool]]
        """
        This sets whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.
        """
elif False:
    ImageScanningConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageScanningConfigurationArgs:
    def __init__(__self__, *,
                 ecr_configuration: Optional[pulumi.Input['ImageEcrConfigurationArgs']] = None,
                 image_scanning_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Contains settings for Image Builder image resource and container image scans.
        :param pulumi.Input['ImageEcrConfigurationArgs'] ecr_configuration: Contains ECR settings for vulnerability scans.
        :param pulumi.Input[bool] image_scanning_enabled: This sets whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.
        """
        if ecr_configuration is not None:
            pulumi.set(__self__, "ecr_configuration", ecr_configuration)
        if image_scanning_enabled is not None:
            pulumi.set(__self__, "image_scanning_enabled", image_scanning_enabled)

    @property
    @pulumi.getter(name="ecrConfiguration")
    def ecr_configuration(self) -> Optional[pulumi.Input['ImageEcrConfigurationArgs']]:
        """
        Contains ECR settings for vulnerability scans.
        """
        return pulumi.get(self, "ecr_configuration")

    @ecr_configuration.setter
    def ecr_configuration(self, value: Optional[pulumi.Input['ImageEcrConfigurationArgs']]):
        pulumi.set(self, "ecr_configuration", value)

    @property
    @pulumi.getter(name="imageScanningEnabled")
    def image_scanning_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        This sets whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.
        """
        return pulumi.get(self, "image_scanning_enabled")

    @image_scanning_enabled.setter
    def image_scanning_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "image_scanning_enabled", value)


if not MYPY:
    class ImageTestsConfigurationArgsDict(TypedDict):
        """
        The image tests configuration used when creating this image.
        """
        image_tests_enabled: NotRequired[pulumi.Input[bool]]
        """
        ImageTestsEnabled
        """
        timeout_minutes: NotRequired[pulumi.Input[int]]
        """
        TimeoutMinutes
        """
elif False:
    ImageTestsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageTestsConfigurationArgs:
    def __init__(__self__, *,
                 image_tests_enabled: Optional[pulumi.Input[bool]] = None,
                 timeout_minutes: Optional[pulumi.Input[int]] = None):
        """
        The image tests configuration used when creating this image.
        :param pulumi.Input[bool] image_tests_enabled: ImageTestsEnabled
        :param pulumi.Input[int] timeout_minutes: TimeoutMinutes
        """
        if image_tests_enabled is not None:
            pulumi.set(__self__, "image_tests_enabled", image_tests_enabled)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @property
    @pulumi.getter(name="imageTestsEnabled")
    def image_tests_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        ImageTestsEnabled
        """
        return pulumi.get(self, "image_tests_enabled")

    @image_tests_enabled.setter
    def image_tests_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "image_tests_enabled", value)

    @property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        TimeoutMinutes
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_minutes", value)


if not MYPY:
    class ImageWorkflowConfigurationArgsDict(TypedDict):
        """
        The workflow configuration of the image
        """
        on_failure: NotRequired[pulumi.Input['ImageWorkflowConfigurationOnFailure']]
        """
        Define execution decision in case of workflow failure
        """
        parallel_group: NotRequired[pulumi.Input[str]]
        """
        The parallel group name
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ImageWorkflowParameterArgsDict']]]]
        """
        The parameters associated with the workflow
        """
        workflow_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the workflow
        """
elif False:
    ImageWorkflowConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageWorkflowConfigurationArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['ImageWorkflowConfigurationOnFailure']] = None,
                 parallel_group: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ImageWorkflowParameterArgs']]]] = None,
                 workflow_arn: Optional[pulumi.Input[str]] = None):
        """
        The workflow configuration of the image
        :param pulumi.Input['ImageWorkflowConfigurationOnFailure'] on_failure: Define execution decision in case of workflow failure
        :param pulumi.Input[str] parallel_group: The parallel group name
        :param pulumi.Input[Sequence[pulumi.Input['ImageWorkflowParameterArgs']]] parameters: The parameters associated with the workflow
        :param pulumi.Input[str] workflow_arn: The Amazon Resource Name (ARN) of the workflow
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if parallel_group is not None:
            pulumi.set(__self__, "parallel_group", parallel_group)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if workflow_arn is not None:
            pulumi.set(__self__, "workflow_arn", workflow_arn)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['ImageWorkflowConfigurationOnFailure']]:
        """
        Define execution decision in case of workflow failure
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['ImageWorkflowConfigurationOnFailure']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="parallelGroup")
    def parallel_group(self) -> Optional[pulumi.Input[str]]:
        """
        The parallel group name
        """
        return pulumi.get(self, "parallel_group")

    @parallel_group.setter
    def parallel_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parallel_group", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ImageWorkflowParameterArgs']]]]:
        """
        The parameters associated with the workflow
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ImageWorkflowParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="workflowArn")
    def workflow_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the workflow
        """
        return pulumi.get(self, "workflow_arn")

    @workflow_arn.setter
    def workflow_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workflow_arn", value)


if not MYPY:
    class ImageWorkflowParameterArgsDict(TypedDict):
        """
        A parameter associated with the workflow
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the workflow parameter to set.
        """
        value: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Sets the value for the named workflow parameter.
        """
elif False:
    ImageWorkflowParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageWorkflowParameterArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A parameter associated with the workflow
        :param pulumi.Input[str] name: The name of the workflow parameter to set.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] value: Sets the value for the named workflow parameter.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the workflow parameter to set.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Sets the value for the named workflow parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InfrastructureConfigurationInstanceMetadataOptionsArgsDict(TypedDict):
        """
        The instance metadata option settings for the infrastructure configuration.
        """
        http_put_response_hop_limit: NotRequired[pulumi.Input[int]]
        """
        Limit the number of hops that an instance metadata request can traverse to reach its destination.
        """
        http_tokens: NotRequired[pulumi.Input['InfrastructureConfigurationInstanceMetadataOptionsHttpTokens']]
        """
        Indicates whether a signed token header is required for instance metadata retrieval requests. The values affect the response as follows: 
        """
elif False:
    InfrastructureConfigurationInstanceMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureConfigurationInstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None,
                 http_tokens: Optional[pulumi.Input['InfrastructureConfigurationInstanceMetadataOptionsHttpTokens']] = None):
        """
        The instance metadata option settings for the infrastructure configuration.
        :param pulumi.Input[int] http_put_response_hop_limit: Limit the number of hops that an instance metadata request can traverse to reach its destination.
        :param pulumi.Input['InfrastructureConfigurationInstanceMetadataOptionsHttpTokens'] http_tokens: Indicates whether a signed token header is required for instance metadata retrieval requests. The values affect the response as follows: 
        """
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Limit the number of hops that an instance metadata request can traverse to reach its destination.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input['InfrastructureConfigurationInstanceMetadataOptionsHttpTokens']]:
        """
        Indicates whether a signed token header is required for instance metadata retrieval requests. The values affect the response as follows: 
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input['InfrastructureConfigurationInstanceMetadataOptionsHttpTokens']]):
        pulumi.set(self, "http_tokens", value)


if not MYPY:
    class InfrastructureConfigurationLoggingArgsDict(TypedDict):
        """
        The logging configuration of the infrastructure configuration.
        """
        s3_logs: NotRequired[pulumi.Input['InfrastructureConfigurationS3LogsArgsDict']]
        """
        The Amazon S3 logging configuration.
        """
elif False:
    InfrastructureConfigurationLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureConfigurationLoggingArgs:
    def __init__(__self__, *,
                 s3_logs: Optional[pulumi.Input['InfrastructureConfigurationS3LogsArgs']] = None):
        """
        The logging configuration of the infrastructure configuration.
        :param pulumi.Input['InfrastructureConfigurationS3LogsArgs'] s3_logs: The Amazon S3 logging configuration.
        """
        if s3_logs is not None:
            pulumi.set(__self__, "s3_logs", s3_logs)

    @property
    @pulumi.getter(name="s3Logs")
    def s3_logs(self) -> Optional[pulumi.Input['InfrastructureConfigurationS3LogsArgs']]:
        """
        The Amazon S3 logging configuration.
        """
        return pulumi.get(self, "s3_logs")

    @s3_logs.setter
    def s3_logs(self, value: Optional[pulumi.Input['InfrastructureConfigurationS3LogsArgs']]):
        pulumi.set(self, "s3_logs", value)


if not MYPY:
    class InfrastructureConfigurationPlacementArgsDict(TypedDict):
        """
        The placement options
        """
        availability_zone: NotRequired[pulumi.Input[str]]
        """
        AvailabilityZone
        """
        host_id: NotRequired[pulumi.Input[str]]
        """
        HostId
        """
        host_resource_group_arn: NotRequired[pulumi.Input[str]]
        """
        HostResourceGroupArn
        """
        tenancy: NotRequired[pulumi.Input['InfrastructureConfigurationPlacementTenancy']]
        """
        Tenancy
        """
elif False:
    InfrastructureConfigurationPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureConfigurationPlacementArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 host_id: Optional[pulumi.Input[str]] = None,
                 host_resource_group_arn: Optional[pulumi.Input[str]] = None,
                 tenancy: Optional[pulumi.Input['InfrastructureConfigurationPlacementTenancy']] = None):
        """
        The placement options
        :param pulumi.Input[str] availability_zone: AvailabilityZone
        :param pulumi.Input[str] host_id: HostId
        :param pulumi.Input[str] host_resource_group_arn: HostResourceGroupArn
        :param pulumi.Input['InfrastructureConfigurationPlacementTenancy'] tenancy: Tenancy
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        AvailabilityZone
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[str]]:
        """
        HostId
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_id", value)

    @property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[pulumi.Input[str]]:
        """
        HostResourceGroupArn
        """
        return pulumi.get(self, "host_resource_group_arn")

    @host_resource_group_arn.setter
    def host_resource_group_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_resource_group_arn", value)

    @property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input['InfrastructureConfigurationPlacementTenancy']]:
        """
        Tenancy
        """
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input['InfrastructureConfigurationPlacementTenancy']]):
        pulumi.set(self, "tenancy", value)


if not MYPY:
    class InfrastructureConfigurationS3LogsArgsDict(TypedDict):
        """
        The S3 path in which to store the logs.
        """
        s3_bucket_name: NotRequired[pulumi.Input[str]]
        """
        S3BucketName
        """
        s3_key_prefix: NotRequired[pulumi.Input[str]]
        """
        S3KeyPrefix
        """
elif False:
    InfrastructureConfigurationS3LogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureConfigurationS3LogsArgs:
    def __init__(__self__, *,
                 s3_bucket_name: Optional[pulumi.Input[str]] = None,
                 s3_key_prefix: Optional[pulumi.Input[str]] = None):
        """
        The S3 path in which to store the logs.
        :param pulumi.Input[str] s3_bucket_name: S3BucketName
        :param pulumi.Input[str] s3_key_prefix: S3KeyPrefix
        """
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_key_prefix is not None:
            pulumi.set(__self__, "s3_key_prefix", s3_key_prefix)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        S3BucketName
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="s3KeyPrefix")
    def s3_key_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        S3KeyPrefix
        """
        return pulumi.get(self, "s3_key_prefix")

    @s3_key_prefix.setter
    def s3_key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_key_prefix", value)


if not MYPY:
    class LifecyclePolicyActionArgsDict(TypedDict):
        """
        The action of the policy detail.
        """
        type: pulumi.Input['LifecyclePolicyActionType']
        """
        The action type of the policy detail.
        """
        include_resources: NotRequired[pulumi.Input['LifecyclePolicyIncludeResourcesArgsDict']]
        """
        Specifies the resources that the lifecycle policy applies to.
        """
elif False:
    LifecyclePolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecyclePolicyActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['LifecyclePolicyActionType'],
                 include_resources: Optional[pulumi.Input['LifecyclePolicyIncludeResourcesArgs']] = None):
        """
        The action of the policy detail.
        :param pulumi.Input['LifecyclePolicyActionType'] type: The action type of the policy detail.
        :param pulumi.Input['LifecyclePolicyIncludeResourcesArgs'] include_resources: Specifies the resources that the lifecycle policy applies to.
        """
        pulumi.set(__self__, "type", type)
        if include_resources is not None:
            pulumi.set(__self__, "include_resources", include_resources)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['LifecyclePolicyActionType']:
        """
        The action type of the policy detail.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['LifecyclePolicyActionType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="includeResources")
    def include_resources(self) -> Optional[pulumi.Input['LifecyclePolicyIncludeResourcesArgs']]:
        """
        Specifies the resources that the lifecycle policy applies to.
        """
        return pulumi.get(self, "include_resources")

    @include_resources.setter
    def include_resources(self, value: Optional[pulumi.Input['LifecyclePolicyIncludeResourcesArgs']]):
        pulumi.set(self, "include_resources", value)


if not MYPY:
    class LifecyclePolicyAmiExclusionRulesArgsDict(TypedDict):
        """
        The AMI exclusion rules for the policy detail.
        """
        is_public: NotRequired[pulumi.Input[bool]]
        """
        Use to apply lifecycle policy actions on whether the AMI is public.
        """
        last_launched: NotRequired[pulumi.Input['LifecyclePolicyLastLaunchedArgsDict']]
        """
        Use to apply lifecycle policy actions on AMIs launched before a certain time.
        """
        regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Use to apply lifecycle policy actions on AMIs distributed to a set of regions.
        """
        shared_accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Use to apply lifecycle policy actions on AMIs shared with a set of regions.
        """
        tag_map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The AMIs to select by tag.
        """
elif False:
    LifecyclePolicyAmiExclusionRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecyclePolicyAmiExclusionRulesArgs:
    def __init__(__self__, *,
                 is_public: Optional[pulumi.Input[bool]] = None,
                 last_launched: Optional[pulumi.Input['LifecyclePolicyLastLaunchedArgs']] = None,
                 regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 shared_accounts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        The AMI exclusion rules for the policy detail.
        :param pulumi.Input[bool] is_public: Use to apply lifecycle policy actions on whether the AMI is public.
        :param pulumi.Input['LifecyclePolicyLastLaunchedArgs'] last_launched: Use to apply lifecycle policy actions on AMIs launched before a certain time.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: Use to apply lifecycle policy actions on AMIs distributed to a set of regions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] shared_accounts: Use to apply lifecycle policy actions on AMIs shared with a set of regions.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tag_map: The AMIs to select by tag.
        """
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_launched is not None:
            pulumi.set(__self__, "last_launched", last_launched)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if shared_accounts is not None:
            pulumi.set(__self__, "shared_accounts", shared_accounts)
        if tag_map is not None:
            pulumi.set(__self__, "tag_map", tag_map)

    @property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[pulumi.Input[bool]]:
        """
        Use to apply lifecycle policy actions on whether the AMI is public.
        """
        return pulumi.get(self, "is_public")

    @is_public.setter
    def is_public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_public", value)

    @property
    @pulumi.getter(name="lastLaunched")
    def last_launched(self) -> Optional[pulumi.Input['LifecyclePolicyLastLaunchedArgs']]:
        """
        Use to apply lifecycle policy actions on AMIs launched before a certain time.
        """
        return pulumi.get(self, "last_launched")

    @last_launched.setter
    def last_launched(self, value: Optional[pulumi.Input['LifecyclePolicyLastLaunchedArgs']]):
        pulumi.set(self, "last_launched", value)

    @property
    @pulumi.getter
    def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Use to apply lifecycle policy actions on AMIs distributed to a set of regions.
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "regions", value)

    @property
    @pulumi.getter(name="sharedAccounts")
    def shared_accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Use to apply lifecycle policy actions on AMIs shared with a set of regions.
        """
        return pulumi.get(self, "shared_accounts")

    @shared_accounts.setter
    def shared_accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "shared_accounts", value)

    @property
    @pulumi.getter(name="tagMap")
    def tag_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The AMIs to select by tag.
        """
        return pulumi.get(self, "tag_map")

    @tag_map.setter
    def tag_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tag_map", value)


if not MYPY:
    class LifecyclePolicyExclusionRulesArgsDict(TypedDict):
        """
        The exclusion rules to apply of the policy detail.
        """
        amis: NotRequired[pulumi.Input['LifecyclePolicyAmiExclusionRulesArgsDict']]
        """
        Lists configuration values that apply to AMIs that Image Builder should exclude from the lifecycle action.
        """
        tag_map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The Image Builder tags to filter on.
        """
elif False:
    LifecyclePolicyExclusionRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecyclePolicyExclusionRulesArgs:
    def __init__(__self__, *,
                 amis: Optional[pulumi.Input['LifecyclePolicyAmiExclusionRulesArgs']] = None,
                 tag_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        The exclusion rules to apply of the policy detail.
        :param pulumi.Input['LifecyclePolicyAmiExclusionRulesArgs'] amis: Lists configuration values that apply to AMIs that Image Builder should exclude from the lifecycle action.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tag_map: The Image Builder tags to filter on.
        """
        if amis is not None:
            pulumi.set(__self__, "amis", amis)
        if tag_map is not None:
            pulumi.set(__self__, "tag_map", tag_map)

    @property
    @pulumi.getter
    def amis(self) -> Optional[pulumi.Input['LifecyclePolicyAmiExclusionRulesArgs']]:
        """
        Lists configuration values that apply to AMIs that Image Builder should exclude from the lifecycle action.
        """
        return pulumi.get(self, "amis")

    @amis.setter
    def amis(self, value: Optional[pulumi.Input['LifecyclePolicyAmiExclusionRulesArgs']]):
        pulumi.set(self, "amis", value)

    @property
    @pulumi.getter(name="tagMap")
    def tag_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The Image Builder tags to filter on.
        """
        return pulumi.get(self, "tag_map")

    @tag_map.setter
    def tag_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tag_map", value)


if not MYPY:
    class LifecyclePolicyFilterArgsDict(TypedDict):
        """
        The filters to apply of the policy detail.
        """
        type: pulumi.Input['LifecyclePolicyFilterType']
        """
        The filter type.
        """
        value: pulumi.Input[int]
        """
        The filter value.
        """
        retain_at_least: NotRequired[pulumi.Input[int]]
        """
        The minimum number of Image Builder resources to retain.
        """
        unit: NotRequired[pulumi.Input['LifecyclePolicyTimeUnit']]
        """
        The value's time unit.
        """
elif False:
    LifecyclePolicyFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecyclePolicyFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['LifecyclePolicyFilterType'],
                 value: pulumi.Input[int],
                 retain_at_least: Optional[pulumi.Input[int]] = None,
                 unit: Optional[pulumi.Input['LifecyclePolicyTimeUnit']] = None):
        """
        The filters to apply of the policy detail.
        :param pulumi.Input['LifecyclePolicyFilterType'] type: The filter type.
        :param pulumi.Input[int] value: The filter value.
        :param pulumi.Input[int] retain_at_least: The minimum number of Image Builder resources to retain.
        :param pulumi.Input['LifecyclePolicyTimeUnit'] unit: The value's time unit.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if retain_at_least is not None:
            pulumi.set(__self__, "retain_at_least", retain_at_least)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['LifecyclePolicyFilterType']:
        """
        The filter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['LifecyclePolicyFilterType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="retainAtLeast")
    def retain_at_least(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum number of Image Builder resources to retain.
        """
        return pulumi.get(self, "retain_at_least")

    @retain_at_least.setter
    def retain_at_least(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retain_at_least", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input['LifecyclePolicyTimeUnit']]:
        """
        The value's time unit.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input['LifecyclePolicyTimeUnit']]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class LifecyclePolicyIncludeResourcesArgsDict(TypedDict):
        """
        The included resources of the policy detail.
        """
        amis: NotRequired[pulumi.Input[bool]]
        """
        Use to configure lifecycle actions on AMIs.
        """
        containers: NotRequired[pulumi.Input[bool]]
        """
        Use to configure lifecycle actions on containers.
        """
        snapshots: NotRequired[pulumi.Input[bool]]
        """
        Use to configure lifecycle actions on snapshots.
        """
elif False:
    LifecyclePolicyIncludeResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecyclePolicyIncludeResourcesArgs:
    def __init__(__self__, *,
                 amis: Optional[pulumi.Input[bool]] = None,
                 containers: Optional[pulumi.Input[bool]] = None,
                 snapshots: Optional[pulumi.Input[bool]] = None):
        """
        The included resources of the policy detail.
        :param pulumi.Input[bool] amis: Use to configure lifecycle actions on AMIs.
        :param pulumi.Input[bool] containers: Use to configure lifecycle actions on containers.
        :param pulumi.Input[bool] snapshots: Use to configure lifecycle actions on snapshots.
        """
        if amis is not None:
            pulumi.set(__self__, "amis", amis)
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if snapshots is not None:
            pulumi.set(__self__, "snapshots", snapshots)

    @property
    @pulumi.getter
    def amis(self) -> Optional[pulumi.Input[bool]]:
        """
        Use to configure lifecycle actions on AMIs.
        """
        return pulumi.get(self, "amis")

    @amis.setter
    def amis(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "amis", value)

    @property
    @pulumi.getter
    def containers(self) -> Optional[pulumi.Input[bool]]:
        """
        Use to configure lifecycle actions on containers.
        """
        return pulumi.get(self, "containers")

    @containers.setter
    def containers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "containers", value)

    @property
    @pulumi.getter
    def snapshots(self) -> Optional[pulumi.Input[bool]]:
        """
        Use to configure lifecycle actions on snapshots.
        """
        return pulumi.get(self, "snapshots")

    @snapshots.setter
    def snapshots(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "snapshots", value)


if not MYPY:
    class LifecyclePolicyLastLaunchedArgsDict(TypedDict):
        """
        The last launched time of a resource.
        """
        unit: pulumi.Input['LifecyclePolicyTimeUnit']
        """
        The value's time unit.
        """
        value: pulumi.Input[int]
        """
        The last launched value.
        """
elif False:
    LifecyclePolicyLastLaunchedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecyclePolicyLastLaunchedArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input['LifecyclePolicyTimeUnit'],
                 value: pulumi.Input[int]):
        """
        The last launched time of a resource.
        :param pulumi.Input['LifecyclePolicyTimeUnit'] unit: The value's time unit.
        :param pulumi.Input[int] value: The last launched value.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input['LifecyclePolicyTimeUnit']:
        """
        The value's time unit.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input['LifecyclePolicyTimeUnit']):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        The last launched value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LifecyclePolicyPolicyDetailArgsDict(TypedDict):
        """
        The policy detail of the lifecycle policy.
        """
        action: pulumi.Input['LifecyclePolicyActionArgsDict']
        """
        Configuration details for the policy action.
        """
        filter: pulumi.Input['LifecyclePolicyFilterArgsDict']
        """
        Specifies the resources that the lifecycle policy applies to.
        """
        exclusion_rules: NotRequired[pulumi.Input['LifecyclePolicyExclusionRulesArgsDict']]
        """
        Additional rules to specify resources that should be exempt from policy actions.
        """
elif False:
    LifecyclePolicyPolicyDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecyclePolicyPolicyDetailArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['LifecyclePolicyActionArgs'],
                 filter: pulumi.Input['LifecyclePolicyFilterArgs'],
                 exclusion_rules: Optional[pulumi.Input['LifecyclePolicyExclusionRulesArgs']] = None):
        """
        The policy detail of the lifecycle policy.
        :param pulumi.Input['LifecyclePolicyActionArgs'] action: Configuration details for the policy action.
        :param pulumi.Input['LifecyclePolicyFilterArgs'] filter: Specifies the resources that the lifecycle policy applies to.
        :param pulumi.Input['LifecyclePolicyExclusionRulesArgs'] exclusion_rules: Additional rules to specify resources that should be exempt from policy actions.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "filter", filter)
        if exclusion_rules is not None:
            pulumi.set(__self__, "exclusion_rules", exclusion_rules)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['LifecyclePolicyActionArgs']:
        """
        Configuration details for the policy action.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['LifecyclePolicyActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['LifecyclePolicyFilterArgs']:
        """
        Specifies the resources that the lifecycle policy applies to.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['LifecyclePolicyFilterArgs']):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="exclusionRules")
    def exclusion_rules(self) -> Optional[pulumi.Input['LifecyclePolicyExclusionRulesArgs']]:
        """
        Additional rules to specify resources that should be exempt from policy actions.
        """
        return pulumi.get(self, "exclusion_rules")

    @exclusion_rules.setter
    def exclusion_rules(self, value: Optional[pulumi.Input['LifecyclePolicyExclusionRulesArgs']]):
        pulumi.set(self, "exclusion_rules", value)


if not MYPY:
    class LifecyclePolicyRecipeSelectionArgsDict(TypedDict):
        """
        The recipe to apply the lifecycle policy for.
        """
        name: pulumi.Input[str]
        """
        The recipe name.
        """
        semantic_version: pulumi.Input[str]
        """
        The recipe version.
        """
elif False:
    LifecyclePolicyRecipeSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecyclePolicyRecipeSelectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 semantic_version: pulumi.Input[str]):
        """
        The recipe to apply the lifecycle policy for.
        :param pulumi.Input[str] name: The recipe name.
        :param pulumi.Input[str] semantic_version: The recipe version.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "semantic_version", semantic_version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The recipe name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="semanticVersion")
    def semantic_version(self) -> pulumi.Input[str]:
        """
        The recipe version.
        """
        return pulumi.get(self, "semantic_version")

    @semantic_version.setter
    def semantic_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "semantic_version", value)


if not MYPY:
    class LifecyclePolicyResourceSelectionArgsDict(TypedDict):
        """
        The resource selection for the lifecycle policy.
        """
        recipes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LifecyclePolicyRecipeSelectionArgsDict']]]]
        """
        The recipes to select.
        """
        tag_map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The Image Builder resources to select by tag.
        """
elif False:
    LifecyclePolicyResourceSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LifecyclePolicyResourceSelectionArgs:
    def __init__(__self__, *,
                 recipes: Optional[pulumi.Input[Sequence[pulumi.Input['LifecyclePolicyRecipeSelectionArgs']]]] = None,
                 tag_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        The resource selection for the lifecycle policy.
        :param pulumi.Input[Sequence[pulumi.Input['LifecyclePolicyRecipeSelectionArgs']]] recipes: The recipes to select.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tag_map: The Image Builder resources to select by tag.
        """
        if recipes is not None:
            pulumi.set(__self__, "recipes", recipes)
        if tag_map is not None:
            pulumi.set(__self__, "tag_map", tag_map)

    @property
    @pulumi.getter
    def recipes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LifecyclePolicyRecipeSelectionArgs']]]]:
        """
        The recipes to select.
        """
        return pulumi.get(self, "recipes")

    @recipes.setter
    def recipes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LifecyclePolicyRecipeSelectionArgs']]]]):
        pulumi.set(self, "recipes", value)

    @property
    @pulumi.getter(name="tagMap")
    def tag_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The Image Builder resources to select by tag.
        """
        return pulumi.get(self, "tag_map")

    @tag_map.setter
    def tag_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tag_map", value)


