# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AnalysisAggregationFunction',
    'AnalysisAggregationSortConfiguration',
    'AnalysisAllSheetsFilterScopeConfiguration',
    'AnalysisAnchorDateConfiguration',
    'AnalysisArcAxisConfiguration',
    'AnalysisArcAxisDisplayRange',
    'AnalysisArcConfiguration',
    'AnalysisArcOptions',
    'AnalysisAttributeAggregationFunction',
    'AnalysisAxisDataOptions',
    'AnalysisAxisDisplayDataDrivenRange',
    'AnalysisAxisDisplayMinMaxRange',
    'AnalysisAxisDisplayOptions',
    'AnalysisAxisDisplayRange',
    'AnalysisAxisLabelOptions',
    'AnalysisAxisLabelReferenceOptions',
    'AnalysisAxisLinearScale',
    'AnalysisAxisLogarithmicScale',
    'AnalysisAxisScale',
    'AnalysisAxisTickLabelOptions',
    'AnalysisBarChartAggregatedFieldWells',
    'AnalysisBarChartConfiguration',
    'AnalysisBarChartFieldWells',
    'AnalysisBarChartSortConfiguration',
    'AnalysisBarChartVisual',
    'AnalysisBinCountOptions',
    'AnalysisBinWidthOptions',
    'AnalysisBodySectionConfiguration',
    'AnalysisBodySectionContent',
    'AnalysisBoxPlotAggregatedFieldWells',
    'AnalysisBoxPlotChartConfiguration',
    'AnalysisBoxPlotFieldWells',
    'AnalysisBoxPlotOptions',
    'AnalysisBoxPlotSortConfiguration',
    'AnalysisBoxPlotStyleOptions',
    'AnalysisBoxPlotVisual',
    'AnalysisCalculatedField',
    'AnalysisCalculatedMeasureField',
    'AnalysisCascadingControlConfiguration',
    'AnalysisCascadingControlSource',
    'AnalysisCategoricalDimensionField',
    'AnalysisCategoricalMeasureField',
    'AnalysisCategoryDrillDownFilter',
    'AnalysisCategoryFilter',
    'AnalysisCategoryFilterConfiguration',
    'AnalysisChartAxisLabelOptions',
    'AnalysisClusterMarker',
    'AnalysisClusterMarkerConfiguration',
    'AnalysisColorScale',
    'AnalysisColorsConfiguration',
    'AnalysisColumnConfiguration',
    'AnalysisColumnHierarchy',
    'AnalysisColumnIdentifier',
    'AnalysisColumnSort',
    'AnalysisColumnTooltipItem',
    'AnalysisComboChartAggregatedFieldWells',
    'AnalysisComboChartConfiguration',
    'AnalysisComboChartFieldWells',
    'AnalysisComboChartSortConfiguration',
    'AnalysisComboChartVisual',
    'AnalysisComparisonConfiguration',
    'AnalysisComparisonFormatConfiguration',
    'AnalysisComputation',
    'AnalysisConditionalFormattingColor',
    'AnalysisConditionalFormattingCustomIconCondition',
    'AnalysisConditionalFormattingCustomIconOptions',
    'AnalysisConditionalFormattingGradientColor',
    'AnalysisConditionalFormattingIcon',
    'AnalysisConditionalFormattingIconDisplayConfiguration',
    'AnalysisConditionalFormattingIconSet',
    'AnalysisConditionalFormattingSolidColor',
    'AnalysisContributionAnalysisDefault',
    'AnalysisCurrencyDisplayFormatConfiguration',
    'AnalysisCustomActionFilterOperation',
    'AnalysisCustomActionNavigationOperation',
    'AnalysisCustomActionSetParametersOperation',
    'AnalysisCustomActionUrlOperation',
    'AnalysisCustomColor',
    'AnalysisCustomContentConfiguration',
    'AnalysisCustomContentVisual',
    'AnalysisCustomFilterConfiguration',
    'AnalysisCustomFilterListConfiguration',
    'AnalysisCustomNarrativeOptions',
    'AnalysisCustomParameterValues',
    'AnalysisCustomValuesConfiguration',
    'AnalysisDataBarsOptions',
    'AnalysisDataColor',
    'AnalysisDataFieldSeriesItem',
    'AnalysisDataLabelOptions',
    'AnalysisDataLabelType',
    'AnalysisDataPathColor',
    'AnalysisDataPathLabelType',
    'AnalysisDataPathSort',
    'AnalysisDataPathValue',
    'AnalysisDataSetIdentifierDeclaration',
    'AnalysisDataSetReference',
    'AnalysisDateAxisOptions',
    'AnalysisDateDimensionField',
    'AnalysisDateMeasureField',
    'AnalysisDateTimeDefaultValues',
    'AnalysisDateTimeFormatConfiguration',
    'AnalysisDateTimeHierarchy',
    'AnalysisDateTimeParameter',
    'AnalysisDateTimeParameterDeclaration',
    'AnalysisDateTimePickerControlDisplayOptions',
    'AnalysisDateTimeValueWhenUnsetConfiguration',
    'AnalysisDecimalDefaultValues',
    'AnalysisDecimalParameter',
    'AnalysisDecimalParameterDeclaration',
    'AnalysisDecimalPlacesConfiguration',
    'AnalysisDecimalValueWhenUnsetConfiguration',
    'AnalysisDefaultFreeFormLayoutConfiguration',
    'AnalysisDefaultGridLayoutConfiguration',
    'AnalysisDefaultInteractiveLayoutConfiguration',
    'AnalysisDefaultNewSheetConfiguration',
    'AnalysisDefaultPaginatedLayoutConfiguration',
    'AnalysisDefaultSectionBasedLayoutConfiguration',
    'AnalysisDefaults',
    'AnalysisDefinition',
    'AnalysisDestinationParameterValueConfiguration',
    'AnalysisDimensionField',
    'AnalysisDonutCenterOptions',
    'AnalysisDonutOptions',
    'AnalysisDrillDownFilter',
    'AnalysisDropDownControlDisplayOptions',
    'AnalysisDynamicDefaultValue',
    'AnalysisEmptyVisual',
    'AnalysisEntity',
    'AnalysisError',
    'AnalysisExcludePeriodConfiguration',
    'AnalysisExplicitHierarchy',
    'AnalysisFieldBasedTooltip',
    'AnalysisFieldLabelType',
    'AnalysisFieldSeriesItem',
    'AnalysisFieldSort',
    'AnalysisFieldSortOptions',
    'AnalysisFieldTooltipItem',
    'AnalysisFilledMapAggregatedFieldWells',
    'AnalysisFilledMapConditionalFormatting',
    'AnalysisFilledMapConditionalFormattingOption',
    'AnalysisFilledMapConfiguration',
    'AnalysisFilledMapFieldWells',
    'AnalysisFilledMapShapeConditionalFormatting',
    'AnalysisFilledMapSortConfiguration',
    'AnalysisFilledMapVisual',
    'AnalysisFilter',
    'AnalysisFilterControl',
    'AnalysisFilterDateTimePickerControl',
    'AnalysisFilterDropDownControl',
    'AnalysisFilterGroup',
    'AnalysisFilterListConfiguration',
    'AnalysisFilterListControl',
    'AnalysisFilterOperationSelectedFieldsConfiguration',
    'AnalysisFilterOperationTargetVisualsConfiguration',
    'AnalysisFilterRelativeDateTimeControl',
    'AnalysisFilterScopeConfiguration',
    'AnalysisFilterSelectableValues',
    'AnalysisFilterSliderControl',
    'AnalysisFilterTextAreaControl',
    'AnalysisFilterTextFieldControl',
    'AnalysisFontConfiguration',
    'AnalysisFontSize',
    'AnalysisFontWeight',
    'AnalysisForecastComputation',
    'AnalysisForecastConfiguration',
    'AnalysisForecastScenario',
    'AnalysisFormatConfiguration',
    'AnalysisFreeFormLayoutCanvasSizeOptions',
    'AnalysisFreeFormLayoutConfiguration',
    'AnalysisFreeFormLayoutElement',
    'AnalysisFreeFormLayoutElementBackgroundStyle',
    'AnalysisFreeFormLayoutElementBorderStyle',
    'AnalysisFreeFormLayoutScreenCanvasSizeOptions',
    'AnalysisFreeFormSectionLayoutConfiguration',
    'AnalysisFunnelChartAggregatedFieldWells',
    'AnalysisFunnelChartConfiguration',
    'AnalysisFunnelChartDataLabelOptions',
    'AnalysisFunnelChartFieldWells',
    'AnalysisFunnelChartSortConfiguration',
    'AnalysisFunnelChartVisual',
    'AnalysisGaugeChartArcConditionalFormatting',
    'AnalysisGaugeChartConditionalFormatting',
    'AnalysisGaugeChartConditionalFormattingOption',
    'AnalysisGaugeChartConfiguration',
    'AnalysisGaugeChartFieldWells',
    'AnalysisGaugeChartOptions',
    'AnalysisGaugeChartPrimaryValueConditionalFormatting',
    'AnalysisGaugeChartVisual',
    'AnalysisGeospatialCoordinateBounds',
    'AnalysisGeospatialHeatmapColorScale',
    'AnalysisGeospatialHeatmapConfiguration',
    'AnalysisGeospatialHeatmapDataColor',
    'AnalysisGeospatialMapAggregatedFieldWells',
    'AnalysisGeospatialMapConfiguration',
    'AnalysisGeospatialMapFieldWells',
    'AnalysisGeospatialMapStyleOptions',
    'AnalysisGeospatialMapVisual',
    'AnalysisGeospatialPointStyleOptions',
    'AnalysisGeospatialWindowOptions',
    'AnalysisGlobalTableBorderOptions',
    'AnalysisGradientColor',
    'AnalysisGradientStop',
    'AnalysisGridLayoutCanvasSizeOptions',
    'AnalysisGridLayoutConfiguration',
    'AnalysisGridLayoutElement',
    'AnalysisGridLayoutScreenCanvasSizeOptions',
    'AnalysisGrowthRateComputation',
    'AnalysisHeaderFooterSectionConfiguration',
    'AnalysisHeatMapAggregatedFieldWells',
    'AnalysisHeatMapConfiguration',
    'AnalysisHeatMapFieldWells',
    'AnalysisHeatMapSortConfiguration',
    'AnalysisHeatMapVisual',
    'AnalysisHistogramAggregatedFieldWells',
    'AnalysisHistogramBinOptions',
    'AnalysisHistogramConfiguration',
    'AnalysisHistogramFieldWells',
    'AnalysisHistogramVisual',
    'AnalysisInsightConfiguration',
    'AnalysisInsightVisual',
    'AnalysisIntegerDefaultValues',
    'AnalysisIntegerParameter',
    'AnalysisIntegerParameterDeclaration',
    'AnalysisIntegerValueWhenUnsetConfiguration',
    'AnalysisItemsLimitConfiguration',
    'AnalysisKpiActualValueConditionalFormatting',
    'AnalysisKpiComparisonValueConditionalFormatting',
    'AnalysisKpiConditionalFormatting',
    'AnalysisKpiConditionalFormattingOption',
    'AnalysisKpiConfiguration',
    'AnalysisKpiFieldWells',
    'AnalysisKpiOptions',
    'AnalysisKpiPrimaryValueConditionalFormatting',
    'AnalysisKpiProgressBarConditionalFormatting',
    'AnalysisKpiSortConfiguration',
    'AnalysisKpiSparklineOptions',
    'AnalysisKpiVisual',
    'AnalysisKpiVisualLayoutOptions',
    'AnalysisKpiVisualStandardLayout',
    'AnalysisLabelOptions',
    'AnalysisLayout',
    'AnalysisLayoutConfiguration',
    'AnalysisLegendOptions',
    'AnalysisLineChartAggregatedFieldWells',
    'AnalysisLineChartConfiguration',
    'AnalysisLineChartDefaultSeriesSettings',
    'AnalysisLineChartFieldWells',
    'AnalysisLineChartLineStyleSettings',
    'AnalysisLineChartMarkerStyleSettings',
    'AnalysisLineChartSeriesSettings',
    'AnalysisLineChartSortConfiguration',
    'AnalysisLineChartVisual',
    'AnalysisLineSeriesAxisDisplayOptions',
    'AnalysisListControlDisplayOptions',
    'AnalysisListControlSearchOptions',
    'AnalysisListControlSelectAllOptions',
    'AnalysisLoadingAnimation',
    'AnalysisLocalNavigationConfiguration',
    'AnalysisLongFormatText',
    'AnalysisMappedDataSetParameter',
    'AnalysisMaximumLabelType',
    'AnalysisMaximumMinimumComputation',
    'AnalysisMeasureField',
    'AnalysisMetricComparisonComputation',
    'AnalysisMinimumLabelType',
    'AnalysisMissingDataConfiguration',
    'AnalysisNegativeValueConfiguration',
    'AnalysisNullValueFormatConfiguration',
    'AnalysisNumberDisplayFormatConfiguration',
    'AnalysisNumberFormatConfiguration',
    'AnalysisNumericAxisOptions',
    'AnalysisNumericEqualityDrillDownFilter',
    'AnalysisNumericEqualityFilter',
    'AnalysisNumericFormatConfiguration',
    'AnalysisNumericRangeFilter',
    'AnalysisNumericRangeFilterValue',
    'AnalysisNumericSeparatorConfiguration',
    'AnalysisNumericalAggregationFunction',
    'AnalysisNumericalDimensionField',
    'AnalysisNumericalMeasureField',
    'AnalysisPaginationConfiguration',
    'AnalysisPanelConfiguration',
    'AnalysisPanelTitleOptions',
    'AnalysisParameterControl',
    'AnalysisParameterDateTimePickerControl',
    'AnalysisParameterDeclaration',
    'AnalysisParameterDropDownControl',
    'AnalysisParameterListControl',
    'AnalysisParameterSelectableValues',
    'AnalysisParameterSliderControl',
    'AnalysisParameterTextAreaControl',
    'AnalysisParameterTextFieldControl',
    'AnalysisParameters',
    'AnalysisPercentVisibleRange',
    'AnalysisPercentageDisplayFormatConfiguration',
    'AnalysisPercentileAggregation',
    'AnalysisPeriodOverPeriodComputation',
    'AnalysisPeriodToDateComputation',
    'AnalysisPieChartAggregatedFieldWells',
    'AnalysisPieChartConfiguration',
    'AnalysisPieChartFieldWells',
    'AnalysisPieChartSortConfiguration',
    'AnalysisPieChartVisual',
    'AnalysisPivotFieldSortOptions',
    'AnalysisPivotTableAggregatedFieldWells',
    'AnalysisPivotTableCellConditionalFormatting',
    'AnalysisPivotTableConditionalFormatting',
    'AnalysisPivotTableConditionalFormattingOption',
    'AnalysisPivotTableConditionalFormattingScope',
    'AnalysisPivotTableConfiguration',
    'AnalysisPivotTableDataPathOption',
    'AnalysisPivotTableFieldCollapseStateOption',
    'AnalysisPivotTableFieldCollapseStateTarget',
    'AnalysisPivotTableFieldOption',
    'AnalysisPivotTableFieldOptions',
    'AnalysisPivotTableFieldSubtotalOptions',
    'AnalysisPivotTableFieldWells',
    'AnalysisPivotTableOptions',
    'AnalysisPivotTablePaginatedReportOptions',
    'AnalysisPivotTableRowsLabelOptions',
    'AnalysisPivotTableSortBy',
    'AnalysisPivotTableSortConfiguration',
    'AnalysisPivotTableTotalOptions',
    'AnalysisPivotTableVisual',
    'AnalysisPivotTotalOptions',
    'AnalysisPredefinedHierarchy',
    'AnalysisProgressBarOptions',
    'AnalysisRadarChartAggregatedFieldWells',
    'AnalysisRadarChartAreaStyleSettings',
    'AnalysisRadarChartConfiguration',
    'AnalysisRadarChartFieldWells',
    'AnalysisRadarChartSeriesSettings',
    'AnalysisRadarChartSortConfiguration',
    'AnalysisRadarChartVisual',
    'AnalysisRangeEndsLabelType',
    'AnalysisReferenceLine',
    'AnalysisReferenceLineCustomLabelConfiguration',
    'AnalysisReferenceLineDataConfiguration',
    'AnalysisReferenceLineDynamicDataConfiguration',
    'AnalysisReferenceLineLabelConfiguration',
    'AnalysisReferenceLineStaticDataConfiguration',
    'AnalysisReferenceLineStyleConfiguration',
    'AnalysisReferenceLineValueLabelConfiguration',
    'AnalysisRelativeDateTimeControlDisplayOptions',
    'AnalysisRelativeDatesFilter',
    'AnalysisResourcePermission',
    'AnalysisRollingDateConfiguration',
    'AnalysisRowAlternateColorOptions',
    'AnalysisSameSheetTargetVisualConfiguration',
    'AnalysisSankeyDiagramAggregatedFieldWells',
    'AnalysisSankeyDiagramChartConfiguration',
    'AnalysisSankeyDiagramFieldWells',
    'AnalysisSankeyDiagramSortConfiguration',
    'AnalysisSankeyDiagramVisual',
    'AnalysisScatterPlotCategoricallyAggregatedFieldWells',
    'AnalysisScatterPlotConfiguration',
    'AnalysisScatterPlotFieldWells',
    'AnalysisScatterPlotUnaggregatedFieldWells',
    'AnalysisScatterPlotVisual',
    'AnalysisScrollBarOptions',
    'AnalysisSecondaryValueOptions',
    'AnalysisSectionAfterPageBreak',
    'AnalysisSectionBasedLayoutCanvasSizeOptions',
    'AnalysisSectionBasedLayoutConfiguration',
    'AnalysisSectionBasedLayoutPaperCanvasSizeOptions',
    'AnalysisSectionLayoutConfiguration',
    'AnalysisSectionPageBreakConfiguration',
    'AnalysisSectionStyle',
    'AnalysisSelectedSheetsFilterScopeConfiguration',
    'AnalysisSeriesItem',
    'AnalysisSetParameterValueConfiguration',
    'AnalysisShapeConditionalFormat',
    'AnalysisSheet',
    'AnalysisSheetControlInfoIconLabelOptions',
    'AnalysisSheetControlLayout',
    'AnalysisSheetControlLayoutConfiguration',
    'AnalysisSheetDefinition',
    'AnalysisSheetElementConfigurationOverrides',
    'AnalysisSheetElementRenderingRule',
    'AnalysisSheetTextBox',
    'AnalysisSheetVisualScopingConfiguration',
    'AnalysisShortFormatText',
    'AnalysisSimpleClusterMarker',
    'AnalysisSliderControlDisplayOptions',
    'AnalysisSmallMultiplesAxisProperties',
    'AnalysisSmallMultiplesOptions',
    'AnalysisSourceEntity',
    'AnalysisSourceTemplate',
    'AnalysisSpacing',
    'AnalysisStringDefaultValues',
    'AnalysisStringFormatConfiguration',
    'AnalysisStringParameter',
    'AnalysisStringParameterDeclaration',
    'AnalysisStringValueWhenUnsetConfiguration',
    'AnalysisSubtotalOptions',
    'AnalysisTableAggregatedFieldWells',
    'AnalysisTableBorderOptions',
    'AnalysisTableCellConditionalFormatting',
    'AnalysisTableCellImageSizingConfiguration',
    'AnalysisTableCellStyle',
    'AnalysisTableConditionalFormatting',
    'AnalysisTableConditionalFormattingOption',
    'AnalysisTableConfiguration',
    'AnalysisTableFieldCustomIconContent',
    'AnalysisTableFieldCustomTextContent',
    'AnalysisTableFieldImageConfiguration',
    'AnalysisTableFieldLinkConfiguration',
    'AnalysisTableFieldLinkContentConfiguration',
    'AnalysisTableFieldOption',
    'AnalysisTableFieldOptions',
    'AnalysisTableFieldUrlConfiguration',
    'AnalysisTableFieldWells',
    'AnalysisTableInlineVisualization',
    'AnalysisTableOptions',
    'AnalysisTablePaginatedReportOptions',
    'AnalysisTablePinnedFieldOptions',
    'AnalysisTableRowConditionalFormatting',
    'AnalysisTableSideBorderOptions',
    'AnalysisTableSortConfiguration',
    'AnalysisTableStyleTarget',
    'AnalysisTableUnaggregatedFieldWells',
    'AnalysisTableVisual',
    'AnalysisTag',
    'AnalysisTextAreaControlDisplayOptions',
    'AnalysisTextConditionalFormat',
    'AnalysisTextControlPlaceholderOptions',
    'AnalysisTextFieldControlDisplayOptions',
    'AnalysisThousandSeparatorOptions',
    'AnalysisTimeBasedForecastProperties',
    'AnalysisTimeEqualityFilter',
    'AnalysisTimeRangeDrillDownFilter',
    'AnalysisTimeRangeFilter',
    'AnalysisTimeRangeFilterValue',
    'AnalysisTooltipItem',
    'AnalysisTooltipOptions',
    'AnalysisTopBottomFilter',
    'AnalysisTopBottomMoversComputation',
    'AnalysisTopBottomRankedComputation',
    'AnalysisTotalAggregationComputation',
    'AnalysisTotalOptions',
    'AnalysisTreeMapAggregatedFieldWells',
    'AnalysisTreeMapConfiguration',
    'AnalysisTreeMapFieldWells',
    'AnalysisTreeMapSortConfiguration',
    'AnalysisTreeMapVisual',
    'AnalysisTrendArrowOptions',
    'AnalysisUnaggregatedField',
    'AnalysisUniqueValuesComputation',
    'AnalysisVisibleRangeOptions',
    'AnalysisVisual',
    'AnalysisVisualCustomAction',
    'AnalysisVisualCustomActionOperation',
    'AnalysisVisualPalette',
    'AnalysisVisualSubtitleLabelOptions',
    'AnalysisVisualTitleLabelOptions',
    'AnalysisWaterfallChartAggregatedFieldWells',
    'AnalysisWaterfallChartConfiguration',
    'AnalysisWaterfallChartFieldWells',
    'AnalysisWaterfallChartOptions',
    'AnalysisWaterfallChartSortConfiguration',
    'AnalysisWaterfallVisual',
    'AnalysisWhatIfPointScenario',
    'AnalysisWhatIfRangeScenario',
    'AnalysisWordCloudAggregatedFieldWells',
    'AnalysisWordCloudChartConfiguration',
    'AnalysisWordCloudFieldWells',
    'AnalysisWordCloudOptions',
    'AnalysisWordCloudSortConfiguration',
    'AnalysisWordCloudVisual',
    'DashboardAdHocFilteringOption',
    'DashboardAggregationFunction',
    'DashboardAggregationSortConfiguration',
    'DashboardAllSheetsFilterScopeConfiguration',
    'DashboardAnalysisDefaults',
    'DashboardAnchorDateConfiguration',
    'DashboardArcAxisConfiguration',
    'DashboardArcAxisDisplayRange',
    'DashboardArcConfiguration',
    'DashboardArcOptions',
    'DashboardAttributeAggregationFunction',
    'DashboardAxisDataOptions',
    'DashboardAxisDisplayDataDrivenRange',
    'DashboardAxisDisplayMinMaxRange',
    'DashboardAxisDisplayOptions',
    'DashboardAxisDisplayRange',
    'DashboardAxisLabelOptions',
    'DashboardAxisLabelReferenceOptions',
    'DashboardAxisLinearScale',
    'DashboardAxisLogarithmicScale',
    'DashboardAxisScale',
    'DashboardAxisTickLabelOptions',
    'DashboardBarChartAggregatedFieldWells',
    'DashboardBarChartConfiguration',
    'DashboardBarChartFieldWells',
    'DashboardBarChartSortConfiguration',
    'DashboardBarChartVisual',
    'DashboardBinCountOptions',
    'DashboardBinWidthOptions',
    'DashboardBodySectionConfiguration',
    'DashboardBodySectionContent',
    'DashboardBoxPlotAggregatedFieldWells',
    'DashboardBoxPlotChartConfiguration',
    'DashboardBoxPlotFieldWells',
    'DashboardBoxPlotOptions',
    'DashboardBoxPlotSortConfiguration',
    'DashboardBoxPlotStyleOptions',
    'DashboardBoxPlotVisual',
    'DashboardCalculatedField',
    'DashboardCalculatedMeasureField',
    'DashboardCascadingControlConfiguration',
    'DashboardCascadingControlSource',
    'DashboardCategoricalDimensionField',
    'DashboardCategoricalMeasureField',
    'DashboardCategoryDrillDownFilter',
    'DashboardCategoryFilter',
    'DashboardCategoryFilterConfiguration',
    'DashboardChartAxisLabelOptions',
    'DashboardClusterMarker',
    'DashboardClusterMarkerConfiguration',
    'DashboardColorScale',
    'DashboardColorsConfiguration',
    'DashboardColumnConfiguration',
    'DashboardColumnHierarchy',
    'DashboardColumnIdentifier',
    'DashboardColumnSort',
    'DashboardColumnTooltipItem',
    'DashboardComboChartAggregatedFieldWells',
    'DashboardComboChartConfiguration',
    'DashboardComboChartFieldWells',
    'DashboardComboChartSortConfiguration',
    'DashboardComboChartVisual',
    'DashboardComparisonConfiguration',
    'DashboardComparisonFormatConfiguration',
    'DashboardComputation',
    'DashboardConditionalFormattingColor',
    'DashboardConditionalFormattingCustomIconCondition',
    'DashboardConditionalFormattingCustomIconOptions',
    'DashboardConditionalFormattingGradientColor',
    'DashboardConditionalFormattingIcon',
    'DashboardConditionalFormattingIconDisplayConfiguration',
    'DashboardConditionalFormattingIconSet',
    'DashboardConditionalFormattingSolidColor',
    'DashboardContributionAnalysisDefault',
    'DashboardCurrencyDisplayFormatConfiguration',
    'DashboardCustomActionFilterOperation',
    'DashboardCustomActionNavigationOperation',
    'DashboardCustomActionSetParametersOperation',
    'DashboardCustomActionUrlOperation',
    'DashboardCustomColor',
    'DashboardCustomContentConfiguration',
    'DashboardCustomContentVisual',
    'DashboardCustomFilterConfiguration',
    'DashboardCustomFilterListConfiguration',
    'DashboardCustomNarrativeOptions',
    'DashboardCustomParameterValues',
    'DashboardCustomValuesConfiguration',
    'DashboardDataBarsOptions',
    'DashboardDataColor',
    'DashboardDataFieldSeriesItem',
    'DashboardDataLabelOptions',
    'DashboardDataLabelType',
    'DashboardDataPathColor',
    'DashboardDataPathLabelType',
    'DashboardDataPathSort',
    'DashboardDataPathValue',
    'DashboardDataPointDrillUpDownOption',
    'DashboardDataPointMenuLabelOption',
    'DashboardDataPointTooltipOption',
    'DashboardDataSetIdentifierDeclaration',
    'DashboardDataSetReference',
    'DashboardDateAxisOptions',
    'DashboardDateDimensionField',
    'DashboardDateMeasureField',
    'DashboardDateTimeDefaultValues',
    'DashboardDateTimeFormatConfiguration',
    'DashboardDateTimeHierarchy',
    'DashboardDateTimeParameter',
    'DashboardDateTimeParameterDeclaration',
    'DashboardDateTimePickerControlDisplayOptions',
    'DashboardDateTimeValueWhenUnsetConfiguration',
    'DashboardDecimalDefaultValues',
    'DashboardDecimalParameter',
    'DashboardDecimalParameterDeclaration',
    'DashboardDecimalPlacesConfiguration',
    'DashboardDecimalValueWhenUnsetConfiguration',
    'DashboardDefaultFreeFormLayoutConfiguration',
    'DashboardDefaultGridLayoutConfiguration',
    'DashboardDefaultInteractiveLayoutConfiguration',
    'DashboardDefaultNewSheetConfiguration',
    'DashboardDefaultPaginatedLayoutConfiguration',
    'DashboardDefaultSectionBasedLayoutConfiguration',
    'DashboardDestinationParameterValueConfiguration',
    'DashboardDimensionField',
    'DashboardDonutCenterOptions',
    'DashboardDonutOptions',
    'DashboardDrillDownFilter',
    'DashboardDropDownControlDisplayOptions',
    'DashboardDynamicDefaultValue',
    'DashboardEmptyVisual',
    'DashboardEntity',
    'DashboardError',
    'DashboardExcludePeriodConfiguration',
    'DashboardExplicitHierarchy',
    'DashboardExportHiddenFieldsOption',
    'DashboardExportToCsvOption',
    'DashboardExportWithHiddenFieldsOption',
    'DashboardFieldBasedTooltip',
    'DashboardFieldLabelType',
    'DashboardFieldSeriesItem',
    'DashboardFieldSort',
    'DashboardFieldSortOptions',
    'DashboardFieldTooltipItem',
    'DashboardFilledMapAggregatedFieldWells',
    'DashboardFilledMapConditionalFormatting',
    'DashboardFilledMapConditionalFormattingOption',
    'DashboardFilledMapConfiguration',
    'DashboardFilledMapFieldWells',
    'DashboardFilledMapShapeConditionalFormatting',
    'DashboardFilledMapSortConfiguration',
    'DashboardFilledMapVisual',
    'DashboardFilter',
    'DashboardFilterControl',
    'DashboardFilterDateTimePickerControl',
    'DashboardFilterDropDownControl',
    'DashboardFilterGroup',
    'DashboardFilterListConfiguration',
    'DashboardFilterListControl',
    'DashboardFilterOperationSelectedFieldsConfiguration',
    'DashboardFilterOperationTargetVisualsConfiguration',
    'DashboardFilterRelativeDateTimeControl',
    'DashboardFilterScopeConfiguration',
    'DashboardFilterSelectableValues',
    'DashboardFilterSliderControl',
    'DashboardFilterTextAreaControl',
    'DashboardFilterTextFieldControl',
    'DashboardFontConfiguration',
    'DashboardFontSize',
    'DashboardFontWeight',
    'DashboardForecastComputation',
    'DashboardForecastConfiguration',
    'DashboardForecastScenario',
    'DashboardFormatConfiguration',
    'DashboardFreeFormLayoutCanvasSizeOptions',
    'DashboardFreeFormLayoutConfiguration',
    'DashboardFreeFormLayoutElement',
    'DashboardFreeFormLayoutElementBackgroundStyle',
    'DashboardFreeFormLayoutElementBorderStyle',
    'DashboardFreeFormLayoutScreenCanvasSizeOptions',
    'DashboardFreeFormSectionLayoutConfiguration',
    'DashboardFunnelChartAggregatedFieldWells',
    'DashboardFunnelChartConfiguration',
    'DashboardFunnelChartDataLabelOptions',
    'DashboardFunnelChartFieldWells',
    'DashboardFunnelChartSortConfiguration',
    'DashboardFunnelChartVisual',
    'DashboardGaugeChartArcConditionalFormatting',
    'DashboardGaugeChartConditionalFormatting',
    'DashboardGaugeChartConditionalFormattingOption',
    'DashboardGaugeChartConfiguration',
    'DashboardGaugeChartFieldWells',
    'DashboardGaugeChartOptions',
    'DashboardGaugeChartPrimaryValueConditionalFormatting',
    'DashboardGaugeChartVisual',
    'DashboardGeospatialCoordinateBounds',
    'DashboardGeospatialHeatmapColorScale',
    'DashboardGeospatialHeatmapConfiguration',
    'DashboardGeospatialHeatmapDataColor',
    'DashboardGeospatialMapAggregatedFieldWells',
    'DashboardGeospatialMapConfiguration',
    'DashboardGeospatialMapFieldWells',
    'DashboardGeospatialMapStyleOptions',
    'DashboardGeospatialMapVisual',
    'DashboardGeospatialPointStyleOptions',
    'DashboardGeospatialWindowOptions',
    'DashboardGlobalTableBorderOptions',
    'DashboardGradientColor',
    'DashboardGradientStop',
    'DashboardGridLayoutCanvasSizeOptions',
    'DashboardGridLayoutConfiguration',
    'DashboardGridLayoutElement',
    'DashboardGridLayoutScreenCanvasSizeOptions',
    'DashboardGrowthRateComputation',
    'DashboardHeaderFooterSectionConfiguration',
    'DashboardHeatMapAggregatedFieldWells',
    'DashboardHeatMapConfiguration',
    'DashboardHeatMapFieldWells',
    'DashboardHeatMapSortConfiguration',
    'DashboardHeatMapVisual',
    'DashboardHistogramAggregatedFieldWells',
    'DashboardHistogramBinOptions',
    'DashboardHistogramConfiguration',
    'DashboardHistogramFieldWells',
    'DashboardHistogramVisual',
    'DashboardInsightConfiguration',
    'DashboardInsightVisual',
    'DashboardIntegerDefaultValues',
    'DashboardIntegerParameter',
    'DashboardIntegerParameterDeclaration',
    'DashboardIntegerValueWhenUnsetConfiguration',
    'DashboardItemsLimitConfiguration',
    'DashboardKpiActualValueConditionalFormatting',
    'DashboardKpiComparisonValueConditionalFormatting',
    'DashboardKpiConditionalFormatting',
    'DashboardKpiConditionalFormattingOption',
    'DashboardKpiConfiguration',
    'DashboardKpiFieldWells',
    'DashboardKpiOptions',
    'DashboardKpiPrimaryValueConditionalFormatting',
    'DashboardKpiProgressBarConditionalFormatting',
    'DashboardKpiSortConfiguration',
    'DashboardKpiSparklineOptions',
    'DashboardKpiVisual',
    'DashboardKpiVisualLayoutOptions',
    'DashboardKpiVisualStandardLayout',
    'DashboardLabelOptions',
    'DashboardLayout',
    'DashboardLayoutConfiguration',
    'DashboardLegendOptions',
    'DashboardLineChartAggregatedFieldWells',
    'DashboardLineChartConfiguration',
    'DashboardLineChartDefaultSeriesSettings',
    'DashboardLineChartFieldWells',
    'DashboardLineChartLineStyleSettings',
    'DashboardLineChartMarkerStyleSettings',
    'DashboardLineChartSeriesSettings',
    'DashboardLineChartSortConfiguration',
    'DashboardLineChartVisual',
    'DashboardLineSeriesAxisDisplayOptions',
    'DashboardListControlDisplayOptions',
    'DashboardListControlSearchOptions',
    'DashboardListControlSelectAllOptions',
    'DashboardLoadingAnimation',
    'DashboardLocalNavigationConfiguration',
    'DashboardLongFormatText',
    'DashboardMappedDataSetParameter',
    'DashboardMaximumLabelType',
    'DashboardMaximumMinimumComputation',
    'DashboardMeasureField',
    'DashboardMetricComparisonComputation',
    'DashboardMinimumLabelType',
    'DashboardMissingDataConfiguration',
    'DashboardNegativeValueConfiguration',
    'DashboardNullValueFormatConfiguration',
    'DashboardNumberDisplayFormatConfiguration',
    'DashboardNumberFormatConfiguration',
    'DashboardNumericAxisOptions',
    'DashboardNumericEqualityDrillDownFilter',
    'DashboardNumericEqualityFilter',
    'DashboardNumericFormatConfiguration',
    'DashboardNumericRangeFilter',
    'DashboardNumericRangeFilterValue',
    'DashboardNumericSeparatorConfiguration',
    'DashboardNumericalAggregationFunction',
    'DashboardNumericalDimensionField',
    'DashboardNumericalMeasureField',
    'DashboardPaginationConfiguration',
    'DashboardPanelConfiguration',
    'DashboardPanelTitleOptions',
    'DashboardParameterControl',
    'DashboardParameterDateTimePickerControl',
    'DashboardParameterDeclaration',
    'DashboardParameterDropDownControl',
    'DashboardParameterListControl',
    'DashboardParameterSelectableValues',
    'DashboardParameterSliderControl',
    'DashboardParameterTextAreaControl',
    'DashboardParameterTextFieldControl',
    'DashboardParameters',
    'DashboardPercentVisibleRange',
    'DashboardPercentageDisplayFormatConfiguration',
    'DashboardPercentileAggregation',
    'DashboardPeriodOverPeriodComputation',
    'DashboardPeriodToDateComputation',
    'DashboardPieChartAggregatedFieldWells',
    'DashboardPieChartConfiguration',
    'DashboardPieChartFieldWells',
    'DashboardPieChartSortConfiguration',
    'DashboardPieChartVisual',
    'DashboardPivotFieldSortOptions',
    'DashboardPivotTableAggregatedFieldWells',
    'DashboardPivotTableCellConditionalFormatting',
    'DashboardPivotTableConditionalFormatting',
    'DashboardPivotTableConditionalFormattingOption',
    'DashboardPivotTableConditionalFormattingScope',
    'DashboardPivotTableConfiguration',
    'DashboardPivotTableDataPathOption',
    'DashboardPivotTableFieldCollapseStateOption',
    'DashboardPivotTableFieldCollapseStateTarget',
    'DashboardPivotTableFieldOption',
    'DashboardPivotTableFieldOptions',
    'DashboardPivotTableFieldSubtotalOptions',
    'DashboardPivotTableFieldWells',
    'DashboardPivotTableOptions',
    'DashboardPivotTablePaginatedReportOptions',
    'DashboardPivotTableRowsLabelOptions',
    'DashboardPivotTableSortBy',
    'DashboardPivotTableSortConfiguration',
    'DashboardPivotTableTotalOptions',
    'DashboardPivotTableVisual',
    'DashboardPivotTotalOptions',
    'DashboardPredefinedHierarchy',
    'DashboardProgressBarOptions',
    'DashboardPublishOptions',
    'DashboardRadarChartAggregatedFieldWells',
    'DashboardRadarChartAreaStyleSettings',
    'DashboardRadarChartConfiguration',
    'DashboardRadarChartFieldWells',
    'DashboardRadarChartSeriesSettings',
    'DashboardRadarChartSortConfiguration',
    'DashboardRadarChartVisual',
    'DashboardRangeEndsLabelType',
    'DashboardReferenceLine',
    'DashboardReferenceLineCustomLabelConfiguration',
    'DashboardReferenceLineDataConfiguration',
    'DashboardReferenceLineDynamicDataConfiguration',
    'DashboardReferenceLineLabelConfiguration',
    'DashboardReferenceLineStaticDataConfiguration',
    'DashboardReferenceLineStyleConfiguration',
    'DashboardReferenceLineValueLabelConfiguration',
    'DashboardRelativeDateTimeControlDisplayOptions',
    'DashboardRelativeDatesFilter',
    'DashboardResourcePermission',
    'DashboardRollingDateConfiguration',
    'DashboardRowAlternateColorOptions',
    'DashboardSameSheetTargetVisualConfiguration',
    'DashboardSankeyDiagramAggregatedFieldWells',
    'DashboardSankeyDiagramChartConfiguration',
    'DashboardSankeyDiagramFieldWells',
    'DashboardSankeyDiagramSortConfiguration',
    'DashboardSankeyDiagramVisual',
    'DashboardScatterPlotCategoricallyAggregatedFieldWells',
    'DashboardScatterPlotConfiguration',
    'DashboardScatterPlotFieldWells',
    'DashboardScatterPlotUnaggregatedFieldWells',
    'DashboardScatterPlotVisual',
    'DashboardScrollBarOptions',
    'DashboardSecondaryValueOptions',
    'DashboardSectionAfterPageBreak',
    'DashboardSectionBasedLayoutCanvasSizeOptions',
    'DashboardSectionBasedLayoutConfiguration',
    'DashboardSectionBasedLayoutPaperCanvasSizeOptions',
    'DashboardSectionLayoutConfiguration',
    'DashboardSectionPageBreakConfiguration',
    'DashboardSectionStyle',
    'DashboardSelectedSheetsFilterScopeConfiguration',
    'DashboardSeriesItem',
    'DashboardSetParameterValueConfiguration',
    'DashboardShapeConditionalFormat',
    'DashboardSheet',
    'DashboardSheetControlInfoIconLabelOptions',
    'DashboardSheetControlLayout',
    'DashboardSheetControlLayoutConfiguration',
    'DashboardSheetControlsOption',
    'DashboardSheetDefinition',
    'DashboardSheetElementConfigurationOverrides',
    'DashboardSheetElementRenderingRule',
    'DashboardSheetLayoutElementMaximizationOption',
    'DashboardSheetTextBox',
    'DashboardSheetVisualScopingConfiguration',
    'DashboardShortFormatText',
    'DashboardSimpleClusterMarker',
    'DashboardSliderControlDisplayOptions',
    'DashboardSmallMultiplesAxisProperties',
    'DashboardSmallMultiplesOptions',
    'DashboardSourceEntity',
    'DashboardSourceTemplate',
    'DashboardSpacing',
    'DashboardStringDefaultValues',
    'DashboardStringFormatConfiguration',
    'DashboardStringParameter',
    'DashboardStringParameterDeclaration',
    'DashboardStringValueWhenUnsetConfiguration',
    'DashboardSubtotalOptions',
    'DashboardTableAggregatedFieldWells',
    'DashboardTableBorderOptions',
    'DashboardTableCellConditionalFormatting',
    'DashboardTableCellImageSizingConfiguration',
    'DashboardTableCellStyle',
    'DashboardTableConditionalFormatting',
    'DashboardTableConditionalFormattingOption',
    'DashboardTableConfiguration',
    'DashboardTableFieldCustomIconContent',
    'DashboardTableFieldCustomTextContent',
    'DashboardTableFieldImageConfiguration',
    'DashboardTableFieldLinkConfiguration',
    'DashboardTableFieldLinkContentConfiguration',
    'DashboardTableFieldOption',
    'DashboardTableFieldOptions',
    'DashboardTableFieldUrlConfiguration',
    'DashboardTableFieldWells',
    'DashboardTableInlineVisualization',
    'DashboardTableOptions',
    'DashboardTablePaginatedReportOptions',
    'DashboardTablePinnedFieldOptions',
    'DashboardTableRowConditionalFormatting',
    'DashboardTableSideBorderOptions',
    'DashboardTableSortConfiguration',
    'DashboardTableStyleTarget',
    'DashboardTableUnaggregatedFieldWells',
    'DashboardTableVisual',
    'DashboardTag',
    'DashboardTextAreaControlDisplayOptions',
    'DashboardTextConditionalFormat',
    'DashboardTextControlPlaceholderOptions',
    'DashboardTextFieldControlDisplayOptions',
    'DashboardThousandSeparatorOptions',
    'DashboardTimeBasedForecastProperties',
    'DashboardTimeEqualityFilter',
    'DashboardTimeRangeDrillDownFilter',
    'DashboardTimeRangeFilter',
    'DashboardTimeRangeFilterValue',
    'DashboardTooltipItem',
    'DashboardTooltipOptions',
    'DashboardTopBottomFilter',
    'DashboardTopBottomMoversComputation',
    'DashboardTopBottomRankedComputation',
    'DashboardTotalAggregationComputation',
    'DashboardTotalOptions',
    'DashboardTreeMapAggregatedFieldWells',
    'DashboardTreeMapConfiguration',
    'DashboardTreeMapFieldWells',
    'DashboardTreeMapSortConfiguration',
    'DashboardTreeMapVisual',
    'DashboardTrendArrowOptions',
    'DashboardUnaggregatedField',
    'DashboardUniqueValuesComputation',
    'DashboardVersion',
    'DashboardVersionDefinition',
    'DashboardVisibleRangeOptions',
    'DashboardVisual',
    'DashboardVisualAxisSortOption',
    'DashboardVisualCustomAction',
    'DashboardVisualCustomActionOperation',
    'DashboardVisualMenuOption',
    'DashboardVisualPalette',
    'DashboardVisualPublishOptions',
    'DashboardVisualSubtitleLabelOptions',
    'DashboardVisualTitleLabelOptions',
    'DashboardWaterfallChartAggregatedFieldWells',
    'DashboardWaterfallChartConfiguration',
    'DashboardWaterfallChartFieldWells',
    'DashboardWaterfallChartOptions',
    'DashboardWaterfallChartSortConfiguration',
    'DashboardWaterfallVisual',
    'DashboardWhatIfPointScenario',
    'DashboardWhatIfRangeScenario',
    'DashboardWordCloudAggregatedFieldWells',
    'DashboardWordCloudChartConfiguration',
    'DashboardWordCloudFieldWells',
    'DashboardWordCloudOptions',
    'DashboardWordCloudSortConfiguration',
    'DashboardWordCloudVisual',
    'DataSetColumnGroup',
    'DataSetColumnLevelPermissionRule',
    'DataSetDatasetParameter',
    'DataSetDateTimeDatasetParameter',
    'DataSetDateTimeDatasetParameterDefaultValues',
    'DataSetDecimalDatasetParameter',
    'DataSetDecimalDatasetParameterDefaultValues',
    'DataSetFieldFolderMap',
    'DataSetGeoSpatialColumnGroup',
    'DataSetIncrementalRefresh',
    'DataSetIngestionWaitPolicy',
    'DataSetIntegerDatasetParameter',
    'DataSetIntegerDatasetParameterDefaultValues',
    'DataSetLogicalTableMap',
    'DataSetLookbackWindow',
    'DataSetOutputColumn',
    'DataSetPhysicalTableMap',
    'DataSetRefreshConfiguration',
    'DataSetRefreshProperties',
    'DataSetResourcePermission',
    'DataSetRowLevelPermissionDataSet',
    'DataSetRowLevelPermissionTagConfiguration',
    'DataSetRowLevelPermissionTagRule',
    'DataSetStringDatasetParameter',
    'DataSetStringDatasetParameterDefaultValues',
    'DataSetTag',
    'DataSetUsageConfiguration',
    'DataSourceAmazonElasticsearchParameters',
    'DataSourceAmazonOpenSearchParameters',
    'DataSourceAthenaParameters',
    'DataSourceAuroraParameters',
    'DataSourceAuroraPostgreSqlParameters',
    'DataSourceCredentialPair',
    'DataSourceCredentials',
    'DataSourceDatabricksParameters',
    'DataSourceErrorInfo',
    'DataSourceManifestFileLocation',
    'DataSourceMariaDbParameters',
    'DataSourceMySqlParameters',
    'DataSourceOracleParameters',
    'DataSourceParameters',
    'DataSourcePostgreSqlParameters',
    'DataSourcePrestoParameters',
    'DataSourceRdsParameters',
    'DataSourceRedshiftParameters',
    'DataSourceResourcePermission',
    'DataSourceS3Parameters',
    'DataSourceSnowflakeParameters',
    'DataSourceSparkParameters',
    'DataSourceSqlServerParameters',
    'DataSourceSslProperties',
    'DataSourceTag',
    'DataSourceTeradataParameters',
    'DataSourceVpcConnectionProperties',
    'RefreshScheduleMap',
    'RefreshScheduleMapScheduleFrequencyProperties',
    'RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayProperties',
    'TemplateAggregationFunction',
    'TemplateAggregationSortConfiguration',
    'TemplateAllSheetsFilterScopeConfiguration',
    'TemplateAnalysisDefaults',
    'TemplateAnchorDateConfiguration',
    'TemplateArcAxisConfiguration',
    'TemplateArcAxisDisplayRange',
    'TemplateArcConfiguration',
    'TemplateArcOptions',
    'TemplateAttributeAggregationFunction',
    'TemplateAxisDataOptions',
    'TemplateAxisDisplayDataDrivenRange',
    'TemplateAxisDisplayMinMaxRange',
    'TemplateAxisDisplayOptions',
    'TemplateAxisDisplayRange',
    'TemplateAxisLabelOptions',
    'TemplateAxisLabelReferenceOptions',
    'TemplateAxisLinearScale',
    'TemplateAxisLogarithmicScale',
    'TemplateAxisScale',
    'TemplateAxisTickLabelOptions',
    'TemplateBarChartAggregatedFieldWells',
    'TemplateBarChartConfiguration',
    'TemplateBarChartFieldWells',
    'TemplateBarChartSortConfiguration',
    'TemplateBarChartVisual',
    'TemplateBinCountOptions',
    'TemplateBinWidthOptions',
    'TemplateBodySectionConfiguration',
    'TemplateBodySectionContent',
    'TemplateBoxPlotAggregatedFieldWells',
    'TemplateBoxPlotChartConfiguration',
    'TemplateBoxPlotFieldWells',
    'TemplateBoxPlotOptions',
    'TemplateBoxPlotSortConfiguration',
    'TemplateBoxPlotStyleOptions',
    'TemplateBoxPlotVisual',
    'TemplateCalculatedField',
    'TemplateCalculatedMeasureField',
    'TemplateCascadingControlConfiguration',
    'TemplateCascadingControlSource',
    'TemplateCategoricalDimensionField',
    'TemplateCategoricalMeasureField',
    'TemplateCategoryDrillDownFilter',
    'TemplateCategoryFilter',
    'TemplateCategoryFilterConfiguration',
    'TemplateChartAxisLabelOptions',
    'TemplateClusterMarker',
    'TemplateClusterMarkerConfiguration',
    'TemplateColorScale',
    'TemplateColorsConfiguration',
    'TemplateColumnConfiguration',
    'TemplateColumnGroupColumnSchema',
    'TemplateColumnGroupSchema',
    'TemplateColumnHierarchy',
    'TemplateColumnIdentifier',
    'TemplateColumnSchema',
    'TemplateColumnSort',
    'TemplateColumnTooltipItem',
    'TemplateComboChartAggregatedFieldWells',
    'TemplateComboChartConfiguration',
    'TemplateComboChartFieldWells',
    'TemplateComboChartSortConfiguration',
    'TemplateComboChartVisual',
    'TemplateComparisonConfiguration',
    'TemplateComparisonFormatConfiguration',
    'TemplateComputation',
    'TemplateConditionalFormattingColor',
    'TemplateConditionalFormattingCustomIconCondition',
    'TemplateConditionalFormattingCustomIconOptions',
    'TemplateConditionalFormattingGradientColor',
    'TemplateConditionalFormattingIcon',
    'TemplateConditionalFormattingIconDisplayConfiguration',
    'TemplateConditionalFormattingIconSet',
    'TemplateConditionalFormattingSolidColor',
    'TemplateContributionAnalysisDefault',
    'TemplateCurrencyDisplayFormatConfiguration',
    'TemplateCustomActionFilterOperation',
    'TemplateCustomActionNavigationOperation',
    'TemplateCustomActionSetParametersOperation',
    'TemplateCustomActionUrlOperation',
    'TemplateCustomColor',
    'TemplateCustomContentConfiguration',
    'TemplateCustomContentVisual',
    'TemplateCustomFilterConfiguration',
    'TemplateCustomFilterListConfiguration',
    'TemplateCustomNarrativeOptions',
    'TemplateCustomParameterValues',
    'TemplateCustomValuesConfiguration',
    'TemplateDataBarsOptions',
    'TemplateDataColor',
    'TemplateDataFieldSeriesItem',
    'TemplateDataLabelOptions',
    'TemplateDataLabelType',
    'TemplateDataPathColor',
    'TemplateDataPathLabelType',
    'TemplateDataPathSort',
    'TemplateDataPathValue',
    'TemplateDataSetConfiguration',
    'TemplateDataSetReference',
    'TemplateDataSetSchema',
    'TemplateDateAxisOptions',
    'TemplateDateDimensionField',
    'TemplateDateMeasureField',
    'TemplateDateTimeDefaultValues',
    'TemplateDateTimeFormatConfiguration',
    'TemplateDateTimeHierarchy',
    'TemplateDateTimeParameterDeclaration',
    'TemplateDateTimePickerControlDisplayOptions',
    'TemplateDateTimeValueWhenUnsetConfiguration',
    'TemplateDecimalDefaultValues',
    'TemplateDecimalParameterDeclaration',
    'TemplateDecimalPlacesConfiguration',
    'TemplateDecimalValueWhenUnsetConfiguration',
    'TemplateDefaultFreeFormLayoutConfiguration',
    'TemplateDefaultGridLayoutConfiguration',
    'TemplateDefaultInteractiveLayoutConfiguration',
    'TemplateDefaultNewSheetConfiguration',
    'TemplateDefaultPaginatedLayoutConfiguration',
    'TemplateDefaultSectionBasedLayoutConfiguration',
    'TemplateDestinationParameterValueConfiguration',
    'TemplateDimensionField',
    'TemplateDonutCenterOptions',
    'TemplateDonutOptions',
    'TemplateDrillDownFilter',
    'TemplateDropDownControlDisplayOptions',
    'TemplateDynamicDefaultValue',
    'TemplateEmptyVisual',
    'TemplateEntity',
    'TemplateError',
    'TemplateExcludePeriodConfiguration',
    'TemplateExplicitHierarchy',
    'TemplateFieldBasedTooltip',
    'TemplateFieldLabelType',
    'TemplateFieldSeriesItem',
    'TemplateFieldSort',
    'TemplateFieldSortOptions',
    'TemplateFieldTooltipItem',
    'TemplateFilledMapAggregatedFieldWells',
    'TemplateFilledMapConditionalFormatting',
    'TemplateFilledMapConditionalFormattingOption',
    'TemplateFilledMapConfiguration',
    'TemplateFilledMapFieldWells',
    'TemplateFilledMapShapeConditionalFormatting',
    'TemplateFilledMapSortConfiguration',
    'TemplateFilledMapVisual',
    'TemplateFilter',
    'TemplateFilterControl',
    'TemplateFilterDateTimePickerControl',
    'TemplateFilterDropDownControl',
    'TemplateFilterGroup',
    'TemplateFilterListConfiguration',
    'TemplateFilterListControl',
    'TemplateFilterOperationSelectedFieldsConfiguration',
    'TemplateFilterOperationTargetVisualsConfiguration',
    'TemplateFilterRelativeDateTimeControl',
    'TemplateFilterScopeConfiguration',
    'TemplateFilterSelectableValues',
    'TemplateFilterSliderControl',
    'TemplateFilterTextAreaControl',
    'TemplateFilterTextFieldControl',
    'TemplateFontConfiguration',
    'TemplateFontSize',
    'TemplateFontWeight',
    'TemplateForecastComputation',
    'TemplateForecastConfiguration',
    'TemplateForecastScenario',
    'TemplateFormatConfiguration',
    'TemplateFreeFormLayoutCanvasSizeOptions',
    'TemplateFreeFormLayoutConfiguration',
    'TemplateFreeFormLayoutElement',
    'TemplateFreeFormLayoutElementBackgroundStyle',
    'TemplateFreeFormLayoutElementBorderStyle',
    'TemplateFreeFormLayoutScreenCanvasSizeOptions',
    'TemplateFreeFormSectionLayoutConfiguration',
    'TemplateFunnelChartAggregatedFieldWells',
    'TemplateFunnelChartConfiguration',
    'TemplateFunnelChartDataLabelOptions',
    'TemplateFunnelChartFieldWells',
    'TemplateFunnelChartSortConfiguration',
    'TemplateFunnelChartVisual',
    'TemplateGaugeChartArcConditionalFormatting',
    'TemplateGaugeChartConditionalFormatting',
    'TemplateGaugeChartConditionalFormattingOption',
    'TemplateGaugeChartConfiguration',
    'TemplateGaugeChartFieldWells',
    'TemplateGaugeChartOptions',
    'TemplateGaugeChartPrimaryValueConditionalFormatting',
    'TemplateGaugeChartVisual',
    'TemplateGeospatialCoordinateBounds',
    'TemplateGeospatialHeatmapColorScale',
    'TemplateGeospatialHeatmapConfiguration',
    'TemplateGeospatialHeatmapDataColor',
    'TemplateGeospatialMapAggregatedFieldWells',
    'TemplateGeospatialMapConfiguration',
    'TemplateGeospatialMapFieldWells',
    'TemplateGeospatialMapStyleOptions',
    'TemplateGeospatialMapVisual',
    'TemplateGeospatialPointStyleOptions',
    'TemplateGeospatialWindowOptions',
    'TemplateGlobalTableBorderOptions',
    'TemplateGradientColor',
    'TemplateGradientStop',
    'TemplateGridLayoutCanvasSizeOptions',
    'TemplateGridLayoutConfiguration',
    'TemplateGridLayoutElement',
    'TemplateGridLayoutScreenCanvasSizeOptions',
    'TemplateGrowthRateComputation',
    'TemplateHeaderFooterSectionConfiguration',
    'TemplateHeatMapAggregatedFieldWells',
    'TemplateHeatMapConfiguration',
    'TemplateHeatMapFieldWells',
    'TemplateHeatMapSortConfiguration',
    'TemplateHeatMapVisual',
    'TemplateHistogramAggregatedFieldWells',
    'TemplateHistogramBinOptions',
    'TemplateHistogramConfiguration',
    'TemplateHistogramFieldWells',
    'TemplateHistogramVisual',
    'TemplateInsightConfiguration',
    'TemplateInsightVisual',
    'TemplateIntegerDefaultValues',
    'TemplateIntegerParameterDeclaration',
    'TemplateIntegerValueWhenUnsetConfiguration',
    'TemplateItemsLimitConfiguration',
    'TemplateKpiActualValueConditionalFormatting',
    'TemplateKpiComparisonValueConditionalFormatting',
    'TemplateKpiConditionalFormatting',
    'TemplateKpiConditionalFormattingOption',
    'TemplateKpiConfiguration',
    'TemplateKpiFieldWells',
    'TemplateKpiOptions',
    'TemplateKpiPrimaryValueConditionalFormatting',
    'TemplateKpiProgressBarConditionalFormatting',
    'TemplateKpiSortConfiguration',
    'TemplateKpiSparklineOptions',
    'TemplateKpiVisual',
    'TemplateKpiVisualLayoutOptions',
    'TemplateKpiVisualStandardLayout',
    'TemplateLabelOptions',
    'TemplateLayout',
    'TemplateLayoutConfiguration',
    'TemplateLegendOptions',
    'TemplateLineChartAggregatedFieldWells',
    'TemplateLineChartConfiguration',
    'TemplateLineChartDefaultSeriesSettings',
    'TemplateLineChartFieldWells',
    'TemplateLineChartLineStyleSettings',
    'TemplateLineChartMarkerStyleSettings',
    'TemplateLineChartSeriesSettings',
    'TemplateLineChartSortConfiguration',
    'TemplateLineChartVisual',
    'TemplateLineSeriesAxisDisplayOptions',
    'TemplateListControlDisplayOptions',
    'TemplateListControlSearchOptions',
    'TemplateListControlSelectAllOptions',
    'TemplateLoadingAnimation',
    'TemplateLocalNavigationConfiguration',
    'TemplateLongFormatText',
    'TemplateMappedDataSetParameter',
    'TemplateMaximumLabelType',
    'TemplateMaximumMinimumComputation',
    'TemplateMeasureField',
    'TemplateMetricComparisonComputation',
    'TemplateMinimumLabelType',
    'TemplateMissingDataConfiguration',
    'TemplateNegativeValueConfiguration',
    'TemplateNullValueFormatConfiguration',
    'TemplateNumberDisplayFormatConfiguration',
    'TemplateNumberFormatConfiguration',
    'TemplateNumericAxisOptions',
    'TemplateNumericEqualityDrillDownFilter',
    'TemplateNumericEqualityFilter',
    'TemplateNumericFormatConfiguration',
    'TemplateNumericRangeFilter',
    'TemplateNumericRangeFilterValue',
    'TemplateNumericSeparatorConfiguration',
    'TemplateNumericalAggregationFunction',
    'TemplateNumericalDimensionField',
    'TemplateNumericalMeasureField',
    'TemplatePaginationConfiguration',
    'TemplatePanelConfiguration',
    'TemplatePanelTitleOptions',
    'TemplateParameterControl',
    'TemplateParameterDateTimePickerControl',
    'TemplateParameterDeclaration',
    'TemplateParameterDropDownControl',
    'TemplateParameterListControl',
    'TemplateParameterSelectableValues',
    'TemplateParameterSliderControl',
    'TemplateParameterTextAreaControl',
    'TemplateParameterTextFieldControl',
    'TemplatePercentVisibleRange',
    'TemplatePercentageDisplayFormatConfiguration',
    'TemplatePercentileAggregation',
    'TemplatePeriodOverPeriodComputation',
    'TemplatePeriodToDateComputation',
    'TemplatePieChartAggregatedFieldWells',
    'TemplatePieChartConfiguration',
    'TemplatePieChartFieldWells',
    'TemplatePieChartSortConfiguration',
    'TemplatePieChartVisual',
    'TemplatePivotFieldSortOptions',
    'TemplatePivotTableAggregatedFieldWells',
    'TemplatePivotTableCellConditionalFormatting',
    'TemplatePivotTableConditionalFormatting',
    'TemplatePivotTableConditionalFormattingOption',
    'TemplatePivotTableConditionalFormattingScope',
    'TemplatePivotTableConfiguration',
    'TemplatePivotTableDataPathOption',
    'TemplatePivotTableFieldCollapseStateOption',
    'TemplatePivotTableFieldCollapseStateTarget',
    'TemplatePivotTableFieldOption',
    'TemplatePivotTableFieldOptions',
    'TemplatePivotTableFieldSubtotalOptions',
    'TemplatePivotTableFieldWells',
    'TemplatePivotTableOptions',
    'TemplatePivotTablePaginatedReportOptions',
    'TemplatePivotTableRowsLabelOptions',
    'TemplatePivotTableSortBy',
    'TemplatePivotTableSortConfiguration',
    'TemplatePivotTableTotalOptions',
    'TemplatePivotTableVisual',
    'TemplatePivotTotalOptions',
    'TemplatePredefinedHierarchy',
    'TemplateProgressBarOptions',
    'TemplateRadarChartAggregatedFieldWells',
    'TemplateRadarChartAreaStyleSettings',
    'TemplateRadarChartConfiguration',
    'TemplateRadarChartFieldWells',
    'TemplateRadarChartSeriesSettings',
    'TemplateRadarChartSortConfiguration',
    'TemplateRadarChartVisual',
    'TemplateRangeEndsLabelType',
    'TemplateReferenceLine',
    'TemplateReferenceLineCustomLabelConfiguration',
    'TemplateReferenceLineDataConfiguration',
    'TemplateReferenceLineDynamicDataConfiguration',
    'TemplateReferenceLineLabelConfiguration',
    'TemplateReferenceLineStaticDataConfiguration',
    'TemplateReferenceLineStyleConfiguration',
    'TemplateReferenceLineValueLabelConfiguration',
    'TemplateRelativeDateTimeControlDisplayOptions',
    'TemplateRelativeDatesFilter',
    'TemplateResourcePermission',
    'TemplateRollingDateConfiguration',
    'TemplateRowAlternateColorOptions',
    'TemplateSameSheetTargetVisualConfiguration',
    'TemplateSankeyDiagramAggregatedFieldWells',
    'TemplateSankeyDiagramChartConfiguration',
    'TemplateSankeyDiagramFieldWells',
    'TemplateSankeyDiagramSortConfiguration',
    'TemplateSankeyDiagramVisual',
    'TemplateScatterPlotCategoricallyAggregatedFieldWells',
    'TemplateScatterPlotConfiguration',
    'TemplateScatterPlotFieldWells',
    'TemplateScatterPlotUnaggregatedFieldWells',
    'TemplateScatterPlotVisual',
    'TemplateScrollBarOptions',
    'TemplateSecondaryValueOptions',
    'TemplateSectionAfterPageBreak',
    'TemplateSectionBasedLayoutCanvasSizeOptions',
    'TemplateSectionBasedLayoutConfiguration',
    'TemplateSectionBasedLayoutPaperCanvasSizeOptions',
    'TemplateSectionLayoutConfiguration',
    'TemplateSectionPageBreakConfiguration',
    'TemplateSectionStyle',
    'TemplateSelectedSheetsFilterScopeConfiguration',
    'TemplateSeriesItem',
    'TemplateSetParameterValueConfiguration',
    'TemplateShapeConditionalFormat',
    'TemplateSheet',
    'TemplateSheetControlInfoIconLabelOptions',
    'TemplateSheetControlLayout',
    'TemplateSheetControlLayoutConfiguration',
    'TemplateSheetDefinition',
    'TemplateSheetElementConfigurationOverrides',
    'TemplateSheetElementRenderingRule',
    'TemplateSheetTextBox',
    'TemplateSheetVisualScopingConfiguration',
    'TemplateShortFormatText',
    'TemplateSimpleClusterMarker',
    'TemplateSliderControlDisplayOptions',
    'TemplateSmallMultiplesAxisProperties',
    'TemplateSmallMultiplesOptions',
    'TemplateSourceAnalysis',
    'TemplateSourceEntity',
    'TemplateSourceTemplate',
    'TemplateSpacing',
    'TemplateStringDefaultValues',
    'TemplateStringFormatConfiguration',
    'TemplateStringParameterDeclaration',
    'TemplateStringValueWhenUnsetConfiguration',
    'TemplateSubtotalOptions',
    'TemplateTableAggregatedFieldWells',
    'TemplateTableBorderOptions',
    'TemplateTableCellConditionalFormatting',
    'TemplateTableCellImageSizingConfiguration',
    'TemplateTableCellStyle',
    'TemplateTableConditionalFormatting',
    'TemplateTableConditionalFormattingOption',
    'TemplateTableConfiguration',
    'TemplateTableFieldCustomIconContent',
    'TemplateTableFieldCustomTextContent',
    'TemplateTableFieldImageConfiguration',
    'TemplateTableFieldLinkConfiguration',
    'TemplateTableFieldLinkContentConfiguration',
    'TemplateTableFieldOption',
    'TemplateTableFieldOptions',
    'TemplateTableFieldUrlConfiguration',
    'TemplateTableFieldWells',
    'TemplateTableInlineVisualization',
    'TemplateTableOptions',
    'TemplateTablePaginatedReportOptions',
    'TemplateTablePinnedFieldOptions',
    'TemplateTableRowConditionalFormatting',
    'TemplateTableSideBorderOptions',
    'TemplateTableSortConfiguration',
    'TemplateTableStyleTarget',
    'TemplateTableUnaggregatedFieldWells',
    'TemplateTableVisual',
    'TemplateTag',
    'TemplateTextAreaControlDisplayOptions',
    'TemplateTextConditionalFormat',
    'TemplateTextControlPlaceholderOptions',
    'TemplateTextFieldControlDisplayOptions',
    'TemplateThousandSeparatorOptions',
    'TemplateTimeBasedForecastProperties',
    'TemplateTimeEqualityFilter',
    'TemplateTimeRangeDrillDownFilter',
    'TemplateTimeRangeFilter',
    'TemplateTimeRangeFilterValue',
    'TemplateTooltipItem',
    'TemplateTooltipOptions',
    'TemplateTopBottomFilter',
    'TemplateTopBottomMoversComputation',
    'TemplateTopBottomRankedComputation',
    'TemplateTotalAggregationComputation',
    'TemplateTotalOptions',
    'TemplateTreeMapAggregatedFieldWells',
    'TemplateTreeMapConfiguration',
    'TemplateTreeMapFieldWells',
    'TemplateTreeMapSortConfiguration',
    'TemplateTreeMapVisual',
    'TemplateTrendArrowOptions',
    'TemplateUnaggregatedField',
    'TemplateUniqueValuesComputation',
    'TemplateVersion',
    'TemplateVersionDefinition',
    'TemplateVisibleRangeOptions',
    'TemplateVisual',
    'TemplateVisualCustomAction',
    'TemplateVisualCustomActionOperation',
    'TemplateVisualPalette',
    'TemplateVisualSubtitleLabelOptions',
    'TemplateVisualTitleLabelOptions',
    'TemplateWaterfallChartAggregatedFieldWells',
    'TemplateWaterfallChartConfiguration',
    'TemplateWaterfallChartFieldWells',
    'TemplateWaterfallChartOptions',
    'TemplateWaterfallChartSortConfiguration',
    'TemplateWaterfallVisual',
    'TemplateWhatIfPointScenario',
    'TemplateWhatIfRangeScenario',
    'TemplateWordCloudAggregatedFieldWells',
    'TemplateWordCloudChartConfiguration',
    'TemplateWordCloudFieldWells',
    'TemplateWordCloudOptions',
    'TemplateWordCloudSortConfiguration',
    'TemplateWordCloudVisual',
    'ThemeBorderStyle',
    'ThemeConfiguration',
    'ThemeDataColorPalette',
    'ThemeError',
    'ThemeFont',
    'ThemeGutterStyle',
    'ThemeMarginStyle',
    'ThemeResourcePermission',
    'ThemeSheetStyle',
    'ThemeTag',
    'ThemeTileLayoutStyle',
    'ThemeTileStyle',
    'ThemeTypography',
    'ThemeUiColorPalette',
    'ThemeVersion',
    'TopicAggregationFunctionParameters',
    'TopicCalculatedField',
    'TopicCategoryFilter',
    'TopicCategoryFilterConstant',
    'TopicCellValueSynonym',
    'TopicCollectiveConstant',
    'TopicColumn',
    'TopicComparativeOrder',
    'TopicDataAggregation',
    'TopicDatasetMetadata',
    'TopicDateRangeFilter',
    'TopicDefaultFormatting',
    'TopicDisplayFormatOptions',
    'TopicFilter',
    'TopicNamedEntity',
    'TopicNamedEntityDefinition',
    'TopicNamedEntityDefinitionMetric',
    'TopicNegativeFormat',
    'TopicNumericEqualityFilter',
    'TopicNumericRangeFilter',
    'TopicRangeConstant',
    'TopicRangeFilterConstant',
    'TopicRelativeDateFilter',
    'TopicSemanticEntityType',
    'TopicSemanticType',
    'TopicSingularFilterConstant',
    'TopicTypeParameters',
    'VpcConnectionNetworkInterface',
    'VpcConnectionTag',
]

@pulumi.output_type
class AnalysisAggregationFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeAggregationFunction":
            suggest = "attribute_aggregation_function"
        elif key == "categoricalAggregationFunction":
            suggest = "categorical_aggregation_function"
        elif key == "dateAggregationFunction":
            suggest = "date_aggregation_function"
        elif key == "numericalAggregationFunction":
            suggest = "numerical_aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisAggregationFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisAggregationFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisAggregationFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_aggregation_function: Optional['outputs.AnalysisAttributeAggregationFunction'] = None,
                 categorical_aggregation_function: Optional['AnalysisCategoricalAggregationFunction'] = None,
                 date_aggregation_function: Optional['AnalysisDateAggregationFunction'] = None,
                 numerical_aggregation_function: Optional['outputs.AnalysisNumericalAggregationFunction'] = None):
        AnalysisAggregationFunction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_aggregation_function=attribute_aggregation_function,
            categorical_aggregation_function=categorical_aggregation_function,
            date_aggregation_function=date_aggregation_function,
            numerical_aggregation_function=numerical_aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_aggregation_function: Optional['outputs.AnalysisAttributeAggregationFunction'] = None,
             categorical_aggregation_function: Optional['AnalysisCategoricalAggregationFunction'] = None,
             date_aggregation_function: Optional['AnalysisDateAggregationFunction'] = None,
             numerical_aggregation_function: Optional['outputs.AnalysisNumericalAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attribute_aggregation_function is not None:
            _setter("attribute_aggregation_function", attribute_aggregation_function)
        if categorical_aggregation_function is not None:
            _setter("categorical_aggregation_function", categorical_aggregation_function)
        if date_aggregation_function is not None:
            _setter("date_aggregation_function", date_aggregation_function)
        if numerical_aggregation_function is not None:
            _setter("numerical_aggregation_function", numerical_aggregation_function)

    @property
    @pulumi.getter(name="attributeAggregationFunction")
    def attribute_aggregation_function(self) -> Optional['outputs.AnalysisAttributeAggregationFunction']:
        return pulumi.get(self, "attribute_aggregation_function")

    @property
    @pulumi.getter(name="categoricalAggregationFunction")
    def categorical_aggregation_function(self) -> Optional['AnalysisCategoricalAggregationFunction']:
        return pulumi.get(self, "categorical_aggregation_function")

    @property
    @pulumi.getter(name="dateAggregationFunction")
    def date_aggregation_function(self) -> Optional['AnalysisDateAggregationFunction']:
        return pulumi.get(self, "date_aggregation_function")

    @property
    @pulumi.getter(name="numericalAggregationFunction")
    def numerical_aggregation_function(self) -> Optional['outputs.AnalysisNumericalAggregationFunction']:
        return pulumi.get(self, "numerical_aggregation_function")


@pulumi.output_type
class AnalysisAggregationSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortDirection":
            suggest = "sort_direction"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisAggregationSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisAggregationSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisAggregationSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 sort_direction: 'AnalysisSortDirection',
                 aggregation_function: Optional['outputs.AnalysisAggregationFunction'] = None):
        AnalysisAggregationSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            sort_direction=sort_direction,
            aggregation_function=aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             sort_direction: 'AnalysisSortDirection',
             aggregation_function: Optional['outputs.AnalysisAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("sort_direction", sort_direction)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="sortDirection")
    def sort_direction(self) -> 'AnalysisSortDirection':
        return pulumi.get(self, "sort_direction")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.AnalysisAggregationFunction']:
        return pulumi.get(self, "aggregation_function")


@pulumi.output_type
class AnalysisAllSheetsFilterScopeConfiguration(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class AnalysisAnchorDateConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anchorOption":
            suggest = "anchor_option"
        elif key == "parameterName":
            suggest = "parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisAnchorDateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisAnchorDateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisAnchorDateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anchor_option: Optional['AnalysisAnchorOption'] = None,
                 parameter_name: Optional[str] = None):
        AnalysisAnchorDateConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            anchor_option=anchor_option,
            parameter_name=parameter_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             anchor_option: Optional['AnalysisAnchorOption'] = None,
             parameter_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if anchor_option is not None:
            _setter("anchor_option", anchor_option)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)

    @property
    @pulumi.getter(name="anchorOption")
    def anchor_option(self) -> Optional['AnalysisAnchorOption']:
        return pulumi.get(self, "anchor_option")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")


@pulumi.output_type
class AnalysisArcAxisConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reserveRange":
            suggest = "reserve_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisArcAxisConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisArcAxisConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisArcAxisConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range: Optional['outputs.AnalysisArcAxisDisplayRange'] = None,
                 reserve_range: Optional[float] = None):
        AnalysisArcAxisConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            range=range,
            reserve_range=reserve_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             range: Optional['outputs.AnalysisArcAxisDisplayRange'] = None,
             reserve_range: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if range is not None:
            _setter("range", range)
        if reserve_range is not None:
            _setter("reserve_range", reserve_range)

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.AnalysisArcAxisDisplayRange']:
        return pulumi.get(self, "range")

    @property
    @pulumi.getter(name="reserveRange")
    def reserve_range(self) -> Optional[float]:
        return pulumi.get(self, "reserve_range")


@pulumi.output_type
class AnalysisArcAxisDisplayRange(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        AnalysisArcAxisDisplayRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class AnalysisArcConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcAngle":
            suggest = "arc_angle"
        elif key == "arcThickness":
            suggest = "arc_thickness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisArcConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisArcConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisArcConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc_angle: Optional[float] = None,
                 arc_thickness: Optional['AnalysisArcThicknessOptions'] = None):
        AnalysisArcConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc_angle=arc_angle,
            arc_thickness=arc_thickness,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc_angle: Optional[float] = None,
             arc_thickness: Optional['AnalysisArcThicknessOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc_angle is not None:
            _setter("arc_angle", arc_angle)
        if arc_thickness is not None:
            _setter("arc_thickness", arc_thickness)

    @property
    @pulumi.getter(name="arcAngle")
    def arc_angle(self) -> Optional[float]:
        return pulumi.get(self, "arc_angle")

    @property
    @pulumi.getter(name="arcThickness")
    def arc_thickness(self) -> Optional['AnalysisArcThicknessOptions']:
        return pulumi.get(self, "arc_thickness")


@pulumi.output_type
class AnalysisArcOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcThickness":
            suggest = "arc_thickness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisArcOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisArcOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisArcOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc_thickness: Optional['AnalysisArcThickness'] = None):
        AnalysisArcOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc_thickness=arc_thickness,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc_thickness: Optional['AnalysisArcThickness'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc_thickness is not None:
            _setter("arc_thickness", arc_thickness)

    @property
    @pulumi.getter(name="arcThickness")
    def arc_thickness(self) -> Optional['AnalysisArcThickness']:
        return pulumi.get(self, "arc_thickness")


@pulumi.output_type
class AnalysisAttributeAggregationFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simpleAttributeAggregation":
            suggest = "simple_attribute_aggregation"
        elif key == "valueForMultipleValues":
            suggest = "value_for_multiple_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisAttributeAggregationFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisAttributeAggregationFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisAttributeAggregationFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 simple_attribute_aggregation: Optional['AnalysisSimpleAttributeAggregationFunction'] = None,
                 value_for_multiple_values: Optional[str] = None):
        AnalysisAttributeAggregationFunction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            simple_attribute_aggregation=simple_attribute_aggregation,
            value_for_multiple_values=value_for_multiple_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             simple_attribute_aggregation: Optional['AnalysisSimpleAttributeAggregationFunction'] = None,
             value_for_multiple_values: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if simple_attribute_aggregation is not None:
            _setter("simple_attribute_aggregation", simple_attribute_aggregation)
        if value_for_multiple_values is not None:
            _setter("value_for_multiple_values", value_for_multiple_values)

    @property
    @pulumi.getter(name="simpleAttributeAggregation")
    def simple_attribute_aggregation(self) -> Optional['AnalysisSimpleAttributeAggregationFunction']:
        return pulumi.get(self, "simple_attribute_aggregation")

    @property
    @pulumi.getter(name="valueForMultipleValues")
    def value_for_multiple_values(self) -> Optional[str]:
        return pulumi.get(self, "value_for_multiple_values")


@pulumi.output_type
class AnalysisAxisDataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateAxisOptions":
            suggest = "date_axis_options"
        elif key == "numericAxisOptions":
            suggest = "numeric_axis_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisAxisDataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisAxisDataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisAxisDataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_axis_options: Optional['outputs.AnalysisDateAxisOptions'] = None,
                 numeric_axis_options: Optional['outputs.AnalysisNumericAxisOptions'] = None):
        AnalysisAxisDataOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_axis_options=date_axis_options,
            numeric_axis_options=numeric_axis_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_axis_options: Optional['outputs.AnalysisDateAxisOptions'] = None,
             numeric_axis_options: Optional['outputs.AnalysisNumericAxisOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_axis_options is not None:
            _setter("date_axis_options", date_axis_options)
        if numeric_axis_options is not None:
            _setter("numeric_axis_options", numeric_axis_options)

    @property
    @pulumi.getter(name="dateAxisOptions")
    def date_axis_options(self) -> Optional['outputs.AnalysisDateAxisOptions']:
        return pulumi.get(self, "date_axis_options")

    @property
    @pulumi.getter(name="numericAxisOptions")
    def numeric_axis_options(self) -> Optional['outputs.AnalysisNumericAxisOptions']:
        return pulumi.get(self, "numeric_axis_options")


@pulumi.output_type
class AnalysisAxisDisplayDataDrivenRange(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class AnalysisAxisDisplayMinMaxRange(dict):
    def __init__(__self__, *,
                 maximum: Optional[float] = None,
                 minimum: Optional[float] = None):
        AnalysisAxisDisplayMinMaxRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum=maximum,
            minimum=minimum,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum: Optional[float] = None,
             minimum: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if maximum is not None:
            _setter("maximum", maximum)
        if minimum is not None:
            _setter("minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[float]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[float]:
        return pulumi.get(self, "minimum")


@pulumi.output_type
class AnalysisAxisDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisLineVisibility":
            suggest = "axis_line_visibility"
        elif key == "axisOffset":
            suggest = "axis_offset"
        elif key == "dataOptions":
            suggest = "data_options"
        elif key == "gridLineVisibility":
            suggest = "grid_line_visibility"
        elif key == "scrollbarOptions":
            suggest = "scrollbar_options"
        elif key == "tickLabelOptions":
            suggest = "tick_label_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisAxisDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisAxisDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisAxisDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_line_visibility: Optional['AnalysisVisibility'] = None,
                 axis_offset: Optional[str] = None,
                 data_options: Optional['outputs.AnalysisAxisDataOptions'] = None,
                 grid_line_visibility: Optional['AnalysisVisibility'] = None,
                 scrollbar_options: Optional['outputs.AnalysisScrollBarOptions'] = None,
                 tick_label_options: Optional['outputs.AnalysisAxisTickLabelOptions'] = None):
        """
        :param str axis_offset: String based length that is composed of value and unit in px
        """
        AnalysisAxisDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_line_visibility=axis_line_visibility,
            axis_offset=axis_offset,
            data_options=data_options,
            grid_line_visibility=grid_line_visibility,
            scrollbar_options=scrollbar_options,
            tick_label_options=tick_label_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_line_visibility: Optional['AnalysisVisibility'] = None,
             axis_offset: Optional[str] = None,
             data_options: Optional['outputs.AnalysisAxisDataOptions'] = None,
             grid_line_visibility: Optional['AnalysisVisibility'] = None,
             scrollbar_options: Optional['outputs.AnalysisScrollBarOptions'] = None,
             tick_label_options: Optional['outputs.AnalysisAxisTickLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_line_visibility is not None:
            _setter("axis_line_visibility", axis_line_visibility)
        if axis_offset is not None:
            _setter("axis_offset", axis_offset)
        if data_options is not None:
            _setter("data_options", data_options)
        if grid_line_visibility is not None:
            _setter("grid_line_visibility", grid_line_visibility)
        if scrollbar_options is not None:
            _setter("scrollbar_options", scrollbar_options)
        if tick_label_options is not None:
            _setter("tick_label_options", tick_label_options)

    @property
    @pulumi.getter(name="axisLineVisibility")
    def axis_line_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "axis_line_visibility")

    @property
    @pulumi.getter(name="axisOffset")
    def axis_offset(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "axis_offset")

    @property
    @pulumi.getter(name="dataOptions")
    def data_options(self) -> Optional['outputs.AnalysisAxisDataOptions']:
        return pulumi.get(self, "data_options")

    @property
    @pulumi.getter(name="gridLineVisibility")
    def grid_line_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "grid_line_visibility")

    @property
    @pulumi.getter(name="scrollbarOptions")
    def scrollbar_options(self) -> Optional['outputs.AnalysisScrollBarOptions']:
        return pulumi.get(self, "scrollbar_options")

    @property
    @pulumi.getter(name="tickLabelOptions")
    def tick_label_options(self) -> Optional['outputs.AnalysisAxisTickLabelOptions']:
        return pulumi.get(self, "tick_label_options")


@pulumi.output_type
class AnalysisAxisDisplayRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDriven":
            suggest = "data_driven"
        elif key == "minMax":
            suggest = "min_max"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisAxisDisplayRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisAxisDisplayRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisAxisDisplayRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_driven: Optional['outputs.AnalysisAxisDisplayDataDrivenRange'] = None,
                 min_max: Optional['outputs.AnalysisAxisDisplayMinMaxRange'] = None):
        AnalysisAxisDisplayRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_driven=data_driven,
            min_max=min_max,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_driven: Optional['outputs.AnalysisAxisDisplayDataDrivenRange'] = None,
             min_max: Optional['outputs.AnalysisAxisDisplayMinMaxRange'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_driven is not None:
            _setter("data_driven", data_driven)
        if min_max is not None:
            _setter("min_max", min_max)

    @property
    @pulumi.getter(name="dataDriven")
    def data_driven(self) -> Optional['outputs.AnalysisAxisDisplayDataDrivenRange']:
        return pulumi.get(self, "data_driven")

    @property
    @pulumi.getter(name="minMax")
    def min_max(self) -> Optional['outputs.AnalysisAxisDisplayMinMaxRange']:
        return pulumi.get(self, "min_max")


@pulumi.output_type
class AnalysisAxisLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyTo":
            suggest = "apply_to"
        elif key == "customLabel":
            suggest = "custom_label"
        elif key == "fontConfiguration":
            suggest = "font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisAxisLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisAxisLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisAxisLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_to: Optional['outputs.AnalysisAxisLabelReferenceOptions'] = None,
                 custom_label: Optional[str] = None,
                 font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None):
        AnalysisAxisLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apply_to=apply_to,
            custom_label=custom_label,
            font_configuration=font_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apply_to: Optional['outputs.AnalysisAxisLabelReferenceOptions'] = None,
             custom_label: Optional[str] = None,
             font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apply_to is not None:
            _setter("apply_to", apply_to)
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)

    @property
    @pulumi.getter(name="applyTo")
    def apply_to(self) -> Optional['outputs.AnalysisAxisLabelReferenceOptions']:
        return pulumi.get(self, "apply_to")

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.AnalysisFontConfiguration']:
        return pulumi.get(self, "font_configuration")


@pulumi.output_type
class AnalysisAxisLabelReferenceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisAxisLabelReferenceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisAxisLabelReferenceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisAxisLabelReferenceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 field_id: str):
        AnalysisAxisLabelReferenceOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class AnalysisAxisLinearScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stepCount":
            suggest = "step_count"
        elif key == "stepSize":
            suggest = "step_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisAxisLinearScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisAxisLinearScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisAxisLinearScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 step_count: Optional[float] = None,
                 step_size: Optional[float] = None):
        AnalysisAxisLinearScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            step_count=step_count,
            step_size=step_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             step_count: Optional[float] = None,
             step_size: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if step_count is not None:
            _setter("step_count", step_count)
        if step_size is not None:
            _setter("step_size", step_size)

    @property
    @pulumi.getter(name="stepCount")
    def step_count(self) -> Optional[float]:
        return pulumi.get(self, "step_count")

    @property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> Optional[float]:
        return pulumi.get(self, "step_size")


@pulumi.output_type
class AnalysisAxisLogarithmicScale(dict):
    def __init__(__self__, *,
                 base: Optional[float] = None):
        AnalysisAxisLogarithmicScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base=base,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if base is not None:
            _setter("base", base)

    @property
    @pulumi.getter
    def base(self) -> Optional[float]:
        return pulumi.get(self, "base")


@pulumi.output_type
class AnalysisAxisScale(dict):
    def __init__(__self__, *,
                 linear: Optional['outputs.AnalysisAxisLinearScale'] = None,
                 logarithmic: Optional['outputs.AnalysisAxisLogarithmicScale'] = None):
        AnalysisAxisScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            linear=linear,
            logarithmic=logarithmic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             linear: Optional['outputs.AnalysisAxisLinearScale'] = None,
             logarithmic: Optional['outputs.AnalysisAxisLogarithmicScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if linear is not None:
            _setter("linear", linear)
        if logarithmic is not None:
            _setter("logarithmic", logarithmic)

    @property
    @pulumi.getter
    def linear(self) -> Optional['outputs.AnalysisAxisLinearScale']:
        return pulumi.get(self, "linear")

    @property
    @pulumi.getter
    def logarithmic(self) -> Optional['outputs.AnalysisAxisLogarithmicScale']:
        return pulumi.get(self, "logarithmic")


@pulumi.output_type
class AnalysisAxisTickLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelOptions":
            suggest = "label_options"
        elif key == "rotationAngle":
            suggest = "rotation_angle"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisAxisTickLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisAxisTickLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisAxisTickLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_options: Optional['outputs.AnalysisLabelOptions'] = None,
                 rotation_angle: Optional[float] = None):
        AnalysisAxisTickLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_options=label_options,
            rotation_angle=rotation_angle,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_options: Optional['outputs.AnalysisLabelOptions'] = None,
             rotation_angle: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if label_options is not None:
            _setter("label_options", label_options)
        if rotation_angle is not None:
            _setter("rotation_angle", rotation_angle)

    @property
    @pulumi.getter(name="labelOptions")
    def label_options(self) -> Optional['outputs.AnalysisLabelOptions']:
        return pulumi.get(self, "label_options")

    @property
    @pulumi.getter(name="rotationAngle")
    def rotation_angle(self) -> Optional[float]:
        return pulumi.get(self, "rotation_angle")


@pulumi.output_type
class AnalysisBarChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "smallMultiples":
            suggest = "small_multiples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBarChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBarChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBarChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 colors: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 small_multiples: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisBarChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            colors=colors,
            small_multiples=small_multiples,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             colors: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             small_multiples: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if colors is not None:
            _setter("colors", colors)
        if small_multiples is not None:
            _setter("small_multiples", small_multiples)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="smallMultiples")
    def small_multiples(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "small_multiples")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisBarChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barsArrangement":
            suggest = "bars_arrangement"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "contributionAnalysisDefaults":
            suggest = "contribution_analysis_defaults"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "smallMultiplesOptions":
            suggest = "small_multiples_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "valueAxis":
            suggest = "value_axis"
        elif key == "valueLabelOptions":
            suggest = "value_label_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBarChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBarChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBarChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bars_arrangement: Optional['AnalysisBarsArrangement'] = None,
                 category_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 color_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 contribution_analysis_defaults: Optional[Sequence['outputs.AnalysisContributionAnalysisDefault']] = None,
                 data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisBarChartFieldWells'] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 orientation: Optional['AnalysisBarChartOrientation'] = None,
                 reference_lines: Optional[Sequence['outputs.AnalysisReferenceLine']] = None,
                 small_multiples_options: Optional['outputs.AnalysisSmallMultiplesOptions'] = None,
                 sort_configuration: Optional['outputs.AnalysisBarChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
                 value_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 value_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None):
        AnalysisBarChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bars_arrangement=bars_arrangement,
            category_axis=category_axis,
            category_label_options=category_label_options,
            color_label_options=color_label_options,
            contribution_analysis_defaults=contribution_analysis_defaults,
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            orientation=orientation,
            reference_lines=reference_lines,
            small_multiples_options=small_multiples_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            value_axis=value_axis,
            value_label_options=value_label_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bars_arrangement: Optional['AnalysisBarsArrangement'] = None,
             category_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             color_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             contribution_analysis_defaults: Optional[Sequence['outputs.AnalysisContributionAnalysisDefault']] = None,
             data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisBarChartFieldWells'] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             orientation: Optional['AnalysisBarChartOrientation'] = None,
             reference_lines: Optional[Sequence['outputs.AnalysisReferenceLine']] = None,
             small_multiples_options: Optional['outputs.AnalysisSmallMultiplesOptions'] = None,
             sort_configuration: Optional['outputs.AnalysisBarChartSortConfiguration'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             value_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             value_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bars_arrangement is not None:
            _setter("bars_arrangement", bars_arrangement)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if contribution_analysis_defaults is not None:
            _setter("contribution_analysis_defaults", contribution_analysis_defaults)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if orientation is not None:
            _setter("orientation", orientation)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if small_multiples_options is not None:
            _setter("small_multiples_options", small_multiples_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if value_axis is not None:
            _setter("value_axis", value_axis)
        if value_label_options is not None:
            _setter("value_label_options", value_label_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="barsArrangement")
    def bars_arrangement(self) -> Optional['AnalysisBarsArrangement']:
        return pulumi.get(self, "bars_arrangement")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="contributionAnalysisDefaults")
    def contribution_analysis_defaults(self) -> Optional[Sequence['outputs.AnalysisContributionAnalysisDefault']]:
        return pulumi.get(self, "contribution_analysis_defaults")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisBarChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter
    def orientation(self) -> Optional['AnalysisBarChartOrientation']:
        return pulumi.get(self, "orientation")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.AnalysisReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="smallMultiplesOptions")
    def small_multiples_options(self) -> Optional['outputs.AnalysisSmallMultiplesOptions']:
        return pulumi.get(self, "small_multiples_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisBarChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="valueAxis")
    def value_axis(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "value_axis")

    @property
    @pulumi.getter(name="valueLabelOptions")
    def value_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "value_label_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class AnalysisBarChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barChartAggregatedFieldWells":
            suggest = "bar_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBarChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBarChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBarChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_chart_aggregated_field_wells: Optional['outputs.AnalysisBarChartAggregatedFieldWells'] = None):
        AnalysisBarChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_chart_aggregated_field_wells=bar_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_chart_aggregated_field_wells: Optional['outputs.AnalysisBarChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_chart_aggregated_field_wells is not None:
            _setter("bar_chart_aggregated_field_wells", bar_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="barChartAggregatedFieldWells")
    def bar_chart_aggregated_field_wells(self) -> Optional['outputs.AnalysisBarChartAggregatedFieldWells']:
        return pulumi.get(self, "bar_chart_aggregated_field_wells")


@pulumi.output_type
class AnalysisBarChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimit":
            suggest = "color_items_limit"
        elif key == "colorSort":
            suggest = "color_sort"
        elif key == "smallMultiplesLimitConfiguration":
            suggest = "small_multiples_limit_configuration"
        elif key == "smallMultiplesSort":
            suggest = "small_multiples_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBarChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBarChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBarChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
                 color_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 color_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
                 small_multiples_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 small_multiples_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisBarChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            color_items_limit=color_items_limit,
            color_sort=color_sort,
            small_multiples_limit_configuration=small_multiples_limit_configuration,
            small_multiples_sort=small_multiples_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             color_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             color_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             small_multiples_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             small_multiples_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit is not None:
            _setter("color_items_limit", color_items_limit)
        if color_sort is not None:
            _setter("color_sort", color_sort)
        if small_multiples_limit_configuration is not None:
            _setter("small_multiples_limit_configuration", small_multiples_limit_configuration)
        if small_multiples_sort is not None:
            _setter("small_multiples_sort", small_multiples_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimit")
    def color_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit")

    @property
    @pulumi.getter(name="colorSort")
    def color_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "color_sort")

    @property
    @pulumi.getter(name="smallMultiplesLimitConfiguration")
    def small_multiples_limit_configuration(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "small_multiples_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesSort")
    def small_multiples_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "small_multiples_sort")


@pulumi.output_type
class AnalysisBarChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBarChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBarChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBarChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisBarChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisBarChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisBarChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisBarChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisBinCountOptions(dict):
    def __init__(__self__, *,
                 value: Optional[float] = None):
        AnalysisBinCountOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisBinWidthOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binCountLimit":
            suggest = "bin_count_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBinWidthOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBinWidthOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBinWidthOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bin_count_limit: Optional[float] = None,
                 value: Optional[float] = None):
        AnalysisBinWidthOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bin_count_limit=bin_count_limit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bin_count_limit: Optional[float] = None,
             value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bin_count_limit is not None:
            _setter("bin_count_limit", bin_count_limit)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="binCountLimit")
    def bin_count_limit(self) -> Optional[float]:
        return pulumi.get(self, "bin_count_limit")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisBodySectionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionId":
            suggest = "section_id"
        elif key == "pageBreakConfiguration":
            suggest = "page_break_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBodySectionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBodySectionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBodySectionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: 'outputs.AnalysisBodySectionContent',
                 section_id: str,
                 page_break_configuration: Optional['outputs.AnalysisSectionPageBreakConfiguration'] = None,
                 style: Optional['outputs.AnalysisSectionStyle'] = None):
        AnalysisBodySectionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            section_id=section_id,
            page_break_configuration=page_break_configuration,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: 'outputs.AnalysisBodySectionContent',
             section_id: str,
             page_break_configuration: Optional['outputs.AnalysisSectionPageBreakConfiguration'] = None,
             style: Optional['outputs.AnalysisSectionStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        _setter("section_id", section_id)
        if page_break_configuration is not None:
            _setter("page_break_configuration", page_break_configuration)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter
    def content(self) -> 'outputs.AnalysisBodySectionContent':
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="sectionId")
    def section_id(self) -> str:
        return pulumi.get(self, "section_id")

    @property
    @pulumi.getter(name="pageBreakConfiguration")
    def page_break_configuration(self) -> Optional['outputs.AnalysisSectionPageBreakConfiguration']:
        return pulumi.get(self, "page_break_configuration")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.AnalysisSectionStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class AnalysisBodySectionContent(dict):
    def __init__(__self__, *,
                 layout: Optional['outputs.AnalysisSectionLayoutConfiguration'] = None):
        AnalysisBodySectionContent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            layout=layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             layout: Optional['outputs.AnalysisSectionLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if layout is not None:
            _setter("layout", layout)

    @property
    @pulumi.getter
    def layout(self) -> Optional['outputs.AnalysisSectionLayoutConfiguration']:
        return pulumi.get(self, "layout")


@pulumi.output_type
class AnalysisBoxPlotAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBoxPlotAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBoxPlotAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBoxPlotAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_by: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisBoxPlotAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_by=group_by,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_by: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_by is not None:
            _setter("group_by", group_by)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisBoxPlotChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boxPlotOptions":
            suggest = "box_plot_options"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBoxPlotChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBoxPlotChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBoxPlotChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 box_plot_options: Optional['outputs.AnalysisBoxPlotOptions'] = None,
                 category_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisBoxPlotFieldWells'] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 reference_lines: Optional[Sequence['outputs.AnalysisReferenceLine']] = None,
                 sort_configuration: Optional['outputs.AnalysisBoxPlotSortConfiguration'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None):
        AnalysisBoxPlotChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            box_plot_options=box_plot_options,
            category_axis=category_axis,
            category_label_options=category_label_options,
            field_wells=field_wells,
            legend=legend,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            reference_lines=reference_lines,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             box_plot_options: Optional['outputs.AnalysisBoxPlotOptions'] = None,
             category_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisBoxPlotFieldWells'] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             reference_lines: Optional[Sequence['outputs.AnalysisReferenceLine']] = None,
             sort_configuration: Optional['outputs.AnalysisBoxPlotSortConfiguration'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if box_plot_options is not None:
            _setter("box_plot_options", box_plot_options)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="boxPlotOptions")
    def box_plot_options(self) -> Optional['outputs.AnalysisBoxPlotOptions']:
        return pulumi.get(self, "box_plot_options")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisBoxPlotFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.AnalysisReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisBoxPlotSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class AnalysisBoxPlotFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boxPlotAggregatedFieldWells":
            suggest = "box_plot_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBoxPlotFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBoxPlotFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBoxPlotFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 box_plot_aggregated_field_wells: Optional['outputs.AnalysisBoxPlotAggregatedFieldWells'] = None):
        AnalysisBoxPlotFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            box_plot_aggregated_field_wells=box_plot_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             box_plot_aggregated_field_wells: Optional['outputs.AnalysisBoxPlotAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if box_plot_aggregated_field_wells is not None:
            _setter("box_plot_aggregated_field_wells", box_plot_aggregated_field_wells)

    @property
    @pulumi.getter(name="boxPlotAggregatedFieldWells")
    def box_plot_aggregated_field_wells(self) -> Optional['outputs.AnalysisBoxPlotAggregatedFieldWells']:
        return pulumi.get(self, "box_plot_aggregated_field_wells")


@pulumi.output_type
class AnalysisBoxPlotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allDataPointsVisibility":
            suggest = "all_data_points_visibility"
        elif key == "outlierVisibility":
            suggest = "outlier_visibility"
        elif key == "styleOptions":
            suggest = "style_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBoxPlotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBoxPlotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBoxPlotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_data_points_visibility: Optional['AnalysisVisibility'] = None,
                 outlier_visibility: Optional['AnalysisVisibility'] = None,
                 style_options: Optional['outputs.AnalysisBoxPlotStyleOptions'] = None):
        AnalysisBoxPlotOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_data_points_visibility=all_data_points_visibility,
            outlier_visibility=outlier_visibility,
            style_options=style_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_data_points_visibility: Optional['AnalysisVisibility'] = None,
             outlier_visibility: Optional['AnalysisVisibility'] = None,
             style_options: Optional['outputs.AnalysisBoxPlotStyleOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_data_points_visibility is not None:
            _setter("all_data_points_visibility", all_data_points_visibility)
        if outlier_visibility is not None:
            _setter("outlier_visibility", outlier_visibility)
        if style_options is not None:
            _setter("style_options", style_options)

    @property
    @pulumi.getter(name="allDataPointsVisibility")
    def all_data_points_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "all_data_points_visibility")

    @property
    @pulumi.getter(name="outlierVisibility")
    def outlier_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "outlier_visibility")

    @property
    @pulumi.getter(name="styleOptions")
    def style_options(self) -> Optional['outputs.AnalysisBoxPlotStyleOptions']:
        return pulumi.get(self, "style_options")


@pulumi.output_type
class AnalysisBoxPlotSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categorySort":
            suggest = "category_sort"
        elif key == "paginationConfiguration":
            suggest = "pagination_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBoxPlotSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBoxPlotSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBoxPlotSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
                 pagination_configuration: Optional['outputs.AnalysisPaginationConfiguration'] = None):
        AnalysisBoxPlotSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_sort=category_sort,
            pagination_configuration=pagination_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             pagination_configuration: Optional['outputs.AnalysisPaginationConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if pagination_configuration is not None:
            _setter("pagination_configuration", pagination_configuration)

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="paginationConfiguration")
    def pagination_configuration(self) -> Optional['outputs.AnalysisPaginationConfiguration']:
        return pulumi.get(self, "pagination_configuration")


@pulumi.output_type
class AnalysisBoxPlotStyleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillStyle":
            suggest = "fill_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBoxPlotStyleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBoxPlotStyleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBoxPlotStyleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fill_style: Optional['AnalysisBoxPlotFillStyle'] = None):
        AnalysisBoxPlotStyleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fill_style=fill_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fill_style: Optional['AnalysisBoxPlotFillStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if fill_style is not None:
            _setter("fill_style", fill_style)

    @property
    @pulumi.getter(name="fillStyle")
    def fill_style(self) -> Optional['AnalysisBoxPlotFillStyle']:
        return pulumi.get(self, "fill_style")


@pulumi.output_type
class AnalysisBoxPlotVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisBoxPlotVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisBoxPlotVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisBoxPlotVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisBoxPlotChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisBoxPlotVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisBoxPlotChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisBoxPlotChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisCalculatedField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCalculatedField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCalculatedField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCalculatedField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 expression: str,
                 name: str):
        AnalysisCalculatedField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            expression=expression,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             expression: str,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("expression", expression)
        _setter("name", name)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class AnalysisCalculatedMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCalculatedMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCalculatedMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCalculatedMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 field_id: str):
        AnalysisCalculatedMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        _setter("field_id", field_id)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class AnalysisCascadingControlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceControls":
            suggest = "source_controls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCascadingControlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCascadingControlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCascadingControlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_controls: Optional[Sequence['outputs.AnalysisCascadingControlSource']] = None):
        AnalysisCascadingControlConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_controls=source_controls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_controls: Optional[Sequence['outputs.AnalysisCascadingControlSource']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if source_controls is not None:
            _setter("source_controls", source_controls)

    @property
    @pulumi.getter(name="sourceControls")
    def source_controls(self) -> Optional[Sequence['outputs.AnalysisCascadingControlSource']]:
        return pulumi.get(self, "source_controls")


@pulumi.output_type
class AnalysisCascadingControlSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnToMatch":
            suggest = "column_to_match"
        elif key == "sourceSheetControlId":
            suggest = "source_sheet_control_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCascadingControlSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCascadingControlSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCascadingControlSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_to_match: Optional['outputs.AnalysisColumnIdentifier'] = None,
                 source_sheet_control_id: Optional[str] = None):
        AnalysisCascadingControlSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_to_match=column_to_match,
            source_sheet_control_id=source_sheet_control_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_to_match: Optional['outputs.AnalysisColumnIdentifier'] = None,
             source_sheet_control_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_to_match is not None:
            _setter("column_to_match", column_to_match)
        if source_sheet_control_id is not None:
            _setter("source_sheet_control_id", source_sheet_control_id)

    @property
    @pulumi.getter(name="columnToMatch")
    def column_to_match(self) -> Optional['outputs.AnalysisColumnIdentifier']:
        return pulumi.get(self, "column_to_match")

    @property
    @pulumi.getter(name="sourceSheetControlId")
    def source_sheet_control_id(self) -> Optional[str]:
        return pulumi.get(self, "source_sheet_control_id")


@pulumi.output_type
class AnalysisCategoricalDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "hierarchyId":
            suggest = "hierarchy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCategoricalDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCategoricalDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCategoricalDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 field_id: str,
                 format_configuration: Optional['outputs.AnalysisStringFormatConfiguration'] = None,
                 hierarchy_id: Optional[str] = None):
        AnalysisCategoricalDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            format_configuration=format_configuration,
            hierarchy_id=hierarchy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             field_id: str,
             format_configuration: Optional['outputs.AnalysisStringFormatConfiguration'] = None,
             hierarchy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if hierarchy_id is not None:
            _setter("hierarchy_id", hierarchy_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.AnalysisStringFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> Optional[str]:
        return pulumi.get(self, "hierarchy_id")


@pulumi.output_type
class AnalysisCategoricalMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCategoricalMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCategoricalMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCategoricalMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 field_id: str,
                 aggregation_function: Optional['AnalysisCategoricalAggregationFunction'] = None,
                 format_configuration: Optional['outputs.AnalysisStringFormatConfiguration'] = None):
        AnalysisCategoricalMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            aggregation_function=aggregation_function,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             field_id: str,
             aggregation_function: Optional['AnalysisCategoricalAggregationFunction'] = None,
             format_configuration: Optional['outputs.AnalysisStringFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['AnalysisCategoricalAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.AnalysisStringFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class AnalysisCategoryDrillDownFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryValues":
            suggest = "category_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCategoryDrillDownFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCategoryDrillDownFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCategoryDrillDownFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_values: Sequence[str],
                 column: 'outputs.AnalysisColumnIdentifier'):
        AnalysisCategoryDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_values=category_values,
            column=column,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_values: Sequence[str],
             column: 'outputs.AnalysisColumnIdentifier',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("category_values", category_values)
        _setter("column", column)

    @property
    @pulumi.getter(name="categoryValues")
    def category_values(self) -> Sequence[str]:
        return pulumi.get(self, "category_values")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")


@pulumi.output_type
class AnalysisCategoryFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCategoryFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCategoryFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCategoryFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 configuration: 'outputs.AnalysisCategoryFilterConfiguration',
                 filter_id: str):
        AnalysisCategoryFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            configuration=configuration,
            filter_id=filter_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             configuration: 'outputs.AnalysisCategoryFilterConfiguration',
             filter_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("configuration", configuration)
        _setter("filter_id", filter_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.AnalysisCategoryFilterConfiguration':
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")


@pulumi.output_type
class AnalysisCategoryFilterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customFilterConfiguration":
            suggest = "custom_filter_configuration"
        elif key == "customFilterListConfiguration":
            suggest = "custom_filter_list_configuration"
        elif key == "filterListConfiguration":
            suggest = "filter_list_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCategoryFilterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCategoryFilterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCategoryFilterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_filter_configuration: Optional['outputs.AnalysisCustomFilterConfiguration'] = None,
                 custom_filter_list_configuration: Optional['outputs.AnalysisCustomFilterListConfiguration'] = None,
                 filter_list_configuration: Optional['outputs.AnalysisFilterListConfiguration'] = None):
        AnalysisCategoryFilterConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_filter_configuration=custom_filter_configuration,
            custom_filter_list_configuration=custom_filter_list_configuration,
            filter_list_configuration=filter_list_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_filter_configuration: Optional['outputs.AnalysisCustomFilterConfiguration'] = None,
             custom_filter_list_configuration: Optional['outputs.AnalysisCustomFilterListConfiguration'] = None,
             filter_list_configuration: Optional['outputs.AnalysisFilterListConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_filter_configuration is not None:
            _setter("custom_filter_configuration", custom_filter_configuration)
        if custom_filter_list_configuration is not None:
            _setter("custom_filter_list_configuration", custom_filter_list_configuration)
        if filter_list_configuration is not None:
            _setter("filter_list_configuration", filter_list_configuration)

    @property
    @pulumi.getter(name="customFilterConfiguration")
    def custom_filter_configuration(self) -> Optional['outputs.AnalysisCustomFilterConfiguration']:
        return pulumi.get(self, "custom_filter_configuration")

    @property
    @pulumi.getter(name="customFilterListConfiguration")
    def custom_filter_list_configuration(self) -> Optional['outputs.AnalysisCustomFilterListConfiguration']:
        return pulumi.get(self, "custom_filter_list_configuration")

    @property
    @pulumi.getter(name="filterListConfiguration")
    def filter_list_configuration(self) -> Optional['outputs.AnalysisFilterListConfiguration']:
        return pulumi.get(self, "filter_list_configuration")


@pulumi.output_type
class AnalysisChartAxisLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisLabelOptions":
            suggest = "axis_label_options"
        elif key == "sortIconVisibility":
            suggest = "sort_icon_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisChartAxisLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisChartAxisLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisChartAxisLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_label_options: Optional[Sequence['outputs.AnalysisAxisLabelOptions']] = None,
                 sort_icon_visibility: Optional['AnalysisVisibility'] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisChartAxisLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_label_options=axis_label_options,
            sort_icon_visibility=sort_icon_visibility,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_label_options: Optional[Sequence['outputs.AnalysisAxisLabelOptions']] = None,
             sort_icon_visibility: Optional['AnalysisVisibility'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_label_options is not None:
            _setter("axis_label_options", axis_label_options)
        if sort_icon_visibility is not None:
            _setter("sort_icon_visibility", sort_icon_visibility)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="axisLabelOptions")
    def axis_label_options(self) -> Optional[Sequence['outputs.AnalysisAxisLabelOptions']]:
        return pulumi.get(self, "axis_label_options")

    @property
    @pulumi.getter(name="sortIconVisibility")
    def sort_icon_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "sort_icon_visibility")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisClusterMarker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simpleClusterMarker":
            suggest = "simple_cluster_marker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisClusterMarker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisClusterMarker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisClusterMarker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 simple_cluster_marker: Optional['outputs.AnalysisSimpleClusterMarker'] = None):
        AnalysisClusterMarker._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            simple_cluster_marker=simple_cluster_marker,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             simple_cluster_marker: Optional['outputs.AnalysisSimpleClusterMarker'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if simple_cluster_marker is not None:
            _setter("simple_cluster_marker", simple_cluster_marker)

    @property
    @pulumi.getter(name="simpleClusterMarker")
    def simple_cluster_marker(self) -> Optional['outputs.AnalysisSimpleClusterMarker']:
        return pulumi.get(self, "simple_cluster_marker")


@pulumi.output_type
class AnalysisClusterMarkerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterMarker":
            suggest = "cluster_marker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisClusterMarkerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisClusterMarkerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisClusterMarkerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_marker: Optional['outputs.AnalysisClusterMarker'] = None):
        AnalysisClusterMarkerConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_marker=cluster_marker,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_marker: Optional['outputs.AnalysisClusterMarker'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cluster_marker is not None:
            _setter("cluster_marker", cluster_marker)

    @property
    @pulumi.getter(name="clusterMarker")
    def cluster_marker(self) -> Optional['outputs.AnalysisClusterMarker']:
        return pulumi.get(self, "cluster_marker")


@pulumi.output_type
class AnalysisColorScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorFillType":
            suggest = "color_fill_type"
        elif key == "nullValueColor":
            suggest = "null_value_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisColorScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisColorScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisColorScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_fill_type: 'AnalysisColorFillType',
                 colors: Sequence['outputs.AnalysisDataColor'],
                 null_value_color: Optional['outputs.AnalysisDataColor'] = None):
        AnalysisColorScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_fill_type=color_fill_type,
            colors=colors,
            null_value_color=null_value_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_fill_type: 'AnalysisColorFillType',
             colors: Sequence['outputs.AnalysisDataColor'],
             null_value_color: Optional['outputs.AnalysisDataColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color_fill_type", color_fill_type)
        _setter("colors", colors)
        if null_value_color is not None:
            _setter("null_value_color", null_value_color)

    @property
    @pulumi.getter(name="colorFillType")
    def color_fill_type(self) -> 'AnalysisColorFillType':
        return pulumi.get(self, "color_fill_type")

    @property
    @pulumi.getter
    def colors(self) -> Sequence['outputs.AnalysisDataColor']:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="nullValueColor")
    def null_value_color(self) -> Optional['outputs.AnalysisDataColor']:
        return pulumi.get(self, "null_value_color")


@pulumi.output_type
class AnalysisColorsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customColors":
            suggest = "custom_colors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisColorsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisColorsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisColorsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_colors: Optional[Sequence['outputs.AnalysisCustomColor']] = None):
        AnalysisColorsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_colors=custom_colors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_colors: Optional[Sequence['outputs.AnalysisCustomColor']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_colors is not None:
            _setter("custom_colors", custom_colors)

    @property
    @pulumi.getter(name="customColors")
    def custom_colors(self) -> Optional[Sequence['outputs.AnalysisCustomColor']]:
        return pulumi.get(self, "custom_colors")


@pulumi.output_type
class AnalysisColumnConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorsConfiguration":
            suggest = "colors_configuration"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisColumnConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisColumnConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisColumnConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 colors_configuration: Optional['outputs.AnalysisColorsConfiguration'] = None,
                 format_configuration: Optional['outputs.AnalysisFormatConfiguration'] = None,
                 role: Optional['AnalysisColumnRole'] = None):
        AnalysisColumnConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            colors_configuration=colors_configuration,
            format_configuration=format_configuration,
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             colors_configuration: Optional['outputs.AnalysisColorsConfiguration'] = None,
             format_configuration: Optional['outputs.AnalysisFormatConfiguration'] = None,
             role: Optional['AnalysisColumnRole'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        if colors_configuration is not None:
            _setter("colors_configuration", colors_configuration)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if role is not None:
            _setter("role", role)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="colorsConfiguration")
    def colors_configuration(self) -> Optional['outputs.AnalysisColorsConfiguration']:
        return pulumi.get(self, "colors_configuration")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.AnalysisFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter
    def role(self) -> Optional['AnalysisColumnRole']:
        return pulumi.get(self, "role")


@pulumi.output_type
class AnalysisColumnHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeHierarchy":
            suggest = "date_time_hierarchy"
        elif key == "explicitHierarchy":
            suggest = "explicit_hierarchy"
        elif key == "predefinedHierarchy":
            suggest = "predefined_hierarchy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisColumnHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisColumnHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisColumnHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_hierarchy: Optional['outputs.AnalysisDateTimeHierarchy'] = None,
                 explicit_hierarchy: Optional['outputs.AnalysisExplicitHierarchy'] = None,
                 predefined_hierarchy: Optional['outputs.AnalysisPredefinedHierarchy'] = None):
        AnalysisColumnHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_hierarchy=date_time_hierarchy,
            explicit_hierarchy=explicit_hierarchy,
            predefined_hierarchy=predefined_hierarchy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_hierarchy: Optional['outputs.AnalysisDateTimeHierarchy'] = None,
             explicit_hierarchy: Optional['outputs.AnalysisExplicitHierarchy'] = None,
             predefined_hierarchy: Optional['outputs.AnalysisPredefinedHierarchy'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_hierarchy is not None:
            _setter("date_time_hierarchy", date_time_hierarchy)
        if explicit_hierarchy is not None:
            _setter("explicit_hierarchy", explicit_hierarchy)
        if predefined_hierarchy is not None:
            _setter("predefined_hierarchy", predefined_hierarchy)

    @property
    @pulumi.getter(name="dateTimeHierarchy")
    def date_time_hierarchy(self) -> Optional['outputs.AnalysisDateTimeHierarchy']:
        return pulumi.get(self, "date_time_hierarchy")

    @property
    @pulumi.getter(name="explicitHierarchy")
    def explicit_hierarchy(self) -> Optional['outputs.AnalysisExplicitHierarchy']:
        return pulumi.get(self, "explicit_hierarchy")

    @property
    @pulumi.getter(name="predefinedHierarchy")
    def predefined_hierarchy(self) -> Optional['outputs.AnalysisPredefinedHierarchy']:
        return pulumi.get(self, "predefined_hierarchy")


@pulumi.output_type
class AnalysisColumnIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "dataSetIdentifier":
            suggest = "data_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisColumnIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisColumnIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisColumnIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 data_set_identifier: str):
        AnalysisColumnIdentifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            data_set_identifier=data_set_identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: str,
             data_set_identifier: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column_name", column_name)
        _setter("data_set_identifier", data_set_identifier)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")


@pulumi.output_type
class AnalysisColumnSort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortBy":
            suggest = "sort_by"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisColumnSort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisColumnSort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisColumnSort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: 'AnalysisSortDirection',
                 sort_by: 'outputs.AnalysisColumnIdentifier',
                 aggregation_function: Optional['outputs.AnalysisAggregationFunction'] = None):
        AnalysisColumnSort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            sort_by=sort_by,
            aggregation_function=aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: 'AnalysisSortDirection',
             sort_by: 'outputs.AnalysisColumnIdentifier',
             aggregation_function: Optional['outputs.AnalysisAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("direction", direction)
        _setter("sort_by", sort_by)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)

    @property
    @pulumi.getter
    def direction(self) -> 'AnalysisSortDirection':
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="sortBy")
    def sort_by(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "sort_by")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.AnalysisAggregationFunction']:
        return pulumi.get(self, "aggregation_function")


@pulumi.output_type
class AnalysisColumnTooltipItem(dict):
    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 aggregation: Optional['outputs.AnalysisAggregationFunction'] = None,
                 label: Optional[str] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisColumnTooltipItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            aggregation=aggregation,
            label=label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             aggregation: Optional['outputs.AnalysisAggregationFunction'] = None,
             label: Optional[str] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if label is not None:
            _setter("label", label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional['outputs.AnalysisAggregationFunction']:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisComboChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barValues":
            suggest = "bar_values"
        elif key == "lineValues":
            suggest = "line_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisComboChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisComboChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisComboChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
                 category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 colors: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 line_values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisComboChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_values=bar_values,
            category=category,
            colors=colors,
            line_values=line_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             colors: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             line_values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_values is not None:
            _setter("bar_values", bar_values)
        if category is not None:
            _setter("category", category)
        if colors is not None:
            _setter("colors", colors)
        if line_values is not None:
            _setter("line_values", line_values)

    @property
    @pulumi.getter(name="barValues")
    def bar_values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "bar_values")

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="lineValues")
    def line_values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "line_values")


@pulumi.output_type
class AnalysisComboChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barDataLabels":
            suggest = "bar_data_labels"
        elif key == "barsArrangement":
            suggest = "bars_arrangement"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "lineDataLabels":
            suggest = "line_data_labels"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "secondaryYAxisDisplayOptions":
            suggest = "secondary_y_axis_display_options"
        elif key == "secondaryYAxisLabelOptions":
            suggest = "secondary_y_axis_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisComboChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisComboChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisComboChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 bars_arrangement: Optional['AnalysisBarsArrangement'] = None,
                 category_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 color_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisComboChartFieldWells'] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 line_data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 reference_lines: Optional[Sequence['outputs.AnalysisReferenceLine']] = None,
                 secondary_y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 secondary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.AnalysisComboChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None):
        AnalysisComboChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_data_labels=bar_data_labels,
            bars_arrangement=bars_arrangement,
            category_axis=category_axis,
            category_label_options=category_label_options,
            color_label_options=color_label_options,
            field_wells=field_wells,
            legend=legend,
            line_data_labels=line_data_labels,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            reference_lines=reference_lines,
            secondary_y_axis_display_options=secondary_y_axis_display_options,
            secondary_y_axis_label_options=secondary_y_axis_label_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             bars_arrangement: Optional['AnalysisBarsArrangement'] = None,
             category_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             color_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisComboChartFieldWells'] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             line_data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             reference_lines: Optional[Sequence['outputs.AnalysisReferenceLine']] = None,
             secondary_y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             secondary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.AnalysisComboChartSortConfiguration'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_data_labels is not None:
            _setter("bar_data_labels", bar_data_labels)
        if bars_arrangement is not None:
            _setter("bars_arrangement", bars_arrangement)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if line_data_labels is not None:
            _setter("line_data_labels", line_data_labels)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if secondary_y_axis_display_options is not None:
            _setter("secondary_y_axis_display_options", secondary_y_axis_display_options)
        if secondary_y_axis_label_options is not None:
            _setter("secondary_y_axis_label_options", secondary_y_axis_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="barDataLabels")
    def bar_data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "bar_data_labels")

    @property
    @pulumi.getter(name="barsArrangement")
    def bars_arrangement(self) -> Optional['AnalysisBarsArrangement']:
        return pulumi.get(self, "bars_arrangement")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisComboChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="lineDataLabels")
    def line_data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "line_data_labels")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.AnalysisReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="secondaryYAxisDisplayOptions")
    def secondary_y_axis_display_options(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "secondary_y_axis_display_options")

    @property
    @pulumi.getter(name="secondaryYAxisLabelOptions")
    def secondary_y_axis_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "secondary_y_axis_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisComboChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class AnalysisComboChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comboChartAggregatedFieldWells":
            suggest = "combo_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisComboChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisComboChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisComboChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 combo_chart_aggregated_field_wells: Optional['outputs.AnalysisComboChartAggregatedFieldWells'] = None):
        AnalysisComboChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            combo_chart_aggregated_field_wells=combo_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             combo_chart_aggregated_field_wells: Optional['outputs.AnalysisComboChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if combo_chart_aggregated_field_wells is not None:
            _setter("combo_chart_aggregated_field_wells", combo_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="comboChartAggregatedFieldWells")
    def combo_chart_aggregated_field_wells(self) -> Optional['outputs.AnalysisComboChartAggregatedFieldWells']:
        return pulumi.get(self, "combo_chart_aggregated_field_wells")


@pulumi.output_type
class AnalysisComboChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimit":
            suggest = "color_items_limit"
        elif key == "colorSort":
            suggest = "color_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisComboChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisComboChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisComboChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
                 color_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 color_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisComboChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            color_items_limit=color_items_limit,
            color_sort=color_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             color_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             color_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit is not None:
            _setter("color_items_limit", color_items_limit)
        if color_sort is not None:
            _setter("color_sort", color_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimit")
    def color_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit")

    @property
    @pulumi.getter(name="colorSort")
    def color_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "color_sort")


@pulumi.output_type
class AnalysisComboChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisComboChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisComboChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisComboChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisComboChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisComboChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisComboChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisComboChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisComparisonConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonFormat":
            suggest = "comparison_format"
        elif key == "comparisonMethod":
            suggest = "comparison_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisComparisonConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisComparisonConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisComparisonConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_format: Optional['outputs.AnalysisComparisonFormatConfiguration'] = None,
                 comparison_method: Optional['AnalysisComparisonMethod'] = None):
        AnalysisComparisonConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_format=comparison_format,
            comparison_method=comparison_method,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_format: Optional['outputs.AnalysisComparisonFormatConfiguration'] = None,
             comparison_method: Optional['AnalysisComparisonMethod'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if comparison_format is not None:
            _setter("comparison_format", comparison_format)
        if comparison_method is not None:
            _setter("comparison_method", comparison_method)

    @property
    @pulumi.getter(name="comparisonFormat")
    def comparison_format(self) -> Optional['outputs.AnalysisComparisonFormatConfiguration']:
        return pulumi.get(self, "comparison_format")

    @property
    @pulumi.getter(name="comparisonMethod")
    def comparison_method(self) -> Optional['AnalysisComparisonMethod']:
        return pulumi.get(self, "comparison_method")


@pulumi.output_type
class AnalysisComparisonFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberDisplayFormatConfiguration":
            suggest = "number_display_format_configuration"
        elif key == "percentageDisplayFormatConfiguration":
            suggest = "percentage_display_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisComparisonFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisComparisonFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisComparisonFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_display_format_configuration: Optional['outputs.AnalysisNumberDisplayFormatConfiguration'] = None,
                 percentage_display_format_configuration: Optional['outputs.AnalysisPercentageDisplayFormatConfiguration'] = None):
        AnalysisComparisonFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            number_display_format_configuration=number_display_format_configuration,
            percentage_display_format_configuration=percentage_display_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             number_display_format_configuration: Optional['outputs.AnalysisNumberDisplayFormatConfiguration'] = None,
             percentage_display_format_configuration: Optional['outputs.AnalysisPercentageDisplayFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if number_display_format_configuration is not None:
            _setter("number_display_format_configuration", number_display_format_configuration)
        if percentage_display_format_configuration is not None:
            _setter("percentage_display_format_configuration", percentage_display_format_configuration)

    @property
    @pulumi.getter(name="numberDisplayFormatConfiguration")
    def number_display_format_configuration(self) -> Optional['outputs.AnalysisNumberDisplayFormatConfiguration']:
        return pulumi.get(self, "number_display_format_configuration")

    @property
    @pulumi.getter(name="percentageDisplayFormatConfiguration")
    def percentage_display_format_configuration(self) -> Optional['outputs.AnalysisPercentageDisplayFormatConfiguration']:
        return pulumi.get(self, "percentage_display_format_configuration")


@pulumi.output_type
class AnalysisComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "growthRate":
            suggest = "growth_rate"
        elif key == "maximumMinimum":
            suggest = "maximum_minimum"
        elif key == "metricComparison":
            suggest = "metric_comparison"
        elif key == "periodOverPeriod":
            suggest = "period_over_period"
        elif key == "periodToDate":
            suggest = "period_to_date"
        elif key == "topBottomMovers":
            suggest = "top_bottom_movers"
        elif key == "topBottomRanked":
            suggest = "top_bottom_ranked"
        elif key == "totalAggregation":
            suggest = "total_aggregation"
        elif key == "uniqueValues":
            suggest = "unique_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forecast: Optional['outputs.AnalysisForecastComputation'] = None,
                 growth_rate: Optional['outputs.AnalysisGrowthRateComputation'] = None,
                 maximum_minimum: Optional['outputs.AnalysisMaximumMinimumComputation'] = None,
                 metric_comparison: Optional['outputs.AnalysisMetricComparisonComputation'] = None,
                 period_over_period: Optional['outputs.AnalysisPeriodOverPeriodComputation'] = None,
                 period_to_date: Optional['outputs.AnalysisPeriodToDateComputation'] = None,
                 top_bottom_movers: Optional['outputs.AnalysisTopBottomMoversComputation'] = None,
                 top_bottom_ranked: Optional['outputs.AnalysisTopBottomRankedComputation'] = None,
                 total_aggregation: Optional['outputs.AnalysisTotalAggregationComputation'] = None,
                 unique_values: Optional['outputs.AnalysisUniqueValuesComputation'] = None):
        AnalysisComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forecast=forecast,
            growth_rate=growth_rate,
            maximum_minimum=maximum_minimum,
            metric_comparison=metric_comparison,
            period_over_period=period_over_period,
            period_to_date=period_to_date,
            top_bottom_movers=top_bottom_movers,
            top_bottom_ranked=top_bottom_ranked,
            total_aggregation=total_aggregation,
            unique_values=unique_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forecast: Optional['outputs.AnalysisForecastComputation'] = None,
             growth_rate: Optional['outputs.AnalysisGrowthRateComputation'] = None,
             maximum_minimum: Optional['outputs.AnalysisMaximumMinimumComputation'] = None,
             metric_comparison: Optional['outputs.AnalysisMetricComparisonComputation'] = None,
             period_over_period: Optional['outputs.AnalysisPeriodOverPeriodComputation'] = None,
             period_to_date: Optional['outputs.AnalysisPeriodToDateComputation'] = None,
             top_bottom_movers: Optional['outputs.AnalysisTopBottomMoversComputation'] = None,
             top_bottom_ranked: Optional['outputs.AnalysisTopBottomRankedComputation'] = None,
             total_aggregation: Optional['outputs.AnalysisTotalAggregationComputation'] = None,
             unique_values: Optional['outputs.AnalysisUniqueValuesComputation'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if forecast is not None:
            _setter("forecast", forecast)
        if growth_rate is not None:
            _setter("growth_rate", growth_rate)
        if maximum_minimum is not None:
            _setter("maximum_minimum", maximum_minimum)
        if metric_comparison is not None:
            _setter("metric_comparison", metric_comparison)
        if period_over_period is not None:
            _setter("period_over_period", period_over_period)
        if period_to_date is not None:
            _setter("period_to_date", period_to_date)
        if top_bottom_movers is not None:
            _setter("top_bottom_movers", top_bottom_movers)
        if top_bottom_ranked is not None:
            _setter("top_bottom_ranked", top_bottom_ranked)
        if total_aggregation is not None:
            _setter("total_aggregation", total_aggregation)
        if unique_values is not None:
            _setter("unique_values", unique_values)

    @property
    @pulumi.getter
    def forecast(self) -> Optional['outputs.AnalysisForecastComputation']:
        return pulumi.get(self, "forecast")

    @property
    @pulumi.getter(name="growthRate")
    def growth_rate(self) -> Optional['outputs.AnalysisGrowthRateComputation']:
        return pulumi.get(self, "growth_rate")

    @property
    @pulumi.getter(name="maximumMinimum")
    def maximum_minimum(self) -> Optional['outputs.AnalysisMaximumMinimumComputation']:
        return pulumi.get(self, "maximum_minimum")

    @property
    @pulumi.getter(name="metricComparison")
    def metric_comparison(self) -> Optional['outputs.AnalysisMetricComparisonComputation']:
        return pulumi.get(self, "metric_comparison")

    @property
    @pulumi.getter(name="periodOverPeriod")
    def period_over_period(self) -> Optional['outputs.AnalysisPeriodOverPeriodComputation']:
        return pulumi.get(self, "period_over_period")

    @property
    @pulumi.getter(name="periodToDate")
    def period_to_date(self) -> Optional['outputs.AnalysisPeriodToDateComputation']:
        return pulumi.get(self, "period_to_date")

    @property
    @pulumi.getter(name="topBottomMovers")
    def top_bottom_movers(self) -> Optional['outputs.AnalysisTopBottomMoversComputation']:
        return pulumi.get(self, "top_bottom_movers")

    @property
    @pulumi.getter(name="topBottomRanked")
    def top_bottom_ranked(self) -> Optional['outputs.AnalysisTopBottomRankedComputation']:
        return pulumi.get(self, "top_bottom_ranked")

    @property
    @pulumi.getter(name="totalAggregation")
    def total_aggregation(self) -> Optional['outputs.AnalysisTotalAggregationComputation']:
        return pulumi.get(self, "total_aggregation")

    @property
    @pulumi.getter(name="uniqueValues")
    def unique_values(self) -> Optional['outputs.AnalysisUniqueValuesComputation']:
        return pulumi.get(self, "unique_values")


@pulumi.output_type
class AnalysisConditionalFormattingColor(dict):
    def __init__(__self__, *,
                 gradient: Optional['outputs.AnalysisConditionalFormattingGradientColor'] = None,
                 solid: Optional['outputs.AnalysisConditionalFormattingSolidColor'] = None):
        AnalysisConditionalFormattingColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gradient=gradient,
            solid=solid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gradient: Optional['outputs.AnalysisConditionalFormattingGradientColor'] = None,
             solid: Optional['outputs.AnalysisConditionalFormattingSolidColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if gradient is not None:
            _setter("gradient", gradient)
        if solid is not None:
            _setter("solid", solid)

    @property
    @pulumi.getter
    def gradient(self) -> Optional['outputs.AnalysisConditionalFormattingGradientColor']:
        return pulumi.get(self, "gradient")

    @property
    @pulumi.getter
    def solid(self) -> Optional['outputs.AnalysisConditionalFormattingSolidColor']:
        return pulumi.get(self, "solid")


@pulumi.output_type
class AnalysisConditionalFormattingCustomIconCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iconOptions":
            suggest = "icon_options"
        elif key == "displayConfiguration":
            suggest = "display_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisConditionalFormattingCustomIconCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisConditionalFormattingCustomIconCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisConditionalFormattingCustomIconCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 icon_options: 'outputs.AnalysisConditionalFormattingCustomIconOptions',
                 color: Optional[str] = None,
                 display_configuration: Optional['outputs.AnalysisConditionalFormattingIconDisplayConfiguration'] = None):
        AnalysisConditionalFormattingCustomIconCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            icon_options=icon_options,
            color=color,
            display_configuration=display_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             icon_options: 'outputs.AnalysisConditionalFormattingCustomIconOptions',
             color: Optional[str] = None,
             display_configuration: Optional['outputs.AnalysisConditionalFormattingIconDisplayConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        _setter("icon_options", icon_options)
        if color is not None:
            _setter("color", color)
        if display_configuration is not None:
            _setter("display_configuration", display_configuration)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="iconOptions")
    def icon_options(self) -> 'outputs.AnalysisConditionalFormattingCustomIconOptions':
        return pulumi.get(self, "icon_options")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="displayConfiguration")
    def display_configuration(self) -> Optional['outputs.AnalysisConditionalFormattingIconDisplayConfiguration']:
        return pulumi.get(self, "display_configuration")


@pulumi.output_type
class AnalysisConditionalFormattingCustomIconOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unicodeIcon":
            suggest = "unicode_icon"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisConditionalFormattingCustomIconOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisConditionalFormattingCustomIconOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisConditionalFormattingCustomIconOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['AnalysisIcon'] = None,
                 unicode_icon: Optional[str] = None):
        AnalysisConditionalFormattingCustomIconOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            unicode_icon=unicode_icon,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['AnalysisIcon'] = None,
             unicode_icon: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if unicode_icon is not None:
            _setter("unicode_icon", unicode_icon)

    @property
    @pulumi.getter
    def icon(self) -> Optional['AnalysisIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="unicodeIcon")
    def unicode_icon(self) -> Optional[str]:
        return pulumi.get(self, "unicode_icon")


@pulumi.output_type
class AnalysisConditionalFormattingGradientColor(dict):
    def __init__(__self__, *,
                 color: 'outputs.AnalysisGradientColor',
                 expression: str):
        AnalysisConditionalFormattingGradientColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: 'outputs.AnalysisGradientColor',
             expression: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)
        _setter("expression", expression)

    @property
    @pulumi.getter
    def color(self) -> 'outputs.AnalysisGradientColor':
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")


@pulumi.output_type
class AnalysisConditionalFormattingIcon(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customCondition":
            suggest = "custom_condition"
        elif key == "iconSet":
            suggest = "icon_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisConditionalFormattingIcon. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisConditionalFormattingIcon.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisConditionalFormattingIcon.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_condition: Optional['outputs.AnalysisConditionalFormattingCustomIconCondition'] = None,
                 icon_set: Optional['outputs.AnalysisConditionalFormattingIconSet'] = None):
        AnalysisConditionalFormattingIcon._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_condition=custom_condition,
            icon_set=icon_set,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_condition: Optional['outputs.AnalysisConditionalFormattingCustomIconCondition'] = None,
             icon_set: Optional['outputs.AnalysisConditionalFormattingIconSet'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_condition is not None:
            _setter("custom_condition", custom_condition)
        if icon_set is not None:
            _setter("icon_set", icon_set)

    @property
    @pulumi.getter(name="customCondition")
    def custom_condition(self) -> Optional['outputs.AnalysisConditionalFormattingCustomIconCondition']:
        return pulumi.get(self, "custom_condition")

    @property
    @pulumi.getter(name="iconSet")
    def icon_set(self) -> Optional['outputs.AnalysisConditionalFormattingIconSet']:
        return pulumi.get(self, "icon_set")


@pulumi.output_type
class AnalysisConditionalFormattingIconDisplayConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iconDisplayOption":
            suggest = "icon_display_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisConditionalFormattingIconDisplayConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisConditionalFormattingIconDisplayConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisConditionalFormattingIconDisplayConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon_display_option: Optional['AnalysisConditionalFormattingIconDisplayOption'] = None):
        AnalysisConditionalFormattingIconDisplayConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon_display_option=icon_display_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon_display_option: Optional['AnalysisConditionalFormattingIconDisplayOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon_display_option is not None:
            _setter("icon_display_option", icon_display_option)

    @property
    @pulumi.getter(name="iconDisplayOption")
    def icon_display_option(self) -> Optional['AnalysisConditionalFormattingIconDisplayOption']:
        return pulumi.get(self, "icon_display_option")


@pulumi.output_type
class AnalysisConditionalFormattingIconSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iconSetType":
            suggest = "icon_set_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisConditionalFormattingIconSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisConditionalFormattingIconSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisConditionalFormattingIconSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 icon_set_type: Optional['AnalysisConditionalFormattingIconSetType'] = None):
        AnalysisConditionalFormattingIconSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            icon_set_type=icon_set_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             icon_set_type: Optional['AnalysisConditionalFormattingIconSetType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if icon_set_type is not None:
            _setter("icon_set_type", icon_set_type)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="iconSetType")
    def icon_set_type(self) -> Optional['AnalysisConditionalFormattingIconSetType']:
        return pulumi.get(self, "icon_set_type")


@pulumi.output_type
class AnalysisConditionalFormattingSolidColor(dict):
    def __init__(__self__, *,
                 expression: str,
                 color: Optional[str] = None):
        AnalysisConditionalFormattingSolidColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            color=color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             color: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if color is not None:
            _setter("color", color)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")


@pulumi.output_type
class AnalysisContributionAnalysisDefault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributorDimensions":
            suggest = "contributor_dimensions"
        elif key == "measureFieldId":
            suggest = "measure_field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisContributionAnalysisDefault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisContributionAnalysisDefault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisContributionAnalysisDefault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contributor_dimensions: Sequence['outputs.AnalysisColumnIdentifier'],
                 measure_field_id: str):
        AnalysisContributionAnalysisDefault._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contributor_dimensions=contributor_dimensions,
            measure_field_id=measure_field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contributor_dimensions: Sequence['outputs.AnalysisColumnIdentifier'],
             measure_field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("contributor_dimensions", contributor_dimensions)
        _setter("measure_field_id", measure_field_id)

    @property
    @pulumi.getter(name="contributorDimensions")
    def contributor_dimensions(self) -> Sequence['outputs.AnalysisColumnIdentifier']:
        return pulumi.get(self, "contributor_dimensions")

    @property
    @pulumi.getter(name="measureFieldId")
    def measure_field_id(self) -> str:
        return pulumi.get(self, "measure_field_id")


@pulumi.output_type
class AnalysisCurrencyDisplayFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlacesConfiguration":
            suggest = "decimal_places_configuration"
        elif key == "negativeValueConfiguration":
            suggest = "negative_value_configuration"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numberScale":
            suggest = "number_scale"
        elif key == "separatorConfiguration":
            suggest = "separator_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCurrencyDisplayFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCurrencyDisplayFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCurrencyDisplayFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places_configuration: Optional['outputs.AnalysisDecimalPlacesConfiguration'] = None,
                 negative_value_configuration: Optional['outputs.AnalysisNegativeValueConfiguration'] = None,
                 null_value_format_configuration: Optional['outputs.AnalysisNullValueFormatConfiguration'] = None,
                 number_scale: Optional['AnalysisNumberScale'] = None,
                 prefix: Optional[str] = None,
                 separator_configuration: Optional['outputs.AnalysisNumericSeparatorConfiguration'] = None,
                 suffix: Optional[str] = None,
                 symbol: Optional[str] = None):
        AnalysisCurrencyDisplayFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places_configuration=decimal_places_configuration,
            negative_value_configuration=negative_value_configuration,
            null_value_format_configuration=null_value_format_configuration,
            number_scale=number_scale,
            prefix=prefix,
            separator_configuration=separator_configuration,
            suffix=suffix,
            symbol=symbol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places_configuration: Optional['outputs.AnalysisDecimalPlacesConfiguration'] = None,
             negative_value_configuration: Optional['outputs.AnalysisNegativeValueConfiguration'] = None,
             null_value_format_configuration: Optional['outputs.AnalysisNullValueFormatConfiguration'] = None,
             number_scale: Optional['AnalysisNumberScale'] = None,
             prefix: Optional[str] = None,
             separator_configuration: Optional['outputs.AnalysisNumericSeparatorConfiguration'] = None,
             suffix: Optional[str] = None,
             symbol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_places_configuration is not None:
            _setter("decimal_places_configuration", decimal_places_configuration)
        if negative_value_configuration is not None:
            _setter("negative_value_configuration", negative_value_configuration)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if number_scale is not None:
            _setter("number_scale", number_scale)
        if prefix is not None:
            _setter("prefix", prefix)
        if separator_configuration is not None:
            _setter("separator_configuration", separator_configuration)
        if suffix is not None:
            _setter("suffix", suffix)
        if symbol is not None:
            _setter("symbol", symbol)

    @property
    @pulumi.getter(name="decimalPlacesConfiguration")
    def decimal_places_configuration(self) -> Optional['outputs.AnalysisDecimalPlacesConfiguration']:
        return pulumi.get(self, "decimal_places_configuration")

    @property
    @pulumi.getter(name="negativeValueConfiguration")
    def negative_value_configuration(self) -> Optional['outputs.AnalysisNegativeValueConfiguration']:
        return pulumi.get(self, "negative_value_configuration")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.AnalysisNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numberScale")
    def number_scale(self) -> Optional['AnalysisNumberScale']:
        return pulumi.get(self, "number_scale")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="separatorConfiguration")
    def separator_configuration(self) -> Optional['outputs.AnalysisNumericSeparatorConfiguration']:
        return pulumi.get(self, "separator_configuration")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter
    def symbol(self) -> Optional[str]:
        return pulumi.get(self, "symbol")


@pulumi.output_type
class AnalysisCustomActionFilterOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedFieldsConfiguration":
            suggest = "selected_fields_configuration"
        elif key == "targetVisualsConfiguration":
            suggest = "target_visuals_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCustomActionFilterOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCustomActionFilterOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCustomActionFilterOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_fields_configuration: 'outputs.AnalysisFilterOperationSelectedFieldsConfiguration',
                 target_visuals_configuration: 'outputs.AnalysisFilterOperationTargetVisualsConfiguration'):
        AnalysisCustomActionFilterOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_fields_configuration=selected_fields_configuration,
            target_visuals_configuration=target_visuals_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_fields_configuration: 'outputs.AnalysisFilterOperationSelectedFieldsConfiguration',
             target_visuals_configuration: 'outputs.AnalysisFilterOperationTargetVisualsConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("selected_fields_configuration", selected_fields_configuration)
        _setter("target_visuals_configuration", target_visuals_configuration)

    @property
    @pulumi.getter(name="selectedFieldsConfiguration")
    def selected_fields_configuration(self) -> 'outputs.AnalysisFilterOperationSelectedFieldsConfiguration':
        return pulumi.get(self, "selected_fields_configuration")

    @property
    @pulumi.getter(name="targetVisualsConfiguration")
    def target_visuals_configuration(self) -> 'outputs.AnalysisFilterOperationTargetVisualsConfiguration':
        return pulumi.get(self, "target_visuals_configuration")


@pulumi.output_type
class AnalysisCustomActionNavigationOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localNavigationConfiguration":
            suggest = "local_navigation_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCustomActionNavigationOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCustomActionNavigationOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCustomActionNavigationOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_navigation_configuration: Optional['outputs.AnalysisLocalNavigationConfiguration'] = None):
        AnalysisCustomActionNavigationOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_navigation_configuration=local_navigation_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_navigation_configuration: Optional['outputs.AnalysisLocalNavigationConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if local_navigation_configuration is not None:
            _setter("local_navigation_configuration", local_navigation_configuration)

    @property
    @pulumi.getter(name="localNavigationConfiguration")
    def local_navigation_configuration(self) -> Optional['outputs.AnalysisLocalNavigationConfiguration']:
        return pulumi.get(self, "local_navigation_configuration")


@pulumi.output_type
class AnalysisCustomActionSetParametersOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueConfigurations":
            suggest = "parameter_value_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCustomActionSetParametersOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCustomActionSetParametersOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCustomActionSetParametersOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_value_configurations: Sequence['outputs.AnalysisSetParameterValueConfiguration']):
        AnalysisCustomActionSetParametersOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_value_configurations=parameter_value_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_value_configurations: Sequence['outputs.AnalysisSetParameterValueConfiguration'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_value_configurations", parameter_value_configurations)

    @property
    @pulumi.getter(name="parameterValueConfigurations")
    def parameter_value_configurations(self) -> Sequence['outputs.AnalysisSetParameterValueConfiguration']:
        return pulumi.get(self, "parameter_value_configurations")


@pulumi.output_type
class AnalysisCustomActionUrlOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlTarget":
            suggest = "url_target"
        elif key == "urlTemplate":
            suggest = "url_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCustomActionUrlOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCustomActionUrlOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCustomActionUrlOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_target: 'AnalysisUrlTargetConfiguration',
                 url_template: str):
        AnalysisCustomActionUrlOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url_target=url_target,
            url_template=url_template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url_target: 'AnalysisUrlTargetConfiguration',
             url_template: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url_target", url_target)
        _setter("url_template", url_template)

    @property
    @pulumi.getter(name="urlTarget")
    def url_target(self) -> 'AnalysisUrlTargetConfiguration':
        return pulumi.get(self, "url_target")

    @property
    @pulumi.getter(name="urlTemplate")
    def url_template(self) -> str:
        return pulumi.get(self, "url_template")


@pulumi.output_type
class AnalysisCustomColor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldValue":
            suggest = "field_value"
        elif key == "specialValue":
            suggest = "special_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCustomColor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCustomColor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCustomColor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: str,
                 field_value: Optional[str] = None,
                 special_value: Optional['AnalysisSpecialValue'] = None):
        AnalysisCustomColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            field_value=field_value,
            special_value=special_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: str,
             field_value: Optional[str] = None,
             special_value: Optional['AnalysisSpecialValue'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)
        if field_value is not None:
            _setter("field_value", field_value)
        if special_value is not None:
            _setter("special_value", special_value)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[str]:
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter(name="specialValue")
    def special_value(self) -> Optional['AnalysisSpecialValue']:
        return pulumi.get(self, "special_value")


@pulumi.output_type
class AnalysisCustomContentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "contentUrl":
            suggest = "content_url"
        elif key == "imageScaling":
            suggest = "image_scaling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCustomContentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCustomContentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCustomContentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional['AnalysisCustomContentType'] = None,
                 content_url: Optional[str] = None,
                 image_scaling: Optional['AnalysisCustomContentImageScalingConfiguration'] = None):
        AnalysisCustomContentConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_type=content_type,
            content_url=content_url,
            image_scaling=image_scaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_type: Optional['AnalysisCustomContentType'] = None,
             content_url: Optional[str] = None,
             image_scaling: Optional['AnalysisCustomContentImageScalingConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if content_type is not None:
            _setter("content_type", content_type)
        if content_url is not None:
            _setter("content_url", content_url)
        if image_scaling is not None:
            _setter("image_scaling", image_scaling)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional['AnalysisCustomContentType']:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="contentUrl")
    def content_url(self) -> Optional[str]:
        return pulumi.get(self, "content_url")

    @property
    @pulumi.getter(name="imageScaling")
    def image_scaling(self) -> Optional['AnalysisCustomContentImageScalingConfiguration']:
        return pulumi.get(self, "image_scaling")


@pulumi.output_type
class AnalysisCustomContentVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCustomContentVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCustomContentVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCustomContentVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisCustomContentConfiguration'] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisCustomContentVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisCustomContentConfiguration'] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisCustomContentConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisCustomFilterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOperator":
            suggest = "match_operator"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "categoryValue":
            suggest = "category_value"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCustomFilterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCustomFilterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCustomFilterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_operator: 'AnalysisCategoryFilterMatchOperator',
                 null_option: 'AnalysisFilterNullOption',
                 category_value: Optional[str] = None,
                 parameter_name: Optional[str] = None,
                 select_all_options: Optional['AnalysisCategoryFilterSelectAllOptions'] = None):
        AnalysisCustomFilterConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_operator=match_operator,
            null_option=null_option,
            category_value=category_value,
            parameter_name=parameter_name,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_operator: 'AnalysisCategoryFilterMatchOperator',
             null_option: 'AnalysisFilterNullOption',
             category_value: Optional[str] = None,
             parameter_name: Optional[str] = None,
             select_all_options: Optional['AnalysisCategoryFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("match_operator", match_operator)
        _setter("null_option", null_option)
        if category_value is not None:
            _setter("category_value", category_value)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'AnalysisCategoryFilterMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'AnalysisFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="categoryValue")
    def category_value(self) -> Optional[str]:
        return pulumi.get(self, "category_value")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['AnalysisCategoryFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class AnalysisCustomFilterListConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOperator":
            suggest = "match_operator"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "categoryValues":
            suggest = "category_values"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCustomFilterListConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCustomFilterListConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCustomFilterListConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_operator: 'AnalysisCategoryFilterMatchOperator',
                 null_option: 'AnalysisFilterNullOption',
                 category_values: Optional[Sequence[str]] = None,
                 select_all_options: Optional['AnalysisCategoryFilterSelectAllOptions'] = None):
        AnalysisCustomFilterListConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_operator=match_operator,
            null_option=null_option,
            category_values=category_values,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_operator: 'AnalysisCategoryFilterMatchOperator',
             null_option: 'AnalysisFilterNullOption',
             category_values: Optional[Sequence[str]] = None,
             select_all_options: Optional['AnalysisCategoryFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("match_operator", match_operator)
        _setter("null_option", null_option)
        if category_values is not None:
            _setter("category_values", category_values)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'AnalysisCategoryFilterMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'AnalysisFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="categoryValues")
    def category_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "category_values")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['AnalysisCategoryFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class AnalysisCustomNarrativeOptions(dict):
    def __init__(__self__, *,
                 narrative: str):
        AnalysisCustomNarrativeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            narrative=narrative,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             narrative: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("narrative", narrative)

    @property
    @pulumi.getter
    def narrative(self) -> str:
        return pulumi.get(self, "narrative")


@pulumi.output_type
class AnalysisCustomParameterValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeValues":
            suggest = "date_time_values"
        elif key == "decimalValues":
            suggest = "decimal_values"
        elif key == "integerValues":
            suggest = "integer_values"
        elif key == "stringValues":
            suggest = "string_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCustomParameterValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCustomParameterValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCustomParameterValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_values: Optional[Sequence[str]] = None,
                 decimal_values: Optional[Sequence[float]] = None,
                 integer_values: Optional[Sequence[float]] = None,
                 string_values: Optional[Sequence[str]] = None):
        AnalysisCustomParameterValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_values=date_time_values,
            decimal_values=decimal_values,
            integer_values=integer_values,
            string_values=string_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_values: Optional[Sequence[str]] = None,
             decimal_values: Optional[Sequence[float]] = None,
             integer_values: Optional[Sequence[float]] = None,
             string_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_values is not None:
            _setter("date_time_values", date_time_values)
        if decimal_values is not None:
            _setter("decimal_values", decimal_values)
        if integer_values is not None:
            _setter("integer_values", integer_values)
        if string_values is not None:
            _setter("string_values", string_values)

    @property
    @pulumi.getter(name="dateTimeValues")
    def date_time_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "date_time_values")

    @property
    @pulumi.getter(name="decimalValues")
    def decimal_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "decimal_values")

    @property
    @pulumi.getter(name="integerValues")
    def integer_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "integer_values")

    @property
    @pulumi.getter(name="stringValues")
    def string_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "string_values")


@pulumi.output_type
class AnalysisCustomValuesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValues":
            suggest = "custom_values"
        elif key == "includeNullValue":
            suggest = "include_null_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisCustomValuesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisCustomValuesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisCustomValuesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_values: 'outputs.AnalysisCustomParameterValues',
                 include_null_value: Optional[bool] = None):
        AnalysisCustomValuesConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_values=custom_values,
            include_null_value=include_null_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_values: 'outputs.AnalysisCustomParameterValues',
             include_null_value: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_values", custom_values)
        if include_null_value is not None:
            _setter("include_null_value", include_null_value)

    @property
    @pulumi.getter(name="customValues")
    def custom_values(self) -> 'outputs.AnalysisCustomParameterValues':
        return pulumi.get(self, "custom_values")

    @property
    @pulumi.getter(name="includeNullValue")
    def include_null_value(self) -> Optional[bool]:
        return pulumi.get(self, "include_null_value")


@pulumi.output_type
class AnalysisDataBarsOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "negativeColor":
            suggest = "negative_color"
        elif key == "positiveColor":
            suggest = "positive_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDataBarsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDataBarsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDataBarsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 negative_color: Optional[str] = None,
                 positive_color: Optional[str] = None):
        AnalysisDataBarsOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            negative_color=negative_color,
            positive_color=positive_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             negative_color: Optional[str] = None,
             positive_color: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if negative_color is not None:
            _setter("negative_color", negative_color)
        if positive_color is not None:
            _setter("positive_color", positive_color)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="negativeColor")
    def negative_color(self) -> Optional[str]:
        return pulumi.get(self, "negative_color")

    @property
    @pulumi.getter(name="positiveColor")
    def positive_color(self) -> Optional[str]:
        return pulumi.get(self, "positive_color")


@pulumi.output_type
class AnalysisDataColor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataValue":
            suggest = "data_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDataColor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDataColor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDataColor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: Optional[str] = None,
                 data_value: Optional[float] = None):
        AnalysisDataColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            data_value=data_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             data_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if data_value is not None:
            _setter("data_value", data_value)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="dataValue")
    def data_value(self) -> Optional[float]:
        return pulumi.get(self, "data_value")


@pulumi.output_type
class AnalysisDataFieldSeriesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "fieldId":
            suggest = "field_id"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDataFieldSeriesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDataFieldSeriesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDataFieldSeriesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: 'AnalysisAxisBinding',
                 field_id: str,
                 field_value: Optional[str] = None,
                 settings: Optional['outputs.AnalysisLineChartSeriesSettings'] = None):
        AnalysisDataFieldSeriesItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            field_id=field_id,
            field_value=field_value,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: 'AnalysisAxisBinding',
             field_id: str,
             field_value: Optional[str] = None,
             settings: Optional['outputs.AnalysisLineChartSeriesSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("axis_binding", axis_binding)
        _setter("field_id", field_id)
        if field_value is not None:
            _setter("field_value", field_value)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> 'AnalysisAxisBinding':
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[str]:
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.AnalysisLineChartSeriesSettings']:
        return pulumi.get(self, "settings")


@pulumi.output_type
class AnalysisDataLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelVisibility":
            suggest = "category_label_visibility"
        elif key == "dataLabelTypes":
            suggest = "data_label_types"
        elif key == "labelColor":
            suggest = "label_color"
        elif key == "labelContent":
            suggest = "label_content"
        elif key == "labelFontConfiguration":
            suggest = "label_font_configuration"
        elif key == "measureLabelVisibility":
            suggest = "measure_label_visibility"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDataLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDataLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDataLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_visibility: Optional['AnalysisVisibility'] = None,
                 data_label_types: Optional[Sequence['outputs.AnalysisDataLabelType']] = None,
                 label_color: Optional[str] = None,
                 label_content: Optional['AnalysisDataLabelContent'] = None,
                 label_font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
                 measure_label_visibility: Optional['AnalysisVisibility'] = None,
                 overlap: Optional['AnalysisDataLabelOverlap'] = None,
                 position: Optional['AnalysisDataLabelPosition'] = None,
                 totals_visibility: Optional['AnalysisVisibility'] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisDataLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_visibility=category_label_visibility,
            data_label_types=data_label_types,
            label_color=label_color,
            label_content=label_content,
            label_font_configuration=label_font_configuration,
            measure_label_visibility=measure_label_visibility,
            overlap=overlap,
            position=position,
            totals_visibility=totals_visibility,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_visibility: Optional['AnalysisVisibility'] = None,
             data_label_types: Optional[Sequence['outputs.AnalysisDataLabelType']] = None,
             label_color: Optional[str] = None,
             label_content: Optional['AnalysisDataLabelContent'] = None,
             label_font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
             measure_label_visibility: Optional['AnalysisVisibility'] = None,
             overlap: Optional['AnalysisDataLabelOverlap'] = None,
             position: Optional['AnalysisDataLabelPosition'] = None,
             totals_visibility: Optional['AnalysisVisibility'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_visibility is not None:
            _setter("category_label_visibility", category_label_visibility)
        if data_label_types is not None:
            _setter("data_label_types", data_label_types)
        if label_color is not None:
            _setter("label_color", label_color)
        if label_content is not None:
            _setter("label_content", label_content)
        if label_font_configuration is not None:
            _setter("label_font_configuration", label_font_configuration)
        if measure_label_visibility is not None:
            _setter("measure_label_visibility", measure_label_visibility)
        if overlap is not None:
            _setter("overlap", overlap)
        if position is not None:
            _setter("position", position)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="categoryLabelVisibility")
    def category_label_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "category_label_visibility")

    @property
    @pulumi.getter(name="dataLabelTypes")
    def data_label_types(self) -> Optional[Sequence['outputs.AnalysisDataLabelType']]:
        return pulumi.get(self, "data_label_types")

    @property
    @pulumi.getter(name="labelColor")
    def label_color(self) -> Optional[str]:
        return pulumi.get(self, "label_color")

    @property
    @pulumi.getter(name="labelContent")
    def label_content(self) -> Optional['AnalysisDataLabelContent']:
        return pulumi.get(self, "label_content")

    @property
    @pulumi.getter(name="labelFontConfiguration")
    def label_font_configuration(self) -> Optional['outputs.AnalysisFontConfiguration']:
        return pulumi.get(self, "label_font_configuration")

    @property
    @pulumi.getter(name="measureLabelVisibility")
    def measure_label_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "measure_label_visibility")

    @property
    @pulumi.getter
    def overlap(self) -> Optional['AnalysisDataLabelOverlap']:
        return pulumi.get(self, "overlap")

    @property
    @pulumi.getter
    def position(self) -> Optional['AnalysisDataLabelPosition']:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "totals_visibility")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisDataLabelType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPathLabelType":
            suggest = "data_path_label_type"
        elif key == "fieldLabelType":
            suggest = "field_label_type"
        elif key == "maximumLabelType":
            suggest = "maximum_label_type"
        elif key == "minimumLabelType":
            suggest = "minimum_label_type"
        elif key == "rangeEndsLabelType":
            suggest = "range_ends_label_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDataLabelType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDataLabelType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDataLabelType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_path_label_type: Optional['outputs.AnalysisDataPathLabelType'] = None,
                 field_label_type: Optional['outputs.AnalysisFieldLabelType'] = None,
                 maximum_label_type: Optional['outputs.AnalysisMaximumLabelType'] = None,
                 minimum_label_type: Optional['outputs.AnalysisMinimumLabelType'] = None,
                 range_ends_label_type: Optional['outputs.AnalysisRangeEndsLabelType'] = None):
        AnalysisDataLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_path_label_type=data_path_label_type,
            field_label_type=field_label_type,
            maximum_label_type=maximum_label_type,
            minimum_label_type=minimum_label_type,
            range_ends_label_type=range_ends_label_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_path_label_type: Optional['outputs.AnalysisDataPathLabelType'] = None,
             field_label_type: Optional['outputs.AnalysisFieldLabelType'] = None,
             maximum_label_type: Optional['outputs.AnalysisMaximumLabelType'] = None,
             minimum_label_type: Optional['outputs.AnalysisMinimumLabelType'] = None,
             range_ends_label_type: Optional['outputs.AnalysisRangeEndsLabelType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_path_label_type is not None:
            _setter("data_path_label_type", data_path_label_type)
        if field_label_type is not None:
            _setter("field_label_type", field_label_type)
        if maximum_label_type is not None:
            _setter("maximum_label_type", maximum_label_type)
        if minimum_label_type is not None:
            _setter("minimum_label_type", minimum_label_type)
        if range_ends_label_type is not None:
            _setter("range_ends_label_type", range_ends_label_type)

    @property
    @pulumi.getter(name="dataPathLabelType")
    def data_path_label_type(self) -> Optional['outputs.AnalysisDataPathLabelType']:
        return pulumi.get(self, "data_path_label_type")

    @property
    @pulumi.getter(name="fieldLabelType")
    def field_label_type(self) -> Optional['outputs.AnalysisFieldLabelType']:
        return pulumi.get(self, "field_label_type")

    @property
    @pulumi.getter(name="maximumLabelType")
    def maximum_label_type(self) -> Optional['outputs.AnalysisMaximumLabelType']:
        return pulumi.get(self, "maximum_label_type")

    @property
    @pulumi.getter(name="minimumLabelType")
    def minimum_label_type(self) -> Optional['outputs.AnalysisMinimumLabelType']:
        return pulumi.get(self, "minimum_label_type")

    @property
    @pulumi.getter(name="rangeEndsLabelType")
    def range_ends_label_type(self) -> Optional['outputs.AnalysisRangeEndsLabelType']:
        return pulumi.get(self, "range_ends_label_type")


@pulumi.output_type
class AnalysisDataPathColor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDataPathColor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDataPathColor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDataPathColor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: str,
                 element: 'outputs.AnalysisDataPathValue',
                 time_granularity: Optional['AnalysisTimeGranularity'] = None):
        AnalysisDataPathColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            element=element,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: str,
             element: 'outputs.AnalysisDataPathValue',
             time_granularity: Optional['AnalysisTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)
        _setter("element", element)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def element(self) -> 'outputs.AnalysisDataPathValue':
        return pulumi.get(self, "element")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['AnalysisTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class AnalysisDataPathLabelType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDataPathLabelType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDataPathLabelType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDataPathLabelType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: Optional[str] = None,
                 field_value: Optional[str] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisDataPathLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            field_value=field_value,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: Optional[str] = None,
             field_value: Optional[str] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_id is not None:
            _setter("field_id", field_id)
        if field_value is not None:
            _setter("field_value", field_value)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[str]:
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisDataPathSort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortPaths":
            suggest = "sort_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDataPathSort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDataPathSort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDataPathSort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: 'AnalysisSortDirection',
                 sort_paths: Sequence['outputs.AnalysisDataPathValue']):
        AnalysisDataPathSort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            sort_paths=sort_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: 'AnalysisSortDirection',
             sort_paths: Sequence['outputs.AnalysisDataPathValue'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("direction", direction)
        _setter("sort_paths", sort_paths)

    @property
    @pulumi.getter
    def direction(self) -> 'AnalysisSortDirection':
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="sortPaths")
    def sort_paths(self) -> Sequence['outputs.AnalysisDataPathValue']:
        return pulumi.get(self, "sort_paths")


@pulumi.output_type
class AnalysisDataPathValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDataPathValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDataPathValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDataPathValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 field_value: str):
        AnalysisDataPathValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            field_value=field_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             field_value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        _setter("field_value", field_value)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> str:
        return pulumi.get(self, "field_value")


@pulumi.output_type
class AnalysisDataSetIdentifierDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetArn":
            suggest = "data_set_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDataSetIdentifierDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDataSetIdentifierDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDataSetIdentifierDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_arn: str,
                 identifier: str):
        AnalysisDataSetIdentifierDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_arn=data_set_arn,
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_arn: str,
             identifier: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_arn", data_set_arn)
        _setter("identifier", identifier)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> str:
        return pulumi.get(self, "data_set_arn")

    @property
    @pulumi.getter
    def identifier(self) -> str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class AnalysisDataSetReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetArn":
            suggest = "data_set_arn"
        elif key == "dataSetPlaceholder":
            suggest = "data_set_placeholder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDataSetReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDataSetReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDataSetReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_arn: str,
                 data_set_placeholder: str):
        AnalysisDataSetReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_arn=data_set_arn,
            data_set_placeholder=data_set_placeholder,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_arn: str,
             data_set_placeholder: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_arn", data_set_arn)
        _setter("data_set_placeholder", data_set_placeholder)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> str:
        return pulumi.get(self, "data_set_arn")

    @property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> str:
        return pulumi.get(self, "data_set_placeholder")


@pulumi.output_type
class AnalysisDateAxisOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "missingDateVisibility":
            suggest = "missing_date_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDateAxisOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDateAxisOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDateAxisOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 missing_date_visibility: Optional['AnalysisVisibility'] = None):
        AnalysisDateAxisOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            missing_date_visibility=missing_date_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             missing_date_visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if missing_date_visibility is not None:
            _setter("missing_date_visibility", missing_date_visibility)

    @property
    @pulumi.getter(name="missingDateVisibility")
    def missing_date_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "missing_date_visibility")


@pulumi.output_type
class AnalysisDateDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "dateGranularity":
            suggest = "date_granularity"
        elif key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "hierarchyId":
            suggest = "hierarchy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDateDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDateDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDateDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 field_id: str,
                 date_granularity: Optional['AnalysisTimeGranularity'] = None,
                 format_configuration: Optional['outputs.AnalysisDateTimeFormatConfiguration'] = None,
                 hierarchy_id: Optional[str] = None):
        AnalysisDateDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            date_granularity=date_granularity,
            format_configuration=format_configuration,
            hierarchy_id=hierarchy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             field_id: str,
             date_granularity: Optional['AnalysisTimeGranularity'] = None,
             format_configuration: Optional['outputs.AnalysisDateTimeFormatConfiguration'] = None,
             hierarchy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if date_granularity is not None:
            _setter("date_granularity", date_granularity)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if hierarchy_id is not None:
            _setter("hierarchy_id", hierarchy_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="dateGranularity")
    def date_granularity(self) -> Optional['AnalysisTimeGranularity']:
        return pulumi.get(self, "date_granularity")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.AnalysisDateTimeFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> Optional[str]:
        return pulumi.get(self, "hierarchy_id")


@pulumi.output_type
class AnalysisDateMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDateMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDateMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDateMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 field_id: str,
                 aggregation_function: Optional['AnalysisDateAggregationFunction'] = None,
                 format_configuration: Optional['outputs.AnalysisDateTimeFormatConfiguration'] = None):
        AnalysisDateMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            aggregation_function=aggregation_function,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             field_id: str,
             aggregation_function: Optional['AnalysisDateAggregationFunction'] = None,
             format_configuration: Optional['outputs.AnalysisDateTimeFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['AnalysisDateAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.AnalysisDateTimeFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class AnalysisDateTimeDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "rollingDate":
            suggest = "rolling_date"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDateTimeDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDateTimeDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDateTimeDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.AnalysisDynamicDefaultValue'] = None,
                 rolling_date: Optional['outputs.AnalysisRollingDateConfiguration'] = None,
                 static_values: Optional[Sequence[str]] = None):
        AnalysisDateTimeDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            rolling_date=rolling_date,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.AnalysisDynamicDefaultValue'] = None,
             rolling_date: Optional['outputs.AnalysisRollingDateConfiguration'] = None,
             static_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if rolling_date is not None:
            _setter("rolling_date", rolling_date)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.AnalysisDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="rollingDate")
    def rolling_date(self) -> Optional['outputs.AnalysisRollingDateConfiguration']:
        return pulumi.get(self, "rolling_date")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class AnalysisDateTimeFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormat":
            suggest = "date_time_format"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numericFormatConfiguration":
            suggest = "numeric_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDateTimeFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDateTimeFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDateTimeFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format: Optional[str] = None,
                 null_value_format_configuration: Optional['outputs.AnalysisNullValueFormatConfiguration'] = None,
                 numeric_format_configuration: Optional['outputs.AnalysisNumericFormatConfiguration'] = None):
        AnalysisDateTimeFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format=date_time_format,
            null_value_format_configuration=null_value_format_configuration,
            numeric_format_configuration=numeric_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format: Optional[str] = None,
             null_value_format_configuration: Optional['outputs.AnalysisNullValueFormatConfiguration'] = None,
             numeric_format_configuration: Optional['outputs.AnalysisNumericFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format is not None:
            _setter("date_time_format", date_time_format)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if numeric_format_configuration is not None:
            _setter("numeric_format_configuration", numeric_format_configuration)

    @property
    @pulumi.getter(name="dateTimeFormat")
    def date_time_format(self) -> Optional[str]:
        return pulumi.get(self, "date_time_format")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.AnalysisNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numericFormatConfiguration")
    def numeric_format_configuration(self) -> Optional['outputs.AnalysisNumericFormatConfiguration']:
        return pulumi.get(self, "numeric_format_configuration")


@pulumi.output_type
class AnalysisDateTimeHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hierarchyId":
            suggest = "hierarchy_id"
        elif key == "drillDownFilters":
            suggest = "drill_down_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDateTimeHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDateTimeHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDateTimeHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hierarchy_id: str,
                 drill_down_filters: Optional[Sequence['outputs.AnalysisDrillDownFilter']] = None):
        AnalysisDateTimeHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hierarchy_id=hierarchy_id,
            drill_down_filters=drill_down_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hierarchy_id: str,
             drill_down_filters: Optional[Sequence['outputs.AnalysisDrillDownFilter']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hierarchy_id", hierarchy_id)
        if drill_down_filters is not None:
            _setter("drill_down_filters", drill_down_filters)

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> str:
        return pulumi.get(self, "hierarchy_id")

    @property
    @pulumi.getter(name="drillDownFilters")
    def drill_down_filters(self) -> Optional[Sequence['outputs.AnalysisDrillDownFilter']]:
        return pulumi.get(self, "drill_down_filters")


@pulumi.output_type
class AnalysisDateTimeParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        AnalysisDateTimeParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisDateTimeParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "timeGranularity":
            suggest = "time_granularity"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDateTimeParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDateTimeParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDateTimeParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 default_values: Optional['outputs.AnalysisDateTimeDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.AnalysisMappedDataSetParameter']] = None,
                 time_granularity: Optional['AnalysisTimeGranularity'] = None,
                 value_when_unset: Optional['outputs.AnalysisDateTimeValueWhenUnsetConfiguration'] = None):
        AnalysisDateTimeParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            time_granularity=time_granularity,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             default_values: Optional['outputs.AnalysisDateTimeDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.AnalysisMappedDataSetParameter']] = None,
             time_granularity: Optional['AnalysisTimeGranularity'] = None,
             value_when_unset: Optional['outputs.AnalysisDateTimeValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.AnalysisDateTimeDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.AnalysisMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['AnalysisTimeGranularity']:
        return pulumi.get(self, "time_granularity")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.AnalysisDateTimeValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class AnalysisDateTimePickerControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormat":
            suggest = "date_time_format"
        elif key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDateTimePickerControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDateTimePickerControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDateTimePickerControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format: Optional[str] = None,
                 info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
                 title_options: Optional['outputs.AnalysisLabelOptions'] = None):
        AnalysisDateTimePickerControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format=date_time_format,
            info_icon_label_options=info_icon_label_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format: Optional[str] = None,
             info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
             title_options: Optional['outputs.AnalysisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format is not None:
            _setter("date_time_format", date_time_format)
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="dateTimeFormat")
    def date_time_format(self) -> Optional[str]:
        return pulumi.get(self, "date_time_format")

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.AnalysisSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.AnalysisLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class AnalysisDateTimeValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDateTimeValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDateTimeValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDateTimeValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[str] = None,
                 value_when_unset_option: Optional['AnalysisValueWhenUnsetOption'] = None):
        AnalysisDateTimeValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[str] = None,
             value_when_unset_option: Optional['AnalysisValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[str]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['AnalysisValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class AnalysisDecimalDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDecimalDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDecimalDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDecimalDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.AnalysisDynamicDefaultValue'] = None,
                 static_values: Optional[Sequence[float]] = None):
        AnalysisDecimalDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.AnalysisDynamicDefaultValue'] = None,
             static_values: Optional[Sequence[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.AnalysisDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class AnalysisDecimalParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[float]):
        AnalysisDecimalParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[float],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[float]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisDecimalParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueType":
            suggest = "parameter_value_type"
        elif key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDecimalParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDecimalParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDecimalParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 parameter_value_type: 'AnalysisParameterValueType',
                 default_values: Optional['outputs.AnalysisDecimalDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.AnalysisMappedDataSetParameter']] = None,
                 value_when_unset: Optional['outputs.AnalysisDecimalValueWhenUnsetConfiguration'] = None):
        AnalysisDecimalParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameter_value_type=parameter_value_type,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             parameter_value_type: 'AnalysisParameterValueType',
             default_values: Optional['outputs.AnalysisDecimalDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.AnalysisMappedDataSetParameter']] = None,
             value_when_unset: Optional['outputs.AnalysisDecimalValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("parameter_value_type", parameter_value_type)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterValueType")
    def parameter_value_type(self) -> 'AnalysisParameterValueType':
        return pulumi.get(self, "parameter_value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.AnalysisDecimalDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.AnalysisMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.AnalysisDecimalValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class AnalysisDecimalPlacesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlaces":
            suggest = "decimal_places"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDecimalPlacesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDecimalPlacesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDecimalPlacesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places: float):
        AnalysisDecimalPlacesConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places=decimal_places,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("decimal_places", decimal_places)

    @property
    @pulumi.getter(name="decimalPlaces")
    def decimal_places(self) -> float:
        return pulumi.get(self, "decimal_places")


@pulumi.output_type
class AnalysisDecimalValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDecimalValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDecimalValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDecimalValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[float] = None,
                 value_when_unset_option: Optional['AnalysisValueWhenUnsetOption'] = None):
        AnalysisDecimalValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[float] = None,
             value_when_unset_option: Optional['AnalysisValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[float]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['AnalysisValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class AnalysisDefaultFreeFormLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDefaultFreeFormLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDefaultFreeFormLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDefaultFreeFormLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canvas_size_options: 'outputs.AnalysisFreeFormLayoutCanvasSizeOptions'):
        AnalysisDefaultFreeFormLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canvas_size_options: 'outputs.AnalysisFreeFormLayoutCanvasSizeOptions',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.AnalysisFreeFormLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class AnalysisDefaultGridLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDefaultGridLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDefaultGridLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDefaultGridLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canvas_size_options: 'outputs.AnalysisGridLayoutCanvasSizeOptions'):
        AnalysisDefaultGridLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canvas_size_options: 'outputs.AnalysisGridLayoutCanvasSizeOptions',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.AnalysisGridLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class AnalysisDefaultInteractiveLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeForm":
            suggest = "free_form"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDefaultInteractiveLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDefaultInteractiveLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDefaultInteractiveLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_form: Optional['outputs.AnalysisDefaultFreeFormLayoutConfiguration'] = None,
                 grid: Optional['outputs.AnalysisDefaultGridLayoutConfiguration'] = None):
        AnalysisDefaultInteractiveLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            free_form=free_form,
            grid=grid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             free_form: Optional['outputs.AnalysisDefaultFreeFormLayoutConfiguration'] = None,
             grid: Optional['outputs.AnalysisDefaultGridLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if free_form is not None:
            _setter("free_form", free_form)
        if grid is not None:
            _setter("grid", grid)

    @property
    @pulumi.getter(name="freeForm")
    def free_form(self) -> Optional['outputs.AnalysisDefaultFreeFormLayoutConfiguration']:
        return pulumi.get(self, "free_form")

    @property
    @pulumi.getter
    def grid(self) -> Optional['outputs.AnalysisDefaultGridLayoutConfiguration']:
        return pulumi.get(self, "grid")


@pulumi.output_type
class AnalysisDefaultNewSheetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interactiveLayoutConfiguration":
            suggest = "interactive_layout_configuration"
        elif key == "paginatedLayoutConfiguration":
            suggest = "paginated_layout_configuration"
        elif key == "sheetContentType":
            suggest = "sheet_content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDefaultNewSheetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDefaultNewSheetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDefaultNewSheetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interactive_layout_configuration: Optional['outputs.AnalysisDefaultInteractiveLayoutConfiguration'] = None,
                 paginated_layout_configuration: Optional['outputs.AnalysisDefaultPaginatedLayoutConfiguration'] = None,
                 sheet_content_type: Optional['AnalysisSheetContentType'] = None):
        AnalysisDefaultNewSheetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interactive_layout_configuration=interactive_layout_configuration,
            paginated_layout_configuration=paginated_layout_configuration,
            sheet_content_type=sheet_content_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interactive_layout_configuration: Optional['outputs.AnalysisDefaultInteractiveLayoutConfiguration'] = None,
             paginated_layout_configuration: Optional['outputs.AnalysisDefaultPaginatedLayoutConfiguration'] = None,
             sheet_content_type: Optional['AnalysisSheetContentType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if interactive_layout_configuration is not None:
            _setter("interactive_layout_configuration", interactive_layout_configuration)
        if paginated_layout_configuration is not None:
            _setter("paginated_layout_configuration", paginated_layout_configuration)
        if sheet_content_type is not None:
            _setter("sheet_content_type", sheet_content_type)

    @property
    @pulumi.getter(name="interactiveLayoutConfiguration")
    def interactive_layout_configuration(self) -> Optional['outputs.AnalysisDefaultInteractiveLayoutConfiguration']:
        return pulumi.get(self, "interactive_layout_configuration")

    @property
    @pulumi.getter(name="paginatedLayoutConfiguration")
    def paginated_layout_configuration(self) -> Optional['outputs.AnalysisDefaultPaginatedLayoutConfiguration']:
        return pulumi.get(self, "paginated_layout_configuration")

    @property
    @pulumi.getter(name="sheetContentType")
    def sheet_content_type(self) -> Optional['AnalysisSheetContentType']:
        return pulumi.get(self, "sheet_content_type")


@pulumi.output_type
class AnalysisDefaultPaginatedLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionBased":
            suggest = "section_based"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDefaultPaginatedLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDefaultPaginatedLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDefaultPaginatedLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 section_based: Optional['outputs.AnalysisDefaultSectionBasedLayoutConfiguration'] = None):
        AnalysisDefaultPaginatedLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            section_based=section_based,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             section_based: Optional['outputs.AnalysisDefaultSectionBasedLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if section_based is not None:
            _setter("section_based", section_based)

    @property
    @pulumi.getter(name="sectionBased")
    def section_based(self) -> Optional['outputs.AnalysisDefaultSectionBasedLayoutConfiguration']:
        return pulumi.get(self, "section_based")


@pulumi.output_type
class AnalysisDefaultSectionBasedLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDefaultSectionBasedLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDefaultSectionBasedLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDefaultSectionBasedLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canvas_size_options: 'outputs.AnalysisSectionBasedLayoutCanvasSizeOptions'):
        AnalysisDefaultSectionBasedLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canvas_size_options: 'outputs.AnalysisSectionBasedLayoutCanvasSizeOptions',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.AnalysisSectionBasedLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class AnalysisDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultNewSheetConfiguration":
            suggest = "default_new_sheet_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_new_sheet_configuration: 'outputs.AnalysisDefaultNewSheetConfiguration'):
        AnalysisDefaults._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_new_sheet_configuration=default_new_sheet_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_new_sheet_configuration: 'outputs.AnalysisDefaultNewSheetConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_new_sheet_configuration", default_new_sheet_configuration)

    @property
    @pulumi.getter(name="defaultNewSheetConfiguration")
    def default_new_sheet_configuration(self) -> 'outputs.AnalysisDefaultNewSheetConfiguration':
        return pulumi.get(self, "default_new_sheet_configuration")


@pulumi.output_type
class AnalysisDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifierDeclarations":
            suggest = "data_set_identifier_declarations"
        elif key == "analysisDefaults":
            suggest = "analysis_defaults"
        elif key == "calculatedFields":
            suggest = "calculated_fields"
        elif key == "columnConfigurations":
            suggest = "column_configurations"
        elif key == "filterGroups":
            suggest = "filter_groups"
        elif key == "parameterDeclarations":
            suggest = "parameter_declarations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier_declarations: Sequence['outputs.AnalysisDataSetIdentifierDeclaration'],
                 analysis_defaults: Optional['outputs.AnalysisDefaults'] = None,
                 calculated_fields: Optional[Sequence['outputs.AnalysisCalculatedField']] = None,
                 column_configurations: Optional[Sequence['outputs.AnalysisColumnConfiguration']] = None,
                 filter_groups: Optional[Sequence['outputs.AnalysisFilterGroup']] = None,
                 parameter_declarations: Optional[Sequence['outputs.AnalysisParameterDeclaration']] = None,
                 sheets: Optional[Sequence['outputs.AnalysisSheetDefinition']] = None):
        AnalysisDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier_declarations=data_set_identifier_declarations,
            analysis_defaults=analysis_defaults,
            calculated_fields=calculated_fields,
            column_configurations=column_configurations,
            filter_groups=filter_groups,
            parameter_declarations=parameter_declarations,
            sheets=sheets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier_declarations: Sequence['outputs.AnalysisDataSetIdentifierDeclaration'],
             analysis_defaults: Optional['outputs.AnalysisDefaults'] = None,
             calculated_fields: Optional[Sequence['outputs.AnalysisCalculatedField']] = None,
             column_configurations: Optional[Sequence['outputs.AnalysisColumnConfiguration']] = None,
             filter_groups: Optional[Sequence['outputs.AnalysisFilterGroup']] = None,
             parameter_declarations: Optional[Sequence['outputs.AnalysisParameterDeclaration']] = None,
             sheets: Optional[Sequence['outputs.AnalysisSheetDefinition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier_declarations", data_set_identifier_declarations)
        if analysis_defaults is not None:
            _setter("analysis_defaults", analysis_defaults)
        if calculated_fields is not None:
            _setter("calculated_fields", calculated_fields)
        if column_configurations is not None:
            _setter("column_configurations", column_configurations)
        if filter_groups is not None:
            _setter("filter_groups", filter_groups)
        if parameter_declarations is not None:
            _setter("parameter_declarations", parameter_declarations)
        if sheets is not None:
            _setter("sheets", sheets)

    @property
    @pulumi.getter(name="dataSetIdentifierDeclarations")
    def data_set_identifier_declarations(self) -> Sequence['outputs.AnalysisDataSetIdentifierDeclaration']:
        return pulumi.get(self, "data_set_identifier_declarations")

    @property
    @pulumi.getter(name="analysisDefaults")
    def analysis_defaults(self) -> Optional['outputs.AnalysisDefaults']:
        return pulumi.get(self, "analysis_defaults")

    @property
    @pulumi.getter(name="calculatedFields")
    def calculated_fields(self) -> Optional[Sequence['outputs.AnalysisCalculatedField']]:
        return pulumi.get(self, "calculated_fields")

    @property
    @pulumi.getter(name="columnConfigurations")
    def column_configurations(self) -> Optional[Sequence['outputs.AnalysisColumnConfiguration']]:
        return pulumi.get(self, "column_configurations")

    @property
    @pulumi.getter(name="filterGroups")
    def filter_groups(self) -> Optional[Sequence['outputs.AnalysisFilterGroup']]:
        return pulumi.get(self, "filter_groups")

    @property
    @pulumi.getter(name="parameterDeclarations")
    def parameter_declarations(self) -> Optional[Sequence['outputs.AnalysisParameterDeclaration']]:
        return pulumi.get(self, "parameter_declarations")

    @property
    @pulumi.getter
    def sheets(self) -> Optional[Sequence['outputs.AnalysisSheetDefinition']]:
        return pulumi.get(self, "sheets")


@pulumi.output_type
class AnalysisDestinationParameterValueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValuesConfiguration":
            suggest = "custom_values_configuration"
        elif key == "selectAllValueOptions":
            suggest = "select_all_value_options"
        elif key == "sourceColumn":
            suggest = "source_column"
        elif key == "sourceField":
            suggest = "source_field"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDestinationParameterValueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDestinationParameterValueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDestinationParameterValueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_values_configuration: Optional['outputs.AnalysisCustomValuesConfiguration'] = None,
                 select_all_value_options: Optional['AnalysisSelectAllValueOptions'] = None,
                 source_column: Optional['outputs.AnalysisColumnIdentifier'] = None,
                 source_field: Optional[str] = None,
                 source_parameter_name: Optional[str] = None):
        AnalysisDestinationParameterValueConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_values_configuration=custom_values_configuration,
            select_all_value_options=select_all_value_options,
            source_column=source_column,
            source_field=source_field,
            source_parameter_name=source_parameter_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_values_configuration: Optional['outputs.AnalysisCustomValuesConfiguration'] = None,
             select_all_value_options: Optional['AnalysisSelectAllValueOptions'] = None,
             source_column: Optional['outputs.AnalysisColumnIdentifier'] = None,
             source_field: Optional[str] = None,
             source_parameter_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_values_configuration is not None:
            _setter("custom_values_configuration", custom_values_configuration)
        if select_all_value_options is not None:
            _setter("select_all_value_options", select_all_value_options)
        if source_column is not None:
            _setter("source_column", source_column)
        if source_field is not None:
            _setter("source_field", source_field)
        if source_parameter_name is not None:
            _setter("source_parameter_name", source_parameter_name)

    @property
    @pulumi.getter(name="customValuesConfiguration")
    def custom_values_configuration(self) -> Optional['outputs.AnalysisCustomValuesConfiguration']:
        return pulumi.get(self, "custom_values_configuration")

    @property
    @pulumi.getter(name="selectAllValueOptions")
    def select_all_value_options(self) -> Optional['AnalysisSelectAllValueOptions']:
        return pulumi.get(self, "select_all_value_options")

    @property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> Optional['outputs.AnalysisColumnIdentifier']:
        return pulumi.get(self, "source_column")

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[str]:
        return pulumi.get(self, "source_field")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "source_parameter_name")


@pulumi.output_type
class AnalysisDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoricalDimensionField":
            suggest = "categorical_dimension_field"
        elif key == "dateDimensionField":
            suggest = "date_dimension_field"
        elif key == "numericalDimensionField":
            suggest = "numerical_dimension_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categorical_dimension_field: Optional['outputs.AnalysisCategoricalDimensionField'] = None,
                 date_dimension_field: Optional['outputs.AnalysisDateDimensionField'] = None,
                 numerical_dimension_field: Optional['outputs.AnalysisNumericalDimensionField'] = None):
        AnalysisDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            categorical_dimension_field=categorical_dimension_field,
            date_dimension_field=date_dimension_field,
            numerical_dimension_field=numerical_dimension_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             categorical_dimension_field: Optional['outputs.AnalysisCategoricalDimensionField'] = None,
             date_dimension_field: Optional['outputs.AnalysisDateDimensionField'] = None,
             numerical_dimension_field: Optional['outputs.AnalysisNumericalDimensionField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if categorical_dimension_field is not None:
            _setter("categorical_dimension_field", categorical_dimension_field)
        if date_dimension_field is not None:
            _setter("date_dimension_field", date_dimension_field)
        if numerical_dimension_field is not None:
            _setter("numerical_dimension_field", numerical_dimension_field)

    @property
    @pulumi.getter(name="categoricalDimensionField")
    def categorical_dimension_field(self) -> Optional['outputs.AnalysisCategoricalDimensionField']:
        return pulumi.get(self, "categorical_dimension_field")

    @property
    @pulumi.getter(name="dateDimensionField")
    def date_dimension_field(self) -> Optional['outputs.AnalysisDateDimensionField']:
        return pulumi.get(self, "date_dimension_field")

    @property
    @pulumi.getter(name="numericalDimensionField")
    def numerical_dimension_field(self) -> Optional['outputs.AnalysisNumericalDimensionField']:
        return pulumi.get(self, "numerical_dimension_field")


@pulumi.output_type
class AnalysisDonutCenterOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelVisibility":
            suggest = "label_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDonutCenterOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDonutCenterOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDonutCenterOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_visibility: Optional['AnalysisVisibility'] = None):
        AnalysisDonutCenterOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_visibility=label_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if label_visibility is not None:
            _setter("label_visibility", label_visibility)

    @property
    @pulumi.getter(name="labelVisibility")
    def label_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "label_visibility")


@pulumi.output_type
class AnalysisDonutOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcOptions":
            suggest = "arc_options"
        elif key == "donutCenterOptions":
            suggest = "donut_center_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDonutOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDonutOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDonutOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc_options: Optional['outputs.AnalysisArcOptions'] = None,
                 donut_center_options: Optional['outputs.AnalysisDonutCenterOptions'] = None):
        AnalysisDonutOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc_options=arc_options,
            donut_center_options=donut_center_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc_options: Optional['outputs.AnalysisArcOptions'] = None,
             donut_center_options: Optional['outputs.AnalysisDonutCenterOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc_options is not None:
            _setter("arc_options", arc_options)
        if donut_center_options is not None:
            _setter("donut_center_options", donut_center_options)

    @property
    @pulumi.getter(name="arcOptions")
    def arc_options(self) -> Optional['outputs.AnalysisArcOptions']:
        return pulumi.get(self, "arc_options")

    @property
    @pulumi.getter(name="donutCenterOptions")
    def donut_center_options(self) -> Optional['outputs.AnalysisDonutCenterOptions']:
        return pulumi.get(self, "donut_center_options")


@pulumi.output_type
class AnalysisDrillDownFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryFilter":
            suggest = "category_filter"
        elif key == "numericEqualityFilter":
            suggest = "numeric_equality_filter"
        elif key == "timeRangeFilter":
            suggest = "time_range_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDrillDownFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDrillDownFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDrillDownFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_filter: Optional['outputs.AnalysisCategoryDrillDownFilter'] = None,
                 numeric_equality_filter: Optional['outputs.AnalysisNumericEqualityDrillDownFilter'] = None,
                 time_range_filter: Optional['outputs.AnalysisTimeRangeDrillDownFilter'] = None):
        AnalysisDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_filter=category_filter,
            numeric_equality_filter=numeric_equality_filter,
            time_range_filter=time_range_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_filter: Optional['outputs.AnalysisCategoryDrillDownFilter'] = None,
             numeric_equality_filter: Optional['outputs.AnalysisNumericEqualityDrillDownFilter'] = None,
             time_range_filter: Optional['outputs.AnalysisTimeRangeDrillDownFilter'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_filter is not None:
            _setter("category_filter", category_filter)
        if numeric_equality_filter is not None:
            _setter("numeric_equality_filter", numeric_equality_filter)
        if time_range_filter is not None:
            _setter("time_range_filter", time_range_filter)

    @property
    @pulumi.getter(name="categoryFilter")
    def category_filter(self) -> Optional['outputs.AnalysisCategoryDrillDownFilter']:
        return pulumi.get(self, "category_filter")

    @property
    @pulumi.getter(name="numericEqualityFilter")
    def numeric_equality_filter(self) -> Optional['outputs.AnalysisNumericEqualityDrillDownFilter']:
        return pulumi.get(self, "numeric_equality_filter")

    @property
    @pulumi.getter(name="timeRangeFilter")
    def time_range_filter(self) -> Optional['outputs.AnalysisTimeRangeDrillDownFilter']:
        return pulumi.get(self, "time_range_filter")


@pulumi.output_type
class AnalysisDropDownControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "selectAllOptions":
            suggest = "select_all_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDropDownControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDropDownControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDropDownControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
                 select_all_options: Optional['outputs.AnalysisListControlSelectAllOptions'] = None,
                 title_options: Optional['outputs.AnalysisLabelOptions'] = None):
        AnalysisDropDownControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            select_all_options=select_all_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
             select_all_options: Optional['outputs.AnalysisListControlSelectAllOptions'] = None,
             title_options: Optional['outputs.AnalysisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.AnalysisSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['outputs.AnalysisListControlSelectAllOptions']:
        return pulumi.get(self, "select_all_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.AnalysisLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class AnalysisDynamicDefaultValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValueColumn":
            suggest = "default_value_column"
        elif key == "groupNameColumn":
            suggest = "group_name_column"
        elif key == "userNameColumn":
            suggest = "user_name_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisDynamicDefaultValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisDynamicDefaultValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisDynamicDefaultValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value_column: 'outputs.AnalysisColumnIdentifier',
                 group_name_column: Optional['outputs.AnalysisColumnIdentifier'] = None,
                 user_name_column: Optional['outputs.AnalysisColumnIdentifier'] = None):
        AnalysisDynamicDefaultValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_value_column=default_value_column,
            group_name_column=group_name_column,
            user_name_column=user_name_column,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_value_column: 'outputs.AnalysisColumnIdentifier',
             group_name_column: Optional['outputs.AnalysisColumnIdentifier'] = None,
             user_name_column: Optional['outputs.AnalysisColumnIdentifier'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_value_column", default_value_column)
        if group_name_column is not None:
            _setter("group_name_column", group_name_column)
        if user_name_column is not None:
            _setter("user_name_column", user_name_column)

    @property
    @pulumi.getter(name="defaultValueColumn")
    def default_value_column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "default_value_column")

    @property
    @pulumi.getter(name="groupNameColumn")
    def group_name_column(self) -> Optional['outputs.AnalysisColumnIdentifier']:
        return pulumi.get(self, "group_name_column")

    @property
    @pulumi.getter(name="userNameColumn")
    def user_name_column(self) -> Optional['outputs.AnalysisColumnIdentifier']:
        return pulumi.get(self, "user_name_column")


@pulumi.output_type
class AnalysisEmptyVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "visualId":
            suggest = "visual_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisEmptyVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisEmptyVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisEmptyVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None):
        AnalysisEmptyVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            visual_id=visual_id,
            actions=actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")


@pulumi.output_type
class AnalysisEntity(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None):
        AnalysisEntity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class AnalysisError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "violatedEntities":
            suggest = "violated_entities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: Optional[str] = None,
                 type: Optional['AnalysisErrorType'] = None,
                 violated_entities: Optional[Sequence['outputs.AnalysisEntity']] = None):
        AnalysisError._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
            type=type,
            violated_entities=violated_entities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: Optional[str] = None,
             type: Optional['AnalysisErrorType'] = None,
             violated_entities: Optional[Sequence['outputs.AnalysisEntity']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if message is not None:
            _setter("message", message)
        if type is not None:
            _setter("type", type)
        if violated_entities is not None:
            _setter("violated_entities", violated_entities)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def type(self) -> Optional['AnalysisErrorType']:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="violatedEntities")
    def violated_entities(self) -> Optional[Sequence['outputs.AnalysisEntity']]:
        return pulumi.get(self, "violated_entities")


@pulumi.output_type
class AnalysisExcludePeriodConfiguration(dict):
    def __init__(__self__, *,
                 amount: float,
                 granularity: 'AnalysisTimeGranularity',
                 status: Optional['AnalysisWidgetStatus'] = None):
        AnalysisExcludePeriodConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amount=amount,
            granularity=granularity,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amount: float,
             granularity: 'AnalysisTimeGranularity',
             status: Optional['AnalysisWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("amount", amount)
        _setter("granularity", granularity)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def amount(self) -> float:
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def granularity(self) -> 'AnalysisTimeGranularity':
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter
    def status(self) -> Optional['AnalysisWidgetStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class AnalysisExplicitHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hierarchyId":
            suggest = "hierarchy_id"
        elif key == "drillDownFilters":
            suggest = "drill_down_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisExplicitHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisExplicitHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisExplicitHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence['outputs.AnalysisColumnIdentifier'],
                 hierarchy_id: str,
                 drill_down_filters: Optional[Sequence['outputs.AnalysisDrillDownFilter']] = None):
        AnalysisExplicitHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            hierarchy_id=hierarchy_id,
            drill_down_filters=drill_down_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Sequence['outputs.AnalysisColumnIdentifier'],
             hierarchy_id: str,
             drill_down_filters: Optional[Sequence['outputs.AnalysisDrillDownFilter']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("columns", columns)
        _setter("hierarchy_id", hierarchy_id)
        if drill_down_filters is not None:
            _setter("drill_down_filters", drill_down_filters)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.AnalysisColumnIdentifier']:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> str:
        return pulumi.get(self, "hierarchy_id")

    @property
    @pulumi.getter(name="drillDownFilters")
    def drill_down_filters(self) -> Optional[Sequence['outputs.AnalysisDrillDownFilter']]:
        return pulumi.get(self, "drill_down_filters")


@pulumi.output_type
class AnalysisFieldBasedTooltip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationVisibility":
            suggest = "aggregation_visibility"
        elif key == "tooltipFields":
            suggest = "tooltip_fields"
        elif key == "tooltipTitleType":
            suggest = "tooltip_title_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFieldBasedTooltip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFieldBasedTooltip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFieldBasedTooltip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_visibility: Optional['AnalysisVisibility'] = None,
                 tooltip_fields: Optional[Sequence['outputs.AnalysisTooltipItem']] = None,
                 tooltip_title_type: Optional['AnalysisTooltipTitleType'] = None):
        AnalysisFieldBasedTooltip._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_visibility=aggregation_visibility,
            tooltip_fields=tooltip_fields,
            tooltip_title_type=tooltip_title_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_visibility: Optional['AnalysisVisibility'] = None,
             tooltip_fields: Optional[Sequence['outputs.AnalysisTooltipItem']] = None,
             tooltip_title_type: Optional['AnalysisTooltipTitleType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregation_visibility is not None:
            _setter("aggregation_visibility", aggregation_visibility)
        if tooltip_fields is not None:
            _setter("tooltip_fields", tooltip_fields)
        if tooltip_title_type is not None:
            _setter("tooltip_title_type", tooltip_title_type)

    @property
    @pulumi.getter(name="aggregationVisibility")
    def aggregation_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "aggregation_visibility")

    @property
    @pulumi.getter(name="tooltipFields")
    def tooltip_fields(self) -> Optional[Sequence['outputs.AnalysisTooltipItem']]:
        return pulumi.get(self, "tooltip_fields")

    @property
    @pulumi.getter(name="tooltipTitleType")
    def tooltip_title_type(self) -> Optional['AnalysisTooltipTitleType']:
        return pulumi.get(self, "tooltip_title_type")


@pulumi.output_type
class AnalysisFieldLabelType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFieldLabelType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFieldLabelType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFieldLabelType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: Optional[str] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisFieldLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: Optional[str] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_id is not None:
            _setter("field_id", field_id)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisFieldSeriesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFieldSeriesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFieldSeriesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFieldSeriesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: 'AnalysisAxisBinding',
                 field_id: str,
                 settings: Optional['outputs.AnalysisLineChartSeriesSettings'] = None):
        AnalysisFieldSeriesItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            field_id=field_id,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: 'AnalysisAxisBinding',
             field_id: str,
             settings: Optional['outputs.AnalysisLineChartSeriesSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("axis_binding", axis_binding)
        _setter("field_id", field_id)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> 'AnalysisAxisBinding':
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.AnalysisLineChartSeriesSettings']:
        return pulumi.get(self, "settings")


@pulumi.output_type
class AnalysisFieldSort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFieldSort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFieldSort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFieldSort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: 'AnalysisSortDirection',
                 field_id: str):
        AnalysisFieldSort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: 'AnalysisSortDirection',
             field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("direction", direction)
        _setter("field_id", field_id)

    @property
    @pulumi.getter
    def direction(self) -> 'AnalysisSortDirection':
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class AnalysisFieldSortOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnSort":
            suggest = "column_sort"
        elif key == "fieldSort":
            suggest = "field_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFieldSortOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFieldSortOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFieldSortOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_sort: Optional['outputs.AnalysisColumnSort'] = None,
                 field_sort: Optional['outputs.AnalysisFieldSort'] = None):
        AnalysisFieldSortOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_sort=column_sort,
            field_sort=field_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_sort: Optional['outputs.AnalysisColumnSort'] = None,
             field_sort: Optional['outputs.AnalysisFieldSort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_sort is not None:
            _setter("column_sort", column_sort)
        if field_sort is not None:
            _setter("field_sort", field_sort)

    @property
    @pulumi.getter(name="columnSort")
    def column_sort(self) -> Optional['outputs.AnalysisColumnSort']:
        return pulumi.get(self, "column_sort")

    @property
    @pulumi.getter(name="fieldSort")
    def field_sort(self) -> Optional['outputs.AnalysisFieldSort']:
        return pulumi.get(self, "field_sort")


@pulumi.output_type
class AnalysisFieldTooltipItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFieldTooltipItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFieldTooltipItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFieldTooltipItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 label: Optional[str] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisFieldTooltipItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            label=label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             label: Optional[str] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if label is not None:
            _setter("label", label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisFilledMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 geospatial: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisFilledMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            geospatial=geospatial,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             geospatial: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if geospatial is not None:
            _setter("geospatial", geospatial)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def geospatial(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "geospatial")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisFilledMapConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilledMapConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilledMapConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilledMapConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Sequence['outputs.AnalysisFilledMapConditionalFormattingOption']):
        AnalysisFilledMapConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Sequence['outputs.AnalysisFilledMapConditionalFormattingOption'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Sequence['outputs.AnalysisFilledMapConditionalFormattingOption']:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class AnalysisFilledMapConditionalFormattingOption(dict):
    def __init__(__self__, *,
                 shape: 'outputs.AnalysisFilledMapShapeConditionalFormatting'):
        AnalysisFilledMapConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            shape=shape,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             shape: 'outputs.AnalysisFilledMapShapeConditionalFormatting',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("shape", shape)

    @property
    @pulumi.getter
    def shape(self) -> 'outputs.AnalysisFilledMapShapeConditionalFormatting':
        return pulumi.get(self, "shape")


@pulumi.output_type
class AnalysisFilledMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldWells":
            suggest = "field_wells"
        elif key == "mapStyleOptions":
            suggest = "map_style_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "windowOptions":
            suggest = "window_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilledMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilledMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilledMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_wells: Optional['outputs.AnalysisFilledMapFieldWells'] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 map_style_options: Optional['outputs.AnalysisGeospatialMapStyleOptions'] = None,
                 sort_configuration: Optional['outputs.AnalysisFilledMapSortConfiguration'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
                 window_options: Optional['outputs.AnalysisGeospatialWindowOptions'] = None):
        AnalysisFilledMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_wells=field_wells,
            legend=legend,
            map_style_options=map_style_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            window_options=window_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_wells: Optional['outputs.AnalysisFilledMapFieldWells'] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             map_style_options: Optional['outputs.AnalysisGeospatialMapStyleOptions'] = None,
             sort_configuration: Optional['outputs.AnalysisFilledMapSortConfiguration'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             window_options: Optional['outputs.AnalysisGeospatialWindowOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if map_style_options is not None:
            _setter("map_style_options", map_style_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if window_options is not None:
            _setter("window_options", window_options)

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisFilledMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="mapStyleOptions")
    def map_style_options(self) -> Optional['outputs.AnalysisGeospatialMapStyleOptions']:
        return pulumi.get(self, "map_style_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisFilledMapSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="windowOptions")
    def window_options(self) -> Optional['outputs.AnalysisGeospatialWindowOptions']:
        return pulumi.get(self, "window_options")


@pulumi.output_type
class AnalysisFilledMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filledMapAggregatedFieldWells":
            suggest = "filled_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilledMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilledMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilledMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filled_map_aggregated_field_wells: Optional['outputs.AnalysisFilledMapAggregatedFieldWells'] = None):
        AnalysisFilledMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filled_map_aggregated_field_wells=filled_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filled_map_aggregated_field_wells: Optional['outputs.AnalysisFilledMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if filled_map_aggregated_field_wells is not None:
            _setter("filled_map_aggregated_field_wells", filled_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="filledMapAggregatedFieldWells")
    def filled_map_aggregated_field_wells(self) -> Optional['outputs.AnalysisFilledMapAggregatedFieldWells']:
        return pulumi.get(self, "filled_map_aggregated_field_wells")


@pulumi.output_type
class AnalysisFilledMapShapeConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilledMapShapeConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilledMapShapeConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilledMapShapeConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 format: Optional['outputs.AnalysisShapeConditionalFormat'] = None):
        AnalysisFilledMapShapeConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            format=format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             format: Optional['outputs.AnalysisShapeConditionalFormat'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if format is not None:
            _setter("format", format)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def format(self) -> Optional['outputs.AnalysisShapeConditionalFormat']:
        return pulumi.get(self, "format")


@pulumi.output_type
class AnalysisFilledMapSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilledMapSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilledMapSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilledMapSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisFilledMapSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class AnalysisFilledMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilledMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilledMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilledMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisFilledMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 conditional_formatting: Optional['outputs.AnalysisFilledMapConditionalFormatting'] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisFilledMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisFilledMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             conditional_formatting: Optional['outputs.AnalysisFilledMapConditionalFormatting'] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisFilledMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.AnalysisFilledMapConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryFilter":
            suggest = "category_filter"
        elif key == "numericEqualityFilter":
            suggest = "numeric_equality_filter"
        elif key == "numericRangeFilter":
            suggest = "numeric_range_filter"
        elif key == "relativeDatesFilter":
            suggest = "relative_dates_filter"
        elif key == "timeEqualityFilter":
            suggest = "time_equality_filter"
        elif key == "timeRangeFilter":
            suggest = "time_range_filter"
        elif key == "topBottomFilter":
            suggest = "top_bottom_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_filter: Optional['outputs.AnalysisCategoryFilter'] = None,
                 numeric_equality_filter: Optional['outputs.AnalysisNumericEqualityFilter'] = None,
                 numeric_range_filter: Optional['outputs.AnalysisNumericRangeFilter'] = None,
                 relative_dates_filter: Optional['outputs.AnalysisRelativeDatesFilter'] = None,
                 time_equality_filter: Optional['outputs.AnalysisTimeEqualityFilter'] = None,
                 time_range_filter: Optional['outputs.AnalysisTimeRangeFilter'] = None,
                 top_bottom_filter: Optional['outputs.AnalysisTopBottomFilter'] = None):
        AnalysisFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_filter=category_filter,
            numeric_equality_filter=numeric_equality_filter,
            numeric_range_filter=numeric_range_filter,
            relative_dates_filter=relative_dates_filter,
            time_equality_filter=time_equality_filter,
            time_range_filter=time_range_filter,
            top_bottom_filter=top_bottom_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_filter: Optional['outputs.AnalysisCategoryFilter'] = None,
             numeric_equality_filter: Optional['outputs.AnalysisNumericEqualityFilter'] = None,
             numeric_range_filter: Optional['outputs.AnalysisNumericRangeFilter'] = None,
             relative_dates_filter: Optional['outputs.AnalysisRelativeDatesFilter'] = None,
             time_equality_filter: Optional['outputs.AnalysisTimeEqualityFilter'] = None,
             time_range_filter: Optional['outputs.AnalysisTimeRangeFilter'] = None,
             top_bottom_filter: Optional['outputs.AnalysisTopBottomFilter'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_filter is not None:
            _setter("category_filter", category_filter)
        if numeric_equality_filter is not None:
            _setter("numeric_equality_filter", numeric_equality_filter)
        if numeric_range_filter is not None:
            _setter("numeric_range_filter", numeric_range_filter)
        if relative_dates_filter is not None:
            _setter("relative_dates_filter", relative_dates_filter)
        if time_equality_filter is not None:
            _setter("time_equality_filter", time_equality_filter)
        if time_range_filter is not None:
            _setter("time_range_filter", time_range_filter)
        if top_bottom_filter is not None:
            _setter("top_bottom_filter", top_bottom_filter)

    @property
    @pulumi.getter(name="categoryFilter")
    def category_filter(self) -> Optional['outputs.AnalysisCategoryFilter']:
        return pulumi.get(self, "category_filter")

    @property
    @pulumi.getter(name="numericEqualityFilter")
    def numeric_equality_filter(self) -> Optional['outputs.AnalysisNumericEqualityFilter']:
        return pulumi.get(self, "numeric_equality_filter")

    @property
    @pulumi.getter(name="numericRangeFilter")
    def numeric_range_filter(self) -> Optional['outputs.AnalysisNumericRangeFilter']:
        return pulumi.get(self, "numeric_range_filter")

    @property
    @pulumi.getter(name="relativeDatesFilter")
    def relative_dates_filter(self) -> Optional['outputs.AnalysisRelativeDatesFilter']:
        return pulumi.get(self, "relative_dates_filter")

    @property
    @pulumi.getter(name="timeEqualityFilter")
    def time_equality_filter(self) -> Optional['outputs.AnalysisTimeEqualityFilter']:
        return pulumi.get(self, "time_equality_filter")

    @property
    @pulumi.getter(name="timeRangeFilter")
    def time_range_filter(self) -> Optional['outputs.AnalysisTimeRangeFilter']:
        return pulumi.get(self, "time_range_filter")

    @property
    @pulumi.getter(name="topBottomFilter")
    def top_bottom_filter(self) -> Optional['outputs.AnalysisTopBottomFilter']:
        return pulumi.get(self, "top_bottom_filter")


@pulumi.output_type
class AnalysisFilterControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimePicker":
            suggest = "date_time_picker"
        elif key == "relativeDateTime":
            suggest = "relative_date_time"
        elif key == "textArea":
            suggest = "text_area"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_picker: Optional['outputs.AnalysisFilterDateTimePickerControl'] = None,
                 dropdown: Optional['outputs.AnalysisFilterDropDownControl'] = None,
                 list: Optional['outputs.AnalysisFilterListControl'] = None,
                 relative_date_time: Optional['outputs.AnalysisFilterRelativeDateTimeControl'] = None,
                 slider: Optional['outputs.AnalysisFilterSliderControl'] = None,
                 text_area: Optional['outputs.AnalysisFilterTextAreaControl'] = None,
                 text_field: Optional['outputs.AnalysisFilterTextFieldControl'] = None):
        AnalysisFilterControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_picker=date_time_picker,
            dropdown=dropdown,
            list=list,
            relative_date_time=relative_date_time,
            slider=slider,
            text_area=text_area,
            text_field=text_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_picker: Optional['outputs.AnalysisFilterDateTimePickerControl'] = None,
             dropdown: Optional['outputs.AnalysisFilterDropDownControl'] = None,
             list: Optional['outputs.AnalysisFilterListControl'] = None,
             relative_date_time: Optional['outputs.AnalysisFilterRelativeDateTimeControl'] = None,
             slider: Optional['outputs.AnalysisFilterSliderControl'] = None,
             text_area: Optional['outputs.AnalysisFilterTextAreaControl'] = None,
             text_field: Optional['outputs.AnalysisFilterTextFieldControl'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_picker is not None:
            _setter("date_time_picker", date_time_picker)
        if dropdown is not None:
            _setter("dropdown", dropdown)
        if list is not None:
            _setter("list", list)
        if relative_date_time is not None:
            _setter("relative_date_time", relative_date_time)
        if slider is not None:
            _setter("slider", slider)
        if text_area is not None:
            _setter("text_area", text_area)
        if text_field is not None:
            _setter("text_field", text_field)

    @property
    @pulumi.getter(name="dateTimePicker")
    def date_time_picker(self) -> Optional['outputs.AnalysisFilterDateTimePickerControl']:
        return pulumi.get(self, "date_time_picker")

    @property
    @pulumi.getter
    def dropdown(self) -> Optional['outputs.AnalysisFilterDropDownControl']:
        return pulumi.get(self, "dropdown")

    @property
    @pulumi.getter
    def list(self) -> Optional['outputs.AnalysisFilterListControl']:
        return pulumi.get(self, "list")

    @property
    @pulumi.getter(name="relativeDateTime")
    def relative_date_time(self) -> Optional['outputs.AnalysisFilterRelativeDateTimeControl']:
        return pulumi.get(self, "relative_date_time")

    @property
    @pulumi.getter
    def slider(self) -> Optional['outputs.AnalysisFilterSliderControl']:
        return pulumi.get(self, "slider")

    @property
    @pulumi.getter(name="textArea")
    def text_area(self) -> Optional['outputs.AnalysisFilterTextAreaControl']:
        return pulumi.get(self, "text_area")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional['outputs.AnalysisFilterTextFieldControl']:
        return pulumi.get(self, "text_field")


@pulumi.output_type
class AnalysisFilterDateTimePickerControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterDateTimePickerControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterDateTimePickerControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterDateTimePickerControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 display_options: Optional['outputs.AnalysisDateTimePickerControlDisplayOptions'] = None,
                 type: Optional['AnalysisSheetControlDateTimePickerType'] = None):
        AnalysisFilterDateTimePickerControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            display_options=display_options,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             display_options: Optional['outputs.AnalysisDateTimePickerControlDisplayOptions'] = None,
             type: Optional['AnalysisSheetControlDateTimePickerType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisDateTimePickerControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter
    def type(self) -> Optional['AnalysisSheetControlDateTimePickerType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class AnalysisFilterDropDownControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterDropDownControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterDropDownControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterDropDownControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.AnalysisCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.AnalysisDropDownControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.AnalysisFilterSelectableValues'] = None,
                 type: Optional['AnalysisSheetControlListType'] = None):
        AnalysisFilterDropDownControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             cascading_control_configuration: Optional['outputs.AnalysisCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.AnalysisDropDownControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.AnalysisFilterSelectableValues'] = None,
             type: Optional['AnalysisSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.AnalysisCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisDropDownControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.AnalysisFilterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['AnalysisSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class AnalysisFilterGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossDataset":
            suggest = "cross_dataset"
        elif key == "filterGroupId":
            suggest = "filter_group_id"
        elif key == "scopeConfiguration":
            suggest = "scope_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cross_dataset: 'AnalysisCrossDatasetTypes',
                 filter_group_id: str,
                 filters: Sequence['outputs.AnalysisFilter'],
                 scope_configuration: 'outputs.AnalysisFilterScopeConfiguration',
                 status: Optional['AnalysisWidgetStatus'] = None):
        AnalysisFilterGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cross_dataset=cross_dataset,
            filter_group_id=filter_group_id,
            filters=filters,
            scope_configuration=scope_configuration,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cross_dataset: 'AnalysisCrossDatasetTypes',
             filter_group_id: str,
             filters: Sequence['outputs.AnalysisFilter'],
             scope_configuration: 'outputs.AnalysisFilterScopeConfiguration',
             status: Optional['AnalysisWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cross_dataset", cross_dataset)
        _setter("filter_group_id", filter_group_id)
        _setter("filters", filters)
        _setter("scope_configuration", scope_configuration)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="crossDataset")
    def cross_dataset(self) -> 'AnalysisCrossDatasetTypes':
        return pulumi.get(self, "cross_dataset")

    @property
    @pulumi.getter(name="filterGroupId")
    def filter_group_id(self) -> str:
        return pulumi.get(self, "filter_group_id")

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.AnalysisFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="scopeConfiguration")
    def scope_configuration(self) -> 'outputs.AnalysisFilterScopeConfiguration':
        return pulumi.get(self, "scope_configuration")

    @property
    @pulumi.getter
    def status(self) -> Optional['AnalysisWidgetStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class AnalysisFilterListConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOperator":
            suggest = "match_operator"
        elif key == "categoryValues":
            suggest = "category_values"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterListConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterListConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterListConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_operator: 'AnalysisCategoryFilterMatchOperator',
                 category_values: Optional[Sequence[str]] = None,
                 select_all_options: Optional['AnalysisCategoryFilterSelectAllOptions'] = None):
        AnalysisFilterListConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_operator=match_operator,
            category_values=category_values,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_operator: 'AnalysisCategoryFilterMatchOperator',
             category_values: Optional[Sequence[str]] = None,
             select_all_options: Optional['AnalysisCategoryFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("match_operator", match_operator)
        if category_values is not None:
            _setter("category_values", category_values)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'AnalysisCategoryFilterMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="categoryValues")
    def category_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "category_values")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['AnalysisCategoryFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class AnalysisFilterListControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterListControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterListControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterListControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.AnalysisCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.AnalysisListControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.AnalysisFilterSelectableValues'] = None,
                 type: Optional['AnalysisSheetControlListType'] = None):
        AnalysisFilterListControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             cascading_control_configuration: Optional['outputs.AnalysisCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.AnalysisListControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.AnalysisFilterSelectableValues'] = None,
             type: Optional['AnalysisSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.AnalysisCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisListControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.AnalysisFilterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['AnalysisSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class AnalysisFilterOperationSelectedFieldsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedColumns":
            suggest = "selected_columns"
        elif key == "selectedFieldOptions":
            suggest = "selected_field_options"
        elif key == "selectedFields":
            suggest = "selected_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterOperationSelectedFieldsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterOperationSelectedFieldsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterOperationSelectedFieldsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_columns: Optional[Sequence['outputs.AnalysisColumnIdentifier']] = None,
                 selected_field_options: Optional['AnalysisSelectedFieldOptions'] = None,
                 selected_fields: Optional[Sequence[str]] = None):
        AnalysisFilterOperationSelectedFieldsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_columns=selected_columns,
            selected_field_options=selected_field_options,
            selected_fields=selected_fields,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_columns: Optional[Sequence['outputs.AnalysisColumnIdentifier']] = None,
             selected_field_options: Optional['AnalysisSelectedFieldOptions'] = None,
             selected_fields: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if selected_columns is not None:
            _setter("selected_columns", selected_columns)
        if selected_field_options is not None:
            _setter("selected_field_options", selected_field_options)
        if selected_fields is not None:
            _setter("selected_fields", selected_fields)

    @property
    @pulumi.getter(name="selectedColumns")
    def selected_columns(self) -> Optional[Sequence['outputs.AnalysisColumnIdentifier']]:
        return pulumi.get(self, "selected_columns")

    @property
    @pulumi.getter(name="selectedFieldOptions")
    def selected_field_options(self) -> Optional['AnalysisSelectedFieldOptions']:
        return pulumi.get(self, "selected_field_options")

    @property
    @pulumi.getter(name="selectedFields")
    def selected_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "selected_fields")


@pulumi.output_type
class AnalysisFilterOperationTargetVisualsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sameSheetTargetVisualConfiguration":
            suggest = "same_sheet_target_visual_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterOperationTargetVisualsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterOperationTargetVisualsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterOperationTargetVisualsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 same_sheet_target_visual_configuration: Optional['outputs.AnalysisSameSheetTargetVisualConfiguration'] = None):
        AnalysisFilterOperationTargetVisualsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            same_sheet_target_visual_configuration=same_sheet_target_visual_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             same_sheet_target_visual_configuration: Optional['outputs.AnalysisSameSheetTargetVisualConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if same_sheet_target_visual_configuration is not None:
            _setter("same_sheet_target_visual_configuration", same_sheet_target_visual_configuration)

    @property
    @pulumi.getter(name="sameSheetTargetVisualConfiguration")
    def same_sheet_target_visual_configuration(self) -> Optional['outputs.AnalysisSameSheetTargetVisualConfiguration']:
        return pulumi.get(self, "same_sheet_target_visual_configuration")


@pulumi.output_type
class AnalysisFilterRelativeDateTimeControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterRelativeDateTimeControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterRelativeDateTimeControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterRelativeDateTimeControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 display_options: Optional['outputs.AnalysisRelativeDateTimeControlDisplayOptions'] = None):
        AnalysisFilterRelativeDateTimeControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             display_options: Optional['outputs.AnalysisRelativeDateTimeControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisRelativeDateTimeControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class AnalysisFilterScopeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allSheets":
            suggest = "all_sheets"
        elif key == "selectedSheets":
            suggest = "selected_sheets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterScopeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterScopeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterScopeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_sheets: Optional['outputs.AnalysisAllSheetsFilterScopeConfiguration'] = None,
                 selected_sheets: Optional['outputs.AnalysisSelectedSheetsFilterScopeConfiguration'] = None):
        AnalysisFilterScopeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_sheets=all_sheets,
            selected_sheets=selected_sheets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_sheets: Optional['outputs.AnalysisAllSheetsFilterScopeConfiguration'] = None,
             selected_sheets: Optional['outputs.AnalysisSelectedSheetsFilterScopeConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_sheets is not None:
            _setter("all_sheets", all_sheets)
        if selected_sheets is not None:
            _setter("selected_sheets", selected_sheets)

    @property
    @pulumi.getter(name="allSheets")
    def all_sheets(self) -> Optional['outputs.AnalysisAllSheetsFilterScopeConfiguration']:
        return pulumi.get(self, "all_sheets")

    @property
    @pulumi.getter(name="selectedSheets")
    def selected_sheets(self) -> Optional['outputs.AnalysisSelectedSheetsFilterScopeConfiguration']:
        return pulumi.get(self, "selected_sheets")


@pulumi.output_type
class AnalysisFilterSelectableValues(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence[str]] = None):
        AnalysisFilterSelectableValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisFilterSliderControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "maximumValue":
            suggest = "maximum_value"
        elif key == "minimumValue":
            suggest = "minimum_value"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "stepSize":
            suggest = "step_size"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterSliderControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterSliderControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterSliderControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 maximum_value: float,
                 minimum_value: float,
                 source_filter_id: str,
                 step_size: float,
                 title: str,
                 display_options: Optional['outputs.AnalysisSliderControlDisplayOptions'] = None,
                 type: Optional['AnalysisSheetControlSliderType'] = None):
        AnalysisFilterSliderControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            maximum_value=maximum_value,
            minimum_value=minimum_value,
            source_filter_id=source_filter_id,
            step_size=step_size,
            title=title,
            display_options=display_options,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             maximum_value: float,
             minimum_value: float,
             source_filter_id: str,
             step_size: float,
             title: str,
             display_options: Optional['outputs.AnalysisSliderControlDisplayOptions'] = None,
             type: Optional['AnalysisSheetControlSliderType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("maximum_value", maximum_value)
        _setter("minimum_value", minimum_value)
        _setter("source_filter_id", source_filter_id)
        _setter("step_size", step_size)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="maximumValue")
    def maximum_value(self) -> float:
        return pulumi.get(self, "maximum_value")

    @property
    @pulumi.getter(name="minimumValue")
    def minimum_value(self) -> float:
        return pulumi.get(self, "minimum_value")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> float:
        return pulumi.get(self, "step_size")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisSliderControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter
    def type(self) -> Optional['AnalysisSheetControlSliderType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class AnalysisFilterTextAreaControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterTextAreaControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterTextAreaControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterTextAreaControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 delimiter: Optional[str] = None,
                 display_options: Optional['outputs.AnalysisTextAreaControlDisplayOptions'] = None):
        AnalysisFilterTextAreaControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            delimiter=delimiter,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             delimiter: Optional[str] = None,
             display_options: Optional['outputs.AnalysisTextAreaControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisTextAreaControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class AnalysisFilterTextFieldControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFilterTextFieldControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFilterTextFieldControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFilterTextFieldControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 display_options: Optional['outputs.AnalysisTextFieldControlDisplayOptions'] = None):
        AnalysisFilterTextFieldControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             display_options: Optional['outputs.AnalysisTextFieldControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisTextFieldControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class AnalysisFontConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontColor":
            suggest = "font_color"
        elif key == "fontDecoration":
            suggest = "font_decoration"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "fontStyle":
            suggest = "font_style"
        elif key == "fontWeight":
            suggest = "font_weight"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFontConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFontConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFontConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_color: Optional[str] = None,
                 font_decoration: Optional['AnalysisFontDecoration'] = None,
                 font_size: Optional['outputs.AnalysisFontSize'] = None,
                 font_style: Optional['AnalysisFontStyle'] = None,
                 font_weight: Optional['outputs.AnalysisFontWeight'] = None):
        AnalysisFontConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_color=font_color,
            font_decoration=font_decoration,
            font_size=font_size,
            font_style=font_style,
            font_weight=font_weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_color: Optional[str] = None,
             font_decoration: Optional['AnalysisFontDecoration'] = None,
             font_size: Optional['outputs.AnalysisFontSize'] = None,
             font_style: Optional['AnalysisFontStyle'] = None,
             font_weight: Optional['outputs.AnalysisFontWeight'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if font_color is not None:
            _setter("font_color", font_color)
        if font_decoration is not None:
            _setter("font_decoration", font_decoration)
        if font_size is not None:
            _setter("font_size", font_size)
        if font_style is not None:
            _setter("font_style", font_style)
        if font_weight is not None:
            _setter("font_weight", font_weight)

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[str]:
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontDecoration")
    def font_decoration(self) -> Optional['AnalysisFontDecoration']:
        return pulumi.get(self, "font_decoration")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional['outputs.AnalysisFontSize']:
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="fontStyle")
    def font_style(self) -> Optional['AnalysisFontStyle']:
        return pulumi.get(self, "font_style")

    @property
    @pulumi.getter(name="fontWeight")
    def font_weight(self) -> Optional['outputs.AnalysisFontWeight']:
        return pulumi.get(self, "font_weight")


@pulumi.output_type
class AnalysisFontSize(dict):
    def __init__(__self__, *,
                 relative: Optional['AnalysisRelativeFontSize'] = None):
        AnalysisFontSize._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            relative=relative,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             relative: Optional['AnalysisRelativeFontSize'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if relative is not None:
            _setter("relative", relative)

    @property
    @pulumi.getter
    def relative(self) -> Optional['AnalysisRelativeFontSize']:
        return pulumi.get(self, "relative")


@pulumi.output_type
class AnalysisFontWeight(dict):
    def __init__(__self__, *,
                 name: Optional['AnalysisFontWeightName'] = None):
        AnalysisFontWeight._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional['AnalysisFontWeightName'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional['AnalysisFontWeightName']:
        return pulumi.get(self, "name")


@pulumi.output_type
class AnalysisForecastComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "customSeasonalityValue":
            suggest = "custom_seasonality_value"
        elif key == "lowerBoundary":
            suggest = "lower_boundary"
        elif key == "periodsBackward":
            suggest = "periods_backward"
        elif key == "periodsForward":
            suggest = "periods_forward"
        elif key == "predictionInterval":
            suggest = "prediction_interval"
        elif key == "upperBoundary":
            suggest = "upper_boundary"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisForecastComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisForecastComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisForecastComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 custom_seasonality_value: Optional[float] = None,
                 lower_boundary: Optional[float] = None,
                 name: Optional[str] = None,
                 periods_backward: Optional[float] = None,
                 periods_forward: Optional[float] = None,
                 prediction_interval: Optional[float] = None,
                 seasonality: Optional['AnalysisForecastComputationSeasonality'] = None,
                 time: Optional['outputs.AnalysisDimensionField'] = None,
                 upper_boundary: Optional[float] = None,
                 value: Optional['outputs.AnalysisMeasureField'] = None):
        AnalysisForecastComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            custom_seasonality_value=custom_seasonality_value,
            lower_boundary=lower_boundary,
            name=name,
            periods_backward=periods_backward,
            periods_forward=periods_forward,
            prediction_interval=prediction_interval,
            seasonality=seasonality,
            time=time,
            upper_boundary=upper_boundary,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             custom_seasonality_value: Optional[float] = None,
             lower_boundary: Optional[float] = None,
             name: Optional[str] = None,
             periods_backward: Optional[float] = None,
             periods_forward: Optional[float] = None,
             prediction_interval: Optional[float] = None,
             seasonality: Optional['AnalysisForecastComputationSeasonality'] = None,
             time: Optional['outputs.AnalysisDimensionField'] = None,
             upper_boundary: Optional[float] = None,
             value: Optional['outputs.AnalysisMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if custom_seasonality_value is not None:
            _setter("custom_seasonality_value", custom_seasonality_value)
        if lower_boundary is not None:
            _setter("lower_boundary", lower_boundary)
        if name is not None:
            _setter("name", name)
        if periods_backward is not None:
            _setter("periods_backward", periods_backward)
        if periods_forward is not None:
            _setter("periods_forward", periods_forward)
        if prediction_interval is not None:
            _setter("prediction_interval", prediction_interval)
        if seasonality is not None:
            _setter("seasonality", seasonality)
        if time is not None:
            _setter("time", time)
        if upper_boundary is not None:
            _setter("upper_boundary", upper_boundary)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter(name="customSeasonalityValue")
    def custom_seasonality_value(self) -> Optional[float]:
        return pulumi.get(self, "custom_seasonality_value")

    @property
    @pulumi.getter(name="lowerBoundary")
    def lower_boundary(self) -> Optional[float]:
        return pulumi.get(self, "lower_boundary")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="periodsBackward")
    def periods_backward(self) -> Optional[float]:
        return pulumi.get(self, "periods_backward")

    @property
    @pulumi.getter(name="periodsForward")
    def periods_forward(self) -> Optional[float]:
        return pulumi.get(self, "periods_forward")

    @property
    @pulumi.getter(name="predictionInterval")
    def prediction_interval(self) -> Optional[float]:
        return pulumi.get(self, "prediction_interval")

    @property
    @pulumi.getter
    def seasonality(self) -> Optional['AnalysisForecastComputationSeasonality']:
        return pulumi.get(self, "seasonality")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.AnalysisDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter(name="upperBoundary")
    def upper_boundary(self) -> Optional[float]:
        return pulumi.get(self, "upper_boundary")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AnalysisMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisForecastConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forecastProperties":
            suggest = "forecast_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisForecastConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisForecastConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisForecastConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forecast_properties: Optional['outputs.AnalysisTimeBasedForecastProperties'] = None,
                 scenario: Optional['outputs.AnalysisForecastScenario'] = None):
        AnalysisForecastConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forecast_properties=forecast_properties,
            scenario=scenario,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forecast_properties: Optional['outputs.AnalysisTimeBasedForecastProperties'] = None,
             scenario: Optional['outputs.AnalysisForecastScenario'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if forecast_properties is not None:
            _setter("forecast_properties", forecast_properties)
        if scenario is not None:
            _setter("scenario", scenario)

    @property
    @pulumi.getter(name="forecastProperties")
    def forecast_properties(self) -> Optional['outputs.AnalysisTimeBasedForecastProperties']:
        return pulumi.get(self, "forecast_properties")

    @property
    @pulumi.getter
    def scenario(self) -> Optional['outputs.AnalysisForecastScenario']:
        return pulumi.get(self, "scenario")


@pulumi.output_type
class AnalysisForecastScenario(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whatIfPointScenario":
            suggest = "what_if_point_scenario"
        elif key == "whatIfRangeScenario":
            suggest = "what_if_range_scenario"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisForecastScenario. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisForecastScenario.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisForecastScenario.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 what_if_point_scenario: Optional['outputs.AnalysisWhatIfPointScenario'] = None,
                 what_if_range_scenario: Optional['outputs.AnalysisWhatIfRangeScenario'] = None):
        AnalysisForecastScenario._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            what_if_point_scenario=what_if_point_scenario,
            what_if_range_scenario=what_if_range_scenario,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             what_if_point_scenario: Optional['outputs.AnalysisWhatIfPointScenario'] = None,
             what_if_range_scenario: Optional['outputs.AnalysisWhatIfRangeScenario'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if what_if_point_scenario is not None:
            _setter("what_if_point_scenario", what_if_point_scenario)
        if what_if_range_scenario is not None:
            _setter("what_if_range_scenario", what_if_range_scenario)

    @property
    @pulumi.getter(name="whatIfPointScenario")
    def what_if_point_scenario(self) -> Optional['outputs.AnalysisWhatIfPointScenario']:
        return pulumi.get(self, "what_if_point_scenario")

    @property
    @pulumi.getter(name="whatIfRangeScenario")
    def what_if_range_scenario(self) -> Optional['outputs.AnalysisWhatIfRangeScenario']:
        return pulumi.get(self, "what_if_range_scenario")


@pulumi.output_type
class AnalysisFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormatConfiguration":
            suggest = "date_time_format_configuration"
        elif key == "numberFormatConfiguration":
            suggest = "number_format_configuration"
        elif key == "stringFormatConfiguration":
            suggest = "string_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format_configuration: Optional['outputs.AnalysisDateTimeFormatConfiguration'] = None,
                 number_format_configuration: Optional['outputs.AnalysisNumberFormatConfiguration'] = None,
                 string_format_configuration: Optional['outputs.AnalysisStringFormatConfiguration'] = None):
        AnalysisFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format_configuration=date_time_format_configuration,
            number_format_configuration=number_format_configuration,
            string_format_configuration=string_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format_configuration: Optional['outputs.AnalysisDateTimeFormatConfiguration'] = None,
             number_format_configuration: Optional['outputs.AnalysisNumberFormatConfiguration'] = None,
             string_format_configuration: Optional['outputs.AnalysisStringFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format_configuration is not None:
            _setter("date_time_format_configuration", date_time_format_configuration)
        if number_format_configuration is not None:
            _setter("number_format_configuration", number_format_configuration)
        if string_format_configuration is not None:
            _setter("string_format_configuration", string_format_configuration)

    @property
    @pulumi.getter(name="dateTimeFormatConfiguration")
    def date_time_format_configuration(self) -> Optional['outputs.AnalysisDateTimeFormatConfiguration']:
        return pulumi.get(self, "date_time_format_configuration")

    @property
    @pulumi.getter(name="numberFormatConfiguration")
    def number_format_configuration(self) -> Optional['outputs.AnalysisNumberFormatConfiguration']:
        return pulumi.get(self, "number_format_configuration")

    @property
    @pulumi.getter(name="stringFormatConfiguration")
    def string_format_configuration(self) -> Optional['outputs.AnalysisStringFormatConfiguration']:
        return pulumi.get(self, "string_format_configuration")


@pulumi.output_type
class AnalysisFreeFormLayoutCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "screenCanvasSizeOptions":
            suggest = "screen_canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFreeFormLayoutCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFreeFormLayoutCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFreeFormLayoutCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 screen_canvas_size_options: Optional['outputs.AnalysisFreeFormLayoutScreenCanvasSizeOptions'] = None):
        AnalysisFreeFormLayoutCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            screen_canvas_size_options=screen_canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             screen_canvas_size_options: Optional['outputs.AnalysisFreeFormLayoutScreenCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if screen_canvas_size_options is not None:
            _setter("screen_canvas_size_options", screen_canvas_size_options)

    @property
    @pulumi.getter(name="screenCanvasSizeOptions")
    def screen_canvas_size_options(self) -> Optional['outputs.AnalysisFreeFormLayoutScreenCanvasSizeOptions']:
        return pulumi.get(self, "screen_canvas_size_options")


@pulumi.output_type
class AnalysisFreeFormLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFreeFormLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFreeFormLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFreeFormLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 elements: Sequence['outputs.AnalysisFreeFormLayoutElement'],
                 canvas_size_options: Optional['outputs.AnalysisFreeFormLayoutCanvasSizeOptions'] = None):
        AnalysisFreeFormLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elements=elements,
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elements: Sequence['outputs.AnalysisFreeFormLayoutElement'],
             canvas_size_options: Optional['outputs.AnalysisFreeFormLayoutCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("elements", elements)
        if canvas_size_options is not None:
            _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter
    def elements(self) -> Sequence['outputs.AnalysisFreeFormLayoutElement']:
        return pulumi.get(self, "elements")

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> Optional['outputs.AnalysisFreeFormLayoutCanvasSizeOptions']:
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class AnalysisFreeFormLayoutElement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elementId":
            suggest = "element_id"
        elif key == "elementType":
            suggest = "element_type"
        elif key == "xAxisLocation":
            suggest = "x_axis_location"
        elif key == "yAxisLocation":
            suggest = "y_axis_location"
        elif key == "backgroundStyle":
            suggest = "background_style"
        elif key == "borderStyle":
            suggest = "border_style"
        elif key == "loadingAnimation":
            suggest = "loading_animation"
        elif key == "renderingRules":
            suggest = "rendering_rules"
        elif key == "selectedBorderStyle":
            suggest = "selected_border_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFreeFormLayoutElement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFreeFormLayoutElement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFreeFormLayoutElement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 element_id: str,
                 element_type: 'AnalysisLayoutElementType',
                 height: str,
                 width: str,
                 x_axis_location: str,
                 y_axis_location: str,
                 background_style: Optional['outputs.AnalysisFreeFormLayoutElementBackgroundStyle'] = None,
                 border_style: Optional['outputs.AnalysisFreeFormLayoutElementBorderStyle'] = None,
                 loading_animation: Optional['outputs.AnalysisLoadingAnimation'] = None,
                 rendering_rules: Optional[Sequence['outputs.AnalysisSheetElementRenderingRule']] = None,
                 selected_border_style: Optional['outputs.AnalysisFreeFormLayoutElementBorderStyle'] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        """
        :param str height: String based length that is composed of value and unit in px
        :param str width: String based length that is composed of value and unit in px
        :param str x_axis_location: String based length that is composed of value and unit in px
        :param str y_axis_location: String based length that is composed of value and unit in px with Integer.MAX_VALUE as maximum value
        """
        AnalysisFreeFormLayoutElement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            element_id=element_id,
            element_type=element_type,
            height=height,
            width=width,
            x_axis_location=x_axis_location,
            y_axis_location=y_axis_location,
            background_style=background_style,
            border_style=border_style,
            loading_animation=loading_animation,
            rendering_rules=rendering_rules,
            selected_border_style=selected_border_style,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             element_id: str,
             element_type: 'AnalysisLayoutElementType',
             height: str,
             width: str,
             x_axis_location: str,
             y_axis_location: str,
             background_style: Optional['outputs.AnalysisFreeFormLayoutElementBackgroundStyle'] = None,
             border_style: Optional['outputs.AnalysisFreeFormLayoutElementBorderStyle'] = None,
             loading_animation: Optional['outputs.AnalysisLoadingAnimation'] = None,
             rendering_rules: Optional[Sequence['outputs.AnalysisSheetElementRenderingRule']] = None,
             selected_border_style: Optional['outputs.AnalysisFreeFormLayoutElementBorderStyle'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("element_id", element_id)
        _setter("element_type", element_type)
        _setter("height", height)
        _setter("width", width)
        _setter("x_axis_location", x_axis_location)
        _setter("y_axis_location", y_axis_location)
        if background_style is not None:
            _setter("background_style", background_style)
        if border_style is not None:
            _setter("border_style", border_style)
        if loading_animation is not None:
            _setter("loading_animation", loading_animation)
        if rendering_rules is not None:
            _setter("rendering_rules", rendering_rules)
        if selected_border_style is not None:
            _setter("selected_border_style", selected_border_style)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="elementId")
    def element_id(self) -> str:
        return pulumi.get(self, "element_id")

    @property
    @pulumi.getter(name="elementType")
    def element_type(self) -> 'AnalysisLayoutElementType':
        return pulumi.get(self, "element_type")

    @property
    @pulumi.getter
    def height(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter(name="xAxisLocation")
    def x_axis_location(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "x_axis_location")

    @property
    @pulumi.getter(name="yAxisLocation")
    def y_axis_location(self) -> str:
        """
        String based length that is composed of value and unit in px with Integer.MAX_VALUE as maximum value
        """
        return pulumi.get(self, "y_axis_location")

    @property
    @pulumi.getter(name="backgroundStyle")
    def background_style(self) -> Optional['outputs.AnalysisFreeFormLayoutElementBackgroundStyle']:
        return pulumi.get(self, "background_style")

    @property
    @pulumi.getter(name="borderStyle")
    def border_style(self) -> Optional['outputs.AnalysisFreeFormLayoutElementBorderStyle']:
        return pulumi.get(self, "border_style")

    @property
    @pulumi.getter(name="loadingAnimation")
    def loading_animation(self) -> Optional['outputs.AnalysisLoadingAnimation']:
        return pulumi.get(self, "loading_animation")

    @property
    @pulumi.getter(name="renderingRules")
    def rendering_rules(self) -> Optional[Sequence['outputs.AnalysisSheetElementRenderingRule']]:
        return pulumi.get(self, "rendering_rules")

    @property
    @pulumi.getter(name="selectedBorderStyle")
    def selected_border_style(self) -> Optional['outputs.AnalysisFreeFormLayoutElementBorderStyle']:
        return pulumi.get(self, "selected_border_style")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisFreeFormLayoutElementBackgroundStyle(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisFreeFormLayoutElementBackgroundStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisFreeFormLayoutElementBorderStyle(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisFreeFormLayoutElementBorderStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisFreeFormLayoutScreenCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optimizedViewPortWidth":
            suggest = "optimized_view_port_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFreeFormLayoutScreenCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFreeFormLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFreeFormLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 optimized_view_port_width: str):
        """
        :param str optimized_view_port_width: String based length that is composed of value and unit in px
        """
        AnalysisFreeFormLayoutScreenCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            optimized_view_port_width=optimized_view_port_width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             optimized_view_port_width: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("optimized_view_port_width", optimized_view_port_width)

    @property
    @pulumi.getter(name="optimizedViewPortWidth")
    def optimized_view_port_width(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "optimized_view_port_width")


@pulumi.output_type
class AnalysisFreeFormSectionLayoutConfiguration(dict):
    def __init__(__self__, *,
                 elements: Sequence['outputs.AnalysisFreeFormLayoutElement']):
        AnalysisFreeFormSectionLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elements=elements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elements: Sequence['outputs.AnalysisFreeFormLayoutElement'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("elements", elements)

    @property
    @pulumi.getter
    def elements(self) -> Sequence['outputs.AnalysisFreeFormLayoutElement']:
        return pulumi.get(self, "elements")


@pulumi.output_type
class AnalysisFunnelChartAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisFunnelChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisFunnelChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "dataLabelOptions":
            suggest = "data_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "valueLabelOptions":
            suggest = "value_label_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFunnelChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFunnelChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFunnelChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 data_label_options: Optional['outputs.AnalysisFunnelChartDataLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisFunnelChartFieldWells'] = None,
                 sort_configuration: Optional['outputs.AnalysisFunnelChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
                 value_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None):
        AnalysisFunnelChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_options=category_label_options,
            data_label_options=data_label_options,
            field_wells=field_wells,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            value_label_options=value_label_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             data_label_options: Optional['outputs.AnalysisFunnelChartDataLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisFunnelChartFieldWells'] = None,
             sort_configuration: Optional['outputs.AnalysisFunnelChartSortConfiguration'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             value_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if data_label_options is not None:
            _setter("data_label_options", data_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if value_label_options is not None:
            _setter("value_label_options", value_label_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="dataLabelOptions")
    def data_label_options(self) -> Optional['outputs.AnalysisFunnelChartDataLabelOptions']:
        return pulumi.get(self, "data_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisFunnelChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisFunnelChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="valueLabelOptions")
    def value_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "value_label_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class AnalysisFunnelChartDataLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelVisibility":
            suggest = "category_label_visibility"
        elif key == "labelColor":
            suggest = "label_color"
        elif key == "labelFontConfiguration":
            suggest = "label_font_configuration"
        elif key == "measureDataLabelStyle":
            suggest = "measure_data_label_style"
        elif key == "measureLabelVisibility":
            suggest = "measure_label_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFunnelChartDataLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFunnelChartDataLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFunnelChartDataLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_visibility: Optional['AnalysisVisibility'] = None,
                 label_color: Optional[str] = None,
                 label_font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
                 measure_data_label_style: Optional['AnalysisFunnelChartMeasureDataLabelStyle'] = None,
                 measure_label_visibility: Optional['AnalysisVisibility'] = None,
                 position: Optional['AnalysisDataLabelPosition'] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisFunnelChartDataLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_visibility=category_label_visibility,
            label_color=label_color,
            label_font_configuration=label_font_configuration,
            measure_data_label_style=measure_data_label_style,
            measure_label_visibility=measure_label_visibility,
            position=position,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_visibility: Optional['AnalysisVisibility'] = None,
             label_color: Optional[str] = None,
             label_font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
             measure_data_label_style: Optional['AnalysisFunnelChartMeasureDataLabelStyle'] = None,
             measure_label_visibility: Optional['AnalysisVisibility'] = None,
             position: Optional['AnalysisDataLabelPosition'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_visibility is not None:
            _setter("category_label_visibility", category_label_visibility)
        if label_color is not None:
            _setter("label_color", label_color)
        if label_font_configuration is not None:
            _setter("label_font_configuration", label_font_configuration)
        if measure_data_label_style is not None:
            _setter("measure_data_label_style", measure_data_label_style)
        if measure_label_visibility is not None:
            _setter("measure_label_visibility", measure_label_visibility)
        if position is not None:
            _setter("position", position)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="categoryLabelVisibility")
    def category_label_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "category_label_visibility")

    @property
    @pulumi.getter(name="labelColor")
    def label_color(self) -> Optional[str]:
        return pulumi.get(self, "label_color")

    @property
    @pulumi.getter(name="labelFontConfiguration")
    def label_font_configuration(self) -> Optional['outputs.AnalysisFontConfiguration']:
        return pulumi.get(self, "label_font_configuration")

    @property
    @pulumi.getter(name="measureDataLabelStyle")
    def measure_data_label_style(self) -> Optional['AnalysisFunnelChartMeasureDataLabelStyle']:
        return pulumi.get(self, "measure_data_label_style")

    @property
    @pulumi.getter(name="measureLabelVisibility")
    def measure_label_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "measure_label_visibility")

    @property
    @pulumi.getter
    def position(self) -> Optional['AnalysisDataLabelPosition']:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisFunnelChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "funnelChartAggregatedFieldWells":
            suggest = "funnel_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFunnelChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFunnelChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFunnelChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 funnel_chart_aggregated_field_wells: Optional['outputs.AnalysisFunnelChartAggregatedFieldWells'] = None):
        AnalysisFunnelChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            funnel_chart_aggregated_field_wells=funnel_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             funnel_chart_aggregated_field_wells: Optional['outputs.AnalysisFunnelChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if funnel_chart_aggregated_field_wells is not None:
            _setter("funnel_chart_aggregated_field_wells", funnel_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="funnelChartAggregatedFieldWells")
    def funnel_chart_aggregated_field_wells(self) -> Optional['outputs.AnalysisFunnelChartAggregatedFieldWells']:
        return pulumi.get(self, "funnel_chart_aggregated_field_wells")


@pulumi.output_type
class AnalysisFunnelChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFunnelChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFunnelChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFunnelChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisFunnelChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class AnalysisFunnelChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisFunnelChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisFunnelChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisFunnelChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisFunnelChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisFunnelChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisFunnelChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisFunnelChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisGaugeChartArcConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "foregroundColor":
            suggest = "foreground_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGaugeChartArcConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGaugeChartArcConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGaugeChartArcConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 foreground_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None):
        AnalysisGaugeChartArcConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            foreground_color=foreground_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             foreground_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if foreground_color is not None:
            _setter("foreground_color", foreground_color)

    @property
    @pulumi.getter(name="foregroundColor")
    def foreground_color(self) -> Optional['outputs.AnalysisConditionalFormattingColor']:
        return pulumi.get(self, "foreground_color")


@pulumi.output_type
class AnalysisGaugeChartConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGaugeChartConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGaugeChartConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGaugeChartConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.AnalysisGaugeChartConditionalFormattingOption']] = None):
        AnalysisGaugeChartConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.AnalysisGaugeChartConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.AnalysisGaugeChartConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class AnalysisGaugeChartConditionalFormattingOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryValue":
            suggest = "primary_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGaugeChartConditionalFormattingOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGaugeChartConditionalFormattingOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGaugeChartConditionalFormattingOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc: Optional['outputs.AnalysisGaugeChartArcConditionalFormatting'] = None,
                 primary_value: Optional['outputs.AnalysisGaugeChartPrimaryValueConditionalFormatting'] = None):
        AnalysisGaugeChartConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc=arc,
            primary_value=primary_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc: Optional['outputs.AnalysisGaugeChartArcConditionalFormatting'] = None,
             primary_value: Optional['outputs.AnalysisGaugeChartPrimaryValueConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc is not None:
            _setter("arc", arc)
        if primary_value is not None:
            _setter("primary_value", primary_value)

    @property
    @pulumi.getter
    def arc(self) -> Optional['outputs.AnalysisGaugeChartArcConditionalFormatting']:
        return pulumi.get(self, "arc")

    @property
    @pulumi.getter(name="primaryValue")
    def primary_value(self) -> Optional['outputs.AnalysisGaugeChartPrimaryValueConditionalFormatting']:
        return pulumi.get(self, "primary_value")


@pulumi.output_type
class AnalysisGaugeChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "gaugeChartOptions":
            suggest = "gauge_chart_options"
        elif key == "tooltipOptions":
            suggest = "tooltip_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGaugeChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGaugeChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGaugeChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisGaugeChartFieldWells'] = None,
                 gauge_chart_options: Optional['outputs.AnalysisGaugeChartOptions'] = None,
                 tooltip_options: Optional['outputs.AnalysisTooltipOptions'] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None):
        AnalysisGaugeChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_labels=data_labels,
            field_wells=field_wells,
            gauge_chart_options=gauge_chart_options,
            tooltip_options=tooltip_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisGaugeChartFieldWells'] = None,
             gauge_chart_options: Optional['outputs.AnalysisGaugeChartOptions'] = None,
             tooltip_options: Optional['outputs.AnalysisTooltipOptions'] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if gauge_chart_options is not None:
            _setter("gauge_chart_options", gauge_chart_options)
        if tooltip_options is not None:
            _setter("tooltip_options", tooltip_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisGaugeChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="gaugeChartOptions")
    def gauge_chart_options(self) -> Optional['outputs.AnalysisGaugeChartOptions']:
        return pulumi.get(self, "gauge_chart_options")

    @property
    @pulumi.getter(name="tooltipOptions")
    def tooltip_options(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class AnalysisGaugeChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValues":
            suggest = "target_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGaugeChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGaugeChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGaugeChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisGaugeChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_values=target_values,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if target_values is not None:
            _setter("target_values", target_values)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="targetValues")
    def target_values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "target_values")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisGaugeChartOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcAxis":
            suggest = "arc_axis"
        elif key == "primaryValueDisplayType":
            suggest = "primary_value_display_type"
        elif key == "primaryValueFontConfiguration":
            suggest = "primary_value_font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGaugeChartOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGaugeChartOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGaugeChartOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc: Optional['outputs.AnalysisArcConfiguration'] = None,
                 arc_axis: Optional['outputs.AnalysisArcAxisConfiguration'] = None,
                 comparison: Optional['outputs.AnalysisComparisonConfiguration'] = None,
                 primary_value_display_type: Optional['AnalysisPrimaryValueDisplayType'] = None,
                 primary_value_font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None):
        AnalysisGaugeChartOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc=arc,
            arc_axis=arc_axis,
            comparison=comparison,
            primary_value_display_type=primary_value_display_type,
            primary_value_font_configuration=primary_value_font_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc: Optional['outputs.AnalysisArcConfiguration'] = None,
             arc_axis: Optional['outputs.AnalysisArcAxisConfiguration'] = None,
             comparison: Optional['outputs.AnalysisComparisonConfiguration'] = None,
             primary_value_display_type: Optional['AnalysisPrimaryValueDisplayType'] = None,
             primary_value_font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc is not None:
            _setter("arc", arc)
        if arc_axis is not None:
            _setter("arc_axis", arc_axis)
        if comparison is not None:
            _setter("comparison", comparison)
        if primary_value_display_type is not None:
            _setter("primary_value_display_type", primary_value_display_type)
        if primary_value_font_configuration is not None:
            _setter("primary_value_font_configuration", primary_value_font_configuration)

    @property
    @pulumi.getter
    def arc(self) -> Optional['outputs.AnalysisArcConfiguration']:
        return pulumi.get(self, "arc")

    @property
    @pulumi.getter(name="arcAxis")
    def arc_axis(self) -> Optional['outputs.AnalysisArcAxisConfiguration']:
        return pulumi.get(self, "arc_axis")

    @property
    @pulumi.getter
    def comparison(self) -> Optional['outputs.AnalysisComparisonConfiguration']:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter(name="primaryValueDisplayType")
    def primary_value_display_type(self) -> Optional['AnalysisPrimaryValueDisplayType']:
        return pulumi.get(self, "primary_value_display_type")

    @property
    @pulumi.getter(name="primaryValueFontConfiguration")
    def primary_value_font_configuration(self) -> Optional['outputs.AnalysisFontConfiguration']:
        return pulumi.get(self, "primary_value_font_configuration")


@pulumi.output_type
class AnalysisGaugeChartPrimaryValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGaugeChartPrimaryValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGaugeChartPrimaryValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGaugeChartPrimaryValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.AnalysisConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None):
        AnalysisGaugeChartPrimaryValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.AnalysisConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.AnalysisConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.AnalysisConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class AnalysisGaugeChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGaugeChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGaugeChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGaugeChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisGaugeChartConfiguration'] = None,
                 conditional_formatting: Optional['outputs.AnalysisGaugeChartConditionalFormatting'] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisGaugeChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisGaugeChartConfiguration'] = None,
             conditional_formatting: Optional['outputs.AnalysisGaugeChartConditionalFormatting'] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisGaugeChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.AnalysisGaugeChartConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisGeospatialCoordinateBounds(dict):
    def __init__(__self__, *,
                 east: float,
                 north: float,
                 south: float,
                 west: float):
        AnalysisGeospatialCoordinateBounds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            east=east,
            north=north,
            south=south,
            west=west,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             east: float,
             north: float,
             south: float,
             west: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("east", east)
        _setter("north", north)
        _setter("south", south)
        _setter("west", west)

    @property
    @pulumi.getter
    def east(self) -> float:
        return pulumi.get(self, "east")

    @property
    @pulumi.getter
    def north(self) -> float:
        return pulumi.get(self, "north")

    @property
    @pulumi.getter
    def south(self) -> float:
        return pulumi.get(self, "south")

    @property
    @pulumi.getter
    def west(self) -> float:
        return pulumi.get(self, "west")


@pulumi.output_type
class AnalysisGeospatialHeatmapColorScale(dict):
    def __init__(__self__, *,
                 colors: Optional[Sequence['outputs.AnalysisGeospatialHeatmapDataColor']] = None):
        AnalysisGeospatialHeatmapColorScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence['outputs.AnalysisGeospatialHeatmapDataColor']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if colors is not None:
            _setter("colors", colors)

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.AnalysisGeospatialHeatmapDataColor']]:
        return pulumi.get(self, "colors")


@pulumi.output_type
class AnalysisGeospatialHeatmapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "heatmapColor":
            suggest = "heatmap_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGeospatialHeatmapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGeospatialHeatmapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGeospatialHeatmapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 heatmap_color: Optional['outputs.AnalysisGeospatialHeatmapColorScale'] = None):
        AnalysisGeospatialHeatmapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            heatmap_color=heatmap_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             heatmap_color: Optional['outputs.AnalysisGeospatialHeatmapColorScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if heatmap_color is not None:
            _setter("heatmap_color", heatmap_color)

    @property
    @pulumi.getter(name="heatmapColor")
    def heatmap_color(self) -> Optional['outputs.AnalysisGeospatialHeatmapColorScale']:
        return pulumi.get(self, "heatmap_color")


@pulumi.output_type
class AnalysisGeospatialHeatmapDataColor(dict):
    def __init__(__self__, *,
                 color: str):
        AnalysisGeospatialHeatmapDataColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")


@pulumi.output_type
class AnalysisGeospatialMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 colors: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 geospatial: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisGeospatialMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
            geospatial=geospatial,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             geospatial: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if colors is not None:
            _setter("colors", colors)
        if geospatial is not None:
            _setter("geospatial", geospatial)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter
    def geospatial(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "geospatial")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisGeospatialMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldWells":
            suggest = "field_wells"
        elif key == "mapStyleOptions":
            suggest = "map_style_options"
        elif key == "pointStyleOptions":
            suggest = "point_style_options"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "windowOptions":
            suggest = "window_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGeospatialMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGeospatialMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGeospatialMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_wells: Optional['outputs.AnalysisGeospatialMapFieldWells'] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 map_style_options: Optional['outputs.AnalysisGeospatialMapStyleOptions'] = None,
                 point_style_options: Optional['outputs.AnalysisGeospatialPointStyleOptions'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
                 window_options: Optional['outputs.AnalysisGeospatialWindowOptions'] = None):
        AnalysisGeospatialMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_wells=field_wells,
            legend=legend,
            map_style_options=map_style_options,
            point_style_options=point_style_options,
            tooltip=tooltip,
            visual_palette=visual_palette,
            window_options=window_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_wells: Optional['outputs.AnalysisGeospatialMapFieldWells'] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             map_style_options: Optional['outputs.AnalysisGeospatialMapStyleOptions'] = None,
             point_style_options: Optional['outputs.AnalysisGeospatialPointStyleOptions'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             window_options: Optional['outputs.AnalysisGeospatialWindowOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if map_style_options is not None:
            _setter("map_style_options", map_style_options)
        if point_style_options is not None:
            _setter("point_style_options", point_style_options)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if window_options is not None:
            _setter("window_options", window_options)

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisGeospatialMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="mapStyleOptions")
    def map_style_options(self) -> Optional['outputs.AnalysisGeospatialMapStyleOptions']:
        return pulumi.get(self, "map_style_options")

    @property
    @pulumi.getter(name="pointStyleOptions")
    def point_style_options(self) -> Optional['outputs.AnalysisGeospatialPointStyleOptions']:
        return pulumi.get(self, "point_style_options")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="windowOptions")
    def window_options(self) -> Optional['outputs.AnalysisGeospatialWindowOptions']:
        return pulumi.get(self, "window_options")


@pulumi.output_type
class AnalysisGeospatialMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geospatialMapAggregatedFieldWells":
            suggest = "geospatial_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGeospatialMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGeospatialMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGeospatialMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geospatial_map_aggregated_field_wells: Optional['outputs.AnalysisGeospatialMapAggregatedFieldWells'] = None):
        AnalysisGeospatialMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            geospatial_map_aggregated_field_wells=geospatial_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             geospatial_map_aggregated_field_wells: Optional['outputs.AnalysisGeospatialMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if geospatial_map_aggregated_field_wells is not None:
            _setter("geospatial_map_aggregated_field_wells", geospatial_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="geospatialMapAggregatedFieldWells")
    def geospatial_map_aggregated_field_wells(self) -> Optional['outputs.AnalysisGeospatialMapAggregatedFieldWells']:
        return pulumi.get(self, "geospatial_map_aggregated_field_wells")


@pulumi.output_type
class AnalysisGeospatialMapStyleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseMapStyle":
            suggest = "base_map_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGeospatialMapStyleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGeospatialMapStyleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGeospatialMapStyleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_map_style: Optional['AnalysisBaseMapStyleType'] = None):
        AnalysisGeospatialMapStyleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base_map_style=base_map_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base_map_style: Optional['AnalysisBaseMapStyleType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if base_map_style is not None:
            _setter("base_map_style", base_map_style)

    @property
    @pulumi.getter(name="baseMapStyle")
    def base_map_style(self) -> Optional['AnalysisBaseMapStyleType']:
        return pulumi.get(self, "base_map_style")


@pulumi.output_type
class AnalysisGeospatialMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGeospatialMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGeospatialMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGeospatialMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisGeospatialMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisGeospatialMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisGeospatialMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisGeospatialMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisGeospatialPointStyleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterMarkerConfiguration":
            suggest = "cluster_marker_configuration"
        elif key == "heatmapConfiguration":
            suggest = "heatmap_configuration"
        elif key == "selectedPointStyle":
            suggest = "selected_point_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGeospatialPointStyleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGeospatialPointStyleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGeospatialPointStyleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_marker_configuration: Optional['outputs.AnalysisClusterMarkerConfiguration'] = None,
                 heatmap_configuration: Optional['outputs.AnalysisGeospatialHeatmapConfiguration'] = None,
                 selected_point_style: Optional['AnalysisGeospatialSelectedPointStyle'] = None):
        AnalysisGeospatialPointStyleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_marker_configuration=cluster_marker_configuration,
            heatmap_configuration=heatmap_configuration,
            selected_point_style=selected_point_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_marker_configuration: Optional['outputs.AnalysisClusterMarkerConfiguration'] = None,
             heatmap_configuration: Optional['outputs.AnalysisGeospatialHeatmapConfiguration'] = None,
             selected_point_style: Optional['AnalysisGeospatialSelectedPointStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cluster_marker_configuration is not None:
            _setter("cluster_marker_configuration", cluster_marker_configuration)
        if heatmap_configuration is not None:
            _setter("heatmap_configuration", heatmap_configuration)
        if selected_point_style is not None:
            _setter("selected_point_style", selected_point_style)

    @property
    @pulumi.getter(name="clusterMarkerConfiguration")
    def cluster_marker_configuration(self) -> Optional['outputs.AnalysisClusterMarkerConfiguration']:
        return pulumi.get(self, "cluster_marker_configuration")

    @property
    @pulumi.getter(name="heatmapConfiguration")
    def heatmap_configuration(self) -> Optional['outputs.AnalysisGeospatialHeatmapConfiguration']:
        return pulumi.get(self, "heatmap_configuration")

    @property
    @pulumi.getter(name="selectedPointStyle")
    def selected_point_style(self) -> Optional['AnalysisGeospatialSelectedPointStyle']:
        return pulumi.get(self, "selected_point_style")


@pulumi.output_type
class AnalysisGeospatialWindowOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mapZoomMode":
            suggest = "map_zoom_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGeospatialWindowOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGeospatialWindowOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGeospatialWindowOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bounds: Optional['outputs.AnalysisGeospatialCoordinateBounds'] = None,
                 map_zoom_mode: Optional['AnalysisMapZoomMode'] = None):
        AnalysisGeospatialWindowOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bounds=bounds,
            map_zoom_mode=map_zoom_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bounds: Optional['outputs.AnalysisGeospatialCoordinateBounds'] = None,
             map_zoom_mode: Optional['AnalysisMapZoomMode'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bounds is not None:
            _setter("bounds", bounds)
        if map_zoom_mode is not None:
            _setter("map_zoom_mode", map_zoom_mode)

    @property
    @pulumi.getter
    def bounds(self) -> Optional['outputs.AnalysisGeospatialCoordinateBounds']:
        return pulumi.get(self, "bounds")

    @property
    @pulumi.getter(name="mapZoomMode")
    def map_zoom_mode(self) -> Optional['AnalysisMapZoomMode']:
        return pulumi.get(self, "map_zoom_mode")


@pulumi.output_type
class AnalysisGlobalTableBorderOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sideSpecificBorder":
            suggest = "side_specific_border"
        elif key == "uniformBorder":
            suggest = "uniform_border"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGlobalTableBorderOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGlobalTableBorderOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGlobalTableBorderOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 side_specific_border: Optional['outputs.AnalysisTableSideBorderOptions'] = None,
                 uniform_border: Optional['outputs.AnalysisTableBorderOptions'] = None):
        AnalysisGlobalTableBorderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            side_specific_border=side_specific_border,
            uniform_border=uniform_border,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             side_specific_border: Optional['outputs.AnalysisTableSideBorderOptions'] = None,
             uniform_border: Optional['outputs.AnalysisTableBorderOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if side_specific_border is not None:
            _setter("side_specific_border", side_specific_border)
        if uniform_border is not None:
            _setter("uniform_border", uniform_border)

    @property
    @pulumi.getter(name="sideSpecificBorder")
    def side_specific_border(self) -> Optional['outputs.AnalysisTableSideBorderOptions']:
        return pulumi.get(self, "side_specific_border")

    @property
    @pulumi.getter(name="uniformBorder")
    def uniform_border(self) -> Optional['outputs.AnalysisTableBorderOptions']:
        return pulumi.get(self, "uniform_border")


@pulumi.output_type
class AnalysisGradientColor(dict):
    def __init__(__self__, *,
                 stops: Optional[Sequence['outputs.AnalysisGradientStop']] = None):
        AnalysisGradientColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stops=stops,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stops: Optional[Sequence['outputs.AnalysisGradientStop']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if stops is not None:
            _setter("stops", stops)

    @property
    @pulumi.getter
    def stops(self) -> Optional[Sequence['outputs.AnalysisGradientStop']]:
        return pulumi.get(self, "stops")


@pulumi.output_type
class AnalysisGradientStop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gradientOffset":
            suggest = "gradient_offset"
        elif key == "dataValue":
            suggest = "data_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGradientStop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGradientStop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGradientStop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gradient_offset: float,
                 color: Optional[str] = None,
                 data_value: Optional[float] = None):
        AnalysisGradientStop._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gradient_offset=gradient_offset,
            color=color,
            data_value=data_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gradient_offset: float,
             color: Optional[str] = None,
             data_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("gradient_offset", gradient_offset)
        if color is not None:
            _setter("color", color)
        if data_value is not None:
            _setter("data_value", data_value)

    @property
    @pulumi.getter(name="gradientOffset")
    def gradient_offset(self) -> float:
        return pulumi.get(self, "gradient_offset")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="dataValue")
    def data_value(self) -> Optional[float]:
        return pulumi.get(self, "data_value")


@pulumi.output_type
class AnalysisGridLayoutCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "screenCanvasSizeOptions":
            suggest = "screen_canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGridLayoutCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGridLayoutCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGridLayoutCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 screen_canvas_size_options: Optional['outputs.AnalysisGridLayoutScreenCanvasSizeOptions'] = None):
        AnalysisGridLayoutCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            screen_canvas_size_options=screen_canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             screen_canvas_size_options: Optional['outputs.AnalysisGridLayoutScreenCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if screen_canvas_size_options is not None:
            _setter("screen_canvas_size_options", screen_canvas_size_options)

    @property
    @pulumi.getter(name="screenCanvasSizeOptions")
    def screen_canvas_size_options(self) -> Optional['outputs.AnalysisGridLayoutScreenCanvasSizeOptions']:
        return pulumi.get(self, "screen_canvas_size_options")


@pulumi.output_type
class AnalysisGridLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGridLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGridLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGridLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 elements: Sequence['outputs.AnalysisGridLayoutElement'],
                 canvas_size_options: Optional['outputs.AnalysisGridLayoutCanvasSizeOptions'] = None):
        AnalysisGridLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elements=elements,
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elements: Sequence['outputs.AnalysisGridLayoutElement'],
             canvas_size_options: Optional['outputs.AnalysisGridLayoutCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("elements", elements)
        if canvas_size_options is not None:
            _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter
    def elements(self) -> Sequence['outputs.AnalysisGridLayoutElement']:
        return pulumi.get(self, "elements")

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> Optional['outputs.AnalysisGridLayoutCanvasSizeOptions']:
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class AnalysisGridLayoutElement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnSpan":
            suggest = "column_span"
        elif key == "elementId":
            suggest = "element_id"
        elif key == "elementType":
            suggest = "element_type"
        elif key == "rowSpan":
            suggest = "row_span"
        elif key == "columnIndex":
            suggest = "column_index"
        elif key == "rowIndex":
            suggest = "row_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGridLayoutElement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGridLayoutElement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGridLayoutElement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_span: float,
                 element_id: str,
                 element_type: 'AnalysisLayoutElementType',
                 row_span: float,
                 column_index: Optional[float] = None,
                 row_index: Optional[float] = None):
        AnalysisGridLayoutElement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_span=column_span,
            element_id=element_id,
            element_type=element_type,
            row_span=row_span,
            column_index=column_index,
            row_index=row_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_span: float,
             element_id: str,
             element_type: 'AnalysisLayoutElementType',
             row_span: float,
             column_index: Optional[float] = None,
             row_index: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column_span", column_span)
        _setter("element_id", element_id)
        _setter("element_type", element_type)
        _setter("row_span", row_span)
        if column_index is not None:
            _setter("column_index", column_index)
        if row_index is not None:
            _setter("row_index", row_index)

    @property
    @pulumi.getter(name="columnSpan")
    def column_span(self) -> float:
        return pulumi.get(self, "column_span")

    @property
    @pulumi.getter(name="elementId")
    def element_id(self) -> str:
        return pulumi.get(self, "element_id")

    @property
    @pulumi.getter(name="elementType")
    def element_type(self) -> 'AnalysisLayoutElementType':
        return pulumi.get(self, "element_type")

    @property
    @pulumi.getter(name="rowSpan")
    def row_span(self) -> float:
        return pulumi.get(self, "row_span")

    @property
    @pulumi.getter(name="columnIndex")
    def column_index(self) -> Optional[float]:
        return pulumi.get(self, "column_index")

    @property
    @pulumi.getter(name="rowIndex")
    def row_index(self) -> Optional[float]:
        return pulumi.get(self, "row_index")


@pulumi.output_type
class AnalysisGridLayoutScreenCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resizeOption":
            suggest = "resize_option"
        elif key == "optimizedViewPortWidth":
            suggest = "optimized_view_port_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGridLayoutScreenCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGridLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGridLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resize_option: 'AnalysisResizeOption',
                 optimized_view_port_width: Optional[str] = None):
        """
        :param str optimized_view_port_width: String based length that is composed of value and unit in px
        """
        AnalysisGridLayoutScreenCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resize_option=resize_option,
            optimized_view_port_width=optimized_view_port_width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resize_option: 'AnalysisResizeOption',
             optimized_view_port_width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("resize_option", resize_option)
        if optimized_view_port_width is not None:
            _setter("optimized_view_port_width", optimized_view_port_width)

    @property
    @pulumi.getter(name="resizeOption")
    def resize_option(self) -> 'AnalysisResizeOption':
        return pulumi.get(self, "resize_option")

    @property
    @pulumi.getter(name="optimizedViewPortWidth")
    def optimized_view_port_width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "optimized_view_port_width")


@pulumi.output_type
class AnalysisGrowthRateComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "periodSize":
            suggest = "period_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisGrowthRateComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisGrowthRateComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisGrowthRateComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 period_size: Optional[float] = None,
                 time: Optional['outputs.AnalysisDimensionField'] = None,
                 value: Optional['outputs.AnalysisMeasureField'] = None):
        AnalysisGrowthRateComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            period_size=period_size,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             period_size: Optional[float] = None,
             time: Optional['outputs.AnalysisDimensionField'] = None,
             value: Optional['outputs.AnalysisMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if period_size is not None:
            _setter("period_size", period_size)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="periodSize")
    def period_size(self) -> Optional[float]:
        return pulumi.get(self, "period_size")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.AnalysisDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AnalysisMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisHeaderFooterSectionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionId":
            suggest = "section_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisHeaderFooterSectionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisHeaderFooterSectionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisHeaderFooterSectionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layout: 'outputs.AnalysisSectionLayoutConfiguration',
                 section_id: str,
                 style: Optional['outputs.AnalysisSectionStyle'] = None):
        AnalysisHeaderFooterSectionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            layout=layout,
            section_id=section_id,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             layout: 'outputs.AnalysisSectionLayoutConfiguration',
             section_id: str,
             style: Optional['outputs.AnalysisSectionStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("layout", layout)
        _setter("section_id", section_id)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter
    def layout(self) -> 'outputs.AnalysisSectionLayoutConfiguration':
        return pulumi.get(self, "layout")

    @property
    @pulumi.getter(name="sectionId")
    def section_id(self) -> str:
        return pulumi.get(self, "section_id")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.AnalysisSectionStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class AnalysisHeatMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 columns: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 rows: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisHeatMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            rows=rows,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             rows: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if columns is not None:
            _setter("columns", columns)
        if rows is not None:
            _setter("rows", rows)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def rows(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "rows")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisHeatMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorScale":
            suggest = "color_scale"
        elif key == "columnLabelOptions":
            suggest = "column_label_options"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "rowLabelOptions":
            suggest = "row_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisHeatMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisHeatMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisHeatMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_scale: Optional['outputs.AnalysisColorScale'] = None,
                 column_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisHeatMapFieldWells'] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 row_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.AnalysisHeatMapSortConfiguration'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None):
        AnalysisHeatMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_scale=color_scale,
            column_label_options=column_label_options,
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            row_label_options=row_label_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_scale: Optional['outputs.AnalysisColorScale'] = None,
             column_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisHeatMapFieldWells'] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             row_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.AnalysisHeatMapSortConfiguration'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color_scale is not None:
            _setter("color_scale", color_scale)
        if column_label_options is not None:
            _setter("column_label_options", column_label_options)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if row_label_options is not None:
            _setter("row_label_options", row_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)

    @property
    @pulumi.getter(name="colorScale")
    def color_scale(self) -> Optional['outputs.AnalysisColorScale']:
        return pulumi.get(self, "color_scale")

    @property
    @pulumi.getter(name="columnLabelOptions")
    def column_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "column_label_options")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisHeatMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="rowLabelOptions")
    def row_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "row_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisHeatMapSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")


@pulumi.output_type
class AnalysisHeatMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "heatMapAggregatedFieldWells":
            suggest = "heat_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisHeatMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisHeatMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisHeatMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 heat_map_aggregated_field_wells: Optional['outputs.AnalysisHeatMapAggregatedFieldWells'] = None):
        AnalysisHeatMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            heat_map_aggregated_field_wells=heat_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             heat_map_aggregated_field_wells: Optional['outputs.AnalysisHeatMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if heat_map_aggregated_field_wells is not None:
            _setter("heat_map_aggregated_field_wells", heat_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="heatMapAggregatedFieldWells")
    def heat_map_aggregated_field_wells(self) -> Optional['outputs.AnalysisHeatMapAggregatedFieldWells']:
        return pulumi.get(self, "heat_map_aggregated_field_wells")


@pulumi.output_type
class AnalysisHeatMapSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "heatMapColumnItemsLimitConfiguration":
            suggest = "heat_map_column_items_limit_configuration"
        elif key == "heatMapColumnSort":
            suggest = "heat_map_column_sort"
        elif key == "heatMapRowItemsLimitConfiguration":
            suggest = "heat_map_row_items_limit_configuration"
        elif key == "heatMapRowSort":
            suggest = "heat_map_row_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisHeatMapSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisHeatMapSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisHeatMapSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 heat_map_column_items_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 heat_map_column_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
                 heat_map_row_items_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 heat_map_row_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisHeatMapSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            heat_map_column_items_limit_configuration=heat_map_column_items_limit_configuration,
            heat_map_column_sort=heat_map_column_sort,
            heat_map_row_items_limit_configuration=heat_map_row_items_limit_configuration,
            heat_map_row_sort=heat_map_row_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             heat_map_column_items_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             heat_map_column_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             heat_map_row_items_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             heat_map_row_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if heat_map_column_items_limit_configuration is not None:
            _setter("heat_map_column_items_limit_configuration", heat_map_column_items_limit_configuration)
        if heat_map_column_sort is not None:
            _setter("heat_map_column_sort", heat_map_column_sort)
        if heat_map_row_items_limit_configuration is not None:
            _setter("heat_map_row_items_limit_configuration", heat_map_row_items_limit_configuration)
        if heat_map_row_sort is not None:
            _setter("heat_map_row_sort", heat_map_row_sort)

    @property
    @pulumi.getter(name="heatMapColumnItemsLimitConfiguration")
    def heat_map_column_items_limit_configuration(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "heat_map_column_items_limit_configuration")

    @property
    @pulumi.getter(name="heatMapColumnSort")
    def heat_map_column_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "heat_map_column_sort")

    @property
    @pulumi.getter(name="heatMapRowItemsLimitConfiguration")
    def heat_map_row_items_limit_configuration(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "heat_map_row_items_limit_configuration")

    @property
    @pulumi.getter(name="heatMapRowSort")
    def heat_map_row_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "heat_map_row_sort")


@pulumi.output_type
class AnalysisHeatMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisHeatMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisHeatMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisHeatMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisHeatMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisHeatMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisHeatMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisHeatMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisHistogramAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisHistogramAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisHistogramBinOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binCount":
            suggest = "bin_count"
        elif key == "binWidth":
            suggest = "bin_width"
        elif key == "selectedBinType":
            suggest = "selected_bin_type"
        elif key == "startValue":
            suggest = "start_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisHistogramBinOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisHistogramBinOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisHistogramBinOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bin_count: Optional['outputs.AnalysisBinCountOptions'] = None,
                 bin_width: Optional['outputs.AnalysisBinWidthOptions'] = None,
                 selected_bin_type: Optional['AnalysisHistogramBinType'] = None,
                 start_value: Optional[float] = None):
        AnalysisHistogramBinOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bin_count=bin_count,
            bin_width=bin_width,
            selected_bin_type=selected_bin_type,
            start_value=start_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bin_count: Optional['outputs.AnalysisBinCountOptions'] = None,
             bin_width: Optional['outputs.AnalysisBinWidthOptions'] = None,
             selected_bin_type: Optional['AnalysisHistogramBinType'] = None,
             start_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bin_count is not None:
            _setter("bin_count", bin_count)
        if bin_width is not None:
            _setter("bin_width", bin_width)
        if selected_bin_type is not None:
            _setter("selected_bin_type", selected_bin_type)
        if start_value is not None:
            _setter("start_value", start_value)

    @property
    @pulumi.getter(name="binCount")
    def bin_count(self) -> Optional['outputs.AnalysisBinCountOptions']:
        return pulumi.get(self, "bin_count")

    @property
    @pulumi.getter(name="binWidth")
    def bin_width(self) -> Optional['outputs.AnalysisBinWidthOptions']:
        return pulumi.get(self, "bin_width")

    @property
    @pulumi.getter(name="selectedBinType")
    def selected_bin_type(self) -> Optional['AnalysisHistogramBinType']:
        return pulumi.get(self, "selected_bin_type")

    @property
    @pulumi.getter(name="startValue")
    def start_value(self) -> Optional[float]:
        return pulumi.get(self, "start_value")


@pulumi.output_type
class AnalysisHistogramConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binOptions":
            suggest = "bin_options"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "xAxisDisplayOptions":
            suggest = "x_axis_display_options"
        elif key == "xAxisLabelOptions":
            suggest = "x_axis_label_options"
        elif key == "yAxisDisplayOptions":
            suggest = "y_axis_display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisHistogramConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisHistogramConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisHistogramConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bin_options: Optional['outputs.AnalysisHistogramBinOptions'] = None,
                 data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisHistogramFieldWells'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
                 x_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 x_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None):
        AnalysisHistogramConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bin_options=bin_options,
            data_labels=data_labels,
            field_wells=field_wells,
            tooltip=tooltip,
            visual_palette=visual_palette,
            x_axis_display_options=x_axis_display_options,
            x_axis_label_options=x_axis_label_options,
            y_axis_display_options=y_axis_display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bin_options: Optional['outputs.AnalysisHistogramBinOptions'] = None,
             data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisHistogramFieldWells'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             x_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             x_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bin_options is not None:
            _setter("bin_options", bin_options)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if x_axis_display_options is not None:
            _setter("x_axis_display_options", x_axis_display_options)
        if x_axis_label_options is not None:
            _setter("x_axis_label_options", x_axis_label_options)
        if y_axis_display_options is not None:
            _setter("y_axis_display_options", y_axis_display_options)

    @property
    @pulumi.getter(name="binOptions")
    def bin_options(self) -> Optional['outputs.AnalysisHistogramBinOptions']:
        return pulumi.get(self, "bin_options")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisHistogramFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="xAxisDisplayOptions")
    def x_axis_display_options(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "x_axis_display_options")

    @property
    @pulumi.getter(name="xAxisLabelOptions")
    def x_axis_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "x_axis_label_options")

    @property
    @pulumi.getter(name="yAxisDisplayOptions")
    def y_axis_display_options(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "y_axis_display_options")


@pulumi.output_type
class AnalysisHistogramFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "histogramAggregatedFieldWells":
            suggest = "histogram_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisHistogramFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisHistogramFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisHistogramFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 histogram_aggregated_field_wells: Optional['outputs.AnalysisHistogramAggregatedFieldWells'] = None):
        AnalysisHistogramFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            histogram_aggregated_field_wells=histogram_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             histogram_aggregated_field_wells: Optional['outputs.AnalysisHistogramAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if histogram_aggregated_field_wells is not None:
            _setter("histogram_aggregated_field_wells", histogram_aggregated_field_wells)

    @property
    @pulumi.getter(name="histogramAggregatedFieldWells")
    def histogram_aggregated_field_wells(self) -> Optional['outputs.AnalysisHistogramAggregatedFieldWells']:
        return pulumi.get(self, "histogram_aggregated_field_wells")


@pulumi.output_type
class AnalysisHistogramVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisHistogramVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisHistogramVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisHistogramVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisHistogramConfiguration'] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisHistogramVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisHistogramConfiguration'] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisHistogramConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisInsightConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customNarrative":
            suggest = "custom_narrative"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisInsightConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisInsightConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisInsightConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computations: Optional[Sequence['outputs.AnalysisComputation']] = None,
                 custom_narrative: Optional['outputs.AnalysisCustomNarrativeOptions'] = None):
        AnalysisInsightConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computations=computations,
            custom_narrative=custom_narrative,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computations: Optional[Sequence['outputs.AnalysisComputation']] = None,
             custom_narrative: Optional['outputs.AnalysisCustomNarrativeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if computations is not None:
            _setter("computations", computations)
        if custom_narrative is not None:
            _setter("custom_narrative", custom_narrative)

    @property
    @pulumi.getter
    def computations(self) -> Optional[Sequence['outputs.AnalysisComputation']]:
        return pulumi.get(self, "computations")

    @property
    @pulumi.getter(name="customNarrative")
    def custom_narrative(self) -> Optional['outputs.AnalysisCustomNarrativeOptions']:
        return pulumi.get(self, "custom_narrative")


@pulumi.output_type
class AnalysisInsightVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "visualId":
            suggest = "visual_id"
        elif key == "insightConfiguration":
            suggest = "insight_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisInsightVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisInsightVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisInsightVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 insight_configuration: Optional['outputs.AnalysisInsightConfiguration'] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisInsightVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            visual_id=visual_id,
            actions=actions,
            insight_configuration=insight_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             insight_configuration: Optional['outputs.AnalysisInsightConfiguration'] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if insight_configuration is not None:
            _setter("insight_configuration", insight_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="insightConfiguration")
    def insight_configuration(self) -> Optional['outputs.AnalysisInsightConfiguration']:
        return pulumi.get(self, "insight_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisIntegerDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisIntegerDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisIntegerDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisIntegerDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.AnalysisDynamicDefaultValue'] = None,
                 static_values: Optional[Sequence[float]] = None):
        AnalysisIntegerDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.AnalysisDynamicDefaultValue'] = None,
             static_values: Optional[Sequence[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.AnalysisDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class AnalysisIntegerParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[float]):
        AnalysisIntegerParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[float],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[float]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisIntegerParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueType":
            suggest = "parameter_value_type"
        elif key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisIntegerParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisIntegerParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisIntegerParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 parameter_value_type: 'AnalysisParameterValueType',
                 default_values: Optional['outputs.AnalysisIntegerDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.AnalysisMappedDataSetParameter']] = None,
                 value_when_unset: Optional['outputs.AnalysisIntegerValueWhenUnsetConfiguration'] = None):
        AnalysisIntegerParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameter_value_type=parameter_value_type,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             parameter_value_type: 'AnalysisParameterValueType',
             default_values: Optional['outputs.AnalysisIntegerDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.AnalysisMappedDataSetParameter']] = None,
             value_when_unset: Optional['outputs.AnalysisIntegerValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("parameter_value_type", parameter_value_type)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterValueType")
    def parameter_value_type(self) -> 'AnalysisParameterValueType':
        return pulumi.get(self, "parameter_value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.AnalysisIntegerDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.AnalysisMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.AnalysisIntegerValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class AnalysisIntegerValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisIntegerValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisIntegerValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisIntegerValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[float] = None,
                 value_when_unset_option: Optional['AnalysisValueWhenUnsetOption'] = None):
        AnalysisIntegerValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[float] = None,
             value_when_unset_option: Optional['AnalysisValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[float]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['AnalysisValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class AnalysisItemsLimitConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "itemsLimit":
            suggest = "items_limit"
        elif key == "otherCategories":
            suggest = "other_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisItemsLimitConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisItemsLimitConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisItemsLimitConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 items_limit: Optional[float] = None,
                 other_categories: Optional['AnalysisOtherCategories'] = None):
        AnalysisItemsLimitConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items_limit=items_limit,
            other_categories=other_categories,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items_limit: Optional[float] = None,
             other_categories: Optional['AnalysisOtherCategories'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if items_limit is not None:
            _setter("items_limit", items_limit)
        if other_categories is not None:
            _setter("other_categories", other_categories)

    @property
    @pulumi.getter(name="itemsLimit")
    def items_limit(self) -> Optional[float]:
        return pulumi.get(self, "items_limit")

    @property
    @pulumi.getter(name="otherCategories")
    def other_categories(self) -> Optional['AnalysisOtherCategories']:
        return pulumi.get(self, "other_categories")


@pulumi.output_type
class AnalysisKpiActualValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiActualValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiActualValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiActualValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.AnalysisConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None):
        AnalysisKpiActualValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.AnalysisConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.AnalysisConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.AnalysisConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class AnalysisKpiComparisonValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiComparisonValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiComparisonValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiComparisonValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.AnalysisConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None):
        AnalysisKpiComparisonValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.AnalysisConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.AnalysisConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.AnalysisConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class AnalysisKpiConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.AnalysisKpiConditionalFormattingOption']] = None):
        AnalysisKpiConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.AnalysisKpiConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.AnalysisKpiConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class AnalysisKpiConditionalFormattingOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actualValue":
            suggest = "actual_value"
        elif key == "comparisonValue":
            suggest = "comparison_value"
        elif key == "primaryValue":
            suggest = "primary_value"
        elif key == "progressBar":
            suggest = "progress_bar"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiConditionalFormattingOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiConditionalFormattingOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiConditionalFormattingOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actual_value: Optional['outputs.AnalysisKpiActualValueConditionalFormatting'] = None,
                 comparison_value: Optional['outputs.AnalysisKpiComparisonValueConditionalFormatting'] = None,
                 primary_value: Optional['outputs.AnalysisKpiPrimaryValueConditionalFormatting'] = None,
                 progress_bar: Optional['outputs.AnalysisKpiProgressBarConditionalFormatting'] = None):
        AnalysisKpiConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actual_value=actual_value,
            comparison_value=comparison_value,
            primary_value=primary_value,
            progress_bar=progress_bar,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actual_value: Optional['outputs.AnalysisKpiActualValueConditionalFormatting'] = None,
             comparison_value: Optional['outputs.AnalysisKpiComparisonValueConditionalFormatting'] = None,
             primary_value: Optional['outputs.AnalysisKpiPrimaryValueConditionalFormatting'] = None,
             progress_bar: Optional['outputs.AnalysisKpiProgressBarConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if actual_value is not None:
            _setter("actual_value", actual_value)
        if comparison_value is not None:
            _setter("comparison_value", comparison_value)
        if primary_value is not None:
            _setter("primary_value", primary_value)
        if progress_bar is not None:
            _setter("progress_bar", progress_bar)

    @property
    @pulumi.getter(name="actualValue")
    def actual_value(self) -> Optional['outputs.AnalysisKpiActualValueConditionalFormatting']:
        return pulumi.get(self, "actual_value")

    @property
    @pulumi.getter(name="comparisonValue")
    def comparison_value(self) -> Optional['outputs.AnalysisKpiComparisonValueConditionalFormatting']:
        return pulumi.get(self, "comparison_value")

    @property
    @pulumi.getter(name="primaryValue")
    def primary_value(self) -> Optional['outputs.AnalysisKpiPrimaryValueConditionalFormatting']:
        return pulumi.get(self, "primary_value")

    @property
    @pulumi.getter(name="progressBar")
    def progress_bar(self) -> Optional['outputs.AnalysisKpiProgressBarConditionalFormatting']:
        return pulumi.get(self, "progress_bar")


@pulumi.output_type
class AnalysisKpiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldWells":
            suggest = "field_wells"
        elif key == "kpiOptions":
            suggest = "kpi_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_wells: Optional['outputs.AnalysisKpiFieldWells'] = None,
                 kpi_options: Optional['outputs.AnalysisKpiOptions'] = None,
                 sort_configuration: Optional['outputs.AnalysisKpiSortConfiguration'] = None):
        AnalysisKpiConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_wells=field_wells,
            kpi_options=kpi_options,
            sort_configuration=sort_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_wells: Optional['outputs.AnalysisKpiFieldWells'] = None,
             kpi_options: Optional['outputs.AnalysisKpiOptions'] = None,
             sort_configuration: Optional['outputs.AnalysisKpiSortConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if kpi_options is not None:
            _setter("kpi_options", kpi_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisKpiFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="kpiOptions")
    def kpi_options(self) -> Optional['outputs.AnalysisKpiOptions']:
        return pulumi.get(self, "kpi_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisKpiSortConfiguration']:
        return pulumi.get(self, "sort_configuration")


@pulumi.output_type
class AnalysisKpiFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValues":
            suggest = "target_values"
        elif key == "trendGroups":
            suggest = "trend_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
                 trend_groups: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisKpiFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_values=target_values,
            trend_groups=trend_groups,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             trend_groups: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if target_values is not None:
            _setter("target_values", target_values)
        if trend_groups is not None:
            _setter("trend_groups", trend_groups)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="targetValues")
    def target_values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "target_values")

    @property
    @pulumi.getter(name="trendGroups")
    def trend_groups(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "trend_groups")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisKpiOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryValueDisplayType":
            suggest = "primary_value_display_type"
        elif key == "primaryValueFontConfiguration":
            suggest = "primary_value_font_configuration"
        elif key == "progressBar":
            suggest = "progress_bar"
        elif key == "secondaryValue":
            suggest = "secondary_value"
        elif key == "secondaryValueFontConfiguration":
            suggest = "secondary_value_font_configuration"
        elif key == "trendArrows":
            suggest = "trend_arrows"
        elif key == "visualLayoutOptions":
            suggest = "visual_layout_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: Optional['outputs.AnalysisComparisonConfiguration'] = None,
                 primary_value_display_type: Optional['AnalysisPrimaryValueDisplayType'] = None,
                 primary_value_font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
                 progress_bar: Optional['outputs.AnalysisProgressBarOptions'] = None,
                 secondary_value: Optional['outputs.AnalysisSecondaryValueOptions'] = None,
                 secondary_value_font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
                 sparkline: Optional['outputs.AnalysisKpiSparklineOptions'] = None,
                 trend_arrows: Optional['outputs.AnalysisTrendArrowOptions'] = None,
                 visual_layout_options: Optional['outputs.AnalysisKpiVisualLayoutOptions'] = None):
        AnalysisKpiOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison=comparison,
            primary_value_display_type=primary_value_display_type,
            primary_value_font_configuration=primary_value_font_configuration,
            progress_bar=progress_bar,
            secondary_value=secondary_value,
            secondary_value_font_configuration=secondary_value_font_configuration,
            sparkline=sparkline,
            trend_arrows=trend_arrows,
            visual_layout_options=visual_layout_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison: Optional['outputs.AnalysisComparisonConfiguration'] = None,
             primary_value_display_type: Optional['AnalysisPrimaryValueDisplayType'] = None,
             primary_value_font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
             progress_bar: Optional['outputs.AnalysisProgressBarOptions'] = None,
             secondary_value: Optional['outputs.AnalysisSecondaryValueOptions'] = None,
             secondary_value_font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
             sparkline: Optional['outputs.AnalysisKpiSparklineOptions'] = None,
             trend_arrows: Optional['outputs.AnalysisTrendArrowOptions'] = None,
             visual_layout_options: Optional['outputs.AnalysisKpiVisualLayoutOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if comparison is not None:
            _setter("comparison", comparison)
        if primary_value_display_type is not None:
            _setter("primary_value_display_type", primary_value_display_type)
        if primary_value_font_configuration is not None:
            _setter("primary_value_font_configuration", primary_value_font_configuration)
        if progress_bar is not None:
            _setter("progress_bar", progress_bar)
        if secondary_value is not None:
            _setter("secondary_value", secondary_value)
        if secondary_value_font_configuration is not None:
            _setter("secondary_value_font_configuration", secondary_value_font_configuration)
        if sparkline is not None:
            _setter("sparkline", sparkline)
        if trend_arrows is not None:
            _setter("trend_arrows", trend_arrows)
        if visual_layout_options is not None:
            _setter("visual_layout_options", visual_layout_options)

    @property
    @pulumi.getter
    def comparison(self) -> Optional['outputs.AnalysisComparisonConfiguration']:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter(name="primaryValueDisplayType")
    def primary_value_display_type(self) -> Optional['AnalysisPrimaryValueDisplayType']:
        return pulumi.get(self, "primary_value_display_type")

    @property
    @pulumi.getter(name="primaryValueFontConfiguration")
    def primary_value_font_configuration(self) -> Optional['outputs.AnalysisFontConfiguration']:
        return pulumi.get(self, "primary_value_font_configuration")

    @property
    @pulumi.getter(name="progressBar")
    def progress_bar(self) -> Optional['outputs.AnalysisProgressBarOptions']:
        return pulumi.get(self, "progress_bar")

    @property
    @pulumi.getter(name="secondaryValue")
    def secondary_value(self) -> Optional['outputs.AnalysisSecondaryValueOptions']:
        return pulumi.get(self, "secondary_value")

    @property
    @pulumi.getter(name="secondaryValueFontConfiguration")
    def secondary_value_font_configuration(self) -> Optional['outputs.AnalysisFontConfiguration']:
        return pulumi.get(self, "secondary_value_font_configuration")

    @property
    @pulumi.getter
    def sparkline(self) -> Optional['outputs.AnalysisKpiSparklineOptions']:
        return pulumi.get(self, "sparkline")

    @property
    @pulumi.getter(name="trendArrows")
    def trend_arrows(self) -> Optional['outputs.AnalysisTrendArrowOptions']:
        return pulumi.get(self, "trend_arrows")

    @property
    @pulumi.getter(name="visualLayoutOptions")
    def visual_layout_options(self) -> Optional['outputs.AnalysisKpiVisualLayoutOptions']:
        return pulumi.get(self, "visual_layout_options")


@pulumi.output_type
class AnalysisKpiPrimaryValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiPrimaryValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiPrimaryValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiPrimaryValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.AnalysisConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None):
        AnalysisKpiPrimaryValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.AnalysisConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.AnalysisConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.AnalysisConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class AnalysisKpiProgressBarConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "foregroundColor":
            suggest = "foreground_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiProgressBarConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiProgressBarConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiProgressBarConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 foreground_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None):
        AnalysisKpiProgressBarConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            foreground_color=foreground_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             foreground_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if foreground_color is not None:
            _setter("foreground_color", foreground_color)

    @property
    @pulumi.getter(name="foregroundColor")
    def foreground_color(self) -> Optional['outputs.AnalysisConditionalFormattingColor']:
        return pulumi.get(self, "foreground_color")


@pulumi.output_type
class AnalysisKpiSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trendGroupSort":
            suggest = "trend_group_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trend_group_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisKpiSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trend_group_sort=trend_group_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trend_group_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if trend_group_sort is not None:
            _setter("trend_group_sort", trend_group_sort)

    @property
    @pulumi.getter(name="trendGroupSort")
    def trend_group_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "trend_group_sort")


@pulumi.output_type
class AnalysisKpiSparklineOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tooltipVisibility":
            suggest = "tooltip_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiSparklineOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiSparklineOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiSparklineOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'AnalysisKpiSparklineType',
                 color: Optional[str] = None,
                 tooltip_visibility: Optional['AnalysisVisibility'] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisKpiSparklineOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            color=color,
            tooltip_visibility=tooltip_visibility,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: 'AnalysisKpiSparklineType',
             color: Optional[str] = None,
             tooltip_visibility: Optional['AnalysisVisibility'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if color is not None:
            _setter("color", color)
        if tooltip_visibility is not None:
            _setter("tooltip_visibility", tooltip_visibility)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def type(self) -> 'AnalysisKpiSparklineType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="tooltipVisibility")
    def tooltip_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "tooltip_visibility")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisKpiVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisKpiConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 conditional_formatting: Optional['outputs.AnalysisKpiConditionalFormatting'] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisKpiVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisKpiConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             conditional_formatting: Optional['outputs.AnalysisKpiConditionalFormatting'] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisKpiConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.AnalysisKpiConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisKpiVisualLayoutOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "standardLayout":
            suggest = "standard_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisKpiVisualLayoutOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisKpiVisualLayoutOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisKpiVisualLayoutOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 standard_layout: Optional['outputs.AnalysisKpiVisualStandardLayout'] = None):
        AnalysisKpiVisualLayoutOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            standard_layout=standard_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             standard_layout: Optional['outputs.AnalysisKpiVisualStandardLayout'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if standard_layout is not None:
            _setter("standard_layout", standard_layout)

    @property
    @pulumi.getter(name="standardLayout")
    def standard_layout(self) -> Optional['outputs.AnalysisKpiVisualStandardLayout']:
        return pulumi.get(self, "standard_layout")


@pulumi.output_type
class AnalysisKpiVisualStandardLayout(dict):
    def __init__(__self__, *,
                 type: 'AnalysisKpiVisualStandardLayoutType'):
        AnalysisKpiVisualStandardLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: 'AnalysisKpiVisualStandardLayoutType',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> 'AnalysisKpiVisualStandardLayoutType':
        return pulumi.get(self, "type")


@pulumi.output_type
class AnalysisLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "fontConfiguration":
            suggest = "font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            font_configuration=font_configuration,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.AnalysisFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisLayout(dict):
    def __init__(__self__, *,
                 configuration: 'outputs.AnalysisLayoutConfiguration'):
        AnalysisLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: 'outputs.AnalysisLayoutConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("configuration", configuration)

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.AnalysisLayoutConfiguration':
        return pulumi.get(self, "configuration")


@pulumi.output_type
class AnalysisLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeFormLayout":
            suggest = "free_form_layout"
        elif key == "gridLayout":
            suggest = "grid_layout"
        elif key == "sectionBasedLayout":
            suggest = "section_based_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_form_layout: Optional['outputs.AnalysisFreeFormLayoutConfiguration'] = None,
                 grid_layout: Optional['outputs.AnalysisGridLayoutConfiguration'] = None,
                 section_based_layout: Optional['outputs.AnalysisSectionBasedLayoutConfiguration'] = None):
        AnalysisLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            free_form_layout=free_form_layout,
            grid_layout=grid_layout,
            section_based_layout=section_based_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             free_form_layout: Optional['outputs.AnalysisFreeFormLayoutConfiguration'] = None,
             grid_layout: Optional['outputs.AnalysisGridLayoutConfiguration'] = None,
             section_based_layout: Optional['outputs.AnalysisSectionBasedLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if free_form_layout is not None:
            _setter("free_form_layout", free_form_layout)
        if grid_layout is not None:
            _setter("grid_layout", grid_layout)
        if section_based_layout is not None:
            _setter("section_based_layout", section_based_layout)

    @property
    @pulumi.getter(name="freeFormLayout")
    def free_form_layout(self) -> Optional['outputs.AnalysisFreeFormLayoutConfiguration']:
        return pulumi.get(self, "free_form_layout")

    @property
    @pulumi.getter(name="gridLayout")
    def grid_layout(self) -> Optional['outputs.AnalysisGridLayoutConfiguration']:
        return pulumi.get(self, "grid_layout")

    @property
    @pulumi.getter(name="sectionBasedLayout")
    def section_based_layout(self) -> Optional['outputs.AnalysisSectionBasedLayoutConfiguration']:
        return pulumi.get(self, "section_based_layout")


@pulumi.output_type
class AnalysisLegendOptions(dict):
    def __init__(__self__, *,
                 height: Optional[str] = None,
                 position: Optional['AnalysisLegendPosition'] = None,
                 title: Optional['outputs.AnalysisLabelOptions'] = None,
                 visibility: Optional['AnalysisVisibility'] = None,
                 width: Optional[str] = None):
        """
        :param str height: String based length that is composed of value and unit in px
        :param str width: String based length that is composed of value and unit in px
        """
        AnalysisLegendOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            height=height,
            position=position,
            title=title,
            visibility=visibility,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             height: Optional[str] = None,
             position: Optional['AnalysisLegendPosition'] = None,
             title: Optional['outputs.AnalysisLabelOptions'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if height is not None:
            _setter("height", height)
        if position is not None:
            _setter("position", position)
        if title is not None:
            _setter("title", title)
        if visibility is not None:
            _setter("visibility", visibility)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def position(self) -> Optional['AnalysisLegendPosition']:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisLabelOptions']:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class AnalysisLineChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "smallMultiples":
            suggest = "small_multiples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLineChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLineChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLineChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 colors: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 small_multiples: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisLineChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            colors=colors,
            small_multiples=small_multiples,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             colors: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             small_multiples: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if colors is not None:
            _setter("colors", colors)
        if small_multiples is not None:
            _setter("small_multiples", small_multiples)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="smallMultiples")
    def small_multiples(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "small_multiples")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisLineChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionAnalysisDefaults":
            suggest = "contribution_analysis_defaults"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "defaultSeriesSettings":
            suggest = "default_series_settings"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "forecastConfigurations":
            suggest = "forecast_configurations"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "secondaryYAxisDisplayOptions":
            suggest = "secondary_y_axis_display_options"
        elif key == "secondaryYAxisLabelOptions":
            suggest = "secondary_y_axis_label_options"
        elif key == "smallMultiplesOptions":
            suggest = "small_multiples_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "xAxisDisplayOptions":
            suggest = "x_axis_display_options"
        elif key == "xAxisLabelOptions":
            suggest = "x_axis_label_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLineChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLineChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLineChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_analysis_defaults: Optional[Sequence['outputs.AnalysisContributionAnalysisDefault']] = None,
                 data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 default_series_settings: Optional['outputs.AnalysisLineChartDefaultSeriesSettings'] = None,
                 field_wells: Optional['outputs.AnalysisLineChartFieldWells'] = None,
                 forecast_configurations: Optional[Sequence['outputs.AnalysisForecastConfiguration']] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.AnalysisLineSeriesAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 reference_lines: Optional[Sequence['outputs.AnalysisReferenceLine']] = None,
                 secondary_y_axis_display_options: Optional['outputs.AnalysisLineSeriesAxisDisplayOptions'] = None,
                 secondary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 series: Optional[Sequence['outputs.AnalysisSeriesItem']] = None,
                 small_multiples_options: Optional['outputs.AnalysisSmallMultiplesOptions'] = None,
                 sort_configuration: Optional['outputs.AnalysisLineChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
                 type: Optional['AnalysisLineChartType'] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
                 x_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 x_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None):
        AnalysisLineChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contribution_analysis_defaults=contribution_analysis_defaults,
            data_labels=data_labels,
            default_series_settings=default_series_settings,
            field_wells=field_wells,
            forecast_configurations=forecast_configurations,
            legend=legend,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            reference_lines=reference_lines,
            secondary_y_axis_display_options=secondary_y_axis_display_options,
            secondary_y_axis_label_options=secondary_y_axis_label_options,
            series=series,
            small_multiples_options=small_multiples_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            type=type,
            visual_palette=visual_palette,
            x_axis_display_options=x_axis_display_options,
            x_axis_label_options=x_axis_label_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contribution_analysis_defaults: Optional[Sequence['outputs.AnalysisContributionAnalysisDefault']] = None,
             data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             default_series_settings: Optional['outputs.AnalysisLineChartDefaultSeriesSettings'] = None,
             field_wells: Optional['outputs.AnalysisLineChartFieldWells'] = None,
             forecast_configurations: Optional[Sequence['outputs.AnalysisForecastConfiguration']] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.AnalysisLineSeriesAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             reference_lines: Optional[Sequence['outputs.AnalysisReferenceLine']] = None,
             secondary_y_axis_display_options: Optional['outputs.AnalysisLineSeriesAxisDisplayOptions'] = None,
             secondary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             series: Optional[Sequence['outputs.AnalysisSeriesItem']] = None,
             small_multiples_options: Optional['outputs.AnalysisSmallMultiplesOptions'] = None,
             sort_configuration: Optional['outputs.AnalysisLineChartSortConfiguration'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             type: Optional['AnalysisLineChartType'] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             x_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             x_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if contribution_analysis_defaults is not None:
            _setter("contribution_analysis_defaults", contribution_analysis_defaults)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if default_series_settings is not None:
            _setter("default_series_settings", default_series_settings)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if forecast_configurations is not None:
            _setter("forecast_configurations", forecast_configurations)
        if legend is not None:
            _setter("legend", legend)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if secondary_y_axis_display_options is not None:
            _setter("secondary_y_axis_display_options", secondary_y_axis_display_options)
        if secondary_y_axis_label_options is not None:
            _setter("secondary_y_axis_label_options", secondary_y_axis_label_options)
        if series is not None:
            _setter("series", series)
        if small_multiples_options is not None:
            _setter("small_multiples_options", small_multiples_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if type is not None:
            _setter("type", type)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if x_axis_display_options is not None:
            _setter("x_axis_display_options", x_axis_display_options)
        if x_axis_label_options is not None:
            _setter("x_axis_label_options", x_axis_label_options)

    @property
    @pulumi.getter(name="contributionAnalysisDefaults")
    def contribution_analysis_defaults(self) -> Optional[Sequence['outputs.AnalysisContributionAnalysisDefault']]:
        return pulumi.get(self, "contribution_analysis_defaults")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="defaultSeriesSettings")
    def default_series_settings(self) -> Optional['outputs.AnalysisLineChartDefaultSeriesSettings']:
        return pulumi.get(self, "default_series_settings")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisLineChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="forecastConfigurations")
    def forecast_configurations(self) -> Optional[Sequence['outputs.AnalysisForecastConfiguration']]:
        return pulumi.get(self, "forecast_configurations")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.AnalysisLineSeriesAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.AnalysisReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="secondaryYAxisDisplayOptions")
    def secondary_y_axis_display_options(self) -> Optional['outputs.AnalysisLineSeriesAxisDisplayOptions']:
        return pulumi.get(self, "secondary_y_axis_display_options")

    @property
    @pulumi.getter(name="secondaryYAxisLabelOptions")
    def secondary_y_axis_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "secondary_y_axis_label_options")

    @property
    @pulumi.getter
    def series(self) -> Optional[Sequence['outputs.AnalysisSeriesItem']]:
        return pulumi.get(self, "series")

    @property
    @pulumi.getter(name="smallMultiplesOptions")
    def small_multiples_options(self) -> Optional['outputs.AnalysisSmallMultiplesOptions']:
        return pulumi.get(self, "small_multiples_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisLineChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter
    def type(self) -> Optional['AnalysisLineChartType']:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="xAxisDisplayOptions")
    def x_axis_display_options(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "x_axis_display_options")

    @property
    @pulumi.getter(name="xAxisLabelOptions")
    def x_axis_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "x_axis_label_options")


@pulumi.output_type
class AnalysisLineChartDefaultSeriesSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "lineStyleSettings":
            suggest = "line_style_settings"
        elif key == "markerStyleSettings":
            suggest = "marker_style_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLineChartDefaultSeriesSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLineChartDefaultSeriesSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLineChartDefaultSeriesSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: Optional['AnalysisAxisBinding'] = None,
                 line_style_settings: Optional['outputs.AnalysisLineChartLineStyleSettings'] = None,
                 marker_style_settings: Optional['outputs.AnalysisLineChartMarkerStyleSettings'] = None):
        AnalysisLineChartDefaultSeriesSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            line_style_settings=line_style_settings,
            marker_style_settings=marker_style_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: Optional['AnalysisAxisBinding'] = None,
             line_style_settings: Optional['outputs.AnalysisLineChartLineStyleSettings'] = None,
             marker_style_settings: Optional['outputs.AnalysisLineChartMarkerStyleSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_binding is not None:
            _setter("axis_binding", axis_binding)
        if line_style_settings is not None:
            _setter("line_style_settings", line_style_settings)
        if marker_style_settings is not None:
            _setter("marker_style_settings", marker_style_settings)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> Optional['AnalysisAxisBinding']:
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="lineStyleSettings")
    def line_style_settings(self) -> Optional['outputs.AnalysisLineChartLineStyleSettings']:
        return pulumi.get(self, "line_style_settings")

    @property
    @pulumi.getter(name="markerStyleSettings")
    def marker_style_settings(self) -> Optional['outputs.AnalysisLineChartMarkerStyleSettings']:
        return pulumi.get(self, "marker_style_settings")


@pulumi.output_type
class AnalysisLineChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineChartAggregatedFieldWells":
            suggest = "line_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLineChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLineChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLineChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_chart_aggregated_field_wells: Optional['outputs.AnalysisLineChartAggregatedFieldWells'] = None):
        AnalysisLineChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            line_chart_aggregated_field_wells=line_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             line_chart_aggregated_field_wells: Optional['outputs.AnalysisLineChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if line_chart_aggregated_field_wells is not None:
            _setter("line_chart_aggregated_field_wells", line_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="lineChartAggregatedFieldWells")
    def line_chart_aggregated_field_wells(self) -> Optional['outputs.AnalysisLineChartAggregatedFieldWells']:
        return pulumi.get(self, "line_chart_aggregated_field_wells")


@pulumi.output_type
class AnalysisLineChartLineStyleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineInterpolation":
            suggest = "line_interpolation"
        elif key == "lineStyle":
            suggest = "line_style"
        elif key == "lineVisibility":
            suggest = "line_visibility"
        elif key == "lineWidth":
            suggest = "line_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLineChartLineStyleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLineChartLineStyleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLineChartLineStyleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_interpolation: Optional['AnalysisLineInterpolation'] = None,
                 line_style: Optional['AnalysisLineChartLineStyle'] = None,
                 line_visibility: Optional['AnalysisVisibility'] = None,
                 line_width: Optional[str] = None):
        """
        :param str line_width: String based length that is composed of value and unit in px
        """
        AnalysisLineChartLineStyleSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            line_interpolation=line_interpolation,
            line_style=line_style,
            line_visibility=line_visibility,
            line_width=line_width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             line_interpolation: Optional['AnalysisLineInterpolation'] = None,
             line_style: Optional['AnalysisLineChartLineStyle'] = None,
             line_visibility: Optional['AnalysisVisibility'] = None,
             line_width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if line_interpolation is not None:
            _setter("line_interpolation", line_interpolation)
        if line_style is not None:
            _setter("line_style", line_style)
        if line_visibility is not None:
            _setter("line_visibility", line_visibility)
        if line_width is not None:
            _setter("line_width", line_width)

    @property
    @pulumi.getter(name="lineInterpolation")
    def line_interpolation(self) -> Optional['AnalysisLineInterpolation']:
        return pulumi.get(self, "line_interpolation")

    @property
    @pulumi.getter(name="lineStyle")
    def line_style(self) -> Optional['AnalysisLineChartLineStyle']:
        return pulumi.get(self, "line_style")

    @property
    @pulumi.getter(name="lineVisibility")
    def line_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "line_visibility")

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "line_width")


@pulumi.output_type
class AnalysisLineChartMarkerStyleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "markerColor":
            suggest = "marker_color"
        elif key == "markerShape":
            suggest = "marker_shape"
        elif key == "markerSize":
            suggest = "marker_size"
        elif key == "markerVisibility":
            suggest = "marker_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLineChartMarkerStyleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLineChartMarkerStyleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLineChartMarkerStyleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 marker_color: Optional[str] = None,
                 marker_shape: Optional['AnalysisLineChartMarkerShape'] = None,
                 marker_size: Optional[str] = None,
                 marker_visibility: Optional['AnalysisVisibility'] = None):
        """
        :param str marker_size: String based length that is composed of value and unit in px
        """
        AnalysisLineChartMarkerStyleSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            marker_color=marker_color,
            marker_shape=marker_shape,
            marker_size=marker_size,
            marker_visibility=marker_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             marker_color: Optional[str] = None,
             marker_shape: Optional['AnalysisLineChartMarkerShape'] = None,
             marker_size: Optional[str] = None,
             marker_visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if marker_color is not None:
            _setter("marker_color", marker_color)
        if marker_shape is not None:
            _setter("marker_shape", marker_shape)
        if marker_size is not None:
            _setter("marker_size", marker_size)
        if marker_visibility is not None:
            _setter("marker_visibility", marker_visibility)

    @property
    @pulumi.getter(name="markerColor")
    def marker_color(self) -> Optional[str]:
        return pulumi.get(self, "marker_color")

    @property
    @pulumi.getter(name="markerShape")
    def marker_shape(self) -> Optional['AnalysisLineChartMarkerShape']:
        return pulumi.get(self, "marker_shape")

    @property
    @pulumi.getter(name="markerSize")
    def marker_size(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "marker_size")

    @property
    @pulumi.getter(name="markerVisibility")
    def marker_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "marker_visibility")


@pulumi.output_type
class AnalysisLineChartSeriesSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineStyleSettings":
            suggest = "line_style_settings"
        elif key == "markerStyleSettings":
            suggest = "marker_style_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLineChartSeriesSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLineChartSeriesSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLineChartSeriesSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_style_settings: Optional['outputs.AnalysisLineChartLineStyleSettings'] = None,
                 marker_style_settings: Optional['outputs.AnalysisLineChartMarkerStyleSettings'] = None):
        AnalysisLineChartSeriesSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            line_style_settings=line_style_settings,
            marker_style_settings=marker_style_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             line_style_settings: Optional['outputs.AnalysisLineChartLineStyleSettings'] = None,
             marker_style_settings: Optional['outputs.AnalysisLineChartMarkerStyleSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if line_style_settings is not None:
            _setter("line_style_settings", line_style_settings)
        if marker_style_settings is not None:
            _setter("marker_style_settings", marker_style_settings)

    @property
    @pulumi.getter(name="lineStyleSettings")
    def line_style_settings(self) -> Optional['outputs.AnalysisLineChartLineStyleSettings']:
        return pulumi.get(self, "line_style_settings")

    @property
    @pulumi.getter(name="markerStyleSettings")
    def marker_style_settings(self) -> Optional['outputs.AnalysisLineChartMarkerStyleSettings']:
        return pulumi.get(self, "marker_style_settings")


@pulumi.output_type
class AnalysisLineChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimitConfiguration":
            suggest = "category_items_limit_configuration"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimitConfiguration":
            suggest = "color_items_limit_configuration"
        elif key == "smallMultiplesLimitConfiguration":
            suggest = "small_multiples_limit_configuration"
        elif key == "smallMultiplesSort":
            suggest = "small_multiples_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLineChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLineChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLineChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
                 color_items_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 small_multiples_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 small_multiples_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisLineChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit_configuration=category_items_limit_configuration,
            category_sort=category_sort,
            color_items_limit_configuration=color_items_limit_configuration,
            small_multiples_limit_configuration=small_multiples_limit_configuration,
            small_multiples_sort=small_multiples_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             color_items_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             small_multiples_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             small_multiples_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit_configuration is not None:
            _setter("category_items_limit_configuration", category_items_limit_configuration)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit_configuration is not None:
            _setter("color_items_limit_configuration", color_items_limit_configuration)
        if small_multiples_limit_configuration is not None:
            _setter("small_multiples_limit_configuration", small_multiples_limit_configuration)
        if small_multiples_sort is not None:
            _setter("small_multiples_sort", small_multiples_sort)

    @property
    @pulumi.getter(name="categoryItemsLimitConfiguration")
    def category_items_limit_configuration(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit_configuration")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimitConfiguration")
    def color_items_limit_configuration(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesLimitConfiguration")
    def small_multiples_limit_configuration(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "small_multiples_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesSort")
    def small_multiples_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "small_multiples_sort")


@pulumi.output_type
class AnalysisLineChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLineChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLineChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLineChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisLineChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisLineChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisLineChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisLineChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisLineSeriesAxisDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisOptions":
            suggest = "axis_options"
        elif key == "missingDataConfigurations":
            suggest = "missing_data_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLineSeriesAxisDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLineSeriesAxisDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLineSeriesAxisDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 missing_data_configurations: Optional[Sequence['outputs.AnalysisMissingDataConfiguration']] = None):
        AnalysisLineSeriesAxisDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_options=axis_options,
            missing_data_configurations=missing_data_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             missing_data_configurations: Optional[Sequence['outputs.AnalysisMissingDataConfiguration']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_options is not None:
            _setter("axis_options", axis_options)
        if missing_data_configurations is not None:
            _setter("missing_data_configurations", missing_data_configurations)

    @property
    @pulumi.getter(name="axisOptions")
    def axis_options(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "axis_options")

    @property
    @pulumi.getter(name="missingDataConfigurations")
    def missing_data_configurations(self) -> Optional[Sequence['outputs.AnalysisMissingDataConfiguration']]:
        return pulumi.get(self, "missing_data_configurations")


@pulumi.output_type
class AnalysisListControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "searchOptions":
            suggest = "search_options"
        elif key == "selectAllOptions":
            suggest = "select_all_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisListControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisListControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisListControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
                 search_options: Optional['outputs.AnalysisListControlSearchOptions'] = None,
                 select_all_options: Optional['outputs.AnalysisListControlSelectAllOptions'] = None,
                 title_options: Optional['outputs.AnalysisLabelOptions'] = None):
        AnalysisListControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            search_options=search_options,
            select_all_options=select_all_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
             search_options: Optional['outputs.AnalysisListControlSearchOptions'] = None,
             select_all_options: Optional['outputs.AnalysisListControlSelectAllOptions'] = None,
             title_options: Optional['outputs.AnalysisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if search_options is not None:
            _setter("search_options", search_options)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.AnalysisSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="searchOptions")
    def search_options(self) -> Optional['outputs.AnalysisListControlSearchOptions']:
        return pulumi.get(self, "search_options")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['outputs.AnalysisListControlSelectAllOptions']:
        return pulumi.get(self, "select_all_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.AnalysisLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class AnalysisListControlSearchOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisListControlSearchOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisListControlSelectAllOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisListControlSelectAllOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisLoadingAnimation(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisLoadingAnimation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisLocalNavigationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetSheetId":
            suggest = "target_sheet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLocalNavigationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLocalNavigationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLocalNavigationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_sheet_id: str):
        AnalysisLocalNavigationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_sheet_id=target_sheet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_sheet_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target_sheet_id", target_sheet_id)

    @property
    @pulumi.getter(name="targetSheetId")
    def target_sheet_id(self) -> str:
        return pulumi.get(self, "target_sheet_id")


@pulumi.output_type
class AnalysisLongFormatText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "plainText":
            suggest = "plain_text"
        elif key == "richText":
            suggest = "rich_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisLongFormatText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisLongFormatText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisLongFormatText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 plain_text: Optional[str] = None,
                 rich_text: Optional[str] = None):
        AnalysisLongFormatText._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            plain_text=plain_text,
            rich_text=rich_text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             plain_text: Optional[str] = None,
             rich_text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if plain_text is not None:
            _setter("plain_text", plain_text)
        if rich_text is not None:
            _setter("rich_text", rich_text)

    @property
    @pulumi.getter(name="plainText")
    def plain_text(self) -> Optional[str]:
        return pulumi.get(self, "plain_text")

    @property
    @pulumi.getter(name="richText")
    def rich_text(self) -> Optional[str]:
        return pulumi.get(self, "rich_text")


@pulumi.output_type
class AnalysisMappedDataSetParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "dataSetParameterName":
            suggest = "data_set_parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisMappedDataSetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisMappedDataSetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisMappedDataSetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 data_set_parameter_name: str):
        AnalysisMappedDataSetParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            data_set_parameter_name=data_set_parameter_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             data_set_parameter_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("data_set_parameter_name", data_set_parameter_name)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="dataSetParameterName")
    def data_set_parameter_name(self) -> str:
        return pulumi.get(self, "data_set_parameter_name")


@pulumi.output_type
class AnalysisMaximumLabelType(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisMaximumLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisMaximumMinimumComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisMaximumMinimumComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisMaximumMinimumComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisMaximumMinimumComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 type: 'AnalysisMaximumMinimumComputationType',
                 name: Optional[str] = None,
                 time: Optional['outputs.AnalysisDimensionField'] = None,
                 value: Optional['outputs.AnalysisMeasureField'] = None):
        AnalysisMaximumMinimumComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            type=type,
            name=name,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             type: 'AnalysisMaximumMinimumComputationType',
             name: Optional[str] = None,
             time: Optional['outputs.AnalysisDimensionField'] = None,
             value: Optional['outputs.AnalysisMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        _setter("type", type)
        if name is not None:
            _setter("name", name)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def type(self) -> 'AnalysisMaximumMinimumComputationType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.AnalysisDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AnalysisMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "calculatedMeasureField":
            suggest = "calculated_measure_field"
        elif key == "categoricalMeasureField":
            suggest = "categorical_measure_field"
        elif key == "dateMeasureField":
            suggest = "date_measure_field"
        elif key == "numericalMeasureField":
            suggest = "numerical_measure_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 calculated_measure_field: Optional['outputs.AnalysisCalculatedMeasureField'] = None,
                 categorical_measure_field: Optional['outputs.AnalysisCategoricalMeasureField'] = None,
                 date_measure_field: Optional['outputs.AnalysisDateMeasureField'] = None,
                 numerical_measure_field: Optional['outputs.AnalysisNumericalMeasureField'] = None):
        AnalysisMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            calculated_measure_field=calculated_measure_field,
            categorical_measure_field=categorical_measure_field,
            date_measure_field=date_measure_field,
            numerical_measure_field=numerical_measure_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             calculated_measure_field: Optional['outputs.AnalysisCalculatedMeasureField'] = None,
             categorical_measure_field: Optional['outputs.AnalysisCategoricalMeasureField'] = None,
             date_measure_field: Optional['outputs.AnalysisDateMeasureField'] = None,
             numerical_measure_field: Optional['outputs.AnalysisNumericalMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if calculated_measure_field is not None:
            _setter("calculated_measure_field", calculated_measure_field)
        if categorical_measure_field is not None:
            _setter("categorical_measure_field", categorical_measure_field)
        if date_measure_field is not None:
            _setter("date_measure_field", date_measure_field)
        if numerical_measure_field is not None:
            _setter("numerical_measure_field", numerical_measure_field)

    @property
    @pulumi.getter(name="calculatedMeasureField")
    def calculated_measure_field(self) -> Optional['outputs.AnalysisCalculatedMeasureField']:
        return pulumi.get(self, "calculated_measure_field")

    @property
    @pulumi.getter(name="categoricalMeasureField")
    def categorical_measure_field(self) -> Optional['outputs.AnalysisCategoricalMeasureField']:
        return pulumi.get(self, "categorical_measure_field")

    @property
    @pulumi.getter(name="dateMeasureField")
    def date_measure_field(self) -> Optional['outputs.AnalysisDateMeasureField']:
        return pulumi.get(self, "date_measure_field")

    @property
    @pulumi.getter(name="numericalMeasureField")
    def numerical_measure_field(self) -> Optional['outputs.AnalysisNumericalMeasureField']:
        return pulumi.get(self, "numerical_measure_field")


@pulumi.output_type
class AnalysisMetricComparisonComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "fromValue":
            suggest = "from_value"
        elif key == "targetValue":
            suggest = "target_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisMetricComparisonComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisMetricComparisonComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisMetricComparisonComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 from_value: Optional['outputs.AnalysisMeasureField'] = None,
                 name: Optional[str] = None,
                 target_value: Optional['outputs.AnalysisMeasureField'] = None,
                 time: Optional['outputs.AnalysisDimensionField'] = None):
        AnalysisMetricComparisonComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            from_value=from_value,
            name=name,
            target_value=target_value,
            time=time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             from_value: Optional['outputs.AnalysisMeasureField'] = None,
             name: Optional[str] = None,
             target_value: Optional['outputs.AnalysisMeasureField'] = None,
             time: Optional['outputs.AnalysisDimensionField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if from_value is not None:
            _setter("from_value", from_value)
        if name is not None:
            _setter("name", name)
        if target_value is not None:
            _setter("target_value", target_value)
        if time is not None:
            _setter("time", time)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional['outputs.AnalysisMeasureField']:
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> Optional['outputs.AnalysisMeasureField']:
        return pulumi.get(self, "target_value")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.AnalysisDimensionField']:
        return pulumi.get(self, "time")


@pulumi.output_type
class AnalysisMinimumLabelType(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisMinimumLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisMissingDataConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "treatmentOption":
            suggest = "treatment_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisMissingDataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisMissingDataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisMissingDataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 treatment_option: Optional['AnalysisMissingDataTreatmentOption'] = None):
        AnalysisMissingDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            treatment_option=treatment_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             treatment_option: Optional['AnalysisMissingDataTreatmentOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if treatment_option is not None:
            _setter("treatment_option", treatment_option)

    @property
    @pulumi.getter(name="treatmentOption")
    def treatment_option(self) -> Optional['AnalysisMissingDataTreatmentOption']:
        return pulumi.get(self, "treatment_option")


@pulumi.output_type
class AnalysisNegativeValueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayMode":
            suggest = "display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNegativeValueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNegativeValueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNegativeValueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_mode: 'AnalysisNegativeValueDisplayMode'):
        AnalysisNegativeValueConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_mode=display_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_mode: 'AnalysisNegativeValueDisplayMode',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("display_mode", display_mode)

    @property
    @pulumi.getter(name="displayMode")
    def display_mode(self) -> 'AnalysisNegativeValueDisplayMode':
        return pulumi.get(self, "display_mode")


@pulumi.output_type
class AnalysisNullValueFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nullString":
            suggest = "null_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNullValueFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNullValueFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNullValueFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 null_string: str):
        AnalysisNullValueFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            null_string=null_string,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             null_string: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("null_string", null_string)

    @property
    @pulumi.getter(name="nullString")
    def null_string(self) -> str:
        return pulumi.get(self, "null_string")


@pulumi.output_type
class AnalysisNumberDisplayFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlacesConfiguration":
            suggest = "decimal_places_configuration"
        elif key == "negativeValueConfiguration":
            suggest = "negative_value_configuration"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numberScale":
            suggest = "number_scale"
        elif key == "separatorConfiguration":
            suggest = "separator_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNumberDisplayFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNumberDisplayFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNumberDisplayFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places_configuration: Optional['outputs.AnalysisDecimalPlacesConfiguration'] = None,
                 negative_value_configuration: Optional['outputs.AnalysisNegativeValueConfiguration'] = None,
                 null_value_format_configuration: Optional['outputs.AnalysisNullValueFormatConfiguration'] = None,
                 number_scale: Optional['AnalysisNumberScale'] = None,
                 prefix: Optional[str] = None,
                 separator_configuration: Optional['outputs.AnalysisNumericSeparatorConfiguration'] = None,
                 suffix: Optional[str] = None):
        AnalysisNumberDisplayFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places_configuration=decimal_places_configuration,
            negative_value_configuration=negative_value_configuration,
            null_value_format_configuration=null_value_format_configuration,
            number_scale=number_scale,
            prefix=prefix,
            separator_configuration=separator_configuration,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places_configuration: Optional['outputs.AnalysisDecimalPlacesConfiguration'] = None,
             negative_value_configuration: Optional['outputs.AnalysisNegativeValueConfiguration'] = None,
             null_value_format_configuration: Optional['outputs.AnalysisNullValueFormatConfiguration'] = None,
             number_scale: Optional['AnalysisNumberScale'] = None,
             prefix: Optional[str] = None,
             separator_configuration: Optional['outputs.AnalysisNumericSeparatorConfiguration'] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_places_configuration is not None:
            _setter("decimal_places_configuration", decimal_places_configuration)
        if negative_value_configuration is not None:
            _setter("negative_value_configuration", negative_value_configuration)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if number_scale is not None:
            _setter("number_scale", number_scale)
        if prefix is not None:
            _setter("prefix", prefix)
        if separator_configuration is not None:
            _setter("separator_configuration", separator_configuration)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter(name="decimalPlacesConfiguration")
    def decimal_places_configuration(self) -> Optional['outputs.AnalysisDecimalPlacesConfiguration']:
        return pulumi.get(self, "decimal_places_configuration")

    @property
    @pulumi.getter(name="negativeValueConfiguration")
    def negative_value_configuration(self) -> Optional['outputs.AnalysisNegativeValueConfiguration']:
        return pulumi.get(self, "negative_value_configuration")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.AnalysisNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numberScale")
    def number_scale(self) -> Optional['AnalysisNumberScale']:
        return pulumi.get(self, "number_scale")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="separatorConfiguration")
    def separator_configuration(self) -> Optional['outputs.AnalysisNumericSeparatorConfiguration']:
        return pulumi.get(self, "separator_configuration")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class AnalysisNumberFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNumberFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNumberFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNumberFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_configuration: Optional['outputs.AnalysisNumericFormatConfiguration'] = None):
        AnalysisNumberFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_configuration: Optional['outputs.AnalysisNumericFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.AnalysisNumericFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class AnalysisNumericAxisOptions(dict):
    def __init__(__self__, *,
                 range: Optional['outputs.AnalysisAxisDisplayRange'] = None,
                 scale: Optional['outputs.AnalysisAxisScale'] = None):
        AnalysisNumericAxisOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            range=range,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             range: Optional['outputs.AnalysisAxisDisplayRange'] = None,
             scale: Optional['outputs.AnalysisAxisScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if range is not None:
            _setter("range", range)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.AnalysisAxisDisplayRange']:
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def scale(self) -> Optional['outputs.AnalysisAxisScale']:
        return pulumi.get(self, "scale")


@pulumi.output_type
class AnalysisNumericEqualityDrillDownFilter(dict):
    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 value: float):
        AnalysisNumericEqualityDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("value", value)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisNumericEqualityFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "matchOperator":
            suggest = "match_operator"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNumericEqualityFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNumericEqualityFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNumericEqualityFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 filter_id: str,
                 match_operator: 'AnalysisNumericEqualityMatchOperator',
                 null_option: 'AnalysisFilterNullOption',
                 aggregation_function: Optional['outputs.AnalysisAggregationFunction'] = None,
                 parameter_name: Optional[str] = None,
                 select_all_options: Optional['AnalysisNumericFilterSelectAllOptions'] = None,
                 value: Optional[float] = None):
        AnalysisNumericEqualityFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            match_operator=match_operator,
            null_option=null_option,
            aggregation_function=aggregation_function,
            parameter_name=parameter_name,
            select_all_options=select_all_options,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             filter_id: str,
             match_operator: 'AnalysisNumericEqualityMatchOperator',
             null_option: 'AnalysisFilterNullOption',
             aggregation_function: Optional['outputs.AnalysisAggregationFunction'] = None,
             parameter_name: Optional[str] = None,
             select_all_options: Optional['AnalysisNumericFilterSelectAllOptions'] = None,
             value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("match_operator", match_operator)
        _setter("null_option", null_option)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'AnalysisNumericEqualityMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'AnalysisFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.AnalysisAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['AnalysisNumericFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisNumericFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currencyDisplayFormatConfiguration":
            suggest = "currency_display_format_configuration"
        elif key == "numberDisplayFormatConfiguration":
            suggest = "number_display_format_configuration"
        elif key == "percentageDisplayFormatConfiguration":
            suggest = "percentage_display_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNumericFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNumericFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNumericFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 currency_display_format_configuration: Optional['outputs.AnalysisCurrencyDisplayFormatConfiguration'] = None,
                 number_display_format_configuration: Optional['outputs.AnalysisNumberDisplayFormatConfiguration'] = None,
                 percentage_display_format_configuration: Optional['outputs.AnalysisPercentageDisplayFormatConfiguration'] = None):
        AnalysisNumericFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            currency_display_format_configuration=currency_display_format_configuration,
            number_display_format_configuration=number_display_format_configuration,
            percentage_display_format_configuration=percentage_display_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             currency_display_format_configuration: Optional['outputs.AnalysisCurrencyDisplayFormatConfiguration'] = None,
             number_display_format_configuration: Optional['outputs.AnalysisNumberDisplayFormatConfiguration'] = None,
             percentage_display_format_configuration: Optional['outputs.AnalysisPercentageDisplayFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if currency_display_format_configuration is not None:
            _setter("currency_display_format_configuration", currency_display_format_configuration)
        if number_display_format_configuration is not None:
            _setter("number_display_format_configuration", number_display_format_configuration)
        if percentage_display_format_configuration is not None:
            _setter("percentage_display_format_configuration", percentage_display_format_configuration)

    @property
    @pulumi.getter(name="currencyDisplayFormatConfiguration")
    def currency_display_format_configuration(self) -> Optional['outputs.AnalysisCurrencyDisplayFormatConfiguration']:
        return pulumi.get(self, "currency_display_format_configuration")

    @property
    @pulumi.getter(name="numberDisplayFormatConfiguration")
    def number_display_format_configuration(self) -> Optional['outputs.AnalysisNumberDisplayFormatConfiguration']:
        return pulumi.get(self, "number_display_format_configuration")

    @property
    @pulumi.getter(name="percentageDisplayFormatConfiguration")
    def percentage_display_format_configuration(self) -> Optional['outputs.AnalysisPercentageDisplayFormatConfiguration']:
        return pulumi.get(self, "percentage_display_format_configuration")


@pulumi.output_type
class AnalysisNumericRangeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "includeMaximum":
            suggest = "include_maximum"
        elif key == "includeMinimum":
            suggest = "include_minimum"
        elif key == "rangeMaximum":
            suggest = "range_maximum"
        elif key == "rangeMinimum":
            suggest = "range_minimum"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNumericRangeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNumericRangeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNumericRangeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 filter_id: str,
                 null_option: 'AnalysisFilterNullOption',
                 aggregation_function: Optional['outputs.AnalysisAggregationFunction'] = None,
                 include_maximum: Optional[bool] = None,
                 include_minimum: Optional[bool] = None,
                 range_maximum: Optional['outputs.AnalysisNumericRangeFilterValue'] = None,
                 range_minimum: Optional['outputs.AnalysisNumericRangeFilterValue'] = None,
                 select_all_options: Optional['AnalysisNumericFilterSelectAllOptions'] = None):
        AnalysisNumericRangeFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            null_option=null_option,
            aggregation_function=aggregation_function,
            include_maximum=include_maximum,
            include_minimum=include_minimum,
            range_maximum=range_maximum,
            range_minimum=range_minimum,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             filter_id: str,
             null_option: 'AnalysisFilterNullOption',
             aggregation_function: Optional['outputs.AnalysisAggregationFunction'] = None,
             include_maximum: Optional[bool] = None,
             include_minimum: Optional[bool] = None,
             range_maximum: Optional['outputs.AnalysisNumericRangeFilterValue'] = None,
             range_minimum: Optional['outputs.AnalysisNumericRangeFilterValue'] = None,
             select_all_options: Optional['AnalysisNumericFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("null_option", null_option)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if include_maximum is not None:
            _setter("include_maximum", include_maximum)
        if include_minimum is not None:
            _setter("include_minimum", include_minimum)
        if range_maximum is not None:
            _setter("range_maximum", range_maximum)
        if range_minimum is not None:
            _setter("range_minimum", range_minimum)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'AnalysisFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.AnalysisAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="includeMaximum")
    def include_maximum(self) -> Optional[bool]:
        return pulumi.get(self, "include_maximum")

    @property
    @pulumi.getter(name="includeMinimum")
    def include_minimum(self) -> Optional[bool]:
        return pulumi.get(self, "include_minimum")

    @property
    @pulumi.getter(name="rangeMaximum")
    def range_maximum(self) -> Optional['outputs.AnalysisNumericRangeFilterValue']:
        return pulumi.get(self, "range_maximum")

    @property
    @pulumi.getter(name="rangeMinimum")
    def range_minimum(self) -> Optional['outputs.AnalysisNumericRangeFilterValue']:
        return pulumi.get(self, "range_minimum")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['AnalysisNumericFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class AnalysisNumericRangeFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticValue":
            suggest = "static_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNumericRangeFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNumericRangeFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNumericRangeFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 static_value: Optional[float] = None):
        AnalysisNumericRangeFilterValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter=parameter,
            static_value=static_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter: Optional[str] = None,
             static_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if parameter is not None:
            _setter("parameter", parameter)
        if static_value is not None:
            _setter("static_value", static_value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter(name="staticValue")
    def static_value(self) -> Optional[float]:
        return pulumi.get(self, "static_value")


@pulumi.output_type
class AnalysisNumericSeparatorConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalSeparator":
            suggest = "decimal_separator"
        elif key == "thousandsSeparator":
            suggest = "thousands_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNumericSeparatorConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNumericSeparatorConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNumericSeparatorConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_separator: Optional['AnalysisNumericSeparatorSymbol'] = None,
                 thousands_separator: Optional['outputs.AnalysisThousandSeparatorOptions'] = None):
        AnalysisNumericSeparatorConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_separator=decimal_separator,
            thousands_separator=thousands_separator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_separator: Optional['AnalysisNumericSeparatorSymbol'] = None,
             thousands_separator: Optional['outputs.AnalysisThousandSeparatorOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_separator is not None:
            _setter("decimal_separator", decimal_separator)
        if thousands_separator is not None:
            _setter("thousands_separator", thousands_separator)

    @property
    @pulumi.getter(name="decimalSeparator")
    def decimal_separator(self) -> Optional['AnalysisNumericSeparatorSymbol']:
        return pulumi.get(self, "decimal_separator")

    @property
    @pulumi.getter(name="thousandsSeparator")
    def thousands_separator(self) -> Optional['outputs.AnalysisThousandSeparatorOptions']:
        return pulumi.get(self, "thousands_separator")


@pulumi.output_type
class AnalysisNumericalAggregationFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "percentileAggregation":
            suggest = "percentile_aggregation"
        elif key == "simpleNumericalAggregation":
            suggest = "simple_numerical_aggregation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNumericalAggregationFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNumericalAggregationFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNumericalAggregationFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentile_aggregation: Optional['outputs.AnalysisPercentileAggregation'] = None,
                 simple_numerical_aggregation: Optional['AnalysisSimpleNumericalAggregationFunction'] = None):
        AnalysisNumericalAggregationFunction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            percentile_aggregation=percentile_aggregation,
            simple_numerical_aggregation=simple_numerical_aggregation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             percentile_aggregation: Optional['outputs.AnalysisPercentileAggregation'] = None,
             simple_numerical_aggregation: Optional['AnalysisSimpleNumericalAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if percentile_aggregation is not None:
            _setter("percentile_aggregation", percentile_aggregation)
        if simple_numerical_aggregation is not None:
            _setter("simple_numerical_aggregation", simple_numerical_aggregation)

    @property
    @pulumi.getter(name="percentileAggregation")
    def percentile_aggregation(self) -> Optional['outputs.AnalysisPercentileAggregation']:
        return pulumi.get(self, "percentile_aggregation")

    @property
    @pulumi.getter(name="simpleNumericalAggregation")
    def simple_numerical_aggregation(self) -> Optional['AnalysisSimpleNumericalAggregationFunction']:
        return pulumi.get(self, "simple_numerical_aggregation")


@pulumi.output_type
class AnalysisNumericalDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "hierarchyId":
            suggest = "hierarchy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNumericalDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNumericalDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNumericalDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 field_id: str,
                 format_configuration: Optional['outputs.AnalysisNumberFormatConfiguration'] = None,
                 hierarchy_id: Optional[str] = None):
        AnalysisNumericalDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            format_configuration=format_configuration,
            hierarchy_id=hierarchy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             field_id: str,
             format_configuration: Optional['outputs.AnalysisNumberFormatConfiguration'] = None,
             hierarchy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if hierarchy_id is not None:
            _setter("hierarchy_id", hierarchy_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.AnalysisNumberFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> Optional[str]:
        return pulumi.get(self, "hierarchy_id")


@pulumi.output_type
class AnalysisNumericalMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisNumericalMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisNumericalMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisNumericalMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 field_id: str,
                 aggregation_function: Optional['outputs.AnalysisNumericalAggregationFunction'] = None,
                 format_configuration: Optional['outputs.AnalysisNumberFormatConfiguration'] = None):
        AnalysisNumericalMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            aggregation_function=aggregation_function,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             field_id: str,
             aggregation_function: Optional['outputs.AnalysisNumericalAggregationFunction'] = None,
             format_configuration: Optional['outputs.AnalysisNumberFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.AnalysisNumericalAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.AnalysisNumberFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class AnalysisPaginationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageNumber":
            suggest = "page_number"
        elif key == "pageSize":
            suggest = "page_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPaginationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPaginationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPaginationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 page_number: float,
                 page_size: float):
        AnalysisPaginationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            page_number=page_number,
            page_size=page_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             page_number: float,
             page_size: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("page_number", page_number)
        _setter("page_size", page_size)

    @property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> float:
        return pulumi.get(self, "page_number")

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> float:
        return pulumi.get(self, "page_size")


@pulumi.output_type
class AnalysisPanelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "backgroundVisibility":
            suggest = "background_visibility"
        elif key == "borderColor":
            suggest = "border_color"
        elif key == "borderStyle":
            suggest = "border_style"
        elif key == "borderThickness":
            suggest = "border_thickness"
        elif key == "borderVisibility":
            suggest = "border_visibility"
        elif key == "gutterSpacing":
            suggest = "gutter_spacing"
        elif key == "gutterVisibility":
            suggest = "gutter_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPanelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPanelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPanelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[str] = None,
                 background_visibility: Optional['AnalysisVisibility'] = None,
                 border_color: Optional[str] = None,
                 border_style: Optional['AnalysisPanelBorderStyle'] = None,
                 border_thickness: Optional[str] = None,
                 border_visibility: Optional['AnalysisVisibility'] = None,
                 gutter_spacing: Optional[str] = None,
                 gutter_visibility: Optional['AnalysisVisibility'] = None,
                 title: Optional['outputs.AnalysisPanelTitleOptions'] = None):
        """
        :param str border_thickness: String based length that is composed of value and unit in px
        :param str gutter_spacing: String based length that is composed of value and unit in px
        """
        AnalysisPanelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            background_visibility=background_visibility,
            border_color=border_color,
            border_style=border_style,
            border_thickness=border_thickness,
            border_visibility=border_visibility,
            gutter_spacing=gutter_spacing,
            gutter_visibility=gutter_visibility,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional[str] = None,
             background_visibility: Optional['AnalysisVisibility'] = None,
             border_color: Optional[str] = None,
             border_style: Optional['AnalysisPanelBorderStyle'] = None,
             border_thickness: Optional[str] = None,
             border_visibility: Optional['AnalysisVisibility'] = None,
             gutter_spacing: Optional[str] = None,
             gutter_visibility: Optional['AnalysisVisibility'] = None,
             title: Optional['outputs.AnalysisPanelTitleOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if background_visibility is not None:
            _setter("background_visibility", background_visibility)
        if border_color is not None:
            _setter("border_color", border_color)
        if border_style is not None:
            _setter("border_style", border_style)
        if border_thickness is not None:
            _setter("border_thickness", border_thickness)
        if border_visibility is not None:
            _setter("border_visibility", border_visibility)
        if gutter_spacing is not None:
            _setter("gutter_spacing", gutter_spacing)
        if gutter_visibility is not None:
            _setter("gutter_visibility", gutter_visibility)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="backgroundVisibility")
    def background_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "background_visibility")

    @property
    @pulumi.getter(name="borderColor")
    def border_color(self) -> Optional[str]:
        return pulumi.get(self, "border_color")

    @property
    @pulumi.getter(name="borderStyle")
    def border_style(self) -> Optional['AnalysisPanelBorderStyle']:
        return pulumi.get(self, "border_style")

    @property
    @pulumi.getter(name="borderThickness")
    def border_thickness(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "border_thickness")

    @property
    @pulumi.getter(name="borderVisibility")
    def border_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "border_visibility")

    @property
    @pulumi.getter(name="gutterSpacing")
    def gutter_spacing(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "gutter_spacing")

    @property
    @pulumi.getter(name="gutterVisibility")
    def gutter_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "gutter_visibility")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisPanelTitleOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisPanelTitleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontConfiguration":
            suggest = "font_configuration"
        elif key == "horizontalTextAlignment":
            suggest = "horizontal_text_alignment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPanelTitleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPanelTitleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPanelTitleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
                 horizontal_text_alignment: Optional['AnalysisHorizontalTextAlignment'] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisPanelTitleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_configuration=font_configuration,
            horizontal_text_alignment=horizontal_text_alignment,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
             horizontal_text_alignment: Optional['AnalysisHorizontalTextAlignment'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if horizontal_text_alignment is not None:
            _setter("horizontal_text_alignment", horizontal_text_alignment)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.AnalysisFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter(name="horizontalTextAlignment")
    def horizontal_text_alignment(self) -> Optional['AnalysisHorizontalTextAlignment']:
        return pulumi.get(self, "horizontal_text_alignment")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisParameterControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimePicker":
            suggest = "date_time_picker"
        elif key == "textArea":
            suggest = "text_area"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisParameterControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisParameterControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisParameterControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_picker: Optional['outputs.AnalysisParameterDateTimePickerControl'] = None,
                 dropdown: Optional['outputs.AnalysisParameterDropDownControl'] = None,
                 list: Optional['outputs.AnalysisParameterListControl'] = None,
                 slider: Optional['outputs.AnalysisParameterSliderControl'] = None,
                 text_area: Optional['outputs.AnalysisParameterTextAreaControl'] = None,
                 text_field: Optional['outputs.AnalysisParameterTextFieldControl'] = None):
        AnalysisParameterControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_picker=date_time_picker,
            dropdown=dropdown,
            list=list,
            slider=slider,
            text_area=text_area,
            text_field=text_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_picker: Optional['outputs.AnalysisParameterDateTimePickerControl'] = None,
             dropdown: Optional['outputs.AnalysisParameterDropDownControl'] = None,
             list: Optional['outputs.AnalysisParameterListControl'] = None,
             slider: Optional['outputs.AnalysisParameterSliderControl'] = None,
             text_area: Optional['outputs.AnalysisParameterTextAreaControl'] = None,
             text_field: Optional['outputs.AnalysisParameterTextFieldControl'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_picker is not None:
            _setter("date_time_picker", date_time_picker)
        if dropdown is not None:
            _setter("dropdown", dropdown)
        if list is not None:
            _setter("list", list)
        if slider is not None:
            _setter("slider", slider)
        if text_area is not None:
            _setter("text_area", text_area)
        if text_field is not None:
            _setter("text_field", text_field)

    @property
    @pulumi.getter(name="dateTimePicker")
    def date_time_picker(self) -> Optional['outputs.AnalysisParameterDateTimePickerControl']:
        return pulumi.get(self, "date_time_picker")

    @property
    @pulumi.getter
    def dropdown(self) -> Optional['outputs.AnalysisParameterDropDownControl']:
        return pulumi.get(self, "dropdown")

    @property
    @pulumi.getter
    def list(self) -> Optional['outputs.AnalysisParameterListControl']:
        return pulumi.get(self, "list")

    @property
    @pulumi.getter
    def slider(self) -> Optional['outputs.AnalysisParameterSliderControl']:
        return pulumi.get(self, "slider")

    @property
    @pulumi.getter(name="textArea")
    def text_area(self) -> Optional['outputs.AnalysisParameterTextAreaControl']:
        return pulumi.get(self, "text_area")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional['outputs.AnalysisParameterTextFieldControl']:
        return pulumi.get(self, "text_field")


@pulumi.output_type
class AnalysisParameterDateTimePickerControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisParameterDateTimePickerControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisParameterDateTimePickerControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisParameterDateTimePickerControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 display_options: Optional['outputs.AnalysisDateTimePickerControlDisplayOptions'] = None):
        AnalysisParameterDateTimePickerControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             display_options: Optional['outputs.AnalysisDateTimePickerControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisDateTimePickerControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class AnalysisParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeParameterDeclaration":
            suggest = "date_time_parameter_declaration"
        elif key == "decimalParameterDeclaration":
            suggest = "decimal_parameter_declaration"
        elif key == "integerParameterDeclaration":
            suggest = "integer_parameter_declaration"
        elif key == "stringParameterDeclaration":
            suggest = "string_parameter_declaration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_parameter_declaration: Optional['outputs.AnalysisDateTimeParameterDeclaration'] = None,
                 decimal_parameter_declaration: Optional['outputs.AnalysisDecimalParameterDeclaration'] = None,
                 integer_parameter_declaration: Optional['outputs.AnalysisIntegerParameterDeclaration'] = None,
                 string_parameter_declaration: Optional['outputs.AnalysisStringParameterDeclaration'] = None):
        AnalysisParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_parameter_declaration=date_time_parameter_declaration,
            decimal_parameter_declaration=decimal_parameter_declaration,
            integer_parameter_declaration=integer_parameter_declaration,
            string_parameter_declaration=string_parameter_declaration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_parameter_declaration: Optional['outputs.AnalysisDateTimeParameterDeclaration'] = None,
             decimal_parameter_declaration: Optional['outputs.AnalysisDecimalParameterDeclaration'] = None,
             integer_parameter_declaration: Optional['outputs.AnalysisIntegerParameterDeclaration'] = None,
             string_parameter_declaration: Optional['outputs.AnalysisStringParameterDeclaration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_parameter_declaration is not None:
            _setter("date_time_parameter_declaration", date_time_parameter_declaration)
        if decimal_parameter_declaration is not None:
            _setter("decimal_parameter_declaration", decimal_parameter_declaration)
        if integer_parameter_declaration is not None:
            _setter("integer_parameter_declaration", integer_parameter_declaration)
        if string_parameter_declaration is not None:
            _setter("string_parameter_declaration", string_parameter_declaration)

    @property
    @pulumi.getter(name="dateTimeParameterDeclaration")
    def date_time_parameter_declaration(self) -> Optional['outputs.AnalysisDateTimeParameterDeclaration']:
        return pulumi.get(self, "date_time_parameter_declaration")

    @property
    @pulumi.getter(name="decimalParameterDeclaration")
    def decimal_parameter_declaration(self) -> Optional['outputs.AnalysisDecimalParameterDeclaration']:
        return pulumi.get(self, "decimal_parameter_declaration")

    @property
    @pulumi.getter(name="integerParameterDeclaration")
    def integer_parameter_declaration(self) -> Optional['outputs.AnalysisIntegerParameterDeclaration']:
        return pulumi.get(self, "integer_parameter_declaration")

    @property
    @pulumi.getter(name="stringParameterDeclaration")
    def string_parameter_declaration(self) -> Optional['outputs.AnalysisStringParameterDeclaration']:
        return pulumi.get(self, "string_parameter_declaration")


@pulumi.output_type
class AnalysisParameterDropDownControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisParameterDropDownControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisParameterDropDownControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisParameterDropDownControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.AnalysisCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.AnalysisDropDownControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.AnalysisParameterSelectableValues'] = None,
                 type: Optional['AnalysisSheetControlListType'] = None):
        AnalysisParameterDropDownControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             cascading_control_configuration: Optional['outputs.AnalysisCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.AnalysisDropDownControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.AnalysisParameterSelectableValues'] = None,
             type: Optional['AnalysisSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.AnalysisCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisDropDownControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.AnalysisParameterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['AnalysisSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class AnalysisParameterListControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisParameterListControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisParameterListControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisParameterListControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.AnalysisCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.AnalysisListControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.AnalysisParameterSelectableValues'] = None,
                 type: Optional['AnalysisSheetControlListType'] = None):
        AnalysisParameterListControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             cascading_control_configuration: Optional['outputs.AnalysisCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.AnalysisListControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.AnalysisParameterSelectableValues'] = None,
             type: Optional['AnalysisSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.AnalysisCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisListControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.AnalysisParameterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['AnalysisSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class AnalysisParameterSelectableValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkToDataSetColumn":
            suggest = "link_to_data_set_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisParameterSelectableValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisParameterSelectableValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisParameterSelectableValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 link_to_data_set_column: Optional['outputs.AnalysisColumnIdentifier'] = None,
                 values: Optional[Sequence[str]] = None):
        AnalysisParameterSelectableValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            link_to_data_set_column=link_to_data_set_column,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             link_to_data_set_column: Optional['outputs.AnalysisColumnIdentifier'] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if link_to_data_set_column is not None:
            _setter("link_to_data_set_column", link_to_data_set_column)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="linkToDataSetColumn")
    def link_to_data_set_column(self) -> Optional['outputs.AnalysisColumnIdentifier']:
        return pulumi.get(self, "link_to_data_set_column")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisParameterSliderControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumValue":
            suggest = "maximum_value"
        elif key == "minimumValue":
            suggest = "minimum_value"
        elif key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "stepSize":
            suggest = "step_size"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisParameterSliderControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisParameterSliderControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisParameterSliderControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_value: float,
                 minimum_value: float,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 step_size: float,
                 title: str,
                 display_options: Optional['outputs.AnalysisSliderControlDisplayOptions'] = None):
        AnalysisParameterSliderControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_value=maximum_value,
            minimum_value=minimum_value,
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            step_size=step_size,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_value: float,
             minimum_value: float,
             parameter_control_id: str,
             source_parameter_name: str,
             step_size: float,
             title: str,
             display_options: Optional['outputs.AnalysisSliderControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("maximum_value", maximum_value)
        _setter("minimum_value", minimum_value)
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("step_size", step_size)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="maximumValue")
    def maximum_value(self) -> float:
        return pulumi.get(self, "maximum_value")

    @property
    @pulumi.getter(name="minimumValue")
    def minimum_value(self) -> float:
        return pulumi.get(self, "minimum_value")

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> float:
        return pulumi.get(self, "step_size")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisSliderControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class AnalysisParameterTextAreaControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisParameterTextAreaControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisParameterTextAreaControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisParameterTextAreaControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 delimiter: Optional[str] = None,
                 display_options: Optional['outputs.AnalysisTextAreaControlDisplayOptions'] = None):
        AnalysisParameterTextAreaControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            delimiter=delimiter,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             delimiter: Optional[str] = None,
             display_options: Optional['outputs.AnalysisTextAreaControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisTextAreaControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class AnalysisParameterTextFieldControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisParameterTextFieldControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisParameterTextFieldControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisParameterTextFieldControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 display_options: Optional['outputs.AnalysisTextFieldControlDisplayOptions'] = None):
        AnalysisParameterTextFieldControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             display_options: Optional['outputs.AnalysisTextFieldControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.AnalysisTextFieldControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class AnalysisParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeParameters":
            suggest = "date_time_parameters"
        elif key == "decimalParameters":
            suggest = "decimal_parameters"
        elif key == "integerParameters":
            suggest = "integer_parameters"
        elif key == "stringParameters":
            suggest = "string_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_parameters: Optional[Sequence['outputs.AnalysisDateTimeParameter']] = None,
                 decimal_parameters: Optional[Sequence['outputs.AnalysisDecimalParameter']] = None,
                 integer_parameters: Optional[Sequence['outputs.AnalysisIntegerParameter']] = None,
                 string_parameters: Optional[Sequence['outputs.AnalysisStringParameter']] = None):
        AnalysisParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_parameters=date_time_parameters,
            decimal_parameters=decimal_parameters,
            integer_parameters=integer_parameters,
            string_parameters=string_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_parameters: Optional[Sequence['outputs.AnalysisDateTimeParameter']] = None,
             decimal_parameters: Optional[Sequence['outputs.AnalysisDecimalParameter']] = None,
             integer_parameters: Optional[Sequence['outputs.AnalysisIntegerParameter']] = None,
             string_parameters: Optional[Sequence['outputs.AnalysisStringParameter']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_parameters is not None:
            _setter("date_time_parameters", date_time_parameters)
        if decimal_parameters is not None:
            _setter("decimal_parameters", decimal_parameters)
        if integer_parameters is not None:
            _setter("integer_parameters", integer_parameters)
        if string_parameters is not None:
            _setter("string_parameters", string_parameters)

    @property
    @pulumi.getter(name="dateTimeParameters")
    def date_time_parameters(self) -> Optional[Sequence['outputs.AnalysisDateTimeParameter']]:
        return pulumi.get(self, "date_time_parameters")

    @property
    @pulumi.getter(name="decimalParameters")
    def decimal_parameters(self) -> Optional[Sequence['outputs.AnalysisDecimalParameter']]:
        return pulumi.get(self, "decimal_parameters")

    @property
    @pulumi.getter(name="integerParameters")
    def integer_parameters(self) -> Optional[Sequence['outputs.AnalysisIntegerParameter']]:
        return pulumi.get(self, "integer_parameters")

    @property
    @pulumi.getter(name="stringParameters")
    def string_parameters(self) -> Optional[Sequence['outputs.AnalysisStringParameter']]:
        return pulumi.get(self, "string_parameters")


@pulumi.output_type
class AnalysisPercentVisibleRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPercentVisibleRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPercentVisibleRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPercentVisibleRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[float] = None,
                 to: Optional[float] = None):
        AnalysisPercentVisibleRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[float] = None,
             to: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[float]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[float]:
        return pulumi.get(self, "to")


@pulumi.output_type
class AnalysisPercentageDisplayFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlacesConfiguration":
            suggest = "decimal_places_configuration"
        elif key == "negativeValueConfiguration":
            suggest = "negative_value_configuration"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "separatorConfiguration":
            suggest = "separator_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPercentageDisplayFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPercentageDisplayFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPercentageDisplayFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places_configuration: Optional['outputs.AnalysisDecimalPlacesConfiguration'] = None,
                 negative_value_configuration: Optional['outputs.AnalysisNegativeValueConfiguration'] = None,
                 null_value_format_configuration: Optional['outputs.AnalysisNullValueFormatConfiguration'] = None,
                 prefix: Optional[str] = None,
                 separator_configuration: Optional['outputs.AnalysisNumericSeparatorConfiguration'] = None,
                 suffix: Optional[str] = None):
        AnalysisPercentageDisplayFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places_configuration=decimal_places_configuration,
            negative_value_configuration=negative_value_configuration,
            null_value_format_configuration=null_value_format_configuration,
            prefix=prefix,
            separator_configuration=separator_configuration,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places_configuration: Optional['outputs.AnalysisDecimalPlacesConfiguration'] = None,
             negative_value_configuration: Optional['outputs.AnalysisNegativeValueConfiguration'] = None,
             null_value_format_configuration: Optional['outputs.AnalysisNullValueFormatConfiguration'] = None,
             prefix: Optional[str] = None,
             separator_configuration: Optional['outputs.AnalysisNumericSeparatorConfiguration'] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_places_configuration is not None:
            _setter("decimal_places_configuration", decimal_places_configuration)
        if negative_value_configuration is not None:
            _setter("negative_value_configuration", negative_value_configuration)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if prefix is not None:
            _setter("prefix", prefix)
        if separator_configuration is not None:
            _setter("separator_configuration", separator_configuration)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter(name="decimalPlacesConfiguration")
    def decimal_places_configuration(self) -> Optional['outputs.AnalysisDecimalPlacesConfiguration']:
        return pulumi.get(self, "decimal_places_configuration")

    @property
    @pulumi.getter(name="negativeValueConfiguration")
    def negative_value_configuration(self) -> Optional['outputs.AnalysisNegativeValueConfiguration']:
        return pulumi.get(self, "negative_value_configuration")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.AnalysisNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="separatorConfiguration")
    def separator_configuration(self) -> Optional['outputs.AnalysisNumericSeparatorConfiguration']:
        return pulumi.get(self, "separator_configuration")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class AnalysisPercentileAggregation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "percentileValue":
            suggest = "percentile_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPercentileAggregation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPercentileAggregation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPercentileAggregation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentile_value: Optional[float] = None):
        AnalysisPercentileAggregation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            percentile_value=percentile_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             percentile_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if percentile_value is not None:
            _setter("percentile_value", percentile_value)

    @property
    @pulumi.getter(name="percentileValue")
    def percentile_value(self) -> Optional[float]:
        return pulumi.get(self, "percentile_value")


@pulumi.output_type
class AnalysisPeriodOverPeriodComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPeriodOverPeriodComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPeriodOverPeriodComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPeriodOverPeriodComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 time: Optional['outputs.AnalysisDimensionField'] = None,
                 value: Optional['outputs.AnalysisMeasureField'] = None):
        AnalysisPeriodOverPeriodComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             time: Optional['outputs.AnalysisDimensionField'] = None,
             value: Optional['outputs.AnalysisMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.AnalysisDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AnalysisMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisPeriodToDateComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "periodTimeGranularity":
            suggest = "period_time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPeriodToDateComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPeriodToDateComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPeriodToDateComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 period_time_granularity: Optional['AnalysisTimeGranularity'] = None,
                 time: Optional['outputs.AnalysisDimensionField'] = None,
                 value: Optional['outputs.AnalysisMeasureField'] = None):
        AnalysisPeriodToDateComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            period_time_granularity=period_time_granularity,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             period_time_granularity: Optional['AnalysisTimeGranularity'] = None,
             time: Optional['outputs.AnalysisDimensionField'] = None,
             value: Optional['outputs.AnalysisMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if period_time_granularity is not None:
            _setter("period_time_granularity", period_time_granularity)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="periodTimeGranularity")
    def period_time_granularity(self) -> Optional['AnalysisTimeGranularity']:
        return pulumi.get(self, "period_time_granularity")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.AnalysisDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AnalysisMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisPieChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "smallMultiples":
            suggest = "small_multiples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPieChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPieChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPieChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 small_multiples: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisPieChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            small_multiples=small_multiples,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             small_multiples: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if small_multiples is not None:
            _setter("small_multiples", small_multiples)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="smallMultiples")
    def small_multiples(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "small_multiples")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisPieChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "contributionAnalysisDefaults":
            suggest = "contribution_analysis_defaults"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "donutOptions":
            suggest = "donut_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "smallMultiplesOptions":
            suggest = "small_multiples_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "valueLabelOptions":
            suggest = "value_label_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPieChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPieChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPieChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 contribution_analysis_defaults: Optional[Sequence['outputs.AnalysisContributionAnalysisDefault']] = None,
                 data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 donut_options: Optional['outputs.AnalysisDonutOptions'] = None,
                 field_wells: Optional['outputs.AnalysisPieChartFieldWells'] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 small_multiples_options: Optional['outputs.AnalysisSmallMultiplesOptions'] = None,
                 sort_configuration: Optional['outputs.AnalysisPieChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
                 value_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None):
        AnalysisPieChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_options=category_label_options,
            contribution_analysis_defaults=contribution_analysis_defaults,
            data_labels=data_labels,
            donut_options=donut_options,
            field_wells=field_wells,
            legend=legend,
            small_multiples_options=small_multiples_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            value_label_options=value_label_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             contribution_analysis_defaults: Optional[Sequence['outputs.AnalysisContributionAnalysisDefault']] = None,
             data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             donut_options: Optional['outputs.AnalysisDonutOptions'] = None,
             field_wells: Optional['outputs.AnalysisPieChartFieldWells'] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             small_multiples_options: Optional['outputs.AnalysisSmallMultiplesOptions'] = None,
             sort_configuration: Optional['outputs.AnalysisPieChartSortConfiguration'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             value_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if contribution_analysis_defaults is not None:
            _setter("contribution_analysis_defaults", contribution_analysis_defaults)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if donut_options is not None:
            _setter("donut_options", donut_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if small_multiples_options is not None:
            _setter("small_multiples_options", small_multiples_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if value_label_options is not None:
            _setter("value_label_options", value_label_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="contributionAnalysisDefaults")
    def contribution_analysis_defaults(self) -> Optional[Sequence['outputs.AnalysisContributionAnalysisDefault']]:
        return pulumi.get(self, "contribution_analysis_defaults")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="donutOptions")
    def donut_options(self) -> Optional['outputs.AnalysisDonutOptions']:
        return pulumi.get(self, "donut_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisPieChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="smallMultiplesOptions")
    def small_multiples_options(self) -> Optional['outputs.AnalysisSmallMultiplesOptions']:
        return pulumi.get(self, "small_multiples_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisPieChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="valueLabelOptions")
    def value_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "value_label_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class AnalysisPieChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pieChartAggregatedFieldWells":
            suggest = "pie_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPieChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPieChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPieChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pie_chart_aggregated_field_wells: Optional['outputs.AnalysisPieChartAggregatedFieldWells'] = None):
        AnalysisPieChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pie_chart_aggregated_field_wells=pie_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pie_chart_aggregated_field_wells: Optional['outputs.AnalysisPieChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pie_chart_aggregated_field_wells is not None:
            _setter("pie_chart_aggregated_field_wells", pie_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="pieChartAggregatedFieldWells")
    def pie_chart_aggregated_field_wells(self) -> Optional['outputs.AnalysisPieChartAggregatedFieldWells']:
        return pulumi.get(self, "pie_chart_aggregated_field_wells")


@pulumi.output_type
class AnalysisPieChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "smallMultiplesLimitConfiguration":
            suggest = "small_multiples_limit_configuration"
        elif key == "smallMultiplesSort":
            suggest = "small_multiples_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPieChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPieChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPieChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
                 small_multiples_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 small_multiples_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisPieChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            small_multiples_limit_configuration=small_multiples_limit_configuration,
            small_multiples_sort=small_multiples_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             small_multiples_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             small_multiples_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if small_multiples_limit_configuration is not None:
            _setter("small_multiples_limit_configuration", small_multiples_limit_configuration)
        if small_multiples_sort is not None:
            _setter("small_multiples_sort", small_multiples_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="smallMultiplesLimitConfiguration")
    def small_multiples_limit_configuration(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "small_multiples_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesSort")
    def small_multiples_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "small_multiples_sort")


@pulumi.output_type
class AnalysisPieChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPieChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPieChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPieChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisPieChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisPieChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisPieChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisPieChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisPivotFieldSortOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "sortBy":
            suggest = "sort_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotFieldSortOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotFieldSortOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotFieldSortOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 sort_by: 'outputs.AnalysisPivotTableSortBy'):
        AnalysisPivotFieldSortOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            sort_by=sort_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             sort_by: 'outputs.AnalysisPivotTableSortBy',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        _setter("sort_by", sort_by)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="sortBy")
    def sort_by(self) -> 'outputs.AnalysisPivotTableSortBy':
        return pulumi.get(self, "sort_by")


@pulumi.output_type
class AnalysisPivotTableAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 columns: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 rows: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisPivotTableAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            rows=rows,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             rows: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if columns is not None:
            _setter("columns", columns)
        if rows is not None:
            _setter("rows", rows)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def rows(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "rows")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisPivotTableCellConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "textFormat":
            suggest = "text_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableCellConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableCellConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableCellConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 scope: Optional['outputs.AnalysisPivotTableConditionalFormattingScope'] = None,
                 scopes: Optional[Sequence['outputs.AnalysisPivotTableConditionalFormattingScope']] = None,
                 text_format: Optional['outputs.AnalysisTextConditionalFormat'] = None):
        AnalysisPivotTableCellConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            scope=scope,
            scopes=scopes,
            text_format=text_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             scope: Optional['outputs.AnalysisPivotTableConditionalFormattingScope'] = None,
             scopes: Optional[Sequence['outputs.AnalysisPivotTableConditionalFormattingScope']] = None,
             text_format: Optional['outputs.AnalysisTextConditionalFormat'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if scope is not None:
            _setter("scope", scope)
        if scopes is not None:
            _setter("scopes", scopes)
        if text_format is not None:
            _setter("text_format", text_format)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.AnalysisPivotTableConditionalFormattingScope']:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence['outputs.AnalysisPivotTableConditionalFormattingScope']]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="textFormat")
    def text_format(self) -> Optional['outputs.AnalysisTextConditionalFormat']:
        return pulumi.get(self, "text_format")


@pulumi.output_type
class AnalysisPivotTableConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.AnalysisPivotTableConditionalFormattingOption']] = None):
        AnalysisPivotTableConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.AnalysisPivotTableConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.AnalysisPivotTableConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class AnalysisPivotTableConditionalFormattingOption(dict):
    def __init__(__self__, *,
                 cell: Optional['outputs.AnalysisPivotTableCellConditionalFormatting'] = None):
        AnalysisPivotTableConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell=cell,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell: Optional['outputs.AnalysisPivotTableCellConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell is not None:
            _setter("cell", cell)

    @property
    @pulumi.getter
    def cell(self) -> Optional['outputs.AnalysisPivotTableCellConditionalFormatting']:
        return pulumi.get(self, "cell")


@pulumi.output_type
class AnalysisPivotTableConditionalFormattingScope(dict):
    def __init__(__self__, *,
                 role: Optional['AnalysisPivotTableConditionalFormattingScopeRole'] = None):
        AnalysisPivotTableConditionalFormattingScope._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role: Optional['AnalysisPivotTableConditionalFormattingScopeRole'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if role is not None:
            _setter("role", role)

    @property
    @pulumi.getter
    def role(self) -> Optional['AnalysisPivotTableConditionalFormattingScopeRole']:
        return pulumi.get(self, "role")


@pulumi.output_type
class AnalysisPivotTableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldOptions":
            suggest = "field_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "paginatedReportOptions":
            suggest = "paginated_report_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "tableOptions":
            suggest = "table_options"
        elif key == "totalOptions":
            suggest = "total_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_options: Optional['outputs.AnalysisPivotTableFieldOptions'] = None,
                 field_wells: Optional['outputs.AnalysisPivotTableFieldWells'] = None,
                 paginated_report_options: Optional['outputs.AnalysisPivotTablePaginatedReportOptions'] = None,
                 sort_configuration: Optional['outputs.AnalysisPivotTableSortConfiguration'] = None,
                 table_options: Optional['outputs.AnalysisPivotTableOptions'] = None,
                 total_options: Optional['outputs.AnalysisPivotTableTotalOptions'] = None):
        AnalysisPivotTableConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_options=field_options,
            field_wells=field_wells,
            paginated_report_options=paginated_report_options,
            sort_configuration=sort_configuration,
            table_options=table_options,
            total_options=total_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_options: Optional['outputs.AnalysisPivotTableFieldOptions'] = None,
             field_wells: Optional['outputs.AnalysisPivotTableFieldWells'] = None,
             paginated_report_options: Optional['outputs.AnalysisPivotTablePaginatedReportOptions'] = None,
             sort_configuration: Optional['outputs.AnalysisPivotTableSortConfiguration'] = None,
             table_options: Optional['outputs.AnalysisPivotTableOptions'] = None,
             total_options: Optional['outputs.AnalysisPivotTableTotalOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_options is not None:
            _setter("field_options", field_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if paginated_report_options is not None:
            _setter("paginated_report_options", paginated_report_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if table_options is not None:
            _setter("table_options", table_options)
        if total_options is not None:
            _setter("total_options", total_options)

    @property
    @pulumi.getter(name="fieldOptions")
    def field_options(self) -> Optional['outputs.AnalysisPivotTableFieldOptions']:
        return pulumi.get(self, "field_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisPivotTableFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="paginatedReportOptions")
    def paginated_report_options(self) -> Optional['outputs.AnalysisPivotTablePaginatedReportOptions']:
        return pulumi.get(self, "paginated_report_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisPivotTableSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="tableOptions")
    def table_options(self) -> Optional['outputs.AnalysisPivotTableOptions']:
        return pulumi.get(self, "table_options")

    @property
    @pulumi.getter(name="totalOptions")
    def total_options(self) -> Optional['outputs.AnalysisPivotTableTotalOptions']:
        return pulumi.get(self, "total_options")


@pulumi.output_type
class AnalysisPivotTableDataPathOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPathList":
            suggest = "data_path_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableDataPathOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableDataPathOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableDataPathOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_path_list: Sequence['outputs.AnalysisDataPathValue'],
                 width: Optional[str] = None):
        """
        :param str width: String based length that is composed of value and unit in px
        """
        AnalysisPivotTableDataPathOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_path_list=data_path_list,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_path_list: Sequence['outputs.AnalysisDataPathValue'],
             width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_path_list", data_path_list)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter(name="dataPathList")
    def data_path_list(self) -> Sequence['outputs.AnalysisDataPathValue']:
        return pulumi.get(self, "data_path_list")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class AnalysisPivotTableFieldCollapseStateOption(dict):
    def __init__(__self__, *,
                 target: 'outputs.AnalysisPivotTableFieldCollapseStateTarget',
                 state: Optional['AnalysisPivotTableFieldCollapseState'] = None):
        AnalysisPivotTableFieldCollapseStateOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: 'outputs.AnalysisPivotTableFieldCollapseStateTarget',
             state: Optional['AnalysisPivotTableFieldCollapseState'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def target(self) -> 'outputs.AnalysisPivotTableFieldCollapseStateTarget':
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def state(self) -> Optional['AnalysisPivotTableFieldCollapseState']:
        return pulumi.get(self, "state")


@pulumi.output_type
class AnalysisPivotTableFieldCollapseStateTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldDataPathValues":
            suggest = "field_data_path_values"
        elif key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableFieldCollapseStateTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableFieldCollapseStateTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableFieldCollapseStateTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_data_path_values: Optional[Sequence['outputs.AnalysisDataPathValue']] = None,
                 field_id: Optional[str] = None):
        AnalysisPivotTableFieldCollapseStateTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_data_path_values=field_data_path_values,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_data_path_values: Optional[Sequence['outputs.AnalysisDataPathValue']] = None,
             field_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_data_path_values is not None:
            _setter("field_data_path_values", field_data_path_values)
        if field_id is not None:
            _setter("field_id", field_id)

    @property
    @pulumi.getter(name="fieldDataPathValues")
    def field_data_path_values(self) -> Optional[Sequence['outputs.AnalysisDataPathValue']]:
        return pulumi.get(self, "field_data_path_values")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class AnalysisPivotTableFieldOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "customLabel":
            suggest = "custom_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableFieldOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableFieldOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableFieldOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 custom_label: Optional[str] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisPivotTableFieldOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            custom_label=custom_label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             custom_label: Optional[str] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisPivotTableFieldOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collapseStateOptions":
            suggest = "collapse_state_options"
        elif key == "dataPathOptions":
            suggest = "data_path_options"
        elif key == "selectedFieldOptions":
            suggest = "selected_field_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableFieldOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableFieldOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableFieldOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collapse_state_options: Optional[Sequence['outputs.AnalysisPivotTableFieldCollapseStateOption']] = None,
                 data_path_options: Optional[Sequence['outputs.AnalysisPivotTableDataPathOption']] = None,
                 selected_field_options: Optional[Sequence['outputs.AnalysisPivotTableFieldOption']] = None):
        AnalysisPivotTableFieldOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collapse_state_options=collapse_state_options,
            data_path_options=data_path_options,
            selected_field_options=selected_field_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collapse_state_options: Optional[Sequence['outputs.AnalysisPivotTableFieldCollapseStateOption']] = None,
             data_path_options: Optional[Sequence['outputs.AnalysisPivotTableDataPathOption']] = None,
             selected_field_options: Optional[Sequence['outputs.AnalysisPivotTableFieldOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if collapse_state_options is not None:
            _setter("collapse_state_options", collapse_state_options)
        if data_path_options is not None:
            _setter("data_path_options", data_path_options)
        if selected_field_options is not None:
            _setter("selected_field_options", selected_field_options)

    @property
    @pulumi.getter(name="collapseStateOptions")
    def collapse_state_options(self) -> Optional[Sequence['outputs.AnalysisPivotTableFieldCollapseStateOption']]:
        return pulumi.get(self, "collapse_state_options")

    @property
    @pulumi.getter(name="dataPathOptions")
    def data_path_options(self) -> Optional[Sequence['outputs.AnalysisPivotTableDataPathOption']]:
        return pulumi.get(self, "data_path_options")

    @property
    @pulumi.getter(name="selectedFieldOptions")
    def selected_field_options(self) -> Optional[Sequence['outputs.AnalysisPivotTableFieldOption']]:
        return pulumi.get(self, "selected_field_options")


@pulumi.output_type
class AnalysisPivotTableFieldSubtotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableFieldSubtotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableFieldSubtotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableFieldSubtotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: Optional[str] = None):
        AnalysisPivotTableFieldSubtotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_id is not None:
            _setter("field_id", field_id)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class AnalysisPivotTableFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pivotTableAggregatedFieldWells":
            suggest = "pivot_table_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pivot_table_aggregated_field_wells: Optional['outputs.AnalysisPivotTableAggregatedFieldWells'] = None):
        AnalysisPivotTableFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pivot_table_aggregated_field_wells=pivot_table_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pivot_table_aggregated_field_wells: Optional['outputs.AnalysisPivotTableAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pivot_table_aggregated_field_wells is not None:
            _setter("pivot_table_aggregated_field_wells", pivot_table_aggregated_field_wells)

    @property
    @pulumi.getter(name="pivotTableAggregatedFieldWells")
    def pivot_table_aggregated_field_wells(self) -> Optional['outputs.AnalysisPivotTableAggregatedFieldWells']:
        return pulumi.get(self, "pivot_table_aggregated_field_wells")


@pulumi.output_type
class AnalysisPivotTableOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellStyle":
            suggest = "cell_style"
        elif key == "collapsedRowDimensionsVisibility":
            suggest = "collapsed_row_dimensions_visibility"
        elif key == "columnHeaderStyle":
            suggest = "column_header_style"
        elif key == "columnNamesVisibility":
            suggest = "column_names_visibility"
        elif key == "defaultCellWidth":
            suggest = "default_cell_width"
        elif key == "metricPlacement":
            suggest = "metric_placement"
        elif key == "rowAlternateColorOptions":
            suggest = "row_alternate_color_options"
        elif key == "rowFieldNamesStyle":
            suggest = "row_field_names_style"
        elif key == "rowHeaderStyle":
            suggest = "row_header_style"
        elif key == "rowsLabelOptions":
            suggest = "rows_label_options"
        elif key == "rowsLayout":
            suggest = "rows_layout"
        elif key == "singleMetricVisibility":
            suggest = "single_metric_visibility"
        elif key == "toggleButtonsVisibility":
            suggest = "toggle_buttons_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
                 collapsed_row_dimensions_visibility: Optional['AnalysisVisibility'] = None,
                 column_header_style: Optional['outputs.AnalysisTableCellStyle'] = None,
                 column_names_visibility: Optional['AnalysisVisibility'] = None,
                 default_cell_width: Optional[str] = None,
                 metric_placement: Optional['AnalysisPivotTableMetricPlacement'] = None,
                 row_alternate_color_options: Optional['outputs.AnalysisRowAlternateColorOptions'] = None,
                 row_field_names_style: Optional['outputs.AnalysisTableCellStyle'] = None,
                 row_header_style: Optional['outputs.AnalysisTableCellStyle'] = None,
                 rows_label_options: Optional['outputs.AnalysisPivotTableRowsLabelOptions'] = None,
                 rows_layout: Optional['AnalysisPivotTableRowsLayout'] = None,
                 single_metric_visibility: Optional['AnalysisVisibility'] = None,
                 toggle_buttons_visibility: Optional['AnalysisVisibility'] = None):
        """
        :param str default_cell_width: String based length that is composed of value and unit in px
        """
        AnalysisPivotTableOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell_style=cell_style,
            collapsed_row_dimensions_visibility=collapsed_row_dimensions_visibility,
            column_header_style=column_header_style,
            column_names_visibility=column_names_visibility,
            default_cell_width=default_cell_width,
            metric_placement=metric_placement,
            row_alternate_color_options=row_alternate_color_options,
            row_field_names_style=row_field_names_style,
            row_header_style=row_header_style,
            rows_label_options=rows_label_options,
            rows_layout=rows_layout,
            single_metric_visibility=single_metric_visibility,
            toggle_buttons_visibility=toggle_buttons_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             collapsed_row_dimensions_visibility: Optional['AnalysisVisibility'] = None,
             column_header_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             column_names_visibility: Optional['AnalysisVisibility'] = None,
             default_cell_width: Optional[str] = None,
             metric_placement: Optional['AnalysisPivotTableMetricPlacement'] = None,
             row_alternate_color_options: Optional['outputs.AnalysisRowAlternateColorOptions'] = None,
             row_field_names_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             row_header_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             rows_label_options: Optional['outputs.AnalysisPivotTableRowsLabelOptions'] = None,
             rows_layout: Optional['AnalysisPivotTableRowsLayout'] = None,
             single_metric_visibility: Optional['AnalysisVisibility'] = None,
             toggle_buttons_visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell_style is not None:
            _setter("cell_style", cell_style)
        if collapsed_row_dimensions_visibility is not None:
            _setter("collapsed_row_dimensions_visibility", collapsed_row_dimensions_visibility)
        if column_header_style is not None:
            _setter("column_header_style", column_header_style)
        if column_names_visibility is not None:
            _setter("column_names_visibility", column_names_visibility)
        if default_cell_width is not None:
            _setter("default_cell_width", default_cell_width)
        if metric_placement is not None:
            _setter("metric_placement", metric_placement)
        if row_alternate_color_options is not None:
            _setter("row_alternate_color_options", row_alternate_color_options)
        if row_field_names_style is not None:
            _setter("row_field_names_style", row_field_names_style)
        if row_header_style is not None:
            _setter("row_header_style", row_header_style)
        if rows_label_options is not None:
            _setter("rows_label_options", rows_label_options)
        if rows_layout is not None:
            _setter("rows_layout", rows_layout)
        if single_metric_visibility is not None:
            _setter("single_metric_visibility", single_metric_visibility)
        if toggle_buttons_visibility is not None:
            _setter("toggle_buttons_visibility", toggle_buttons_visibility)

    @property
    @pulumi.getter(name="cellStyle")
    def cell_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "cell_style")

    @property
    @pulumi.getter(name="collapsedRowDimensionsVisibility")
    def collapsed_row_dimensions_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "collapsed_row_dimensions_visibility")

    @property
    @pulumi.getter(name="columnHeaderStyle")
    def column_header_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "column_header_style")

    @property
    @pulumi.getter(name="columnNamesVisibility")
    def column_names_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "column_names_visibility")

    @property
    @pulumi.getter(name="defaultCellWidth")
    def default_cell_width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "default_cell_width")

    @property
    @pulumi.getter(name="metricPlacement")
    def metric_placement(self) -> Optional['AnalysisPivotTableMetricPlacement']:
        return pulumi.get(self, "metric_placement")

    @property
    @pulumi.getter(name="rowAlternateColorOptions")
    def row_alternate_color_options(self) -> Optional['outputs.AnalysisRowAlternateColorOptions']:
        return pulumi.get(self, "row_alternate_color_options")

    @property
    @pulumi.getter(name="rowFieldNamesStyle")
    def row_field_names_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "row_field_names_style")

    @property
    @pulumi.getter(name="rowHeaderStyle")
    def row_header_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "row_header_style")

    @property
    @pulumi.getter(name="rowsLabelOptions")
    def rows_label_options(self) -> Optional['outputs.AnalysisPivotTableRowsLabelOptions']:
        return pulumi.get(self, "rows_label_options")

    @property
    @pulumi.getter(name="rowsLayout")
    def rows_layout(self) -> Optional['AnalysisPivotTableRowsLayout']:
        return pulumi.get(self, "rows_layout")

    @property
    @pulumi.getter(name="singleMetricVisibility")
    def single_metric_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "single_metric_visibility")

    @property
    @pulumi.getter(name="toggleButtonsVisibility")
    def toggle_buttons_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "toggle_buttons_visibility")


@pulumi.output_type
class AnalysisPivotTablePaginatedReportOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overflowColumnHeaderVisibility":
            suggest = "overflow_column_header_visibility"
        elif key == "verticalOverflowVisibility":
            suggest = "vertical_overflow_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTablePaginatedReportOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTablePaginatedReportOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTablePaginatedReportOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 overflow_column_header_visibility: Optional['AnalysisVisibility'] = None,
                 vertical_overflow_visibility: Optional['AnalysisVisibility'] = None):
        AnalysisPivotTablePaginatedReportOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            overflow_column_header_visibility=overflow_column_header_visibility,
            vertical_overflow_visibility=vertical_overflow_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             overflow_column_header_visibility: Optional['AnalysisVisibility'] = None,
             vertical_overflow_visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if overflow_column_header_visibility is not None:
            _setter("overflow_column_header_visibility", overflow_column_header_visibility)
        if vertical_overflow_visibility is not None:
            _setter("vertical_overflow_visibility", vertical_overflow_visibility)

    @property
    @pulumi.getter(name="overflowColumnHeaderVisibility")
    def overflow_column_header_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "overflow_column_header_visibility")

    @property
    @pulumi.getter(name="verticalOverflowVisibility")
    def vertical_overflow_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "vertical_overflow_visibility")


@pulumi.output_type
class AnalysisPivotTableRowsLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableRowsLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableRowsLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableRowsLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisPivotTableRowsLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisPivotTableSortBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPath":
            suggest = "data_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableSortBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableSortBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableSortBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional['outputs.AnalysisColumnSort'] = None,
                 data_path: Optional['outputs.AnalysisDataPathSort'] = None,
                 field: Optional['outputs.AnalysisFieldSort'] = None):
        AnalysisPivotTableSortBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            data_path=data_path,
            field=field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: Optional['outputs.AnalysisColumnSort'] = None,
             data_path: Optional['outputs.AnalysisDataPathSort'] = None,
             field: Optional['outputs.AnalysisFieldSort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column is not None:
            _setter("column", column)
        if data_path is not None:
            _setter("data_path", data_path)
        if field is not None:
            _setter("field", field)

    @property
    @pulumi.getter
    def column(self) -> Optional['outputs.AnalysisColumnSort']:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="dataPath")
    def data_path(self) -> Optional['outputs.AnalysisDataPathSort']:
        return pulumi.get(self, "data_path")

    @property
    @pulumi.getter
    def field(self) -> Optional['outputs.AnalysisFieldSort']:
        return pulumi.get(self, "field")


@pulumi.output_type
class AnalysisPivotTableSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldSortOptions":
            suggest = "field_sort_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_sort_options: Optional[Sequence['outputs.AnalysisPivotFieldSortOptions']] = None):
        AnalysisPivotTableSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_sort_options=field_sort_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_sort_options: Optional[Sequence['outputs.AnalysisPivotFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_sort_options is not None:
            _setter("field_sort_options", field_sort_options)

    @property
    @pulumi.getter(name="fieldSortOptions")
    def field_sort_options(self) -> Optional[Sequence['outputs.AnalysisPivotFieldSortOptions']]:
        return pulumi.get(self, "field_sort_options")


@pulumi.output_type
class AnalysisPivotTableTotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnSubtotalOptions":
            suggest = "column_subtotal_options"
        elif key == "columnTotalOptions":
            suggest = "column_total_options"
        elif key == "rowSubtotalOptions":
            suggest = "row_subtotal_options"
        elif key == "rowTotalOptions":
            suggest = "row_total_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableTotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableTotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableTotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_subtotal_options: Optional['outputs.AnalysisSubtotalOptions'] = None,
                 column_total_options: Optional['outputs.AnalysisPivotTotalOptions'] = None,
                 row_subtotal_options: Optional['outputs.AnalysisSubtotalOptions'] = None,
                 row_total_options: Optional['outputs.AnalysisPivotTotalOptions'] = None):
        AnalysisPivotTableTotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_subtotal_options=column_subtotal_options,
            column_total_options=column_total_options,
            row_subtotal_options=row_subtotal_options,
            row_total_options=row_total_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_subtotal_options: Optional['outputs.AnalysisSubtotalOptions'] = None,
             column_total_options: Optional['outputs.AnalysisPivotTotalOptions'] = None,
             row_subtotal_options: Optional['outputs.AnalysisSubtotalOptions'] = None,
             row_total_options: Optional['outputs.AnalysisPivotTotalOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_subtotal_options is not None:
            _setter("column_subtotal_options", column_subtotal_options)
        if column_total_options is not None:
            _setter("column_total_options", column_total_options)
        if row_subtotal_options is not None:
            _setter("row_subtotal_options", row_subtotal_options)
        if row_total_options is not None:
            _setter("row_total_options", row_total_options)

    @property
    @pulumi.getter(name="columnSubtotalOptions")
    def column_subtotal_options(self) -> Optional['outputs.AnalysisSubtotalOptions']:
        return pulumi.get(self, "column_subtotal_options")

    @property
    @pulumi.getter(name="columnTotalOptions")
    def column_total_options(self) -> Optional['outputs.AnalysisPivotTotalOptions']:
        return pulumi.get(self, "column_total_options")

    @property
    @pulumi.getter(name="rowSubtotalOptions")
    def row_subtotal_options(self) -> Optional['outputs.AnalysisSubtotalOptions']:
        return pulumi.get(self, "row_subtotal_options")

    @property
    @pulumi.getter(name="rowTotalOptions")
    def row_total_options(self) -> Optional['outputs.AnalysisPivotTotalOptions']:
        return pulumi.get(self, "row_total_options")


@pulumi.output_type
class AnalysisPivotTableVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTableVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTableVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTableVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisPivotTableConfiguration'] = None,
                 conditional_formatting: Optional['outputs.AnalysisPivotTableConditionalFormatting'] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisPivotTableVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisPivotTableConfiguration'] = None,
             conditional_formatting: Optional['outputs.AnalysisPivotTableConditionalFormatting'] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisPivotTableConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.AnalysisPivotTableConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisPivotTotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "metricHeaderCellStyle":
            suggest = "metric_header_cell_style"
        elif key == "scrollStatus":
            suggest = "scroll_status"
        elif key == "totalCellStyle":
            suggest = "total_cell_style"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"
        elif key == "valueCellStyle":
            suggest = "value_cell_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPivotTotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPivotTotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPivotTotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 metric_header_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
                 placement: Optional['AnalysisTableTotalsPlacement'] = None,
                 scroll_status: Optional['AnalysisTableTotalsScrollStatus'] = None,
                 total_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
                 totals_visibility: Optional['AnalysisVisibility'] = None,
                 value_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None):
        AnalysisPivotTotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            metric_header_cell_style=metric_header_cell_style,
            placement=placement,
            scroll_status=scroll_status,
            total_cell_style=total_cell_style,
            totals_visibility=totals_visibility,
            value_cell_style=value_cell_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             metric_header_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             placement: Optional['AnalysisTableTotalsPlacement'] = None,
             scroll_status: Optional['AnalysisTableTotalsScrollStatus'] = None,
             total_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             totals_visibility: Optional['AnalysisVisibility'] = None,
             value_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if metric_header_cell_style is not None:
            _setter("metric_header_cell_style", metric_header_cell_style)
        if placement is not None:
            _setter("placement", placement)
        if scroll_status is not None:
            _setter("scroll_status", scroll_status)
        if total_cell_style is not None:
            _setter("total_cell_style", total_cell_style)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)
        if value_cell_style is not None:
            _setter("value_cell_style", value_cell_style)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="metricHeaderCellStyle")
    def metric_header_cell_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "metric_header_cell_style")

    @property
    @pulumi.getter
    def placement(self) -> Optional['AnalysisTableTotalsPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="scrollStatus")
    def scroll_status(self) -> Optional['AnalysisTableTotalsScrollStatus']:
        return pulumi.get(self, "scroll_status")

    @property
    @pulumi.getter(name="totalCellStyle")
    def total_cell_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "total_cell_style")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "totals_visibility")

    @property
    @pulumi.getter(name="valueCellStyle")
    def value_cell_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "value_cell_style")


@pulumi.output_type
class AnalysisPredefinedHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hierarchyId":
            suggest = "hierarchy_id"
        elif key == "drillDownFilters":
            suggest = "drill_down_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisPredefinedHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisPredefinedHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisPredefinedHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence['outputs.AnalysisColumnIdentifier'],
                 hierarchy_id: str,
                 drill_down_filters: Optional[Sequence['outputs.AnalysisDrillDownFilter']] = None):
        AnalysisPredefinedHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            hierarchy_id=hierarchy_id,
            drill_down_filters=drill_down_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Sequence['outputs.AnalysisColumnIdentifier'],
             hierarchy_id: str,
             drill_down_filters: Optional[Sequence['outputs.AnalysisDrillDownFilter']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("columns", columns)
        _setter("hierarchy_id", hierarchy_id)
        if drill_down_filters is not None:
            _setter("drill_down_filters", drill_down_filters)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.AnalysisColumnIdentifier']:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> str:
        return pulumi.get(self, "hierarchy_id")

    @property
    @pulumi.getter(name="drillDownFilters")
    def drill_down_filters(self) -> Optional[Sequence['outputs.AnalysisDrillDownFilter']]:
        return pulumi.get(self, "drill_down_filters")


@pulumi.output_type
class AnalysisProgressBarOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisProgressBarOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisRadarChartAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 color: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisRadarChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            color=color,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             color: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if color is not None:
            _setter("color", color)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def color(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisRadarChartAreaStyleSettings(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisRadarChartAreaStyleSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisRadarChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alternateBandColorsVisibility":
            suggest = "alternate_band_colors_visibility"
        elif key == "alternateBandEvenColor":
            suggest = "alternate_band_even_color"
        elif key == "alternateBandOddColor":
            suggest = "alternate_band_odd_color"
        elif key == "axesRangeScale":
            suggest = "axes_range_scale"
        elif key == "baseSeriesSettings":
            suggest = "base_series_settings"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "colorAxis":
            suggest = "color_axis"
        elif key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "startAngle":
            suggest = "start_angle"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisRadarChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisRadarChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisRadarChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alternate_band_colors_visibility: Optional['AnalysisVisibility'] = None,
                 alternate_band_even_color: Optional[str] = None,
                 alternate_band_odd_color: Optional[str] = None,
                 axes_range_scale: Optional['AnalysisRadarChartAxesRangeScale'] = None,
                 base_series_settings: Optional['outputs.AnalysisRadarChartSeriesSettings'] = None,
                 category_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 color_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 color_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisRadarChartFieldWells'] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 shape: Optional['AnalysisRadarChartShape'] = None,
                 sort_configuration: Optional['outputs.AnalysisRadarChartSortConfiguration'] = None,
                 start_angle: Optional[float] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None):
        AnalysisRadarChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alternate_band_colors_visibility=alternate_band_colors_visibility,
            alternate_band_even_color=alternate_band_even_color,
            alternate_band_odd_color=alternate_band_odd_color,
            axes_range_scale=axes_range_scale,
            base_series_settings=base_series_settings,
            category_axis=category_axis,
            category_label_options=category_label_options,
            color_axis=color_axis,
            color_label_options=color_label_options,
            field_wells=field_wells,
            legend=legend,
            shape=shape,
            sort_configuration=sort_configuration,
            start_angle=start_angle,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alternate_band_colors_visibility: Optional['AnalysisVisibility'] = None,
             alternate_band_even_color: Optional[str] = None,
             alternate_band_odd_color: Optional[str] = None,
             axes_range_scale: Optional['AnalysisRadarChartAxesRangeScale'] = None,
             base_series_settings: Optional['outputs.AnalysisRadarChartSeriesSettings'] = None,
             category_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             color_axis: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             color_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisRadarChartFieldWells'] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             shape: Optional['AnalysisRadarChartShape'] = None,
             sort_configuration: Optional['outputs.AnalysisRadarChartSortConfiguration'] = None,
             start_angle: Optional[float] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if alternate_band_colors_visibility is not None:
            _setter("alternate_band_colors_visibility", alternate_band_colors_visibility)
        if alternate_band_even_color is not None:
            _setter("alternate_band_even_color", alternate_band_even_color)
        if alternate_band_odd_color is not None:
            _setter("alternate_band_odd_color", alternate_band_odd_color)
        if axes_range_scale is not None:
            _setter("axes_range_scale", axes_range_scale)
        if base_series_settings is not None:
            _setter("base_series_settings", base_series_settings)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if color_axis is not None:
            _setter("color_axis", color_axis)
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if shape is not None:
            _setter("shape", shape)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if start_angle is not None:
            _setter("start_angle", start_angle)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="alternateBandColorsVisibility")
    def alternate_band_colors_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "alternate_band_colors_visibility")

    @property
    @pulumi.getter(name="alternateBandEvenColor")
    def alternate_band_even_color(self) -> Optional[str]:
        return pulumi.get(self, "alternate_band_even_color")

    @property
    @pulumi.getter(name="alternateBandOddColor")
    def alternate_band_odd_color(self) -> Optional[str]:
        return pulumi.get(self, "alternate_band_odd_color")

    @property
    @pulumi.getter(name="axesRangeScale")
    def axes_range_scale(self) -> Optional['AnalysisRadarChartAxesRangeScale']:
        return pulumi.get(self, "axes_range_scale")

    @property
    @pulumi.getter(name="baseSeriesSettings")
    def base_series_settings(self) -> Optional['outputs.AnalysisRadarChartSeriesSettings']:
        return pulumi.get(self, "base_series_settings")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="colorAxis")
    def color_axis(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "color_axis")

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisRadarChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter
    def shape(self) -> Optional['AnalysisRadarChartShape']:
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisRadarChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="startAngle")
    def start_angle(self) -> Optional[float]:
        return pulumi.get(self, "start_angle")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class AnalysisRadarChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "radarChartAggregatedFieldWells":
            suggest = "radar_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisRadarChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisRadarChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisRadarChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 radar_chart_aggregated_field_wells: Optional['outputs.AnalysisRadarChartAggregatedFieldWells'] = None):
        AnalysisRadarChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            radar_chart_aggregated_field_wells=radar_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             radar_chart_aggregated_field_wells: Optional['outputs.AnalysisRadarChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if radar_chart_aggregated_field_wells is not None:
            _setter("radar_chart_aggregated_field_wells", radar_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="radarChartAggregatedFieldWells")
    def radar_chart_aggregated_field_wells(self) -> Optional['outputs.AnalysisRadarChartAggregatedFieldWells']:
        return pulumi.get(self, "radar_chart_aggregated_field_wells")


@pulumi.output_type
class AnalysisRadarChartSeriesSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "areaStyleSettings":
            suggest = "area_style_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisRadarChartSeriesSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisRadarChartSeriesSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisRadarChartSeriesSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area_style_settings: Optional['outputs.AnalysisRadarChartAreaStyleSettings'] = None):
        AnalysisRadarChartSeriesSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            area_style_settings=area_style_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             area_style_settings: Optional['outputs.AnalysisRadarChartAreaStyleSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if area_style_settings is not None:
            _setter("area_style_settings", area_style_settings)

    @property
    @pulumi.getter(name="areaStyleSettings")
    def area_style_settings(self) -> Optional['outputs.AnalysisRadarChartAreaStyleSettings']:
        return pulumi.get(self, "area_style_settings")


@pulumi.output_type
class AnalysisRadarChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimit":
            suggest = "color_items_limit"
        elif key == "colorSort":
            suggest = "color_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisRadarChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisRadarChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisRadarChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
                 color_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 color_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisRadarChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            color_items_limit=color_items_limit,
            color_sort=color_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             color_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             color_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit is not None:
            _setter("color_items_limit", color_items_limit)
        if color_sort is not None:
            _setter("color_sort", color_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimit")
    def color_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit")

    @property
    @pulumi.getter(name="colorSort")
    def color_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "color_sort")


@pulumi.output_type
class AnalysisRadarChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisRadarChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisRadarChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisRadarChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisRadarChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisRadarChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisRadarChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisRadarChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisRangeEndsLabelType(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisRangeEndsLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisReferenceLine(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataConfiguration":
            suggest = "data_configuration"
        elif key == "labelConfiguration":
            suggest = "label_configuration"
        elif key == "styleConfiguration":
            suggest = "style_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisReferenceLine. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisReferenceLine.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisReferenceLine.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_configuration: 'outputs.AnalysisReferenceLineDataConfiguration',
                 label_configuration: Optional['outputs.AnalysisReferenceLineLabelConfiguration'] = None,
                 status: Optional['AnalysisWidgetStatus'] = None,
                 style_configuration: Optional['outputs.AnalysisReferenceLineStyleConfiguration'] = None):
        AnalysisReferenceLine._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_configuration=data_configuration,
            label_configuration=label_configuration,
            status=status,
            style_configuration=style_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_configuration: 'outputs.AnalysisReferenceLineDataConfiguration',
             label_configuration: Optional['outputs.AnalysisReferenceLineLabelConfiguration'] = None,
             status: Optional['AnalysisWidgetStatus'] = None,
             style_configuration: Optional['outputs.AnalysisReferenceLineStyleConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_configuration", data_configuration)
        if label_configuration is not None:
            _setter("label_configuration", label_configuration)
        if status is not None:
            _setter("status", status)
        if style_configuration is not None:
            _setter("style_configuration", style_configuration)

    @property
    @pulumi.getter(name="dataConfiguration")
    def data_configuration(self) -> 'outputs.AnalysisReferenceLineDataConfiguration':
        return pulumi.get(self, "data_configuration")

    @property
    @pulumi.getter(name="labelConfiguration")
    def label_configuration(self) -> Optional['outputs.AnalysisReferenceLineLabelConfiguration']:
        return pulumi.get(self, "label_configuration")

    @property
    @pulumi.getter
    def status(self) -> Optional['AnalysisWidgetStatus']:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="styleConfiguration")
    def style_configuration(self) -> Optional['outputs.AnalysisReferenceLineStyleConfiguration']:
        return pulumi.get(self, "style_configuration")


@pulumi.output_type
class AnalysisReferenceLineCustomLabelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisReferenceLineCustomLabelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisReferenceLineCustomLabelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisReferenceLineCustomLabelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: str):
        AnalysisReferenceLineCustomLabelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_label", custom_label)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> str:
        return pulumi.get(self, "custom_label")


@pulumi.output_type
class AnalysisReferenceLineDataConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "dynamicConfiguration":
            suggest = "dynamic_configuration"
        elif key == "staticConfiguration":
            suggest = "static_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisReferenceLineDataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisReferenceLineDataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisReferenceLineDataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: Optional['AnalysisAxisBinding'] = None,
                 dynamic_configuration: Optional['outputs.AnalysisReferenceLineDynamicDataConfiguration'] = None,
                 static_configuration: Optional['outputs.AnalysisReferenceLineStaticDataConfiguration'] = None):
        AnalysisReferenceLineDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            dynamic_configuration=dynamic_configuration,
            static_configuration=static_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: Optional['AnalysisAxisBinding'] = None,
             dynamic_configuration: Optional['outputs.AnalysisReferenceLineDynamicDataConfiguration'] = None,
             static_configuration: Optional['outputs.AnalysisReferenceLineStaticDataConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_binding is not None:
            _setter("axis_binding", axis_binding)
        if dynamic_configuration is not None:
            _setter("dynamic_configuration", dynamic_configuration)
        if static_configuration is not None:
            _setter("static_configuration", static_configuration)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> Optional['AnalysisAxisBinding']:
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="dynamicConfiguration")
    def dynamic_configuration(self) -> Optional['outputs.AnalysisReferenceLineDynamicDataConfiguration']:
        return pulumi.get(self, "dynamic_configuration")

    @property
    @pulumi.getter(name="staticConfiguration")
    def static_configuration(self) -> Optional['outputs.AnalysisReferenceLineStaticDataConfiguration']:
        return pulumi.get(self, "static_configuration")


@pulumi.output_type
class AnalysisReferenceLineDynamicDataConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "measureAggregationFunction":
            suggest = "measure_aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisReferenceLineDynamicDataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisReferenceLineDynamicDataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisReferenceLineDynamicDataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 calculation: 'outputs.AnalysisNumericalAggregationFunction',
                 column: 'outputs.AnalysisColumnIdentifier',
                 measure_aggregation_function: Optional['outputs.AnalysisAggregationFunction'] = None):
        AnalysisReferenceLineDynamicDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            calculation=calculation,
            column=column,
            measure_aggregation_function=measure_aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             calculation: 'outputs.AnalysisNumericalAggregationFunction',
             column: 'outputs.AnalysisColumnIdentifier',
             measure_aggregation_function: Optional['outputs.AnalysisAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("calculation", calculation)
        _setter("column", column)
        if measure_aggregation_function is not None:
            _setter("measure_aggregation_function", measure_aggregation_function)

    @property
    @pulumi.getter
    def calculation(self) -> 'outputs.AnalysisNumericalAggregationFunction':
        return pulumi.get(self, "calculation")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="measureAggregationFunction")
    def measure_aggregation_function(self) -> Optional['outputs.AnalysisAggregationFunction']:
        return pulumi.get(self, "measure_aggregation_function")


@pulumi.output_type
class AnalysisReferenceLineLabelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabelConfiguration":
            suggest = "custom_label_configuration"
        elif key == "fontColor":
            suggest = "font_color"
        elif key == "fontConfiguration":
            suggest = "font_configuration"
        elif key == "horizontalPosition":
            suggest = "horizontal_position"
        elif key == "valueLabelConfiguration":
            suggest = "value_label_configuration"
        elif key == "verticalPosition":
            suggest = "vertical_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisReferenceLineLabelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisReferenceLineLabelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisReferenceLineLabelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label_configuration: Optional['outputs.AnalysisReferenceLineCustomLabelConfiguration'] = None,
                 font_color: Optional[str] = None,
                 font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
                 horizontal_position: Optional['AnalysisReferenceLineLabelHorizontalPosition'] = None,
                 value_label_configuration: Optional['outputs.AnalysisReferenceLineValueLabelConfiguration'] = None,
                 vertical_position: Optional['AnalysisReferenceLineLabelVerticalPosition'] = None):
        AnalysisReferenceLineLabelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label_configuration=custom_label_configuration,
            font_color=font_color,
            font_configuration=font_configuration,
            horizontal_position=horizontal_position,
            value_label_configuration=value_label_configuration,
            vertical_position=vertical_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label_configuration: Optional['outputs.AnalysisReferenceLineCustomLabelConfiguration'] = None,
             font_color: Optional[str] = None,
             font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
             horizontal_position: Optional['AnalysisReferenceLineLabelHorizontalPosition'] = None,
             value_label_configuration: Optional['outputs.AnalysisReferenceLineValueLabelConfiguration'] = None,
             vertical_position: Optional['AnalysisReferenceLineLabelVerticalPosition'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label_configuration is not None:
            _setter("custom_label_configuration", custom_label_configuration)
        if font_color is not None:
            _setter("font_color", font_color)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if horizontal_position is not None:
            _setter("horizontal_position", horizontal_position)
        if value_label_configuration is not None:
            _setter("value_label_configuration", value_label_configuration)
        if vertical_position is not None:
            _setter("vertical_position", vertical_position)

    @property
    @pulumi.getter(name="customLabelConfiguration")
    def custom_label_configuration(self) -> Optional['outputs.AnalysisReferenceLineCustomLabelConfiguration']:
        return pulumi.get(self, "custom_label_configuration")

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[str]:
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.AnalysisFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter(name="horizontalPosition")
    def horizontal_position(self) -> Optional['AnalysisReferenceLineLabelHorizontalPosition']:
        return pulumi.get(self, "horizontal_position")

    @property
    @pulumi.getter(name="valueLabelConfiguration")
    def value_label_configuration(self) -> Optional['outputs.AnalysisReferenceLineValueLabelConfiguration']:
        return pulumi.get(self, "value_label_configuration")

    @property
    @pulumi.getter(name="verticalPosition")
    def vertical_position(self) -> Optional['AnalysisReferenceLineLabelVerticalPosition']:
        return pulumi.get(self, "vertical_position")


@pulumi.output_type
class AnalysisReferenceLineStaticDataConfiguration(dict):
    def __init__(__self__, *,
                 value: float):
        AnalysisReferenceLineStaticDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisReferenceLineStyleConfiguration(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 pattern: Optional['AnalysisReferenceLinePatternType'] = None):
        AnalysisReferenceLineStyleConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            pattern=pattern,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             pattern: Optional['AnalysisReferenceLinePatternType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if pattern is not None:
            _setter("pattern", pattern)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def pattern(self) -> Optional['AnalysisReferenceLinePatternType']:
        return pulumi.get(self, "pattern")


@pulumi.output_type
class AnalysisReferenceLineValueLabelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "relativePosition":
            suggest = "relative_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisReferenceLineValueLabelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisReferenceLineValueLabelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisReferenceLineValueLabelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_configuration: Optional['outputs.AnalysisNumericFormatConfiguration'] = None,
                 relative_position: Optional['AnalysisReferenceLineValueLabelRelativePosition'] = None):
        AnalysisReferenceLineValueLabelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_configuration=format_configuration,
            relative_position=relative_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_configuration: Optional['outputs.AnalysisNumericFormatConfiguration'] = None,
             relative_position: Optional['AnalysisReferenceLineValueLabelRelativePosition'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if relative_position is not None:
            _setter("relative_position", relative_position)

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.AnalysisNumericFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="relativePosition")
    def relative_position(self) -> Optional['AnalysisReferenceLineValueLabelRelativePosition']:
        return pulumi.get(self, "relative_position")


@pulumi.output_type
class AnalysisRelativeDateTimeControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormat":
            suggest = "date_time_format"
        elif key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisRelativeDateTimeControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisRelativeDateTimeControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisRelativeDateTimeControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format: Optional[str] = None,
                 info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
                 title_options: Optional['outputs.AnalysisLabelOptions'] = None):
        AnalysisRelativeDateTimeControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format=date_time_format,
            info_icon_label_options=info_icon_label_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format: Optional[str] = None,
             info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
             title_options: Optional['outputs.AnalysisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format is not None:
            _setter("date_time_format", date_time_format)
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="dateTimeFormat")
    def date_time_format(self) -> Optional[str]:
        return pulumi.get(self, "date_time_format")

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.AnalysisSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.AnalysisLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class AnalysisRelativeDatesFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anchorDateConfiguration":
            suggest = "anchor_date_configuration"
        elif key == "filterId":
            suggest = "filter_id"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "relativeDateType":
            suggest = "relative_date_type"
        elif key == "timeGranularity":
            suggest = "time_granularity"
        elif key == "excludePeriodConfiguration":
            suggest = "exclude_period_configuration"
        elif key == "minimumGranularity":
            suggest = "minimum_granularity"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "relativeDateValue":
            suggest = "relative_date_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisRelativeDatesFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisRelativeDatesFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisRelativeDatesFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anchor_date_configuration: 'outputs.AnalysisAnchorDateConfiguration',
                 column: 'outputs.AnalysisColumnIdentifier',
                 filter_id: str,
                 null_option: 'AnalysisFilterNullOption',
                 relative_date_type: 'AnalysisRelativeDateType',
                 time_granularity: 'AnalysisTimeGranularity',
                 exclude_period_configuration: Optional['outputs.AnalysisExcludePeriodConfiguration'] = None,
                 minimum_granularity: Optional['AnalysisTimeGranularity'] = None,
                 parameter_name: Optional[str] = None,
                 relative_date_value: Optional[float] = None):
        AnalysisRelativeDatesFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            anchor_date_configuration=anchor_date_configuration,
            column=column,
            filter_id=filter_id,
            null_option=null_option,
            relative_date_type=relative_date_type,
            time_granularity=time_granularity,
            exclude_period_configuration=exclude_period_configuration,
            minimum_granularity=minimum_granularity,
            parameter_name=parameter_name,
            relative_date_value=relative_date_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             anchor_date_configuration: 'outputs.AnalysisAnchorDateConfiguration',
             column: 'outputs.AnalysisColumnIdentifier',
             filter_id: str,
             null_option: 'AnalysisFilterNullOption',
             relative_date_type: 'AnalysisRelativeDateType',
             time_granularity: 'AnalysisTimeGranularity',
             exclude_period_configuration: Optional['outputs.AnalysisExcludePeriodConfiguration'] = None,
             minimum_granularity: Optional['AnalysisTimeGranularity'] = None,
             parameter_name: Optional[str] = None,
             relative_date_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("anchor_date_configuration", anchor_date_configuration)
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("null_option", null_option)
        _setter("relative_date_type", relative_date_type)
        _setter("time_granularity", time_granularity)
        if exclude_period_configuration is not None:
            _setter("exclude_period_configuration", exclude_period_configuration)
        if minimum_granularity is not None:
            _setter("minimum_granularity", minimum_granularity)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if relative_date_value is not None:
            _setter("relative_date_value", relative_date_value)

    @property
    @pulumi.getter(name="anchorDateConfiguration")
    def anchor_date_configuration(self) -> 'outputs.AnalysisAnchorDateConfiguration':
        return pulumi.get(self, "anchor_date_configuration")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'AnalysisFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="relativeDateType")
    def relative_date_type(self) -> 'AnalysisRelativeDateType':
        return pulumi.get(self, "relative_date_type")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> 'AnalysisTimeGranularity':
        return pulumi.get(self, "time_granularity")

    @property
    @pulumi.getter(name="excludePeriodConfiguration")
    def exclude_period_configuration(self) -> Optional['outputs.AnalysisExcludePeriodConfiguration']:
        return pulumi.get(self, "exclude_period_configuration")

    @property
    @pulumi.getter(name="minimumGranularity")
    def minimum_granularity(self) -> Optional['AnalysisTimeGranularity']:
        return pulumi.get(self, "minimum_granularity")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="relativeDateValue")
    def relative_date_value(self) -> Optional[float]:
        return pulumi.get(self, "relative_date_value")


@pulumi.output_type
class AnalysisResourcePermission(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str,
                 resource: Optional[str] = None):
        AnalysisResourcePermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
            resource=resource,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Sequence[str],
             principal: str,
             resource: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        _setter("principal", principal)
        if resource is not None:
            _setter("resource", resource)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        return pulumi.get(self, "principal")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")


@pulumi.output_type
class AnalysisRollingDateConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisRollingDateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisRollingDateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisRollingDateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 data_set_identifier: Optional[str] = None):
        AnalysisRollingDateConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            data_set_identifier=data_set_identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             data_set_identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if data_set_identifier is not None:
            _setter("data_set_identifier", data_set_identifier)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> Optional[str]:
        return pulumi.get(self, "data_set_identifier")


@pulumi.output_type
class AnalysisRowAlternateColorOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowAlternateColors":
            suggest = "row_alternate_colors"
        elif key == "usePrimaryBackgroundColor":
            suggest = "use_primary_background_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisRowAlternateColorOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisRowAlternateColorOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisRowAlternateColorOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 row_alternate_colors: Optional[Sequence[str]] = None,
                 status: Optional['AnalysisWidgetStatus'] = None,
                 use_primary_background_color: Optional['AnalysisWidgetStatus'] = None):
        AnalysisRowAlternateColorOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            row_alternate_colors=row_alternate_colors,
            status=status,
            use_primary_background_color=use_primary_background_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             row_alternate_colors: Optional[Sequence[str]] = None,
             status: Optional['AnalysisWidgetStatus'] = None,
             use_primary_background_color: Optional['AnalysisWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if row_alternate_colors is not None:
            _setter("row_alternate_colors", row_alternate_colors)
        if status is not None:
            _setter("status", status)
        if use_primary_background_color is not None:
            _setter("use_primary_background_color", use_primary_background_color)

    @property
    @pulumi.getter(name="rowAlternateColors")
    def row_alternate_colors(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "row_alternate_colors")

    @property
    @pulumi.getter
    def status(self) -> Optional['AnalysisWidgetStatus']:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="usePrimaryBackgroundColor")
    def use_primary_background_color(self) -> Optional['AnalysisWidgetStatus']:
        return pulumi.get(self, "use_primary_background_color")


@pulumi.output_type
class AnalysisSameSheetTargetVisualConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetVisualOptions":
            suggest = "target_visual_options"
        elif key == "targetVisuals":
            suggest = "target_visuals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSameSheetTargetVisualConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSameSheetTargetVisualConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSameSheetTargetVisualConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_visual_options: Optional['AnalysisTargetVisualOptions'] = None,
                 target_visuals: Optional[Sequence[str]] = None):
        AnalysisSameSheetTargetVisualConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_visual_options=target_visual_options,
            target_visuals=target_visuals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_visual_options: Optional['AnalysisTargetVisualOptions'] = None,
             target_visuals: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if target_visual_options is not None:
            _setter("target_visual_options", target_visual_options)
        if target_visuals is not None:
            _setter("target_visuals", target_visuals)

    @property
    @pulumi.getter(name="targetVisualOptions")
    def target_visual_options(self) -> Optional['AnalysisTargetVisualOptions']:
        return pulumi.get(self, "target_visual_options")

    @property
    @pulumi.getter(name="targetVisuals")
    def target_visuals(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "target_visuals")


@pulumi.output_type
class AnalysisSankeyDiagramAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 destination: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 source: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 weight: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisSankeyDiagramAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            source=source,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             source: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             weight: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination is not None:
            _setter("destination", destination)
        if source is not None:
            _setter("source", source)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter
    def destination(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def source(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def weight(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class AnalysisSankeyDiagramChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSankeyDiagramChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSankeyDiagramChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSankeyDiagramChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisSankeyDiagramFieldWells'] = None,
                 sort_configuration: Optional['outputs.AnalysisSankeyDiagramSortConfiguration'] = None):
        AnalysisSankeyDiagramChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_labels=data_labels,
            field_wells=field_wells,
            sort_configuration=sort_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisSankeyDiagramFieldWells'] = None,
             sort_configuration: Optional['outputs.AnalysisSankeyDiagramSortConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisSankeyDiagramFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisSankeyDiagramSortConfiguration']:
        return pulumi.get(self, "sort_configuration")


@pulumi.output_type
class AnalysisSankeyDiagramFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sankeyDiagramAggregatedFieldWells":
            suggest = "sankey_diagram_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSankeyDiagramFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSankeyDiagramFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSankeyDiagramFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sankey_diagram_aggregated_field_wells: Optional['outputs.AnalysisSankeyDiagramAggregatedFieldWells'] = None):
        AnalysisSankeyDiagramFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sankey_diagram_aggregated_field_wells=sankey_diagram_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sankey_diagram_aggregated_field_wells: Optional['outputs.AnalysisSankeyDiagramAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sankey_diagram_aggregated_field_wells is not None:
            _setter("sankey_diagram_aggregated_field_wells", sankey_diagram_aggregated_field_wells)

    @property
    @pulumi.getter(name="sankeyDiagramAggregatedFieldWells")
    def sankey_diagram_aggregated_field_wells(self) -> Optional['outputs.AnalysisSankeyDiagramAggregatedFieldWells']:
        return pulumi.get(self, "sankey_diagram_aggregated_field_wells")


@pulumi.output_type
class AnalysisSankeyDiagramSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationItemsLimit":
            suggest = "destination_items_limit"
        elif key == "sourceItemsLimit":
            suggest = "source_items_limit"
        elif key == "weightSort":
            suggest = "weight_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSankeyDiagramSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSankeyDiagramSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSankeyDiagramSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 source_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 weight_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisSankeyDiagramSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_items_limit=destination_items_limit,
            source_items_limit=source_items_limit,
            weight_sort=weight_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             source_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             weight_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination_items_limit is not None:
            _setter("destination_items_limit", destination_items_limit)
        if source_items_limit is not None:
            _setter("source_items_limit", source_items_limit)
        if weight_sort is not None:
            _setter("weight_sort", weight_sort)

    @property
    @pulumi.getter(name="destinationItemsLimit")
    def destination_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "destination_items_limit")

    @property
    @pulumi.getter(name="sourceItemsLimit")
    def source_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "source_items_limit")

    @property
    @pulumi.getter(name="weightSort")
    def weight_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "weight_sort")


@pulumi.output_type
class AnalysisSankeyDiagramVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSankeyDiagramVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSankeyDiagramVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSankeyDiagramVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisSankeyDiagramChartConfiguration'] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisSankeyDiagramVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisSankeyDiagramChartConfiguration'] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisSankeyDiagramChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisScatterPlotCategoricallyAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAxis":
            suggest = "x_axis"
        elif key == "yAxis":
            suggest = "y_axis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisScatterPlotCategoricallyAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisScatterPlotCategoricallyAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisScatterPlotCategoricallyAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 label: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 size: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
                 x_axis: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
                 y_axis: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisScatterPlotCategoricallyAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            label=label,
            size=size,
            x_axis=x_axis,
            y_axis=y_axis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             label: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             size: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             x_axis: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             y_axis: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if label is not None:
            _setter("label", label)
        if size is not None:
            _setter("size", size)
        if x_axis is not None:
            _setter("x_axis", x_axis)
        if y_axis is not None:
            _setter("y_axis", y_axis)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def label(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def size(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="xAxis")
    def x_axis(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "x_axis")

    @property
    @pulumi.getter(name="yAxis")
    def y_axis(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "y_axis")


@pulumi.output_type
class AnalysisScatterPlotConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "xAxisDisplayOptions":
            suggest = "x_axis_display_options"
        elif key == "xAxisLabelOptions":
            suggest = "x_axis_label_options"
        elif key == "yAxisDisplayOptions":
            suggest = "y_axis_display_options"
        elif key == "yAxisLabelOptions":
            suggest = "y_axis_label_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisScatterPlotConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisScatterPlotConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisScatterPlotConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisScatterPlotFieldWells'] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
                 x_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 x_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None):
        AnalysisScatterPlotConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            tooltip=tooltip,
            visual_palette=visual_palette,
            x_axis_display_options=x_axis_display_options,
            x_axis_label_options=x_axis_label_options,
            y_axis_display_options=y_axis_display_options,
            y_axis_label_options=y_axis_label_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisScatterPlotFieldWells'] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             x_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             x_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if x_axis_display_options is not None:
            _setter("x_axis_display_options", x_axis_display_options)
        if x_axis_label_options is not None:
            _setter("x_axis_label_options", x_axis_label_options)
        if y_axis_display_options is not None:
            _setter("y_axis_display_options", y_axis_display_options)
        if y_axis_label_options is not None:
            _setter("y_axis_label_options", y_axis_label_options)

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisScatterPlotFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="xAxisDisplayOptions")
    def x_axis_display_options(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "x_axis_display_options")

    @property
    @pulumi.getter(name="xAxisLabelOptions")
    def x_axis_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "x_axis_label_options")

    @property
    @pulumi.getter(name="yAxisDisplayOptions")
    def y_axis_display_options(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "y_axis_display_options")

    @property
    @pulumi.getter(name="yAxisLabelOptions")
    def y_axis_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "y_axis_label_options")


@pulumi.output_type
class AnalysisScatterPlotFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scatterPlotCategoricallyAggregatedFieldWells":
            suggest = "scatter_plot_categorically_aggregated_field_wells"
        elif key == "scatterPlotUnaggregatedFieldWells":
            suggest = "scatter_plot_unaggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisScatterPlotFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisScatterPlotFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisScatterPlotFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scatter_plot_categorically_aggregated_field_wells: Optional['outputs.AnalysisScatterPlotCategoricallyAggregatedFieldWells'] = None,
                 scatter_plot_unaggregated_field_wells: Optional['outputs.AnalysisScatterPlotUnaggregatedFieldWells'] = None):
        AnalysisScatterPlotFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scatter_plot_categorically_aggregated_field_wells=scatter_plot_categorically_aggregated_field_wells,
            scatter_plot_unaggregated_field_wells=scatter_plot_unaggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scatter_plot_categorically_aggregated_field_wells: Optional['outputs.AnalysisScatterPlotCategoricallyAggregatedFieldWells'] = None,
             scatter_plot_unaggregated_field_wells: Optional['outputs.AnalysisScatterPlotUnaggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if scatter_plot_categorically_aggregated_field_wells is not None:
            _setter("scatter_plot_categorically_aggregated_field_wells", scatter_plot_categorically_aggregated_field_wells)
        if scatter_plot_unaggregated_field_wells is not None:
            _setter("scatter_plot_unaggregated_field_wells", scatter_plot_unaggregated_field_wells)

    @property
    @pulumi.getter(name="scatterPlotCategoricallyAggregatedFieldWells")
    def scatter_plot_categorically_aggregated_field_wells(self) -> Optional['outputs.AnalysisScatterPlotCategoricallyAggregatedFieldWells']:
        return pulumi.get(self, "scatter_plot_categorically_aggregated_field_wells")

    @property
    @pulumi.getter(name="scatterPlotUnaggregatedFieldWells")
    def scatter_plot_unaggregated_field_wells(self) -> Optional['outputs.AnalysisScatterPlotUnaggregatedFieldWells']:
        return pulumi.get(self, "scatter_plot_unaggregated_field_wells")


@pulumi.output_type
class AnalysisScatterPlotUnaggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAxis":
            suggest = "x_axis"
        elif key == "yAxis":
            suggest = "y_axis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisScatterPlotUnaggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisScatterPlotUnaggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisScatterPlotUnaggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 label: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 size: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
                 x_axis: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 y_axis: Optional[Sequence['outputs.AnalysisDimensionField']] = None):
        AnalysisScatterPlotUnaggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            label=label,
            size=size,
            x_axis=x_axis,
            y_axis=y_axis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             label: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             size: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             x_axis: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             y_axis: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if label is not None:
            _setter("label", label)
        if size is not None:
            _setter("size", size)
        if x_axis is not None:
            _setter("x_axis", x_axis)
        if y_axis is not None:
            _setter("y_axis", y_axis)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def label(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def size(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="xAxis")
    def x_axis(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "x_axis")

    @property
    @pulumi.getter(name="yAxis")
    def y_axis(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "y_axis")


@pulumi.output_type
class AnalysisScatterPlotVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisScatterPlotVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisScatterPlotVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisScatterPlotVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisScatterPlotConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisScatterPlotVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisScatterPlotConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisScatterPlotConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisScrollBarOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibleRange":
            suggest = "visible_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisScrollBarOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisScrollBarOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisScrollBarOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None,
                 visible_range: Optional['outputs.AnalysisVisibleRangeOptions'] = None):
        AnalysisScrollBarOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
            visible_range=visible_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             visible_range: Optional['outputs.AnalysisVisibleRangeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)
        if visible_range is not None:
            _setter("visible_range", visible_range)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter(name="visibleRange")
    def visible_range(self) -> Optional['outputs.AnalysisVisibleRangeOptions']:
        return pulumi.get(self, "visible_range")


@pulumi.output_type
class AnalysisSecondaryValueOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisSecondaryValueOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisSectionAfterPageBreak(dict):
    def __init__(__self__, *,
                 status: Optional['AnalysisSectionPageBreakStatus'] = None):
        AnalysisSectionAfterPageBreak._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: Optional['AnalysisSectionPageBreakStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional['AnalysisSectionPageBreakStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class AnalysisSectionBasedLayoutCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paperCanvasSizeOptions":
            suggest = "paper_canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSectionBasedLayoutCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSectionBasedLayoutCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSectionBasedLayoutCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paper_canvas_size_options: Optional['outputs.AnalysisSectionBasedLayoutPaperCanvasSizeOptions'] = None):
        AnalysisSectionBasedLayoutCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            paper_canvas_size_options=paper_canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             paper_canvas_size_options: Optional['outputs.AnalysisSectionBasedLayoutPaperCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if paper_canvas_size_options is not None:
            _setter("paper_canvas_size_options", paper_canvas_size_options)

    @property
    @pulumi.getter(name="paperCanvasSizeOptions")
    def paper_canvas_size_options(self) -> Optional['outputs.AnalysisSectionBasedLayoutPaperCanvasSizeOptions']:
        return pulumi.get(self, "paper_canvas_size_options")


@pulumi.output_type
class AnalysisSectionBasedLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodySections":
            suggest = "body_sections"
        elif key == "canvasSizeOptions":
            suggest = "canvas_size_options"
        elif key == "footerSections":
            suggest = "footer_sections"
        elif key == "headerSections":
            suggest = "header_sections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSectionBasedLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSectionBasedLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSectionBasedLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_sections: Sequence['outputs.AnalysisBodySectionConfiguration'],
                 canvas_size_options: 'outputs.AnalysisSectionBasedLayoutCanvasSizeOptions',
                 footer_sections: Sequence['outputs.AnalysisHeaderFooterSectionConfiguration'],
                 header_sections: Sequence['outputs.AnalysisHeaderFooterSectionConfiguration']):
        AnalysisSectionBasedLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            body_sections=body_sections,
            canvas_size_options=canvas_size_options,
            footer_sections=footer_sections,
            header_sections=header_sections,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             body_sections: Sequence['outputs.AnalysisBodySectionConfiguration'],
             canvas_size_options: 'outputs.AnalysisSectionBasedLayoutCanvasSizeOptions',
             footer_sections: Sequence['outputs.AnalysisHeaderFooterSectionConfiguration'],
             header_sections: Sequence['outputs.AnalysisHeaderFooterSectionConfiguration'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("body_sections", body_sections)
        _setter("canvas_size_options", canvas_size_options)
        _setter("footer_sections", footer_sections)
        _setter("header_sections", header_sections)

    @property
    @pulumi.getter(name="bodySections")
    def body_sections(self) -> Sequence['outputs.AnalysisBodySectionConfiguration']:
        return pulumi.get(self, "body_sections")

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.AnalysisSectionBasedLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")

    @property
    @pulumi.getter(name="footerSections")
    def footer_sections(self) -> Sequence['outputs.AnalysisHeaderFooterSectionConfiguration']:
        return pulumi.get(self, "footer_sections")

    @property
    @pulumi.getter(name="headerSections")
    def header_sections(self) -> Sequence['outputs.AnalysisHeaderFooterSectionConfiguration']:
        return pulumi.get(self, "header_sections")


@pulumi.output_type
class AnalysisSectionBasedLayoutPaperCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paperMargin":
            suggest = "paper_margin"
        elif key == "paperOrientation":
            suggest = "paper_orientation"
        elif key == "paperSize":
            suggest = "paper_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSectionBasedLayoutPaperCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSectionBasedLayoutPaperCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSectionBasedLayoutPaperCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paper_margin: Optional['outputs.AnalysisSpacing'] = None,
                 paper_orientation: Optional['AnalysisPaperOrientation'] = None,
                 paper_size: Optional['AnalysisPaperSize'] = None):
        AnalysisSectionBasedLayoutPaperCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            paper_margin=paper_margin,
            paper_orientation=paper_orientation,
            paper_size=paper_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             paper_margin: Optional['outputs.AnalysisSpacing'] = None,
             paper_orientation: Optional['AnalysisPaperOrientation'] = None,
             paper_size: Optional['AnalysisPaperSize'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if paper_margin is not None:
            _setter("paper_margin", paper_margin)
        if paper_orientation is not None:
            _setter("paper_orientation", paper_orientation)
        if paper_size is not None:
            _setter("paper_size", paper_size)

    @property
    @pulumi.getter(name="paperMargin")
    def paper_margin(self) -> Optional['outputs.AnalysisSpacing']:
        return pulumi.get(self, "paper_margin")

    @property
    @pulumi.getter(name="paperOrientation")
    def paper_orientation(self) -> Optional['AnalysisPaperOrientation']:
        return pulumi.get(self, "paper_orientation")

    @property
    @pulumi.getter(name="paperSize")
    def paper_size(self) -> Optional['AnalysisPaperSize']:
        return pulumi.get(self, "paper_size")


@pulumi.output_type
class AnalysisSectionLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeFormLayout":
            suggest = "free_form_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSectionLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSectionLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSectionLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_form_layout: 'outputs.AnalysisFreeFormSectionLayoutConfiguration'):
        AnalysisSectionLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            free_form_layout=free_form_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             free_form_layout: 'outputs.AnalysisFreeFormSectionLayoutConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("free_form_layout", free_form_layout)

    @property
    @pulumi.getter(name="freeFormLayout")
    def free_form_layout(self) -> 'outputs.AnalysisFreeFormSectionLayoutConfiguration':
        return pulumi.get(self, "free_form_layout")


@pulumi.output_type
class AnalysisSectionPageBreakConfiguration(dict):
    def __init__(__self__, *,
                 after: Optional['outputs.AnalysisSectionAfterPageBreak'] = None):
        AnalysisSectionPageBreakConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            after=after,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             after: Optional['outputs.AnalysisSectionAfterPageBreak'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if after is not None:
            _setter("after", after)

    @property
    @pulumi.getter
    def after(self) -> Optional['outputs.AnalysisSectionAfterPageBreak']:
        return pulumi.get(self, "after")


@pulumi.output_type
class AnalysisSectionStyle(dict):
    def __init__(__self__, *,
                 height: Optional[str] = None,
                 padding: Optional['outputs.AnalysisSpacing'] = None):
        """
        :param str height: String based length that is composed of value and unit in px
        """
        AnalysisSectionStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            height=height,
            padding=padding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             height: Optional[str] = None,
             padding: Optional['outputs.AnalysisSpacing'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if height is not None:
            _setter("height", height)
        if padding is not None:
            _setter("padding", padding)

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def padding(self) -> Optional['outputs.AnalysisSpacing']:
        return pulumi.get(self, "padding")


@pulumi.output_type
class AnalysisSelectedSheetsFilterScopeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetVisualScopingConfigurations":
            suggest = "sheet_visual_scoping_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSelectedSheetsFilterScopeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSelectedSheetsFilterScopeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSelectedSheetsFilterScopeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sheet_visual_scoping_configurations: Optional[Sequence['outputs.AnalysisSheetVisualScopingConfiguration']] = None):
        AnalysisSelectedSheetsFilterScopeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sheet_visual_scoping_configurations=sheet_visual_scoping_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sheet_visual_scoping_configurations: Optional[Sequence['outputs.AnalysisSheetVisualScopingConfiguration']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sheet_visual_scoping_configurations is not None:
            _setter("sheet_visual_scoping_configurations", sheet_visual_scoping_configurations)

    @property
    @pulumi.getter(name="sheetVisualScopingConfigurations")
    def sheet_visual_scoping_configurations(self) -> Optional[Sequence['outputs.AnalysisSheetVisualScopingConfiguration']]:
        return pulumi.get(self, "sheet_visual_scoping_configurations")


@pulumi.output_type
class AnalysisSeriesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataFieldSeriesItem":
            suggest = "data_field_series_item"
        elif key == "fieldSeriesItem":
            suggest = "field_series_item"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSeriesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSeriesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSeriesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_field_series_item: Optional['outputs.AnalysisDataFieldSeriesItem'] = None,
                 field_series_item: Optional['outputs.AnalysisFieldSeriesItem'] = None):
        AnalysisSeriesItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_field_series_item=data_field_series_item,
            field_series_item=field_series_item,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_field_series_item: Optional['outputs.AnalysisDataFieldSeriesItem'] = None,
             field_series_item: Optional['outputs.AnalysisFieldSeriesItem'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_field_series_item is not None:
            _setter("data_field_series_item", data_field_series_item)
        if field_series_item is not None:
            _setter("field_series_item", field_series_item)

    @property
    @pulumi.getter(name="dataFieldSeriesItem")
    def data_field_series_item(self) -> Optional['outputs.AnalysisDataFieldSeriesItem']:
        return pulumi.get(self, "data_field_series_item")

    @property
    @pulumi.getter(name="fieldSeriesItem")
    def field_series_item(self) -> Optional['outputs.AnalysisFieldSeriesItem']:
        return pulumi.get(self, "field_series_item")


@pulumi.output_type
class AnalysisSetParameterValueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationParameterName":
            suggest = "destination_parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSetParameterValueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSetParameterValueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSetParameterValueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_parameter_name: str,
                 value: 'outputs.AnalysisDestinationParameterValueConfiguration'):
        AnalysisSetParameterValueConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_parameter_name=destination_parameter_name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_parameter_name: str,
             value: 'outputs.AnalysisDestinationParameterValueConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("destination_parameter_name", destination_parameter_name)
        _setter("value", value)

    @property
    @pulumi.getter(name="destinationParameterName")
    def destination_parameter_name(self) -> str:
        return pulumi.get(self, "destination_parameter_name")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.AnalysisDestinationParameterValueConfiguration':
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisShapeConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisShapeConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisShapeConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisShapeConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: 'outputs.AnalysisConditionalFormattingColor'):
        AnalysisShapeConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: 'outputs.AnalysisConditionalFormattingColor',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("background_color", background_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> 'outputs.AnalysisConditionalFormattingColor':
        return pulumi.get(self, "background_color")


@pulumi.output_type
class AnalysisSheet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetId":
            suggest = "sheet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSheet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSheet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSheet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 sheet_id: Optional[str] = None):
        AnalysisSheet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            sheet_id=sheet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             sheet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if sheet_id is not None:
            _setter("sheet_id", sheet_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sheetId")
    def sheet_id(self) -> Optional[str]:
        return pulumi.get(self, "sheet_id")


@pulumi.output_type
class AnalysisSheetControlInfoIconLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconText":
            suggest = "info_icon_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSheetControlInfoIconLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSheetControlInfoIconLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSheetControlInfoIconLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_text: Optional[str] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisSheetControlInfoIconLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_text=info_icon_text,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_text: Optional[str] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_text is not None:
            _setter("info_icon_text", info_icon_text)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="infoIconText")
    def info_icon_text(self) -> Optional[str]:
        return pulumi.get(self, "info_icon_text")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisSheetControlLayout(dict):
    def __init__(__self__, *,
                 configuration: 'outputs.AnalysisSheetControlLayoutConfiguration'):
        AnalysisSheetControlLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: 'outputs.AnalysisSheetControlLayoutConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("configuration", configuration)

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.AnalysisSheetControlLayoutConfiguration':
        return pulumi.get(self, "configuration")


@pulumi.output_type
class AnalysisSheetControlLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gridLayout":
            suggest = "grid_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSheetControlLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSheetControlLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSheetControlLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grid_layout: Optional['outputs.AnalysisGridLayoutConfiguration'] = None):
        AnalysisSheetControlLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grid_layout=grid_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grid_layout: Optional['outputs.AnalysisGridLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if grid_layout is not None:
            _setter("grid_layout", grid_layout)

    @property
    @pulumi.getter(name="gridLayout")
    def grid_layout(self) -> Optional['outputs.AnalysisGridLayoutConfiguration']:
        return pulumi.get(self, "grid_layout")


@pulumi.output_type
class AnalysisSheetDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetId":
            suggest = "sheet_id"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "filterControls":
            suggest = "filter_controls"
        elif key == "parameterControls":
            suggest = "parameter_controls"
        elif key == "sheetControlLayouts":
            suggest = "sheet_control_layouts"
        elif key == "textBoxes":
            suggest = "text_boxes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSheetDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSheetDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSheetDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sheet_id: str,
                 content_type: Optional['AnalysisSheetContentType'] = None,
                 description: Optional[str] = None,
                 filter_controls: Optional[Sequence['outputs.AnalysisFilterControl']] = None,
                 layouts: Optional[Sequence['outputs.AnalysisLayout']] = None,
                 name: Optional[str] = None,
                 parameter_controls: Optional[Sequence['outputs.AnalysisParameterControl']] = None,
                 sheet_control_layouts: Optional[Sequence['outputs.AnalysisSheetControlLayout']] = None,
                 text_boxes: Optional[Sequence['outputs.AnalysisSheetTextBox']] = None,
                 title: Optional[str] = None,
                 visuals: Optional[Sequence['outputs.AnalysisVisual']] = None):
        AnalysisSheetDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sheet_id=sheet_id,
            content_type=content_type,
            description=description,
            filter_controls=filter_controls,
            layouts=layouts,
            name=name,
            parameter_controls=parameter_controls,
            sheet_control_layouts=sheet_control_layouts,
            text_boxes=text_boxes,
            title=title,
            visuals=visuals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sheet_id: str,
             content_type: Optional['AnalysisSheetContentType'] = None,
             description: Optional[str] = None,
             filter_controls: Optional[Sequence['outputs.AnalysisFilterControl']] = None,
             layouts: Optional[Sequence['outputs.AnalysisLayout']] = None,
             name: Optional[str] = None,
             parameter_controls: Optional[Sequence['outputs.AnalysisParameterControl']] = None,
             sheet_control_layouts: Optional[Sequence['outputs.AnalysisSheetControlLayout']] = None,
             text_boxes: Optional[Sequence['outputs.AnalysisSheetTextBox']] = None,
             title: Optional[str] = None,
             visuals: Optional[Sequence['outputs.AnalysisVisual']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sheet_id", sheet_id)
        if content_type is not None:
            _setter("content_type", content_type)
        if description is not None:
            _setter("description", description)
        if filter_controls is not None:
            _setter("filter_controls", filter_controls)
        if layouts is not None:
            _setter("layouts", layouts)
        if name is not None:
            _setter("name", name)
        if parameter_controls is not None:
            _setter("parameter_controls", parameter_controls)
        if sheet_control_layouts is not None:
            _setter("sheet_control_layouts", sheet_control_layouts)
        if text_boxes is not None:
            _setter("text_boxes", text_boxes)
        if title is not None:
            _setter("title", title)
        if visuals is not None:
            _setter("visuals", visuals)

    @property
    @pulumi.getter(name="sheetId")
    def sheet_id(self) -> str:
        return pulumi.get(self, "sheet_id")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional['AnalysisSheetContentType']:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="filterControls")
    def filter_controls(self) -> Optional[Sequence['outputs.AnalysisFilterControl']]:
        return pulumi.get(self, "filter_controls")

    @property
    @pulumi.getter
    def layouts(self) -> Optional[Sequence['outputs.AnalysisLayout']]:
        return pulumi.get(self, "layouts")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterControls")
    def parameter_controls(self) -> Optional[Sequence['outputs.AnalysisParameterControl']]:
        return pulumi.get(self, "parameter_controls")

    @property
    @pulumi.getter(name="sheetControlLayouts")
    def sheet_control_layouts(self) -> Optional[Sequence['outputs.AnalysisSheetControlLayout']]:
        return pulumi.get(self, "sheet_control_layouts")

    @property
    @pulumi.getter(name="textBoxes")
    def text_boxes(self) -> Optional[Sequence['outputs.AnalysisSheetTextBox']]:
        return pulumi.get(self, "text_boxes")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def visuals(self) -> Optional[Sequence['outputs.AnalysisVisual']]:
        return pulumi.get(self, "visuals")


@pulumi.output_type
class AnalysisSheetElementConfigurationOverrides(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisSheetElementConfigurationOverrides._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisSheetElementRenderingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationOverrides":
            suggest = "configuration_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSheetElementRenderingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSheetElementRenderingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSheetElementRenderingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_overrides: 'outputs.AnalysisSheetElementConfigurationOverrides',
                 expression: str):
        AnalysisSheetElementRenderingRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration_overrides=configuration_overrides,
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration_overrides: 'outputs.AnalysisSheetElementConfigurationOverrides',
             expression: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("configuration_overrides", configuration_overrides)
        _setter("expression", expression)

    @property
    @pulumi.getter(name="configurationOverrides")
    def configuration_overrides(self) -> 'outputs.AnalysisSheetElementConfigurationOverrides':
        return pulumi.get(self, "configuration_overrides")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")


@pulumi.output_type
class AnalysisSheetTextBox(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetTextBoxId":
            suggest = "sheet_text_box_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSheetTextBox. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSheetTextBox.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSheetTextBox.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sheet_text_box_id: str,
                 content: Optional[str] = None):
        AnalysisSheetTextBox._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sheet_text_box_id=sheet_text_box_id,
            content=content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sheet_text_box_id: str,
             content: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sheet_text_box_id", sheet_text_box_id)
        if content is not None:
            _setter("content", content)

    @property
    @pulumi.getter(name="sheetTextBoxId")
    def sheet_text_box_id(self) -> str:
        return pulumi.get(self, "sheet_text_box_id")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")


@pulumi.output_type
class AnalysisSheetVisualScopingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetId":
            suggest = "sheet_id"
        elif key == "visualIds":
            suggest = "visual_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSheetVisualScopingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSheetVisualScopingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSheetVisualScopingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scope: 'AnalysisFilterVisualScope',
                 sheet_id: str,
                 visual_ids: Optional[Sequence[str]] = None):
        AnalysisSheetVisualScopingConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scope=scope,
            sheet_id=sheet_id,
            visual_ids=visual_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scope: 'AnalysisFilterVisualScope',
             sheet_id: str,
             visual_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("scope", scope)
        _setter("sheet_id", sheet_id)
        if visual_ids is not None:
            _setter("visual_ids", visual_ids)

    @property
    @pulumi.getter
    def scope(self) -> 'AnalysisFilterVisualScope':
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="sheetId")
    def sheet_id(self) -> str:
        return pulumi.get(self, "sheet_id")

    @property
    @pulumi.getter(name="visualIds")
    def visual_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "visual_ids")


@pulumi.output_type
class AnalysisShortFormatText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "plainText":
            suggest = "plain_text"
        elif key == "richText":
            suggest = "rich_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisShortFormatText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisShortFormatText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisShortFormatText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 plain_text: Optional[str] = None,
                 rich_text: Optional[str] = None):
        AnalysisShortFormatText._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            plain_text=plain_text,
            rich_text=rich_text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             plain_text: Optional[str] = None,
             rich_text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if plain_text is not None:
            _setter("plain_text", plain_text)
        if rich_text is not None:
            _setter("rich_text", rich_text)

    @property
    @pulumi.getter(name="plainText")
    def plain_text(self) -> Optional[str]:
        return pulumi.get(self, "plain_text")

    @property
    @pulumi.getter(name="richText")
    def rich_text(self) -> Optional[str]:
        return pulumi.get(self, "rich_text")


@pulumi.output_type
class AnalysisSimpleClusterMarker(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None):
        AnalysisSimpleClusterMarker._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")


@pulumi.output_type
class AnalysisSliderControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSliderControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSliderControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSliderControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
                 title_options: Optional['outputs.AnalysisLabelOptions'] = None):
        AnalysisSliderControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
             title_options: Optional['outputs.AnalysisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.AnalysisSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.AnalysisLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class AnalysisSmallMultiplesAxisProperties(dict):
    def __init__(__self__, *,
                 placement: Optional['AnalysisSmallMultiplesAxisPlacement'] = None,
                 scale: Optional['AnalysisSmallMultiplesAxisScale'] = None):
        AnalysisSmallMultiplesAxisProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            placement=placement,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             placement: Optional['AnalysisSmallMultiplesAxisPlacement'] = None,
             scale: Optional['AnalysisSmallMultiplesAxisScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if placement is not None:
            _setter("placement", placement)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter
    def placement(self) -> Optional['AnalysisSmallMultiplesAxisPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter
    def scale(self) -> Optional['AnalysisSmallMultiplesAxisScale']:
        return pulumi.get(self, "scale")


@pulumi.output_type
class AnalysisSmallMultiplesOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVisibleColumns":
            suggest = "max_visible_columns"
        elif key == "maxVisibleRows":
            suggest = "max_visible_rows"
        elif key == "panelConfiguration":
            suggest = "panel_configuration"
        elif key == "xAxis":
            suggest = "x_axis"
        elif key == "yAxis":
            suggest = "y_axis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSmallMultiplesOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSmallMultiplesOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSmallMultiplesOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_visible_columns: Optional[float] = None,
                 max_visible_rows: Optional[float] = None,
                 panel_configuration: Optional['outputs.AnalysisPanelConfiguration'] = None,
                 x_axis: Optional['outputs.AnalysisSmallMultiplesAxisProperties'] = None,
                 y_axis: Optional['outputs.AnalysisSmallMultiplesAxisProperties'] = None):
        AnalysisSmallMultiplesOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_visible_columns=max_visible_columns,
            max_visible_rows=max_visible_rows,
            panel_configuration=panel_configuration,
            x_axis=x_axis,
            y_axis=y_axis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_visible_columns: Optional[float] = None,
             max_visible_rows: Optional[float] = None,
             panel_configuration: Optional['outputs.AnalysisPanelConfiguration'] = None,
             x_axis: Optional['outputs.AnalysisSmallMultiplesAxisProperties'] = None,
             y_axis: Optional['outputs.AnalysisSmallMultiplesAxisProperties'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_visible_columns is not None:
            _setter("max_visible_columns", max_visible_columns)
        if max_visible_rows is not None:
            _setter("max_visible_rows", max_visible_rows)
        if panel_configuration is not None:
            _setter("panel_configuration", panel_configuration)
        if x_axis is not None:
            _setter("x_axis", x_axis)
        if y_axis is not None:
            _setter("y_axis", y_axis)

    @property
    @pulumi.getter(name="maxVisibleColumns")
    def max_visible_columns(self) -> Optional[float]:
        return pulumi.get(self, "max_visible_columns")

    @property
    @pulumi.getter(name="maxVisibleRows")
    def max_visible_rows(self) -> Optional[float]:
        return pulumi.get(self, "max_visible_rows")

    @property
    @pulumi.getter(name="panelConfiguration")
    def panel_configuration(self) -> Optional['outputs.AnalysisPanelConfiguration']:
        return pulumi.get(self, "panel_configuration")

    @property
    @pulumi.getter(name="xAxis")
    def x_axis(self) -> Optional['outputs.AnalysisSmallMultiplesAxisProperties']:
        return pulumi.get(self, "x_axis")

    @property
    @pulumi.getter(name="yAxis")
    def y_axis(self) -> Optional['outputs.AnalysisSmallMultiplesAxisProperties']:
        return pulumi.get(self, "y_axis")


@pulumi.output_type
class AnalysisSourceEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceTemplate":
            suggest = "source_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSourceEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSourceEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSourceEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_template: Optional['outputs.AnalysisSourceTemplate'] = None):
        AnalysisSourceEntity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_template=source_template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_template: Optional['outputs.AnalysisSourceTemplate'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if source_template is not None:
            _setter("source_template", source_template)

    @property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional['outputs.AnalysisSourceTemplate']:
        return pulumi.get(self, "source_template")


@pulumi.output_type
class AnalysisSourceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetReferences":
            suggest = "data_set_references"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSourceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSourceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSourceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 data_set_references: Sequence['outputs.AnalysisDataSetReference']):
        AnalysisSourceTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            data_set_references=data_set_references,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: str,
             data_set_references: Sequence['outputs.AnalysisDataSetReference'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("arn", arn)
        _setter("data_set_references", data_set_references)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> Sequence['outputs.AnalysisDataSetReference']:
        return pulumi.get(self, "data_set_references")


@pulumi.output_type
class AnalysisSpacing(dict):
    def __init__(__self__, *,
                 bottom: Optional[str] = None,
                 left: Optional[str] = None,
                 right: Optional[str] = None,
                 top: Optional[str] = None):
        """
        :param str bottom: String based length that is composed of value and unit
        :param str left: String based length that is composed of value and unit
        :param str right: String based length that is composed of value and unit
        :param str top: String based length that is composed of value and unit
        """
        AnalysisSpacing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bottom=bottom,
            left=left,
            right=right,
            top=top,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bottom: Optional[str] = None,
             left: Optional[str] = None,
             right: Optional[str] = None,
             top: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bottom is not None:
            _setter("bottom", bottom)
        if left is not None:
            _setter("left", left)
        if right is not None:
            _setter("right", right)
        if top is not None:
            _setter("top", top)

    @property
    @pulumi.getter
    def bottom(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "bottom")

    @property
    @pulumi.getter
    def left(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "left")

    @property
    @pulumi.getter
    def right(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "right")

    @property
    @pulumi.getter
    def top(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "top")


@pulumi.output_type
class AnalysisStringDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisStringDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisStringDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisStringDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.AnalysisDynamicDefaultValue'] = None,
                 static_values: Optional[Sequence[str]] = None):
        AnalysisStringDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.AnalysisDynamicDefaultValue'] = None,
             static_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.AnalysisDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class AnalysisStringFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numericFormatConfiguration":
            suggest = "numeric_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisStringFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisStringFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisStringFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 null_value_format_configuration: Optional['outputs.AnalysisNullValueFormatConfiguration'] = None,
                 numeric_format_configuration: Optional['outputs.AnalysisNumericFormatConfiguration'] = None):
        AnalysisStringFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            null_value_format_configuration=null_value_format_configuration,
            numeric_format_configuration=numeric_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             null_value_format_configuration: Optional['outputs.AnalysisNullValueFormatConfiguration'] = None,
             numeric_format_configuration: Optional['outputs.AnalysisNumericFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if numeric_format_configuration is not None:
            _setter("numeric_format_configuration", numeric_format_configuration)

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.AnalysisNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numericFormatConfiguration")
    def numeric_format_configuration(self) -> Optional['outputs.AnalysisNumericFormatConfiguration']:
        return pulumi.get(self, "numeric_format_configuration")


@pulumi.output_type
class AnalysisStringParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        AnalysisStringParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisStringParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueType":
            suggest = "parameter_value_type"
        elif key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisStringParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisStringParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisStringParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 parameter_value_type: 'AnalysisParameterValueType',
                 default_values: Optional['outputs.AnalysisStringDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.AnalysisMappedDataSetParameter']] = None,
                 value_when_unset: Optional['outputs.AnalysisStringValueWhenUnsetConfiguration'] = None):
        AnalysisStringParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameter_value_type=parameter_value_type,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             parameter_value_type: 'AnalysisParameterValueType',
             default_values: Optional['outputs.AnalysisStringDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.AnalysisMappedDataSetParameter']] = None,
             value_when_unset: Optional['outputs.AnalysisStringValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("parameter_value_type", parameter_value_type)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterValueType")
    def parameter_value_type(self) -> 'AnalysisParameterValueType':
        return pulumi.get(self, "parameter_value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.AnalysisStringDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.AnalysisMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.AnalysisStringValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class AnalysisStringValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisStringValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisStringValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisStringValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[str] = None,
                 value_when_unset_option: Optional['AnalysisValueWhenUnsetOption'] = None):
        AnalysisStringValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[str] = None,
             value_when_unset_option: Optional['AnalysisValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[str]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['AnalysisValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class AnalysisSubtotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "fieldLevel":
            suggest = "field_level"
        elif key == "fieldLevelOptions":
            suggest = "field_level_options"
        elif key == "metricHeaderCellStyle":
            suggest = "metric_header_cell_style"
        elif key == "styleTargets":
            suggest = "style_targets"
        elif key == "totalCellStyle":
            suggest = "total_cell_style"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"
        elif key == "valueCellStyle":
            suggest = "value_cell_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSubtotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSubtotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSubtotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 field_level: Optional['AnalysisPivotTableSubtotalLevel'] = None,
                 field_level_options: Optional[Sequence['outputs.AnalysisPivotTableFieldSubtotalOptions']] = None,
                 metric_header_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
                 style_targets: Optional[Sequence['outputs.AnalysisTableStyleTarget']] = None,
                 total_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
                 totals_visibility: Optional['AnalysisVisibility'] = None,
                 value_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None):
        AnalysisSubtotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            field_level=field_level,
            field_level_options=field_level_options,
            metric_header_cell_style=metric_header_cell_style,
            style_targets=style_targets,
            total_cell_style=total_cell_style,
            totals_visibility=totals_visibility,
            value_cell_style=value_cell_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             field_level: Optional['AnalysisPivotTableSubtotalLevel'] = None,
             field_level_options: Optional[Sequence['outputs.AnalysisPivotTableFieldSubtotalOptions']] = None,
             metric_header_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             style_targets: Optional[Sequence['outputs.AnalysisTableStyleTarget']] = None,
             total_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             totals_visibility: Optional['AnalysisVisibility'] = None,
             value_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if field_level is not None:
            _setter("field_level", field_level)
        if field_level_options is not None:
            _setter("field_level_options", field_level_options)
        if metric_header_cell_style is not None:
            _setter("metric_header_cell_style", metric_header_cell_style)
        if style_targets is not None:
            _setter("style_targets", style_targets)
        if total_cell_style is not None:
            _setter("total_cell_style", total_cell_style)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)
        if value_cell_style is not None:
            _setter("value_cell_style", value_cell_style)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="fieldLevel")
    def field_level(self) -> Optional['AnalysisPivotTableSubtotalLevel']:
        return pulumi.get(self, "field_level")

    @property
    @pulumi.getter(name="fieldLevelOptions")
    def field_level_options(self) -> Optional[Sequence['outputs.AnalysisPivotTableFieldSubtotalOptions']]:
        return pulumi.get(self, "field_level_options")

    @property
    @pulumi.getter(name="metricHeaderCellStyle")
    def metric_header_cell_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "metric_header_cell_style")

    @property
    @pulumi.getter(name="styleTargets")
    def style_targets(self) -> Optional[Sequence['outputs.AnalysisTableStyleTarget']]:
        return pulumi.get(self, "style_targets")

    @property
    @pulumi.getter(name="totalCellStyle")
    def total_cell_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "total_cell_style")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "totals_visibility")

    @property
    @pulumi.getter(name="valueCellStyle")
    def value_cell_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "value_cell_style")


@pulumi.output_type
class AnalysisTableAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_by: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisTableAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_by=group_by,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_by: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_by is not None:
            _setter("group_by", group_by)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisTableBorderOptions(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 style: Optional['AnalysisTableBorderStyle'] = None,
                 thickness: Optional[float] = None):
        AnalysisTableBorderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            style=style,
            thickness=thickness,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             style: Optional['AnalysisTableBorderStyle'] = None,
             thickness: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if style is not None:
            _setter("style", style)
        if thickness is not None:
            _setter("thickness", thickness)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def style(self) -> Optional['AnalysisTableBorderStyle']:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def thickness(self) -> Optional[float]:
        return pulumi.get(self, "thickness")


@pulumi.output_type
class AnalysisTableCellConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "textFormat":
            suggest = "text_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableCellConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableCellConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableCellConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 text_format: Optional['outputs.AnalysisTextConditionalFormat'] = None):
        AnalysisTableCellConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            text_format=text_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             text_format: Optional['outputs.AnalysisTextConditionalFormat'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if text_format is not None:
            _setter("text_format", text_format)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="textFormat")
    def text_format(self) -> Optional['outputs.AnalysisTextConditionalFormat']:
        return pulumi.get(self, "text_format")


@pulumi.output_type
class AnalysisTableCellImageSizingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableCellImageScalingConfiguration":
            suggest = "table_cell_image_scaling_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableCellImageSizingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableCellImageSizingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableCellImageSizingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_cell_image_scaling_configuration: Optional['AnalysisTableCellImageScalingConfiguration'] = None):
        AnalysisTableCellImageSizingConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            table_cell_image_scaling_configuration=table_cell_image_scaling_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             table_cell_image_scaling_configuration: Optional['AnalysisTableCellImageScalingConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if table_cell_image_scaling_configuration is not None:
            _setter("table_cell_image_scaling_configuration", table_cell_image_scaling_configuration)

    @property
    @pulumi.getter(name="tableCellImageScalingConfiguration")
    def table_cell_image_scaling_configuration(self) -> Optional['AnalysisTableCellImageScalingConfiguration']:
        return pulumi.get(self, "table_cell_image_scaling_configuration")


@pulumi.output_type
class AnalysisTableCellStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "fontConfiguration":
            suggest = "font_configuration"
        elif key == "horizontalTextAlignment":
            suggest = "horizontal_text_alignment"
        elif key == "textWrap":
            suggest = "text_wrap"
        elif key == "verticalTextAlignment":
            suggest = "vertical_text_alignment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableCellStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableCellStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableCellStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[str] = None,
                 border: Optional['outputs.AnalysisGlobalTableBorderOptions'] = None,
                 font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
                 height: Optional[float] = None,
                 horizontal_text_alignment: Optional['AnalysisHorizontalTextAlignment'] = None,
                 text_wrap: Optional['AnalysisTextWrap'] = None,
                 vertical_text_alignment: Optional['AnalysisVerticalTextAlignment'] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisTableCellStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            border=border,
            font_configuration=font_configuration,
            height=height,
            horizontal_text_alignment=horizontal_text_alignment,
            text_wrap=text_wrap,
            vertical_text_alignment=vertical_text_alignment,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional[str] = None,
             border: Optional['outputs.AnalysisGlobalTableBorderOptions'] = None,
             font_configuration: Optional['outputs.AnalysisFontConfiguration'] = None,
             height: Optional[float] = None,
             horizontal_text_alignment: Optional['AnalysisHorizontalTextAlignment'] = None,
             text_wrap: Optional['AnalysisTextWrap'] = None,
             vertical_text_alignment: Optional['AnalysisVerticalTextAlignment'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if border is not None:
            _setter("border", border)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if height is not None:
            _setter("height", height)
        if horizontal_text_alignment is not None:
            _setter("horizontal_text_alignment", horizontal_text_alignment)
        if text_wrap is not None:
            _setter("text_wrap", text_wrap)
        if vertical_text_alignment is not None:
            _setter("vertical_text_alignment", vertical_text_alignment)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def border(self) -> Optional['outputs.AnalysisGlobalTableBorderOptions']:
        return pulumi.get(self, "border")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.AnalysisFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter
    def height(self) -> Optional[float]:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="horizontalTextAlignment")
    def horizontal_text_alignment(self) -> Optional['AnalysisHorizontalTextAlignment']:
        return pulumi.get(self, "horizontal_text_alignment")

    @property
    @pulumi.getter(name="textWrap")
    def text_wrap(self) -> Optional['AnalysisTextWrap']:
        return pulumi.get(self, "text_wrap")

    @property
    @pulumi.getter(name="verticalTextAlignment")
    def vertical_text_alignment(self) -> Optional['AnalysisVerticalTextAlignment']:
        return pulumi.get(self, "vertical_text_alignment")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisTableConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.AnalysisTableConditionalFormattingOption']] = None):
        AnalysisTableConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.AnalysisTableConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.AnalysisTableConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class AnalysisTableConditionalFormattingOption(dict):
    def __init__(__self__, *,
                 cell: Optional['outputs.AnalysisTableCellConditionalFormatting'] = None,
                 row: Optional['outputs.AnalysisTableRowConditionalFormatting'] = None):
        AnalysisTableConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell=cell,
            row=row,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell: Optional['outputs.AnalysisTableCellConditionalFormatting'] = None,
             row: Optional['outputs.AnalysisTableRowConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell is not None:
            _setter("cell", cell)
        if row is not None:
            _setter("row", row)

    @property
    @pulumi.getter
    def cell(self) -> Optional['outputs.AnalysisTableCellConditionalFormatting']:
        return pulumi.get(self, "cell")

    @property
    @pulumi.getter
    def row(self) -> Optional['outputs.AnalysisTableRowConditionalFormatting']:
        return pulumi.get(self, "row")


@pulumi.output_type
class AnalysisTableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldOptions":
            suggest = "field_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "paginatedReportOptions":
            suggest = "paginated_report_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "tableInlineVisualizations":
            suggest = "table_inline_visualizations"
        elif key == "tableOptions":
            suggest = "table_options"
        elif key == "totalOptions":
            suggest = "total_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_options: Optional['outputs.AnalysisTableFieldOptions'] = None,
                 field_wells: Optional['outputs.AnalysisTableFieldWells'] = None,
                 paginated_report_options: Optional['outputs.AnalysisTablePaginatedReportOptions'] = None,
                 sort_configuration: Optional['outputs.AnalysisTableSortConfiguration'] = None,
                 table_inline_visualizations: Optional[Sequence['outputs.AnalysisTableInlineVisualization']] = None,
                 table_options: Optional['outputs.AnalysisTableOptions'] = None,
                 total_options: Optional['outputs.AnalysisTotalOptions'] = None):
        AnalysisTableConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_options=field_options,
            field_wells=field_wells,
            paginated_report_options=paginated_report_options,
            sort_configuration=sort_configuration,
            table_inline_visualizations=table_inline_visualizations,
            table_options=table_options,
            total_options=total_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_options: Optional['outputs.AnalysisTableFieldOptions'] = None,
             field_wells: Optional['outputs.AnalysisTableFieldWells'] = None,
             paginated_report_options: Optional['outputs.AnalysisTablePaginatedReportOptions'] = None,
             sort_configuration: Optional['outputs.AnalysisTableSortConfiguration'] = None,
             table_inline_visualizations: Optional[Sequence['outputs.AnalysisTableInlineVisualization']] = None,
             table_options: Optional['outputs.AnalysisTableOptions'] = None,
             total_options: Optional['outputs.AnalysisTotalOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_options is not None:
            _setter("field_options", field_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if paginated_report_options is not None:
            _setter("paginated_report_options", paginated_report_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if table_inline_visualizations is not None:
            _setter("table_inline_visualizations", table_inline_visualizations)
        if table_options is not None:
            _setter("table_options", table_options)
        if total_options is not None:
            _setter("total_options", total_options)

    @property
    @pulumi.getter(name="fieldOptions")
    def field_options(self) -> Optional['outputs.AnalysisTableFieldOptions']:
        return pulumi.get(self, "field_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisTableFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="paginatedReportOptions")
    def paginated_report_options(self) -> Optional['outputs.AnalysisTablePaginatedReportOptions']:
        return pulumi.get(self, "paginated_report_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisTableSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="tableInlineVisualizations")
    def table_inline_visualizations(self) -> Optional[Sequence['outputs.AnalysisTableInlineVisualization']]:
        return pulumi.get(self, "table_inline_visualizations")

    @property
    @pulumi.getter(name="tableOptions")
    def table_options(self) -> Optional['outputs.AnalysisTableOptions']:
        return pulumi.get(self, "table_options")

    @property
    @pulumi.getter(name="totalOptions")
    def total_options(self) -> Optional['outputs.AnalysisTotalOptions']:
        return pulumi.get(self, "total_options")


@pulumi.output_type
class AnalysisTableFieldCustomIconContent(dict):
    def __init__(__self__, *,
                 icon: Optional['AnalysisTableFieldIconSetType'] = None):
        AnalysisTableFieldCustomIconContent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['AnalysisTableFieldIconSetType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)

    @property
    @pulumi.getter
    def icon(self) -> Optional['AnalysisTableFieldIconSetType']:
        return pulumi.get(self, "icon")


@pulumi.output_type
class AnalysisTableFieldCustomTextContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontConfiguration":
            suggest = "font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableFieldCustomTextContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableFieldCustomTextContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableFieldCustomTextContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_configuration: 'outputs.AnalysisFontConfiguration',
                 value: Optional[str] = None):
        AnalysisTableFieldCustomTextContent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_configuration=font_configuration,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_configuration: 'outputs.AnalysisFontConfiguration',
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("font_configuration", font_configuration)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> 'outputs.AnalysisFontConfiguration':
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisTableFieldImageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizingOptions":
            suggest = "sizing_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableFieldImageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableFieldImageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableFieldImageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sizing_options: Optional['outputs.AnalysisTableCellImageSizingConfiguration'] = None):
        AnalysisTableFieldImageConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sizing_options=sizing_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sizing_options: Optional['outputs.AnalysisTableCellImageSizingConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sizing_options is not None:
            _setter("sizing_options", sizing_options)

    @property
    @pulumi.getter(name="sizingOptions")
    def sizing_options(self) -> Optional['outputs.AnalysisTableCellImageSizingConfiguration']:
        return pulumi.get(self, "sizing_options")


@pulumi.output_type
class AnalysisTableFieldLinkConfiguration(dict):
    def __init__(__self__, *,
                 content: 'outputs.AnalysisTableFieldLinkContentConfiguration',
                 target: 'AnalysisUrlTargetConfiguration'):
        AnalysisTableFieldLinkConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: 'outputs.AnalysisTableFieldLinkContentConfiguration',
             target: 'AnalysisUrlTargetConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        _setter("target", target)

    @property
    @pulumi.getter
    def content(self) -> 'outputs.AnalysisTableFieldLinkContentConfiguration':
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def target(self) -> 'AnalysisUrlTargetConfiguration':
        return pulumi.get(self, "target")


@pulumi.output_type
class AnalysisTableFieldLinkContentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customIconContent":
            suggest = "custom_icon_content"
        elif key == "customTextContent":
            suggest = "custom_text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableFieldLinkContentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableFieldLinkContentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableFieldLinkContentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_icon_content: Optional['outputs.AnalysisTableFieldCustomIconContent'] = None,
                 custom_text_content: Optional['outputs.AnalysisTableFieldCustomTextContent'] = None):
        AnalysisTableFieldLinkContentConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_icon_content=custom_icon_content,
            custom_text_content=custom_text_content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_icon_content: Optional['outputs.AnalysisTableFieldCustomIconContent'] = None,
             custom_text_content: Optional['outputs.AnalysisTableFieldCustomTextContent'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_icon_content is not None:
            _setter("custom_icon_content", custom_icon_content)
        if custom_text_content is not None:
            _setter("custom_text_content", custom_text_content)

    @property
    @pulumi.getter(name="customIconContent")
    def custom_icon_content(self) -> Optional['outputs.AnalysisTableFieldCustomIconContent']:
        return pulumi.get(self, "custom_icon_content")

    @property
    @pulumi.getter(name="customTextContent")
    def custom_text_content(self) -> Optional['outputs.AnalysisTableFieldCustomTextContent']:
        return pulumi.get(self, "custom_text_content")


@pulumi.output_type
class AnalysisTableFieldOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "customLabel":
            suggest = "custom_label"
        elif key == "urlStyling":
            suggest = "url_styling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableFieldOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableFieldOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableFieldOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 custom_label: Optional[str] = None,
                 url_styling: Optional['outputs.AnalysisTableFieldUrlConfiguration'] = None,
                 visibility: Optional['AnalysisVisibility'] = None,
                 width: Optional[str] = None):
        """
        :param str width: String based length that is composed of value and unit in px
        """
        AnalysisTableFieldOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            custom_label=custom_label,
            url_styling=url_styling,
            visibility=visibility,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             custom_label: Optional[str] = None,
             url_styling: Optional['outputs.AnalysisTableFieldUrlConfiguration'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if url_styling is not None:
            _setter("url_styling", url_styling)
        if visibility is not None:
            _setter("visibility", visibility)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="urlStyling")
    def url_styling(self) -> Optional['outputs.AnalysisTableFieldUrlConfiguration']:
        return pulumi.get(self, "url_styling")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class AnalysisTableFieldOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pinnedFieldOptions":
            suggest = "pinned_field_options"
        elif key == "selectedFieldOptions":
            suggest = "selected_field_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableFieldOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableFieldOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableFieldOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 order: Optional[Sequence[str]] = None,
                 pinned_field_options: Optional['outputs.AnalysisTablePinnedFieldOptions'] = None,
                 selected_field_options: Optional[Sequence['outputs.AnalysisTableFieldOption']] = None):
        AnalysisTableFieldOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            order=order,
            pinned_field_options=pinned_field_options,
            selected_field_options=selected_field_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             order: Optional[Sequence[str]] = None,
             pinned_field_options: Optional['outputs.AnalysisTablePinnedFieldOptions'] = None,
             selected_field_options: Optional[Sequence['outputs.AnalysisTableFieldOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if order is not None:
            _setter("order", order)
        if pinned_field_options is not None:
            _setter("pinned_field_options", pinned_field_options)
        if selected_field_options is not None:
            _setter("selected_field_options", selected_field_options)

    @property
    @pulumi.getter
    def order(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="pinnedFieldOptions")
    def pinned_field_options(self) -> Optional['outputs.AnalysisTablePinnedFieldOptions']:
        return pulumi.get(self, "pinned_field_options")

    @property
    @pulumi.getter(name="selectedFieldOptions")
    def selected_field_options(self) -> Optional[Sequence['outputs.AnalysisTableFieldOption']]:
        return pulumi.get(self, "selected_field_options")


@pulumi.output_type
class AnalysisTableFieldUrlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageConfiguration":
            suggest = "image_configuration"
        elif key == "linkConfiguration":
            suggest = "link_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableFieldUrlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableFieldUrlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableFieldUrlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_configuration: Optional['outputs.AnalysisTableFieldImageConfiguration'] = None,
                 link_configuration: Optional['outputs.AnalysisTableFieldLinkConfiguration'] = None):
        AnalysisTableFieldUrlConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            image_configuration=image_configuration,
            link_configuration=link_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             image_configuration: Optional['outputs.AnalysisTableFieldImageConfiguration'] = None,
             link_configuration: Optional['outputs.AnalysisTableFieldLinkConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if image_configuration is not None:
            _setter("image_configuration", image_configuration)
        if link_configuration is not None:
            _setter("link_configuration", link_configuration)

    @property
    @pulumi.getter(name="imageConfiguration")
    def image_configuration(self) -> Optional['outputs.AnalysisTableFieldImageConfiguration']:
        return pulumi.get(self, "image_configuration")

    @property
    @pulumi.getter(name="linkConfiguration")
    def link_configuration(self) -> Optional['outputs.AnalysisTableFieldLinkConfiguration']:
        return pulumi.get(self, "link_configuration")


@pulumi.output_type
class AnalysisTableFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableAggregatedFieldWells":
            suggest = "table_aggregated_field_wells"
        elif key == "tableUnaggregatedFieldWells":
            suggest = "table_unaggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_aggregated_field_wells: Optional['outputs.AnalysisTableAggregatedFieldWells'] = None,
                 table_unaggregated_field_wells: Optional['outputs.AnalysisTableUnaggregatedFieldWells'] = None):
        AnalysisTableFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            table_aggregated_field_wells=table_aggregated_field_wells,
            table_unaggregated_field_wells=table_unaggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             table_aggregated_field_wells: Optional['outputs.AnalysisTableAggregatedFieldWells'] = None,
             table_unaggregated_field_wells: Optional['outputs.AnalysisTableUnaggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if table_aggregated_field_wells is not None:
            _setter("table_aggregated_field_wells", table_aggregated_field_wells)
        if table_unaggregated_field_wells is not None:
            _setter("table_unaggregated_field_wells", table_unaggregated_field_wells)

    @property
    @pulumi.getter(name="tableAggregatedFieldWells")
    def table_aggregated_field_wells(self) -> Optional['outputs.AnalysisTableAggregatedFieldWells']:
        return pulumi.get(self, "table_aggregated_field_wells")

    @property
    @pulumi.getter(name="tableUnaggregatedFieldWells")
    def table_unaggregated_field_wells(self) -> Optional['outputs.AnalysisTableUnaggregatedFieldWells']:
        return pulumi.get(self, "table_unaggregated_field_wells")


@pulumi.output_type
class AnalysisTableInlineVisualization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataBars":
            suggest = "data_bars"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableInlineVisualization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableInlineVisualization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableInlineVisualization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_bars: Optional['outputs.AnalysisDataBarsOptions'] = None):
        AnalysisTableInlineVisualization._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_bars=data_bars,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_bars: Optional['outputs.AnalysisDataBarsOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_bars is not None:
            _setter("data_bars", data_bars)

    @property
    @pulumi.getter(name="dataBars")
    def data_bars(self) -> Optional['outputs.AnalysisDataBarsOptions']:
        return pulumi.get(self, "data_bars")


@pulumi.output_type
class AnalysisTableOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellStyle":
            suggest = "cell_style"
        elif key == "headerStyle":
            suggest = "header_style"
        elif key == "rowAlternateColorOptions":
            suggest = "row_alternate_color_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
                 header_style: Optional['outputs.AnalysisTableCellStyle'] = None,
                 orientation: Optional['AnalysisTableOrientation'] = None,
                 row_alternate_color_options: Optional['outputs.AnalysisRowAlternateColorOptions'] = None):
        AnalysisTableOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell_style=cell_style,
            header_style=header_style,
            orientation=orientation,
            row_alternate_color_options=row_alternate_color_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             header_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             orientation: Optional['AnalysisTableOrientation'] = None,
             row_alternate_color_options: Optional['outputs.AnalysisRowAlternateColorOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell_style is not None:
            _setter("cell_style", cell_style)
        if header_style is not None:
            _setter("header_style", header_style)
        if orientation is not None:
            _setter("orientation", orientation)
        if row_alternate_color_options is not None:
            _setter("row_alternate_color_options", row_alternate_color_options)

    @property
    @pulumi.getter(name="cellStyle")
    def cell_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "cell_style")

    @property
    @pulumi.getter(name="headerStyle")
    def header_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "header_style")

    @property
    @pulumi.getter
    def orientation(self) -> Optional['AnalysisTableOrientation']:
        return pulumi.get(self, "orientation")

    @property
    @pulumi.getter(name="rowAlternateColorOptions")
    def row_alternate_color_options(self) -> Optional['outputs.AnalysisRowAlternateColorOptions']:
        return pulumi.get(self, "row_alternate_color_options")


@pulumi.output_type
class AnalysisTablePaginatedReportOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overflowColumnHeaderVisibility":
            suggest = "overflow_column_header_visibility"
        elif key == "verticalOverflowVisibility":
            suggest = "vertical_overflow_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTablePaginatedReportOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTablePaginatedReportOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTablePaginatedReportOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 overflow_column_header_visibility: Optional['AnalysisVisibility'] = None,
                 vertical_overflow_visibility: Optional['AnalysisVisibility'] = None):
        AnalysisTablePaginatedReportOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            overflow_column_header_visibility=overflow_column_header_visibility,
            vertical_overflow_visibility=vertical_overflow_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             overflow_column_header_visibility: Optional['AnalysisVisibility'] = None,
             vertical_overflow_visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if overflow_column_header_visibility is not None:
            _setter("overflow_column_header_visibility", overflow_column_header_visibility)
        if vertical_overflow_visibility is not None:
            _setter("vertical_overflow_visibility", vertical_overflow_visibility)

    @property
    @pulumi.getter(name="overflowColumnHeaderVisibility")
    def overflow_column_header_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "overflow_column_header_visibility")

    @property
    @pulumi.getter(name="verticalOverflowVisibility")
    def vertical_overflow_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "vertical_overflow_visibility")


@pulumi.output_type
class AnalysisTablePinnedFieldOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pinnedLeftFields":
            suggest = "pinned_left_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTablePinnedFieldOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTablePinnedFieldOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTablePinnedFieldOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pinned_left_fields: Optional[Sequence[str]] = None):
        AnalysisTablePinnedFieldOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pinned_left_fields=pinned_left_fields,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pinned_left_fields: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pinned_left_fields is not None:
            _setter("pinned_left_fields", pinned_left_fields)

    @property
    @pulumi.getter(name="pinnedLeftFields")
    def pinned_left_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "pinned_left_fields")


@pulumi.output_type
class AnalysisTableRowConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableRowConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableRowConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableRowConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
                 text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None):
        AnalysisTableRowConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
             text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional['outputs.AnalysisConditionalFormattingColor']:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.AnalysisConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class AnalysisTableSideBorderOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "innerHorizontal":
            suggest = "inner_horizontal"
        elif key == "innerVertical":
            suggest = "inner_vertical"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableSideBorderOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableSideBorderOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableSideBorderOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bottom: Optional['outputs.AnalysisTableBorderOptions'] = None,
                 inner_horizontal: Optional['outputs.AnalysisTableBorderOptions'] = None,
                 inner_vertical: Optional['outputs.AnalysisTableBorderOptions'] = None,
                 left: Optional['outputs.AnalysisTableBorderOptions'] = None,
                 right: Optional['outputs.AnalysisTableBorderOptions'] = None,
                 top: Optional['outputs.AnalysisTableBorderOptions'] = None):
        AnalysisTableSideBorderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bottom=bottom,
            inner_horizontal=inner_horizontal,
            inner_vertical=inner_vertical,
            left=left,
            right=right,
            top=top,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bottom: Optional['outputs.AnalysisTableBorderOptions'] = None,
             inner_horizontal: Optional['outputs.AnalysisTableBorderOptions'] = None,
             inner_vertical: Optional['outputs.AnalysisTableBorderOptions'] = None,
             left: Optional['outputs.AnalysisTableBorderOptions'] = None,
             right: Optional['outputs.AnalysisTableBorderOptions'] = None,
             top: Optional['outputs.AnalysisTableBorderOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bottom is not None:
            _setter("bottom", bottom)
        if inner_horizontal is not None:
            _setter("inner_horizontal", inner_horizontal)
        if inner_vertical is not None:
            _setter("inner_vertical", inner_vertical)
        if left is not None:
            _setter("left", left)
        if right is not None:
            _setter("right", right)
        if top is not None:
            _setter("top", top)

    @property
    @pulumi.getter
    def bottom(self) -> Optional['outputs.AnalysisTableBorderOptions']:
        return pulumi.get(self, "bottom")

    @property
    @pulumi.getter(name="innerHorizontal")
    def inner_horizontal(self) -> Optional['outputs.AnalysisTableBorderOptions']:
        return pulumi.get(self, "inner_horizontal")

    @property
    @pulumi.getter(name="innerVertical")
    def inner_vertical(self) -> Optional['outputs.AnalysisTableBorderOptions']:
        return pulumi.get(self, "inner_vertical")

    @property
    @pulumi.getter
    def left(self) -> Optional['outputs.AnalysisTableBorderOptions']:
        return pulumi.get(self, "left")

    @property
    @pulumi.getter
    def right(self) -> Optional['outputs.AnalysisTableBorderOptions']:
        return pulumi.get(self, "right")

    @property
    @pulumi.getter
    def top(self) -> Optional['outputs.AnalysisTableBorderOptions']:
        return pulumi.get(self, "top")


@pulumi.output_type
class AnalysisTableSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paginationConfiguration":
            suggest = "pagination_configuration"
        elif key == "rowSort":
            suggest = "row_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pagination_configuration: Optional['outputs.AnalysisPaginationConfiguration'] = None,
                 row_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisTableSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pagination_configuration=pagination_configuration,
            row_sort=row_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pagination_configuration: Optional['outputs.AnalysisPaginationConfiguration'] = None,
             row_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pagination_configuration is not None:
            _setter("pagination_configuration", pagination_configuration)
        if row_sort is not None:
            _setter("row_sort", row_sort)

    @property
    @pulumi.getter(name="paginationConfiguration")
    def pagination_configuration(self) -> Optional['outputs.AnalysisPaginationConfiguration']:
        return pulumi.get(self, "pagination_configuration")

    @property
    @pulumi.getter(name="rowSort")
    def row_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "row_sort")


@pulumi.output_type
class AnalysisTableStyleTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellType":
            suggest = "cell_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableStyleTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableStyleTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableStyleTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cell_type: 'AnalysisStyledCellType'):
        AnalysisTableStyleTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell_type=cell_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell_type: 'AnalysisStyledCellType',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cell_type", cell_type)

    @property
    @pulumi.getter(name="cellType")
    def cell_type(self) -> 'AnalysisStyledCellType':
        return pulumi.get(self, "cell_type")


@pulumi.output_type
class AnalysisTableUnaggregatedFieldWells(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.AnalysisUnaggregatedField']] = None):
        AnalysisTableUnaggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Optional[Sequence['outputs.AnalysisUnaggregatedField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisUnaggregatedField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisTableVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTableVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTableVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTableVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisTableConfiguration'] = None,
                 conditional_formatting: Optional['outputs.AnalysisTableConditionalFormatting'] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisTableVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisTableConfiguration'] = None,
             conditional_formatting: Optional['outputs.AnalysisTableConditionalFormatting'] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisTableConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.AnalysisTableConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        AnalysisTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisTextAreaControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "placeholderOptions":
            suggest = "placeholder_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTextAreaControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTextAreaControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTextAreaControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
                 placeholder_options: Optional['outputs.AnalysisTextControlPlaceholderOptions'] = None,
                 title_options: Optional['outputs.AnalysisLabelOptions'] = None):
        AnalysisTextAreaControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            placeholder_options=placeholder_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
             placeholder_options: Optional['outputs.AnalysisTextControlPlaceholderOptions'] = None,
             title_options: Optional['outputs.AnalysisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if placeholder_options is not None:
            _setter("placeholder_options", placeholder_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.AnalysisSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="placeholderOptions")
    def placeholder_options(self) -> Optional['outputs.AnalysisTextControlPlaceholderOptions']:
        return pulumi.get(self, "placeholder_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.AnalysisLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class AnalysisTextConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTextConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTextConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTextConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
                 icon: Optional['outputs.AnalysisConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None):
        AnalysisTextConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
             icon: Optional['outputs.AnalysisConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.AnalysisConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional['outputs.AnalysisConditionalFormattingColor']:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.AnalysisConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.AnalysisConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class AnalysisTextControlPlaceholderOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisTextControlPlaceholderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisTextFieldControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "placeholderOptions":
            suggest = "placeholder_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTextFieldControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTextFieldControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTextFieldControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
                 placeholder_options: Optional['outputs.AnalysisTextControlPlaceholderOptions'] = None,
                 title_options: Optional['outputs.AnalysisLabelOptions'] = None):
        AnalysisTextFieldControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            placeholder_options=placeholder_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.AnalysisSheetControlInfoIconLabelOptions'] = None,
             placeholder_options: Optional['outputs.AnalysisTextControlPlaceholderOptions'] = None,
             title_options: Optional['outputs.AnalysisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if placeholder_options is not None:
            _setter("placeholder_options", placeholder_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.AnalysisSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="placeholderOptions")
    def placeholder_options(self) -> Optional['outputs.AnalysisTextControlPlaceholderOptions']:
        return pulumi.get(self, "placeholder_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.AnalysisLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class AnalysisThousandSeparatorOptions(dict):
    def __init__(__self__, *,
                 symbol: Optional['AnalysisNumericSeparatorSymbol'] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisThousandSeparatorOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            symbol=symbol,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             symbol: Optional['AnalysisNumericSeparatorSymbol'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if symbol is not None:
            _setter("symbol", symbol)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def symbol(self) -> Optional['AnalysisNumericSeparatorSymbol']:
        return pulumi.get(self, "symbol")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisTimeBasedForecastProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lowerBoundary":
            suggest = "lower_boundary"
        elif key == "periodsBackward":
            suggest = "periods_backward"
        elif key == "periodsForward":
            suggest = "periods_forward"
        elif key == "predictionInterval":
            suggest = "prediction_interval"
        elif key == "upperBoundary":
            suggest = "upper_boundary"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTimeBasedForecastProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTimeBasedForecastProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTimeBasedForecastProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lower_boundary: Optional[float] = None,
                 periods_backward: Optional[float] = None,
                 periods_forward: Optional[float] = None,
                 prediction_interval: Optional[float] = None,
                 seasonality: Optional[float] = None,
                 upper_boundary: Optional[float] = None):
        AnalysisTimeBasedForecastProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lower_boundary=lower_boundary,
            periods_backward=periods_backward,
            periods_forward=periods_forward,
            prediction_interval=prediction_interval,
            seasonality=seasonality,
            upper_boundary=upper_boundary,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lower_boundary: Optional[float] = None,
             periods_backward: Optional[float] = None,
             periods_forward: Optional[float] = None,
             prediction_interval: Optional[float] = None,
             seasonality: Optional[float] = None,
             upper_boundary: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if lower_boundary is not None:
            _setter("lower_boundary", lower_boundary)
        if periods_backward is not None:
            _setter("periods_backward", periods_backward)
        if periods_forward is not None:
            _setter("periods_forward", periods_forward)
        if prediction_interval is not None:
            _setter("prediction_interval", prediction_interval)
        if seasonality is not None:
            _setter("seasonality", seasonality)
        if upper_boundary is not None:
            _setter("upper_boundary", upper_boundary)

    @property
    @pulumi.getter(name="lowerBoundary")
    def lower_boundary(self) -> Optional[float]:
        return pulumi.get(self, "lower_boundary")

    @property
    @pulumi.getter(name="periodsBackward")
    def periods_backward(self) -> Optional[float]:
        return pulumi.get(self, "periods_backward")

    @property
    @pulumi.getter(name="periodsForward")
    def periods_forward(self) -> Optional[float]:
        return pulumi.get(self, "periods_forward")

    @property
    @pulumi.getter(name="predictionInterval")
    def prediction_interval(self) -> Optional[float]:
        return pulumi.get(self, "prediction_interval")

    @property
    @pulumi.getter
    def seasonality(self) -> Optional[float]:
        return pulumi.get(self, "seasonality")

    @property
    @pulumi.getter(name="upperBoundary")
    def upper_boundary(self) -> Optional[float]:
        return pulumi.get(self, "upper_boundary")


@pulumi.output_type
class AnalysisTimeEqualityFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTimeEqualityFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTimeEqualityFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTimeEqualityFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 filter_id: str,
                 parameter_name: Optional[str] = None,
                 time_granularity: Optional['AnalysisTimeGranularity'] = None,
                 value: Optional[str] = None):
        AnalysisTimeEqualityFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            parameter_name=parameter_name,
            time_granularity=time_granularity,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             filter_id: str,
             parameter_name: Optional[str] = None,
             time_granularity: Optional['AnalysisTimeGranularity'] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['AnalysisTimeGranularity']:
        return pulumi.get(self, "time_granularity")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisTimeRangeDrillDownFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeMaximum":
            suggest = "range_maximum"
        elif key == "rangeMinimum":
            suggest = "range_minimum"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTimeRangeDrillDownFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTimeRangeDrillDownFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTimeRangeDrillDownFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 range_maximum: str,
                 range_minimum: str,
                 time_granularity: 'AnalysisTimeGranularity'):
        AnalysisTimeRangeDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            range_maximum=range_maximum,
            range_minimum=range_minimum,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             range_maximum: str,
             range_minimum: str,
             time_granularity: 'AnalysisTimeGranularity',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("range_maximum", range_maximum)
        _setter("range_minimum", range_minimum)
        _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="rangeMaximum")
    def range_maximum(self) -> str:
        return pulumi.get(self, "range_maximum")

    @property
    @pulumi.getter(name="rangeMinimum")
    def range_minimum(self) -> str:
        return pulumi.get(self, "range_minimum")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> 'AnalysisTimeGranularity':
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class AnalysisTimeRangeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "excludePeriodConfiguration":
            suggest = "exclude_period_configuration"
        elif key == "includeMaximum":
            suggest = "include_maximum"
        elif key == "includeMinimum":
            suggest = "include_minimum"
        elif key == "rangeMaximumValue":
            suggest = "range_maximum_value"
        elif key == "rangeMinimumValue":
            suggest = "range_minimum_value"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTimeRangeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTimeRangeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTimeRangeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 filter_id: str,
                 null_option: 'AnalysisFilterNullOption',
                 exclude_period_configuration: Optional['outputs.AnalysisExcludePeriodConfiguration'] = None,
                 include_maximum: Optional[bool] = None,
                 include_minimum: Optional[bool] = None,
                 range_maximum_value: Optional['outputs.AnalysisTimeRangeFilterValue'] = None,
                 range_minimum_value: Optional['outputs.AnalysisTimeRangeFilterValue'] = None,
                 time_granularity: Optional['AnalysisTimeGranularity'] = None):
        AnalysisTimeRangeFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            null_option=null_option,
            exclude_period_configuration=exclude_period_configuration,
            include_maximum=include_maximum,
            include_minimum=include_minimum,
            range_maximum_value=range_maximum_value,
            range_minimum_value=range_minimum_value,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             filter_id: str,
             null_option: 'AnalysisFilterNullOption',
             exclude_period_configuration: Optional['outputs.AnalysisExcludePeriodConfiguration'] = None,
             include_maximum: Optional[bool] = None,
             include_minimum: Optional[bool] = None,
             range_maximum_value: Optional['outputs.AnalysisTimeRangeFilterValue'] = None,
             range_minimum_value: Optional['outputs.AnalysisTimeRangeFilterValue'] = None,
             time_granularity: Optional['AnalysisTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("null_option", null_option)
        if exclude_period_configuration is not None:
            _setter("exclude_period_configuration", exclude_period_configuration)
        if include_maximum is not None:
            _setter("include_maximum", include_maximum)
        if include_minimum is not None:
            _setter("include_minimum", include_minimum)
        if range_maximum_value is not None:
            _setter("range_maximum_value", range_maximum_value)
        if range_minimum_value is not None:
            _setter("range_minimum_value", range_minimum_value)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'AnalysisFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="excludePeriodConfiguration")
    def exclude_period_configuration(self) -> Optional['outputs.AnalysisExcludePeriodConfiguration']:
        return pulumi.get(self, "exclude_period_configuration")

    @property
    @pulumi.getter(name="includeMaximum")
    def include_maximum(self) -> Optional[bool]:
        return pulumi.get(self, "include_maximum")

    @property
    @pulumi.getter(name="includeMinimum")
    def include_minimum(self) -> Optional[bool]:
        return pulumi.get(self, "include_minimum")

    @property
    @pulumi.getter(name="rangeMaximumValue")
    def range_maximum_value(self) -> Optional['outputs.AnalysisTimeRangeFilterValue']:
        return pulumi.get(self, "range_maximum_value")

    @property
    @pulumi.getter(name="rangeMinimumValue")
    def range_minimum_value(self) -> Optional['outputs.AnalysisTimeRangeFilterValue']:
        return pulumi.get(self, "range_minimum_value")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['AnalysisTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class AnalysisTimeRangeFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollingDate":
            suggest = "rolling_date"
        elif key == "staticValue":
            suggest = "static_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTimeRangeFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTimeRangeFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTimeRangeFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 rolling_date: Optional['outputs.AnalysisRollingDateConfiguration'] = None,
                 static_value: Optional[str] = None):
        AnalysisTimeRangeFilterValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter=parameter,
            rolling_date=rolling_date,
            static_value=static_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter: Optional[str] = None,
             rolling_date: Optional['outputs.AnalysisRollingDateConfiguration'] = None,
             static_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if parameter is not None:
            _setter("parameter", parameter)
        if rolling_date is not None:
            _setter("rolling_date", rolling_date)
        if static_value is not None:
            _setter("static_value", static_value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter(name="rollingDate")
    def rolling_date(self) -> Optional['outputs.AnalysisRollingDateConfiguration']:
        return pulumi.get(self, "rolling_date")

    @property
    @pulumi.getter(name="staticValue")
    def static_value(self) -> Optional[str]:
        return pulumi.get(self, "static_value")


@pulumi.output_type
class AnalysisTooltipItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnTooltipItem":
            suggest = "column_tooltip_item"
        elif key == "fieldTooltipItem":
            suggest = "field_tooltip_item"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTooltipItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTooltipItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTooltipItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_tooltip_item: Optional['outputs.AnalysisColumnTooltipItem'] = None,
                 field_tooltip_item: Optional['outputs.AnalysisFieldTooltipItem'] = None):
        AnalysisTooltipItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_tooltip_item=column_tooltip_item,
            field_tooltip_item=field_tooltip_item,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_tooltip_item: Optional['outputs.AnalysisColumnTooltipItem'] = None,
             field_tooltip_item: Optional['outputs.AnalysisFieldTooltipItem'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_tooltip_item is not None:
            _setter("column_tooltip_item", column_tooltip_item)
        if field_tooltip_item is not None:
            _setter("field_tooltip_item", field_tooltip_item)

    @property
    @pulumi.getter(name="columnTooltipItem")
    def column_tooltip_item(self) -> Optional['outputs.AnalysisColumnTooltipItem']:
        return pulumi.get(self, "column_tooltip_item")

    @property
    @pulumi.getter(name="fieldTooltipItem")
    def field_tooltip_item(self) -> Optional['outputs.AnalysisFieldTooltipItem']:
        return pulumi.get(self, "field_tooltip_item")


@pulumi.output_type
class AnalysisTooltipOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldBasedTooltip":
            suggest = "field_based_tooltip"
        elif key == "selectedTooltipType":
            suggest = "selected_tooltip_type"
        elif key == "tooltipVisibility":
            suggest = "tooltip_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTooltipOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTooltipOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTooltipOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_based_tooltip: Optional['outputs.AnalysisFieldBasedTooltip'] = None,
                 selected_tooltip_type: Optional['AnalysisSelectedTooltipType'] = None,
                 tooltip_visibility: Optional['AnalysisVisibility'] = None):
        AnalysisTooltipOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_based_tooltip=field_based_tooltip,
            selected_tooltip_type=selected_tooltip_type,
            tooltip_visibility=tooltip_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_based_tooltip: Optional['outputs.AnalysisFieldBasedTooltip'] = None,
             selected_tooltip_type: Optional['AnalysisSelectedTooltipType'] = None,
             tooltip_visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_based_tooltip is not None:
            _setter("field_based_tooltip", field_based_tooltip)
        if selected_tooltip_type is not None:
            _setter("selected_tooltip_type", selected_tooltip_type)
        if tooltip_visibility is not None:
            _setter("tooltip_visibility", tooltip_visibility)

    @property
    @pulumi.getter(name="fieldBasedTooltip")
    def field_based_tooltip(self) -> Optional['outputs.AnalysisFieldBasedTooltip']:
        return pulumi.get(self, "field_based_tooltip")

    @property
    @pulumi.getter(name="selectedTooltipType")
    def selected_tooltip_type(self) -> Optional['AnalysisSelectedTooltipType']:
        return pulumi.get(self, "selected_tooltip_type")

    @property
    @pulumi.getter(name="tooltipVisibility")
    def tooltip_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "tooltip_visibility")


@pulumi.output_type
class AnalysisTopBottomFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationSortConfigurations":
            suggest = "aggregation_sort_configurations"
        elif key == "filterId":
            suggest = "filter_id"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTopBottomFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTopBottomFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTopBottomFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_sort_configurations: Sequence['outputs.AnalysisAggregationSortConfiguration'],
                 column: 'outputs.AnalysisColumnIdentifier',
                 filter_id: str,
                 limit: Optional[float] = None,
                 parameter_name: Optional[str] = None,
                 time_granularity: Optional['AnalysisTimeGranularity'] = None):
        AnalysisTopBottomFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_sort_configurations=aggregation_sort_configurations,
            column=column,
            filter_id=filter_id,
            limit=limit,
            parameter_name=parameter_name,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_sort_configurations: Sequence['outputs.AnalysisAggregationSortConfiguration'],
             column: 'outputs.AnalysisColumnIdentifier',
             filter_id: str,
             limit: Optional[float] = None,
             parameter_name: Optional[str] = None,
             time_granularity: Optional['AnalysisTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation_sort_configurations", aggregation_sort_configurations)
        _setter("column", column)
        _setter("filter_id", filter_id)
        if limit is not None:
            _setter("limit", limit)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter(name="aggregationSortConfigurations")
    def aggregation_sort_configurations(self) -> Sequence['outputs.AnalysisAggregationSortConfiguration']:
        return pulumi.get(self, "aggregation_sort_configurations")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['AnalysisTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class AnalysisTopBottomMoversComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "moverSize":
            suggest = "mover_size"
        elif key == "sortOrder":
            suggest = "sort_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTopBottomMoversComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTopBottomMoversComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTopBottomMoversComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 type: 'AnalysisTopBottomComputationType',
                 category: Optional['outputs.AnalysisDimensionField'] = None,
                 mover_size: Optional[float] = None,
                 name: Optional[str] = None,
                 sort_order: Optional['AnalysisTopBottomSortOrder'] = None,
                 time: Optional['outputs.AnalysisDimensionField'] = None,
                 value: Optional['outputs.AnalysisMeasureField'] = None):
        AnalysisTopBottomMoversComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            type=type,
            category=category,
            mover_size=mover_size,
            name=name,
            sort_order=sort_order,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             type: 'AnalysisTopBottomComputationType',
             category: Optional['outputs.AnalysisDimensionField'] = None,
             mover_size: Optional[float] = None,
             name: Optional[str] = None,
             sort_order: Optional['AnalysisTopBottomSortOrder'] = None,
             time: Optional['outputs.AnalysisDimensionField'] = None,
             value: Optional['outputs.AnalysisMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        _setter("type", type)
        if category is not None:
            _setter("category", category)
        if mover_size is not None:
            _setter("mover_size", mover_size)
        if name is not None:
            _setter("name", name)
        if sort_order is not None:
            _setter("sort_order", sort_order)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def type(self) -> 'AnalysisTopBottomComputationType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional['outputs.AnalysisDimensionField']:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="moverSize")
    def mover_size(self) -> Optional[float]:
        return pulumi.get(self, "mover_size")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> Optional['AnalysisTopBottomSortOrder']:
        return pulumi.get(self, "sort_order")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.AnalysisDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AnalysisMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisTopBottomRankedComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "resultSize":
            suggest = "result_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTopBottomRankedComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTopBottomRankedComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTopBottomRankedComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 type: 'AnalysisTopBottomComputationType',
                 category: Optional['outputs.AnalysisDimensionField'] = None,
                 name: Optional[str] = None,
                 result_size: Optional[float] = None,
                 value: Optional['outputs.AnalysisMeasureField'] = None):
        AnalysisTopBottomRankedComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            type=type,
            category=category,
            name=name,
            result_size=result_size,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             type: 'AnalysisTopBottomComputationType',
             category: Optional['outputs.AnalysisDimensionField'] = None,
             name: Optional[str] = None,
             result_size: Optional[float] = None,
             value: Optional['outputs.AnalysisMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        _setter("type", type)
        if category is not None:
            _setter("category", category)
        if name is not None:
            _setter("name", name)
        if result_size is not None:
            _setter("result_size", result_size)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def type(self) -> 'AnalysisTopBottomComputationType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional['outputs.AnalysisDimensionField']:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resultSize")
    def result_size(self) -> Optional[float]:
        return pulumi.get(self, "result_size")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AnalysisMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisTotalAggregationComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTotalAggregationComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTotalAggregationComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTotalAggregationComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 value: Optional['outputs.AnalysisMeasureField'] = None):
        AnalysisTotalAggregationComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             value: Optional['outputs.AnalysisMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AnalysisMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisTotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "scrollStatus":
            suggest = "scroll_status"
        elif key == "totalCellStyle":
            suggest = "total_cell_style"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 placement: Optional['AnalysisTableTotalsPlacement'] = None,
                 scroll_status: Optional['AnalysisTableTotalsScrollStatus'] = None,
                 total_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
                 totals_visibility: Optional['AnalysisVisibility'] = None):
        AnalysisTotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            placement=placement,
            scroll_status=scroll_status,
            total_cell_style=total_cell_style,
            totals_visibility=totals_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             placement: Optional['AnalysisTableTotalsPlacement'] = None,
             scroll_status: Optional['AnalysisTableTotalsScrollStatus'] = None,
             total_cell_style: Optional['outputs.AnalysisTableCellStyle'] = None,
             totals_visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if placement is not None:
            _setter("placement", placement)
        if scroll_status is not None:
            _setter("scroll_status", scroll_status)
        if total_cell_style is not None:
            _setter("total_cell_style", total_cell_style)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter
    def placement(self) -> Optional['AnalysisTableTotalsPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="scrollStatus")
    def scroll_status(self) -> Optional['AnalysisTableTotalsScrollStatus']:
        return pulumi.get(self, "scroll_status")

    @property
    @pulumi.getter(name="totalCellStyle")
    def total_cell_style(self) -> Optional['outputs.AnalysisTableCellStyle']:
        return pulumi.get(self, "total_cell_style")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "totals_visibility")


@pulumi.output_type
class AnalysisTreeMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 colors: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
                 groups: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 sizes: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisTreeMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
            groups=groups,
            sizes=sizes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             groups: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             sizes: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if colors is not None:
            _setter("colors", colors)
        if groups is not None:
            _setter("groups", groups)
        if sizes is not None:
            _setter("sizes", sizes)

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def sizes(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "sizes")


@pulumi.output_type
class AnalysisTreeMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "colorScale":
            suggest = "color_scale"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "groupLabelOptions":
            suggest = "group_label_options"
        elif key == "sizeLabelOptions":
            suggest = "size_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTreeMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTreeMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTreeMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 color_scale: Optional['outputs.AnalysisColorScale'] = None,
                 data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisTreeMapFieldWells'] = None,
                 group_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 size_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.AnalysisTreeMapSortConfiguration'] = None,
                 tooltip: Optional['outputs.AnalysisTooltipOptions'] = None):
        AnalysisTreeMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_label_options=color_label_options,
            color_scale=color_scale,
            data_labels=data_labels,
            field_wells=field_wells,
            group_label_options=group_label_options,
            legend=legend,
            size_label_options=size_label_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             color_scale: Optional['outputs.AnalysisColorScale'] = None,
             data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisTreeMapFieldWells'] = None,
             group_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             size_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.AnalysisTreeMapSortConfiguration'] = None,
             tooltip: Optional['outputs.AnalysisTooltipOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if color_scale is not None:
            _setter("color_scale", color_scale)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if group_label_options is not None:
            _setter("group_label_options", group_label_options)
        if legend is not None:
            _setter("legend", legend)
        if size_label_options is not None:
            _setter("size_label_options", size_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="colorScale")
    def color_scale(self) -> Optional['outputs.AnalysisColorScale']:
        return pulumi.get(self, "color_scale")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisTreeMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="groupLabelOptions")
    def group_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "group_label_options")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="sizeLabelOptions")
    def size_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "size_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisTreeMapSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.AnalysisTooltipOptions']:
        return pulumi.get(self, "tooltip")


@pulumi.output_type
class AnalysisTreeMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "treeMapAggregatedFieldWells":
            suggest = "tree_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTreeMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTreeMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTreeMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tree_map_aggregated_field_wells: Optional['outputs.AnalysisTreeMapAggregatedFieldWells'] = None):
        AnalysisTreeMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tree_map_aggregated_field_wells=tree_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tree_map_aggregated_field_wells: Optional['outputs.AnalysisTreeMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if tree_map_aggregated_field_wells is not None:
            _setter("tree_map_aggregated_field_wells", tree_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="treeMapAggregatedFieldWells")
    def tree_map_aggregated_field_wells(self) -> Optional['outputs.AnalysisTreeMapAggregatedFieldWells']:
        return pulumi.get(self, "tree_map_aggregated_field_wells")


@pulumi.output_type
class AnalysisTreeMapSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "treeMapGroupItemsLimitConfiguration":
            suggest = "tree_map_group_items_limit_configuration"
        elif key == "treeMapSort":
            suggest = "tree_map_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTreeMapSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTreeMapSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTreeMapSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tree_map_group_items_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 tree_map_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisTreeMapSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tree_map_group_items_limit_configuration=tree_map_group_items_limit_configuration,
            tree_map_sort=tree_map_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tree_map_group_items_limit_configuration: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             tree_map_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if tree_map_group_items_limit_configuration is not None:
            _setter("tree_map_group_items_limit_configuration", tree_map_group_items_limit_configuration)
        if tree_map_sort is not None:
            _setter("tree_map_sort", tree_map_sort)

    @property
    @pulumi.getter(name="treeMapGroupItemsLimitConfiguration")
    def tree_map_group_items_limit_configuration(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "tree_map_group_items_limit_configuration")

    @property
    @pulumi.getter(name="treeMapSort")
    def tree_map_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "tree_map_sort")


@pulumi.output_type
class AnalysisTreeMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTreeMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTreeMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTreeMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisTreeMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisTreeMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisTreeMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisTreeMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisTrendArrowOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisTrendArrowOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisUnaggregatedField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisUnaggregatedField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisUnaggregatedField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisUnaggregatedField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.AnalysisColumnIdentifier',
                 field_id: str,
                 format_configuration: Optional['outputs.AnalysisFormatConfiguration'] = None):
        AnalysisUnaggregatedField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.AnalysisColumnIdentifier',
             field_id: str,
             format_configuration: Optional['outputs.AnalysisFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.AnalysisColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.AnalysisFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class AnalysisUniqueValuesComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisUniqueValuesComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisUniqueValuesComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisUniqueValuesComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 category: Optional['outputs.AnalysisDimensionField'] = None,
                 name: Optional[str] = None):
        AnalysisUniqueValuesComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            category=category,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             category: Optional['outputs.AnalysisDimensionField'] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if category is not None:
            _setter("category", category)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def category(self) -> Optional['outputs.AnalysisDimensionField']:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class AnalysisVisibleRangeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "percentRange":
            suggest = "percent_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisVisibleRangeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisVisibleRangeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisVisibleRangeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percent_range: Optional['outputs.AnalysisPercentVisibleRange'] = None):
        AnalysisVisibleRangeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            percent_range=percent_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             percent_range: Optional['outputs.AnalysisPercentVisibleRange'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if percent_range is not None:
            _setter("percent_range", percent_range)

    @property
    @pulumi.getter(name="percentRange")
    def percent_range(self) -> Optional['outputs.AnalysisPercentVisibleRange']:
        return pulumi.get(self, "percent_range")


@pulumi.output_type
class AnalysisVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barChartVisual":
            suggest = "bar_chart_visual"
        elif key == "boxPlotVisual":
            suggest = "box_plot_visual"
        elif key == "comboChartVisual":
            suggest = "combo_chart_visual"
        elif key == "customContentVisual":
            suggest = "custom_content_visual"
        elif key == "emptyVisual":
            suggest = "empty_visual"
        elif key == "filledMapVisual":
            suggest = "filled_map_visual"
        elif key == "funnelChartVisual":
            suggest = "funnel_chart_visual"
        elif key == "gaugeChartVisual":
            suggest = "gauge_chart_visual"
        elif key == "geospatialMapVisual":
            suggest = "geospatial_map_visual"
        elif key == "heatMapVisual":
            suggest = "heat_map_visual"
        elif key == "histogramVisual":
            suggest = "histogram_visual"
        elif key == "insightVisual":
            suggest = "insight_visual"
        elif key == "kpiVisual":
            suggest = "kpi_visual"
        elif key == "lineChartVisual":
            suggest = "line_chart_visual"
        elif key == "pieChartVisual":
            suggest = "pie_chart_visual"
        elif key == "pivotTableVisual":
            suggest = "pivot_table_visual"
        elif key == "radarChartVisual":
            suggest = "radar_chart_visual"
        elif key == "sankeyDiagramVisual":
            suggest = "sankey_diagram_visual"
        elif key == "scatterPlotVisual":
            suggest = "scatter_plot_visual"
        elif key == "tableVisual":
            suggest = "table_visual"
        elif key == "treeMapVisual":
            suggest = "tree_map_visual"
        elif key == "waterfallVisual":
            suggest = "waterfall_visual"
        elif key == "wordCloudVisual":
            suggest = "word_cloud_visual"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_chart_visual: Optional['outputs.AnalysisBarChartVisual'] = None,
                 box_plot_visual: Optional['outputs.AnalysisBoxPlotVisual'] = None,
                 combo_chart_visual: Optional['outputs.AnalysisComboChartVisual'] = None,
                 custom_content_visual: Optional['outputs.AnalysisCustomContentVisual'] = None,
                 empty_visual: Optional['outputs.AnalysisEmptyVisual'] = None,
                 filled_map_visual: Optional['outputs.AnalysisFilledMapVisual'] = None,
                 funnel_chart_visual: Optional['outputs.AnalysisFunnelChartVisual'] = None,
                 gauge_chart_visual: Optional['outputs.AnalysisGaugeChartVisual'] = None,
                 geospatial_map_visual: Optional['outputs.AnalysisGeospatialMapVisual'] = None,
                 heat_map_visual: Optional['outputs.AnalysisHeatMapVisual'] = None,
                 histogram_visual: Optional['outputs.AnalysisHistogramVisual'] = None,
                 insight_visual: Optional['outputs.AnalysisInsightVisual'] = None,
                 kpi_visual: Optional['outputs.AnalysisKpiVisual'] = None,
                 line_chart_visual: Optional['outputs.AnalysisLineChartVisual'] = None,
                 pie_chart_visual: Optional['outputs.AnalysisPieChartVisual'] = None,
                 pivot_table_visual: Optional['outputs.AnalysisPivotTableVisual'] = None,
                 radar_chart_visual: Optional['outputs.AnalysisRadarChartVisual'] = None,
                 sankey_diagram_visual: Optional['outputs.AnalysisSankeyDiagramVisual'] = None,
                 scatter_plot_visual: Optional['outputs.AnalysisScatterPlotVisual'] = None,
                 table_visual: Optional['outputs.AnalysisTableVisual'] = None,
                 tree_map_visual: Optional['outputs.AnalysisTreeMapVisual'] = None,
                 waterfall_visual: Optional['outputs.AnalysisWaterfallVisual'] = None,
                 word_cloud_visual: Optional['outputs.AnalysisWordCloudVisual'] = None):
        AnalysisVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_chart_visual=bar_chart_visual,
            box_plot_visual=box_plot_visual,
            combo_chart_visual=combo_chart_visual,
            custom_content_visual=custom_content_visual,
            empty_visual=empty_visual,
            filled_map_visual=filled_map_visual,
            funnel_chart_visual=funnel_chart_visual,
            gauge_chart_visual=gauge_chart_visual,
            geospatial_map_visual=geospatial_map_visual,
            heat_map_visual=heat_map_visual,
            histogram_visual=histogram_visual,
            insight_visual=insight_visual,
            kpi_visual=kpi_visual,
            line_chart_visual=line_chart_visual,
            pie_chart_visual=pie_chart_visual,
            pivot_table_visual=pivot_table_visual,
            radar_chart_visual=radar_chart_visual,
            sankey_diagram_visual=sankey_diagram_visual,
            scatter_plot_visual=scatter_plot_visual,
            table_visual=table_visual,
            tree_map_visual=tree_map_visual,
            waterfall_visual=waterfall_visual,
            word_cloud_visual=word_cloud_visual,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_chart_visual: Optional['outputs.AnalysisBarChartVisual'] = None,
             box_plot_visual: Optional['outputs.AnalysisBoxPlotVisual'] = None,
             combo_chart_visual: Optional['outputs.AnalysisComboChartVisual'] = None,
             custom_content_visual: Optional['outputs.AnalysisCustomContentVisual'] = None,
             empty_visual: Optional['outputs.AnalysisEmptyVisual'] = None,
             filled_map_visual: Optional['outputs.AnalysisFilledMapVisual'] = None,
             funnel_chart_visual: Optional['outputs.AnalysisFunnelChartVisual'] = None,
             gauge_chart_visual: Optional['outputs.AnalysisGaugeChartVisual'] = None,
             geospatial_map_visual: Optional['outputs.AnalysisGeospatialMapVisual'] = None,
             heat_map_visual: Optional['outputs.AnalysisHeatMapVisual'] = None,
             histogram_visual: Optional['outputs.AnalysisHistogramVisual'] = None,
             insight_visual: Optional['outputs.AnalysisInsightVisual'] = None,
             kpi_visual: Optional['outputs.AnalysisKpiVisual'] = None,
             line_chart_visual: Optional['outputs.AnalysisLineChartVisual'] = None,
             pie_chart_visual: Optional['outputs.AnalysisPieChartVisual'] = None,
             pivot_table_visual: Optional['outputs.AnalysisPivotTableVisual'] = None,
             radar_chart_visual: Optional['outputs.AnalysisRadarChartVisual'] = None,
             sankey_diagram_visual: Optional['outputs.AnalysisSankeyDiagramVisual'] = None,
             scatter_plot_visual: Optional['outputs.AnalysisScatterPlotVisual'] = None,
             table_visual: Optional['outputs.AnalysisTableVisual'] = None,
             tree_map_visual: Optional['outputs.AnalysisTreeMapVisual'] = None,
             waterfall_visual: Optional['outputs.AnalysisWaterfallVisual'] = None,
             word_cloud_visual: Optional['outputs.AnalysisWordCloudVisual'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_chart_visual is not None:
            _setter("bar_chart_visual", bar_chart_visual)
        if box_plot_visual is not None:
            _setter("box_plot_visual", box_plot_visual)
        if combo_chart_visual is not None:
            _setter("combo_chart_visual", combo_chart_visual)
        if custom_content_visual is not None:
            _setter("custom_content_visual", custom_content_visual)
        if empty_visual is not None:
            _setter("empty_visual", empty_visual)
        if filled_map_visual is not None:
            _setter("filled_map_visual", filled_map_visual)
        if funnel_chart_visual is not None:
            _setter("funnel_chart_visual", funnel_chart_visual)
        if gauge_chart_visual is not None:
            _setter("gauge_chart_visual", gauge_chart_visual)
        if geospatial_map_visual is not None:
            _setter("geospatial_map_visual", geospatial_map_visual)
        if heat_map_visual is not None:
            _setter("heat_map_visual", heat_map_visual)
        if histogram_visual is not None:
            _setter("histogram_visual", histogram_visual)
        if insight_visual is not None:
            _setter("insight_visual", insight_visual)
        if kpi_visual is not None:
            _setter("kpi_visual", kpi_visual)
        if line_chart_visual is not None:
            _setter("line_chart_visual", line_chart_visual)
        if pie_chart_visual is not None:
            _setter("pie_chart_visual", pie_chart_visual)
        if pivot_table_visual is not None:
            _setter("pivot_table_visual", pivot_table_visual)
        if radar_chart_visual is not None:
            _setter("radar_chart_visual", radar_chart_visual)
        if sankey_diagram_visual is not None:
            _setter("sankey_diagram_visual", sankey_diagram_visual)
        if scatter_plot_visual is not None:
            _setter("scatter_plot_visual", scatter_plot_visual)
        if table_visual is not None:
            _setter("table_visual", table_visual)
        if tree_map_visual is not None:
            _setter("tree_map_visual", tree_map_visual)
        if waterfall_visual is not None:
            _setter("waterfall_visual", waterfall_visual)
        if word_cloud_visual is not None:
            _setter("word_cloud_visual", word_cloud_visual)

    @property
    @pulumi.getter(name="barChartVisual")
    def bar_chart_visual(self) -> Optional['outputs.AnalysisBarChartVisual']:
        return pulumi.get(self, "bar_chart_visual")

    @property
    @pulumi.getter(name="boxPlotVisual")
    def box_plot_visual(self) -> Optional['outputs.AnalysisBoxPlotVisual']:
        return pulumi.get(self, "box_plot_visual")

    @property
    @pulumi.getter(name="comboChartVisual")
    def combo_chart_visual(self) -> Optional['outputs.AnalysisComboChartVisual']:
        return pulumi.get(self, "combo_chart_visual")

    @property
    @pulumi.getter(name="customContentVisual")
    def custom_content_visual(self) -> Optional['outputs.AnalysisCustomContentVisual']:
        return pulumi.get(self, "custom_content_visual")

    @property
    @pulumi.getter(name="emptyVisual")
    def empty_visual(self) -> Optional['outputs.AnalysisEmptyVisual']:
        return pulumi.get(self, "empty_visual")

    @property
    @pulumi.getter(name="filledMapVisual")
    def filled_map_visual(self) -> Optional['outputs.AnalysisFilledMapVisual']:
        return pulumi.get(self, "filled_map_visual")

    @property
    @pulumi.getter(name="funnelChartVisual")
    def funnel_chart_visual(self) -> Optional['outputs.AnalysisFunnelChartVisual']:
        return pulumi.get(self, "funnel_chart_visual")

    @property
    @pulumi.getter(name="gaugeChartVisual")
    def gauge_chart_visual(self) -> Optional['outputs.AnalysisGaugeChartVisual']:
        return pulumi.get(self, "gauge_chart_visual")

    @property
    @pulumi.getter(name="geospatialMapVisual")
    def geospatial_map_visual(self) -> Optional['outputs.AnalysisGeospatialMapVisual']:
        return pulumi.get(self, "geospatial_map_visual")

    @property
    @pulumi.getter(name="heatMapVisual")
    def heat_map_visual(self) -> Optional['outputs.AnalysisHeatMapVisual']:
        return pulumi.get(self, "heat_map_visual")

    @property
    @pulumi.getter(name="histogramVisual")
    def histogram_visual(self) -> Optional['outputs.AnalysisHistogramVisual']:
        return pulumi.get(self, "histogram_visual")

    @property
    @pulumi.getter(name="insightVisual")
    def insight_visual(self) -> Optional['outputs.AnalysisInsightVisual']:
        return pulumi.get(self, "insight_visual")

    @property
    @pulumi.getter(name="kpiVisual")
    def kpi_visual(self) -> Optional['outputs.AnalysisKpiVisual']:
        return pulumi.get(self, "kpi_visual")

    @property
    @pulumi.getter(name="lineChartVisual")
    def line_chart_visual(self) -> Optional['outputs.AnalysisLineChartVisual']:
        return pulumi.get(self, "line_chart_visual")

    @property
    @pulumi.getter(name="pieChartVisual")
    def pie_chart_visual(self) -> Optional['outputs.AnalysisPieChartVisual']:
        return pulumi.get(self, "pie_chart_visual")

    @property
    @pulumi.getter(name="pivotTableVisual")
    def pivot_table_visual(self) -> Optional['outputs.AnalysisPivotTableVisual']:
        return pulumi.get(self, "pivot_table_visual")

    @property
    @pulumi.getter(name="radarChartVisual")
    def radar_chart_visual(self) -> Optional['outputs.AnalysisRadarChartVisual']:
        return pulumi.get(self, "radar_chart_visual")

    @property
    @pulumi.getter(name="sankeyDiagramVisual")
    def sankey_diagram_visual(self) -> Optional['outputs.AnalysisSankeyDiagramVisual']:
        return pulumi.get(self, "sankey_diagram_visual")

    @property
    @pulumi.getter(name="scatterPlotVisual")
    def scatter_plot_visual(self) -> Optional['outputs.AnalysisScatterPlotVisual']:
        return pulumi.get(self, "scatter_plot_visual")

    @property
    @pulumi.getter(name="tableVisual")
    def table_visual(self) -> Optional['outputs.AnalysisTableVisual']:
        return pulumi.get(self, "table_visual")

    @property
    @pulumi.getter(name="treeMapVisual")
    def tree_map_visual(self) -> Optional['outputs.AnalysisTreeMapVisual']:
        return pulumi.get(self, "tree_map_visual")

    @property
    @pulumi.getter(name="waterfallVisual")
    def waterfall_visual(self) -> Optional['outputs.AnalysisWaterfallVisual']:
        return pulumi.get(self, "waterfall_visual")

    @property
    @pulumi.getter(name="wordCloudVisual")
    def word_cloud_visual(self) -> Optional['outputs.AnalysisWordCloudVisual']:
        return pulumi.get(self, "word_cloud_visual")


@pulumi.output_type
class AnalysisVisualCustomAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionOperations":
            suggest = "action_operations"
        elif key == "customActionId":
            suggest = "custom_action_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisVisualCustomAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisVisualCustomAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisVisualCustomAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_operations: Sequence['outputs.AnalysisVisualCustomActionOperation'],
                 custom_action_id: str,
                 name: str,
                 trigger: 'AnalysisVisualCustomActionTrigger',
                 status: Optional['AnalysisWidgetStatus'] = None):
        AnalysisVisualCustomAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_operations=action_operations,
            custom_action_id=custom_action_id,
            name=name,
            trigger=trigger,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_operations: Sequence['outputs.AnalysisVisualCustomActionOperation'],
             custom_action_id: str,
             name: str,
             trigger: 'AnalysisVisualCustomActionTrigger',
             status: Optional['AnalysisWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action_operations", action_operations)
        _setter("custom_action_id", custom_action_id)
        _setter("name", name)
        _setter("trigger", trigger)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="actionOperations")
    def action_operations(self) -> Sequence['outputs.AnalysisVisualCustomActionOperation']:
        return pulumi.get(self, "action_operations")

    @property
    @pulumi.getter(name="customActionId")
    def custom_action_id(self) -> str:
        return pulumi.get(self, "custom_action_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def trigger(self) -> 'AnalysisVisualCustomActionTrigger':
        return pulumi.get(self, "trigger")

    @property
    @pulumi.getter
    def status(self) -> Optional['AnalysisWidgetStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class AnalysisVisualCustomActionOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterOperation":
            suggest = "filter_operation"
        elif key == "navigationOperation":
            suggest = "navigation_operation"
        elif key == "setParametersOperation":
            suggest = "set_parameters_operation"
        elif key == "urlOperation":
            suggest = "url_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisVisualCustomActionOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisVisualCustomActionOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisVisualCustomActionOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_operation: Optional['outputs.AnalysisCustomActionFilterOperation'] = None,
                 navigation_operation: Optional['outputs.AnalysisCustomActionNavigationOperation'] = None,
                 set_parameters_operation: Optional['outputs.AnalysisCustomActionSetParametersOperation'] = None,
                 url_operation: Optional['outputs.AnalysisCustomActionUrlOperation'] = None):
        AnalysisVisualCustomActionOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_operation=filter_operation,
            navigation_operation=navigation_operation,
            set_parameters_operation=set_parameters_operation,
            url_operation=url_operation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_operation: Optional['outputs.AnalysisCustomActionFilterOperation'] = None,
             navigation_operation: Optional['outputs.AnalysisCustomActionNavigationOperation'] = None,
             set_parameters_operation: Optional['outputs.AnalysisCustomActionSetParametersOperation'] = None,
             url_operation: Optional['outputs.AnalysisCustomActionUrlOperation'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if filter_operation is not None:
            _setter("filter_operation", filter_operation)
        if navigation_operation is not None:
            _setter("navigation_operation", navigation_operation)
        if set_parameters_operation is not None:
            _setter("set_parameters_operation", set_parameters_operation)
        if url_operation is not None:
            _setter("url_operation", url_operation)

    @property
    @pulumi.getter(name="filterOperation")
    def filter_operation(self) -> Optional['outputs.AnalysisCustomActionFilterOperation']:
        return pulumi.get(self, "filter_operation")

    @property
    @pulumi.getter(name="navigationOperation")
    def navigation_operation(self) -> Optional['outputs.AnalysisCustomActionNavigationOperation']:
        return pulumi.get(self, "navigation_operation")

    @property
    @pulumi.getter(name="setParametersOperation")
    def set_parameters_operation(self) -> Optional['outputs.AnalysisCustomActionSetParametersOperation']:
        return pulumi.get(self, "set_parameters_operation")

    @property
    @pulumi.getter(name="urlOperation")
    def url_operation(self) -> Optional['outputs.AnalysisCustomActionUrlOperation']:
        return pulumi.get(self, "url_operation")


@pulumi.output_type
class AnalysisVisualPalette(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chartColor":
            suggest = "chart_color"
        elif key == "colorMap":
            suggest = "color_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisVisualPalette. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisVisualPalette.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisVisualPalette.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chart_color: Optional[str] = None,
                 color_map: Optional[Sequence['outputs.AnalysisDataPathColor']] = None):
        AnalysisVisualPalette._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            chart_color=chart_color,
            color_map=color_map,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             chart_color: Optional[str] = None,
             color_map: Optional[Sequence['outputs.AnalysisDataPathColor']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if chart_color is not None:
            _setter("chart_color", chart_color)
        if color_map is not None:
            _setter("color_map", color_map)

    @property
    @pulumi.getter(name="chartColor")
    def chart_color(self) -> Optional[str]:
        return pulumi.get(self, "chart_color")

    @property
    @pulumi.getter(name="colorMap")
    def color_map(self) -> Optional[Sequence['outputs.AnalysisDataPathColor']]:
        return pulumi.get(self, "color_map")


@pulumi.output_type
class AnalysisVisualSubtitleLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatText":
            suggest = "format_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisVisualSubtitleLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisVisualSubtitleLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisVisualSubtitleLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_text: Optional['outputs.AnalysisLongFormatText'] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisVisualSubtitleLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_text=format_text,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_text: Optional['outputs.AnalysisLongFormatText'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_text is not None:
            _setter("format_text", format_text)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="formatText")
    def format_text(self) -> Optional['outputs.AnalysisLongFormatText']:
        return pulumi.get(self, "format_text")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisVisualTitleLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatText":
            suggest = "format_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisVisualTitleLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisVisualTitleLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisVisualTitleLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_text: Optional['outputs.AnalysisShortFormatText'] = None,
                 visibility: Optional['AnalysisVisibility'] = None):
        AnalysisVisualTitleLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_text=format_text,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_text: Optional['outputs.AnalysisShortFormatText'] = None,
             visibility: Optional['AnalysisVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_text is not None:
            _setter("format_text", format_text)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="formatText")
    def format_text(self) -> Optional['outputs.AnalysisShortFormatText']:
        return pulumi.get(self, "format_text")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['AnalysisVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class AnalysisWaterfallChartAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 breakdowns: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 categories: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 values: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisWaterfallChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            breakdowns=breakdowns,
            categories=categories,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             breakdowns: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             categories: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             values: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if breakdowns is not None:
            _setter("breakdowns", breakdowns)
        if categories is not None:
            _setter("categories", categories)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def breakdowns(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "breakdowns")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisWaterfallChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryAxisDisplayOptions":
            suggest = "category_axis_display_options"
        elif key == "categoryAxisLabelOptions":
            suggest = "category_axis_label_options"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "waterfallChartOptions":
            suggest = "waterfall_chart_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWaterfallChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWaterfallChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWaterfallChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 category_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisWaterfallChartFieldWells'] = None,
                 legend: Optional['outputs.AnalysisLegendOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.AnalysisWaterfallChartSortConfiguration'] = None,
                 visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
                 waterfall_chart_options: Optional['outputs.AnalysisWaterfallChartOptions'] = None):
        AnalysisWaterfallChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_axis_display_options=category_axis_display_options,
            category_axis_label_options=category_axis_label_options,
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            sort_configuration=sort_configuration,
            visual_palette=visual_palette,
            waterfall_chart_options=waterfall_chart_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             category_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             data_labels: Optional['outputs.AnalysisDataLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisWaterfallChartFieldWells'] = None,
             legend: Optional['outputs.AnalysisLegendOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.AnalysisAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.AnalysisWaterfallChartSortConfiguration'] = None,
             visual_palette: Optional['outputs.AnalysisVisualPalette'] = None,
             waterfall_chart_options: Optional['outputs.AnalysisWaterfallChartOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_axis_display_options is not None:
            _setter("category_axis_display_options", category_axis_display_options)
        if category_axis_label_options is not None:
            _setter("category_axis_label_options", category_axis_label_options)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if waterfall_chart_options is not None:
            _setter("waterfall_chart_options", waterfall_chart_options)

    @property
    @pulumi.getter(name="categoryAxisDisplayOptions")
    def category_axis_display_options(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "category_axis_display_options")

    @property
    @pulumi.getter(name="categoryAxisLabelOptions")
    def category_axis_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "category_axis_label_options")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.AnalysisDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisWaterfallChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.AnalysisLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.AnalysisAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisWaterfallChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.AnalysisVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="waterfallChartOptions")
    def waterfall_chart_options(self) -> Optional['outputs.AnalysisWaterfallChartOptions']:
        return pulumi.get(self, "waterfall_chart_options")


@pulumi.output_type
class AnalysisWaterfallChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waterfallChartAggregatedFieldWells":
            suggest = "waterfall_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWaterfallChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWaterfallChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWaterfallChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 waterfall_chart_aggregated_field_wells: Optional['outputs.AnalysisWaterfallChartAggregatedFieldWells'] = None):
        AnalysisWaterfallChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            waterfall_chart_aggregated_field_wells=waterfall_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             waterfall_chart_aggregated_field_wells: Optional['outputs.AnalysisWaterfallChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if waterfall_chart_aggregated_field_wells is not None:
            _setter("waterfall_chart_aggregated_field_wells", waterfall_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="waterfallChartAggregatedFieldWells")
    def waterfall_chart_aggregated_field_wells(self) -> Optional['outputs.AnalysisWaterfallChartAggregatedFieldWells']:
        return pulumi.get(self, "waterfall_chart_aggregated_field_wells")


@pulumi.output_type
class AnalysisWaterfallChartOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalBarLabel":
            suggest = "total_bar_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWaterfallChartOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWaterfallChartOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWaterfallChartOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_bar_label: Optional[str] = None):
        AnalysisWaterfallChartOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            total_bar_label=total_bar_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             total_bar_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if total_bar_label is not None:
            _setter("total_bar_label", total_bar_label)

    @property
    @pulumi.getter(name="totalBarLabel")
    def total_bar_label(self) -> Optional[str]:
        return pulumi.get(self, "total_bar_label")


@pulumi.output_type
class AnalysisWaterfallChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "breakdownItemsLimit":
            suggest = "breakdown_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWaterfallChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWaterfallChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWaterfallChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 breakdown_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisWaterfallChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            breakdown_items_limit=breakdown_items_limit,
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             breakdown_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if breakdown_items_limit is not None:
            _setter("breakdown_items_limit", breakdown_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="breakdownItemsLimit")
    def breakdown_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "breakdown_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class AnalysisWaterfallVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWaterfallVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWaterfallVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWaterfallVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisWaterfallChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisWaterfallVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisWaterfallChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisWaterfallChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AnalysisWhatIfPointScenario(dict):
    def __init__(__self__, *,
                 date: str,
                 value: float):
        AnalysisWhatIfPointScenario._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date=date,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date: str,
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("date", date)
        _setter("value", value)

    @property
    @pulumi.getter
    def date(self) -> str:
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisWhatIfRangeScenario(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWhatIfRangeScenario. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWhatIfRangeScenario.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWhatIfRangeScenario.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str,
                 value: float):
        AnalysisWhatIfRangeScenario._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_date=end_date,
            start_date=start_date,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_date: str,
             start_date: str,
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_date", end_date)
        _setter("start_date", start_date)
        _setter("value", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalysisWordCloudAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWordCloudAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWordCloudAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWordCloudAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_by: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
                 size: Optional[Sequence['outputs.AnalysisMeasureField']] = None):
        AnalysisWordCloudAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_by=group_by,
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_by: Optional[Sequence['outputs.AnalysisDimensionField']] = None,
             size: Optional[Sequence['outputs.AnalysisMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_by is not None:
            _setter("group_by", group_by)
        if size is not None:
            _setter("size", size)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[Sequence['outputs.AnalysisDimensionField']]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def size(self) -> Optional[Sequence['outputs.AnalysisMeasureField']]:
        return pulumi.get(self, "size")


@pulumi.output_type
class AnalysisWordCloudChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "wordCloudOptions":
            suggest = "word_cloud_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWordCloudChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWordCloudChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWordCloudChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.AnalysisWordCloudFieldWells'] = None,
                 sort_configuration: Optional['outputs.AnalysisWordCloudSortConfiguration'] = None,
                 word_cloud_options: Optional['outputs.AnalysisWordCloudOptions'] = None):
        AnalysisWordCloudChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_options=category_label_options,
            field_wells=field_wells,
            sort_configuration=sort_configuration,
            word_cloud_options=word_cloud_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_options: Optional['outputs.AnalysisChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.AnalysisWordCloudFieldWells'] = None,
             sort_configuration: Optional['outputs.AnalysisWordCloudSortConfiguration'] = None,
             word_cloud_options: Optional['outputs.AnalysisWordCloudOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if word_cloud_options is not None:
            _setter("word_cloud_options", word_cloud_options)

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.AnalysisChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.AnalysisWordCloudFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.AnalysisWordCloudSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="wordCloudOptions")
    def word_cloud_options(self) -> Optional['outputs.AnalysisWordCloudOptions']:
        return pulumi.get(self, "word_cloud_options")


@pulumi.output_type
class AnalysisWordCloudFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wordCloudAggregatedFieldWells":
            suggest = "word_cloud_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWordCloudFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWordCloudFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWordCloudFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 word_cloud_aggregated_field_wells: Optional['outputs.AnalysisWordCloudAggregatedFieldWells'] = None):
        AnalysisWordCloudFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            word_cloud_aggregated_field_wells=word_cloud_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             word_cloud_aggregated_field_wells: Optional['outputs.AnalysisWordCloudAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if word_cloud_aggregated_field_wells is not None:
            _setter("word_cloud_aggregated_field_wells", word_cloud_aggregated_field_wells)

    @property
    @pulumi.getter(name="wordCloudAggregatedFieldWells")
    def word_cloud_aggregated_field_wells(self) -> Optional['outputs.AnalysisWordCloudAggregatedFieldWells']:
        return pulumi.get(self, "word_cloud_aggregated_field_wells")


@pulumi.output_type
class AnalysisWordCloudOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudLayout":
            suggest = "cloud_layout"
        elif key == "maximumStringLength":
            suggest = "maximum_string_length"
        elif key == "wordCasing":
            suggest = "word_casing"
        elif key == "wordOrientation":
            suggest = "word_orientation"
        elif key == "wordPadding":
            suggest = "word_padding"
        elif key == "wordScaling":
            suggest = "word_scaling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWordCloudOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWordCloudOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWordCloudOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_layout: Optional['AnalysisWordCloudCloudLayout'] = None,
                 maximum_string_length: Optional[float] = None,
                 word_casing: Optional['AnalysisWordCloudWordCasing'] = None,
                 word_orientation: Optional['AnalysisWordCloudWordOrientation'] = None,
                 word_padding: Optional['AnalysisWordCloudWordPadding'] = None,
                 word_scaling: Optional['AnalysisWordCloudWordScaling'] = None):
        AnalysisWordCloudOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_layout=cloud_layout,
            maximum_string_length=maximum_string_length,
            word_casing=word_casing,
            word_orientation=word_orientation,
            word_padding=word_padding,
            word_scaling=word_scaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_layout: Optional['AnalysisWordCloudCloudLayout'] = None,
             maximum_string_length: Optional[float] = None,
             word_casing: Optional['AnalysisWordCloudWordCasing'] = None,
             word_orientation: Optional['AnalysisWordCloudWordOrientation'] = None,
             word_padding: Optional['AnalysisWordCloudWordPadding'] = None,
             word_scaling: Optional['AnalysisWordCloudWordScaling'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cloud_layout is not None:
            _setter("cloud_layout", cloud_layout)
        if maximum_string_length is not None:
            _setter("maximum_string_length", maximum_string_length)
        if word_casing is not None:
            _setter("word_casing", word_casing)
        if word_orientation is not None:
            _setter("word_orientation", word_orientation)
        if word_padding is not None:
            _setter("word_padding", word_padding)
        if word_scaling is not None:
            _setter("word_scaling", word_scaling)

    @property
    @pulumi.getter(name="cloudLayout")
    def cloud_layout(self) -> Optional['AnalysisWordCloudCloudLayout']:
        return pulumi.get(self, "cloud_layout")

    @property
    @pulumi.getter(name="maximumStringLength")
    def maximum_string_length(self) -> Optional[float]:
        return pulumi.get(self, "maximum_string_length")

    @property
    @pulumi.getter(name="wordCasing")
    def word_casing(self) -> Optional['AnalysisWordCloudWordCasing']:
        return pulumi.get(self, "word_casing")

    @property
    @pulumi.getter(name="wordOrientation")
    def word_orientation(self) -> Optional['AnalysisWordCloudWordOrientation']:
        return pulumi.get(self, "word_orientation")

    @property
    @pulumi.getter(name="wordPadding")
    def word_padding(self) -> Optional['AnalysisWordCloudWordPadding']:
        return pulumi.get(self, "word_padding")

    @property
    @pulumi.getter(name="wordScaling")
    def word_scaling(self) -> Optional['AnalysisWordCloudWordScaling']:
        return pulumi.get(self, "word_scaling")


@pulumi.output_type
class AnalysisWordCloudSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWordCloudSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWordCloudSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWordCloudSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None):
        AnalysisWordCloudSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.AnalysisItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.AnalysisFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.AnalysisItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.AnalysisFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class AnalysisWordCloudVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisWordCloudVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisWordCloudVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisWordCloudVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.AnalysisWordCloudChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
                 subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None):
        AnalysisWordCloudVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.AnalysisVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.AnalysisWordCloudChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.AnalysisColumnHierarchy']] = None,
             subtitle: Optional['outputs.AnalysisVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.AnalysisVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AnalysisVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.AnalysisWordCloudChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.AnalysisColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.AnalysisVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AnalysisVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardAdHocFilteringOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAdHocFilteringOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAdHocFilteringOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAdHocFilteringOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional['DashboardBehavior'] = None):
        DashboardAdHocFilteringOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional['DashboardBehavior'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional['DashboardBehavior']:
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardAggregationFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeAggregationFunction":
            suggest = "attribute_aggregation_function"
        elif key == "categoricalAggregationFunction":
            suggest = "categorical_aggregation_function"
        elif key == "dateAggregationFunction":
            suggest = "date_aggregation_function"
        elif key == "numericalAggregationFunction":
            suggest = "numerical_aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAggregationFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAggregationFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAggregationFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_aggregation_function: Optional['outputs.DashboardAttributeAggregationFunction'] = None,
                 categorical_aggregation_function: Optional['DashboardCategoricalAggregationFunction'] = None,
                 date_aggregation_function: Optional['DashboardDateAggregationFunction'] = None,
                 numerical_aggregation_function: Optional['outputs.DashboardNumericalAggregationFunction'] = None):
        DashboardAggregationFunction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_aggregation_function=attribute_aggregation_function,
            categorical_aggregation_function=categorical_aggregation_function,
            date_aggregation_function=date_aggregation_function,
            numerical_aggregation_function=numerical_aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_aggregation_function: Optional['outputs.DashboardAttributeAggregationFunction'] = None,
             categorical_aggregation_function: Optional['DashboardCategoricalAggregationFunction'] = None,
             date_aggregation_function: Optional['DashboardDateAggregationFunction'] = None,
             numerical_aggregation_function: Optional['outputs.DashboardNumericalAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attribute_aggregation_function is not None:
            _setter("attribute_aggregation_function", attribute_aggregation_function)
        if categorical_aggregation_function is not None:
            _setter("categorical_aggregation_function", categorical_aggregation_function)
        if date_aggregation_function is not None:
            _setter("date_aggregation_function", date_aggregation_function)
        if numerical_aggregation_function is not None:
            _setter("numerical_aggregation_function", numerical_aggregation_function)

    @property
    @pulumi.getter(name="attributeAggregationFunction")
    def attribute_aggregation_function(self) -> Optional['outputs.DashboardAttributeAggregationFunction']:
        return pulumi.get(self, "attribute_aggregation_function")

    @property
    @pulumi.getter(name="categoricalAggregationFunction")
    def categorical_aggregation_function(self) -> Optional['DashboardCategoricalAggregationFunction']:
        return pulumi.get(self, "categorical_aggregation_function")

    @property
    @pulumi.getter(name="dateAggregationFunction")
    def date_aggregation_function(self) -> Optional['DashboardDateAggregationFunction']:
        return pulumi.get(self, "date_aggregation_function")

    @property
    @pulumi.getter(name="numericalAggregationFunction")
    def numerical_aggregation_function(self) -> Optional['outputs.DashboardNumericalAggregationFunction']:
        return pulumi.get(self, "numerical_aggregation_function")


@pulumi.output_type
class DashboardAggregationSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortDirection":
            suggest = "sort_direction"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAggregationSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAggregationSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAggregationSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 sort_direction: 'DashboardSortDirection',
                 aggregation_function: Optional['outputs.DashboardAggregationFunction'] = None):
        DashboardAggregationSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            sort_direction=sort_direction,
            aggregation_function=aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             sort_direction: 'DashboardSortDirection',
             aggregation_function: Optional['outputs.DashboardAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("sort_direction", sort_direction)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="sortDirection")
    def sort_direction(self) -> 'DashboardSortDirection':
        return pulumi.get(self, "sort_direction")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.DashboardAggregationFunction']:
        return pulumi.get(self, "aggregation_function")


@pulumi.output_type
class DashboardAllSheetsFilterScopeConfiguration(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class DashboardAnalysisDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultNewSheetConfiguration":
            suggest = "default_new_sheet_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAnalysisDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAnalysisDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAnalysisDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_new_sheet_configuration: 'outputs.DashboardDefaultNewSheetConfiguration'):
        DashboardAnalysisDefaults._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_new_sheet_configuration=default_new_sheet_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_new_sheet_configuration: 'outputs.DashboardDefaultNewSheetConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_new_sheet_configuration", default_new_sheet_configuration)

    @property
    @pulumi.getter(name="defaultNewSheetConfiguration")
    def default_new_sheet_configuration(self) -> 'outputs.DashboardDefaultNewSheetConfiguration':
        return pulumi.get(self, "default_new_sheet_configuration")


@pulumi.output_type
class DashboardAnchorDateConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anchorOption":
            suggest = "anchor_option"
        elif key == "parameterName":
            suggest = "parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAnchorDateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAnchorDateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAnchorDateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anchor_option: Optional['DashboardAnchorOption'] = None,
                 parameter_name: Optional[str] = None):
        DashboardAnchorDateConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            anchor_option=anchor_option,
            parameter_name=parameter_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             anchor_option: Optional['DashboardAnchorOption'] = None,
             parameter_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if anchor_option is not None:
            _setter("anchor_option", anchor_option)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)

    @property
    @pulumi.getter(name="anchorOption")
    def anchor_option(self) -> Optional['DashboardAnchorOption']:
        return pulumi.get(self, "anchor_option")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")


@pulumi.output_type
class DashboardArcAxisConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reserveRange":
            suggest = "reserve_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardArcAxisConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardArcAxisConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardArcAxisConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range: Optional['outputs.DashboardArcAxisDisplayRange'] = None,
                 reserve_range: Optional[float] = None):
        DashboardArcAxisConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            range=range,
            reserve_range=reserve_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             range: Optional['outputs.DashboardArcAxisDisplayRange'] = None,
             reserve_range: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if range is not None:
            _setter("range", range)
        if reserve_range is not None:
            _setter("reserve_range", reserve_range)

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.DashboardArcAxisDisplayRange']:
        return pulumi.get(self, "range")

    @property
    @pulumi.getter(name="reserveRange")
    def reserve_range(self) -> Optional[float]:
        return pulumi.get(self, "reserve_range")


@pulumi.output_type
class DashboardArcAxisDisplayRange(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        DashboardArcAxisDisplayRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class DashboardArcConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcAngle":
            suggest = "arc_angle"
        elif key == "arcThickness":
            suggest = "arc_thickness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardArcConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardArcConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardArcConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc_angle: Optional[float] = None,
                 arc_thickness: Optional['DashboardArcThicknessOptions'] = None):
        DashboardArcConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc_angle=arc_angle,
            arc_thickness=arc_thickness,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc_angle: Optional[float] = None,
             arc_thickness: Optional['DashboardArcThicknessOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc_angle is not None:
            _setter("arc_angle", arc_angle)
        if arc_thickness is not None:
            _setter("arc_thickness", arc_thickness)

    @property
    @pulumi.getter(name="arcAngle")
    def arc_angle(self) -> Optional[float]:
        return pulumi.get(self, "arc_angle")

    @property
    @pulumi.getter(name="arcThickness")
    def arc_thickness(self) -> Optional['DashboardArcThicknessOptions']:
        return pulumi.get(self, "arc_thickness")


@pulumi.output_type
class DashboardArcOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcThickness":
            suggest = "arc_thickness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardArcOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardArcOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardArcOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc_thickness: Optional['DashboardArcThickness'] = None):
        DashboardArcOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc_thickness=arc_thickness,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc_thickness: Optional['DashboardArcThickness'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc_thickness is not None:
            _setter("arc_thickness", arc_thickness)

    @property
    @pulumi.getter(name="arcThickness")
    def arc_thickness(self) -> Optional['DashboardArcThickness']:
        return pulumi.get(self, "arc_thickness")


@pulumi.output_type
class DashboardAttributeAggregationFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simpleAttributeAggregation":
            suggest = "simple_attribute_aggregation"
        elif key == "valueForMultipleValues":
            suggest = "value_for_multiple_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAttributeAggregationFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAttributeAggregationFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAttributeAggregationFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 simple_attribute_aggregation: Optional['DashboardSimpleAttributeAggregationFunction'] = None,
                 value_for_multiple_values: Optional[str] = None):
        DashboardAttributeAggregationFunction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            simple_attribute_aggregation=simple_attribute_aggregation,
            value_for_multiple_values=value_for_multiple_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             simple_attribute_aggregation: Optional['DashboardSimpleAttributeAggregationFunction'] = None,
             value_for_multiple_values: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if simple_attribute_aggregation is not None:
            _setter("simple_attribute_aggregation", simple_attribute_aggregation)
        if value_for_multiple_values is not None:
            _setter("value_for_multiple_values", value_for_multiple_values)

    @property
    @pulumi.getter(name="simpleAttributeAggregation")
    def simple_attribute_aggregation(self) -> Optional['DashboardSimpleAttributeAggregationFunction']:
        return pulumi.get(self, "simple_attribute_aggregation")

    @property
    @pulumi.getter(name="valueForMultipleValues")
    def value_for_multiple_values(self) -> Optional[str]:
        return pulumi.get(self, "value_for_multiple_values")


@pulumi.output_type
class DashboardAxisDataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateAxisOptions":
            suggest = "date_axis_options"
        elif key == "numericAxisOptions":
            suggest = "numeric_axis_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAxisDataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAxisDataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAxisDataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_axis_options: Optional['outputs.DashboardDateAxisOptions'] = None,
                 numeric_axis_options: Optional['outputs.DashboardNumericAxisOptions'] = None):
        DashboardAxisDataOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_axis_options=date_axis_options,
            numeric_axis_options=numeric_axis_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_axis_options: Optional['outputs.DashboardDateAxisOptions'] = None,
             numeric_axis_options: Optional['outputs.DashboardNumericAxisOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_axis_options is not None:
            _setter("date_axis_options", date_axis_options)
        if numeric_axis_options is not None:
            _setter("numeric_axis_options", numeric_axis_options)

    @property
    @pulumi.getter(name="dateAxisOptions")
    def date_axis_options(self) -> Optional['outputs.DashboardDateAxisOptions']:
        return pulumi.get(self, "date_axis_options")

    @property
    @pulumi.getter(name="numericAxisOptions")
    def numeric_axis_options(self) -> Optional['outputs.DashboardNumericAxisOptions']:
        return pulumi.get(self, "numeric_axis_options")


@pulumi.output_type
class DashboardAxisDisplayDataDrivenRange(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class DashboardAxisDisplayMinMaxRange(dict):
    def __init__(__self__, *,
                 maximum: Optional[float] = None,
                 minimum: Optional[float] = None):
        DashboardAxisDisplayMinMaxRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum=maximum,
            minimum=minimum,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum: Optional[float] = None,
             minimum: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if maximum is not None:
            _setter("maximum", maximum)
        if minimum is not None:
            _setter("minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[float]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[float]:
        return pulumi.get(self, "minimum")


@pulumi.output_type
class DashboardAxisDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisLineVisibility":
            suggest = "axis_line_visibility"
        elif key == "axisOffset":
            suggest = "axis_offset"
        elif key == "dataOptions":
            suggest = "data_options"
        elif key == "gridLineVisibility":
            suggest = "grid_line_visibility"
        elif key == "scrollbarOptions":
            suggest = "scrollbar_options"
        elif key == "tickLabelOptions":
            suggest = "tick_label_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAxisDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAxisDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAxisDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_line_visibility: Optional['DashboardVisibility'] = None,
                 axis_offset: Optional[str] = None,
                 data_options: Optional['outputs.DashboardAxisDataOptions'] = None,
                 grid_line_visibility: Optional['DashboardVisibility'] = None,
                 scrollbar_options: Optional['outputs.DashboardScrollBarOptions'] = None,
                 tick_label_options: Optional['outputs.DashboardAxisTickLabelOptions'] = None):
        """
        :param str axis_offset: String based length that is composed of value and unit in px
        """
        DashboardAxisDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_line_visibility=axis_line_visibility,
            axis_offset=axis_offset,
            data_options=data_options,
            grid_line_visibility=grid_line_visibility,
            scrollbar_options=scrollbar_options,
            tick_label_options=tick_label_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_line_visibility: Optional['DashboardVisibility'] = None,
             axis_offset: Optional[str] = None,
             data_options: Optional['outputs.DashboardAxisDataOptions'] = None,
             grid_line_visibility: Optional['DashboardVisibility'] = None,
             scrollbar_options: Optional['outputs.DashboardScrollBarOptions'] = None,
             tick_label_options: Optional['outputs.DashboardAxisTickLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_line_visibility is not None:
            _setter("axis_line_visibility", axis_line_visibility)
        if axis_offset is not None:
            _setter("axis_offset", axis_offset)
        if data_options is not None:
            _setter("data_options", data_options)
        if grid_line_visibility is not None:
            _setter("grid_line_visibility", grid_line_visibility)
        if scrollbar_options is not None:
            _setter("scrollbar_options", scrollbar_options)
        if tick_label_options is not None:
            _setter("tick_label_options", tick_label_options)

    @property
    @pulumi.getter(name="axisLineVisibility")
    def axis_line_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "axis_line_visibility")

    @property
    @pulumi.getter(name="axisOffset")
    def axis_offset(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "axis_offset")

    @property
    @pulumi.getter(name="dataOptions")
    def data_options(self) -> Optional['outputs.DashboardAxisDataOptions']:
        return pulumi.get(self, "data_options")

    @property
    @pulumi.getter(name="gridLineVisibility")
    def grid_line_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "grid_line_visibility")

    @property
    @pulumi.getter(name="scrollbarOptions")
    def scrollbar_options(self) -> Optional['outputs.DashboardScrollBarOptions']:
        return pulumi.get(self, "scrollbar_options")

    @property
    @pulumi.getter(name="tickLabelOptions")
    def tick_label_options(self) -> Optional['outputs.DashboardAxisTickLabelOptions']:
        return pulumi.get(self, "tick_label_options")


@pulumi.output_type
class DashboardAxisDisplayRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDriven":
            suggest = "data_driven"
        elif key == "minMax":
            suggest = "min_max"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAxisDisplayRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAxisDisplayRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAxisDisplayRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_driven: Optional['outputs.DashboardAxisDisplayDataDrivenRange'] = None,
                 min_max: Optional['outputs.DashboardAxisDisplayMinMaxRange'] = None):
        DashboardAxisDisplayRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_driven=data_driven,
            min_max=min_max,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_driven: Optional['outputs.DashboardAxisDisplayDataDrivenRange'] = None,
             min_max: Optional['outputs.DashboardAxisDisplayMinMaxRange'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_driven is not None:
            _setter("data_driven", data_driven)
        if min_max is not None:
            _setter("min_max", min_max)

    @property
    @pulumi.getter(name="dataDriven")
    def data_driven(self) -> Optional['outputs.DashboardAxisDisplayDataDrivenRange']:
        return pulumi.get(self, "data_driven")

    @property
    @pulumi.getter(name="minMax")
    def min_max(self) -> Optional['outputs.DashboardAxisDisplayMinMaxRange']:
        return pulumi.get(self, "min_max")


@pulumi.output_type
class DashboardAxisLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyTo":
            suggest = "apply_to"
        elif key == "customLabel":
            suggest = "custom_label"
        elif key == "fontConfiguration":
            suggest = "font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAxisLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAxisLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAxisLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_to: Optional['outputs.DashboardAxisLabelReferenceOptions'] = None,
                 custom_label: Optional[str] = None,
                 font_configuration: Optional['outputs.DashboardFontConfiguration'] = None):
        DashboardAxisLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apply_to=apply_to,
            custom_label=custom_label,
            font_configuration=font_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apply_to: Optional['outputs.DashboardAxisLabelReferenceOptions'] = None,
             custom_label: Optional[str] = None,
             font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apply_to is not None:
            _setter("apply_to", apply_to)
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)

    @property
    @pulumi.getter(name="applyTo")
    def apply_to(self) -> Optional['outputs.DashboardAxisLabelReferenceOptions']:
        return pulumi.get(self, "apply_to")

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.DashboardFontConfiguration']:
        return pulumi.get(self, "font_configuration")


@pulumi.output_type
class DashboardAxisLabelReferenceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAxisLabelReferenceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAxisLabelReferenceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAxisLabelReferenceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 field_id: str):
        DashboardAxisLabelReferenceOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class DashboardAxisLinearScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stepCount":
            suggest = "step_count"
        elif key == "stepSize":
            suggest = "step_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAxisLinearScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAxisLinearScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAxisLinearScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 step_count: Optional[float] = None,
                 step_size: Optional[float] = None):
        DashboardAxisLinearScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            step_count=step_count,
            step_size=step_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             step_count: Optional[float] = None,
             step_size: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if step_count is not None:
            _setter("step_count", step_count)
        if step_size is not None:
            _setter("step_size", step_size)

    @property
    @pulumi.getter(name="stepCount")
    def step_count(self) -> Optional[float]:
        return pulumi.get(self, "step_count")

    @property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> Optional[float]:
        return pulumi.get(self, "step_size")


@pulumi.output_type
class DashboardAxisLogarithmicScale(dict):
    def __init__(__self__, *,
                 base: Optional[float] = None):
        DashboardAxisLogarithmicScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base=base,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if base is not None:
            _setter("base", base)

    @property
    @pulumi.getter
    def base(self) -> Optional[float]:
        return pulumi.get(self, "base")


@pulumi.output_type
class DashboardAxisScale(dict):
    def __init__(__self__, *,
                 linear: Optional['outputs.DashboardAxisLinearScale'] = None,
                 logarithmic: Optional['outputs.DashboardAxisLogarithmicScale'] = None):
        DashboardAxisScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            linear=linear,
            logarithmic=logarithmic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             linear: Optional['outputs.DashboardAxisLinearScale'] = None,
             logarithmic: Optional['outputs.DashboardAxisLogarithmicScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if linear is not None:
            _setter("linear", linear)
        if logarithmic is not None:
            _setter("logarithmic", logarithmic)

    @property
    @pulumi.getter
    def linear(self) -> Optional['outputs.DashboardAxisLinearScale']:
        return pulumi.get(self, "linear")

    @property
    @pulumi.getter
    def logarithmic(self) -> Optional['outputs.DashboardAxisLogarithmicScale']:
        return pulumi.get(self, "logarithmic")


@pulumi.output_type
class DashboardAxisTickLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelOptions":
            suggest = "label_options"
        elif key == "rotationAngle":
            suggest = "rotation_angle"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardAxisTickLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardAxisTickLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardAxisTickLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_options: Optional['outputs.DashboardLabelOptions'] = None,
                 rotation_angle: Optional[float] = None):
        DashboardAxisTickLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_options=label_options,
            rotation_angle=rotation_angle,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_options: Optional['outputs.DashboardLabelOptions'] = None,
             rotation_angle: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if label_options is not None:
            _setter("label_options", label_options)
        if rotation_angle is not None:
            _setter("rotation_angle", rotation_angle)

    @property
    @pulumi.getter(name="labelOptions")
    def label_options(self) -> Optional['outputs.DashboardLabelOptions']:
        return pulumi.get(self, "label_options")

    @property
    @pulumi.getter(name="rotationAngle")
    def rotation_angle(self) -> Optional[float]:
        return pulumi.get(self, "rotation_angle")


@pulumi.output_type
class DashboardBarChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "smallMultiples":
            suggest = "small_multiples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBarChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBarChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBarChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 colors: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 small_multiples: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardBarChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            colors=colors,
            small_multiples=small_multiples,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             colors: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             small_multiples: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if colors is not None:
            _setter("colors", colors)
        if small_multiples is not None:
            _setter("small_multiples", small_multiples)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="smallMultiples")
    def small_multiples(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "small_multiples")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardBarChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barsArrangement":
            suggest = "bars_arrangement"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "contributionAnalysisDefaults":
            suggest = "contribution_analysis_defaults"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "smallMultiplesOptions":
            suggest = "small_multiples_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "valueAxis":
            suggest = "value_axis"
        elif key == "valueLabelOptions":
            suggest = "value_label_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBarChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBarChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBarChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bars_arrangement: Optional['DashboardBarsArrangement'] = None,
                 category_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 color_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 contribution_analysis_defaults: Optional[Sequence['outputs.DashboardContributionAnalysisDefault']] = None,
                 data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardBarChartFieldWells'] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 orientation: Optional['DashboardBarChartOrientation'] = None,
                 reference_lines: Optional[Sequence['outputs.DashboardReferenceLine']] = None,
                 small_multiples_options: Optional['outputs.DashboardSmallMultiplesOptions'] = None,
                 sort_configuration: Optional['outputs.DashboardBarChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
                 value_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 value_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None):
        DashboardBarChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bars_arrangement=bars_arrangement,
            category_axis=category_axis,
            category_label_options=category_label_options,
            color_label_options=color_label_options,
            contribution_analysis_defaults=contribution_analysis_defaults,
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            orientation=orientation,
            reference_lines=reference_lines,
            small_multiples_options=small_multiples_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            value_axis=value_axis,
            value_label_options=value_label_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bars_arrangement: Optional['DashboardBarsArrangement'] = None,
             category_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             color_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             contribution_analysis_defaults: Optional[Sequence['outputs.DashboardContributionAnalysisDefault']] = None,
             data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardBarChartFieldWells'] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             orientation: Optional['DashboardBarChartOrientation'] = None,
             reference_lines: Optional[Sequence['outputs.DashboardReferenceLine']] = None,
             small_multiples_options: Optional['outputs.DashboardSmallMultiplesOptions'] = None,
             sort_configuration: Optional['outputs.DashboardBarChartSortConfiguration'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             value_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             value_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bars_arrangement is not None:
            _setter("bars_arrangement", bars_arrangement)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if contribution_analysis_defaults is not None:
            _setter("contribution_analysis_defaults", contribution_analysis_defaults)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if orientation is not None:
            _setter("orientation", orientation)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if small_multiples_options is not None:
            _setter("small_multiples_options", small_multiples_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if value_axis is not None:
            _setter("value_axis", value_axis)
        if value_label_options is not None:
            _setter("value_label_options", value_label_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="barsArrangement")
    def bars_arrangement(self) -> Optional['DashboardBarsArrangement']:
        return pulumi.get(self, "bars_arrangement")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="contributionAnalysisDefaults")
    def contribution_analysis_defaults(self) -> Optional[Sequence['outputs.DashboardContributionAnalysisDefault']]:
        return pulumi.get(self, "contribution_analysis_defaults")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardBarChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter
    def orientation(self) -> Optional['DashboardBarChartOrientation']:
        return pulumi.get(self, "orientation")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.DashboardReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="smallMultiplesOptions")
    def small_multiples_options(self) -> Optional['outputs.DashboardSmallMultiplesOptions']:
        return pulumi.get(self, "small_multiples_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardBarChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="valueAxis")
    def value_axis(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "value_axis")

    @property
    @pulumi.getter(name="valueLabelOptions")
    def value_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "value_label_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class DashboardBarChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barChartAggregatedFieldWells":
            suggest = "bar_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBarChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBarChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBarChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_chart_aggregated_field_wells: Optional['outputs.DashboardBarChartAggregatedFieldWells'] = None):
        DashboardBarChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_chart_aggregated_field_wells=bar_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_chart_aggregated_field_wells: Optional['outputs.DashboardBarChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_chart_aggregated_field_wells is not None:
            _setter("bar_chart_aggregated_field_wells", bar_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="barChartAggregatedFieldWells")
    def bar_chart_aggregated_field_wells(self) -> Optional['outputs.DashboardBarChartAggregatedFieldWells']:
        return pulumi.get(self, "bar_chart_aggregated_field_wells")


@pulumi.output_type
class DashboardBarChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimit":
            suggest = "color_items_limit"
        elif key == "colorSort":
            suggest = "color_sort"
        elif key == "smallMultiplesLimitConfiguration":
            suggest = "small_multiples_limit_configuration"
        elif key == "smallMultiplesSort":
            suggest = "small_multiples_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBarChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBarChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBarChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
                 color_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 color_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
                 small_multiples_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 small_multiples_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardBarChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            color_items_limit=color_items_limit,
            color_sort=color_sort,
            small_multiples_limit_configuration=small_multiples_limit_configuration,
            small_multiples_sort=small_multiples_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             color_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             color_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             small_multiples_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             small_multiples_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit is not None:
            _setter("color_items_limit", color_items_limit)
        if color_sort is not None:
            _setter("color_sort", color_sort)
        if small_multiples_limit_configuration is not None:
            _setter("small_multiples_limit_configuration", small_multiples_limit_configuration)
        if small_multiples_sort is not None:
            _setter("small_multiples_sort", small_multiples_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimit")
    def color_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit")

    @property
    @pulumi.getter(name="colorSort")
    def color_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "color_sort")

    @property
    @pulumi.getter(name="smallMultiplesLimitConfiguration")
    def small_multiples_limit_configuration(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "small_multiples_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesSort")
    def small_multiples_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "small_multiples_sort")


@pulumi.output_type
class DashboardBarChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBarChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBarChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBarChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardBarChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardBarChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardBarChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardBarChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardBinCountOptions(dict):
    def __init__(__self__, *,
                 value: Optional[float] = None):
        DashboardBinCountOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardBinWidthOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binCountLimit":
            suggest = "bin_count_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBinWidthOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBinWidthOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBinWidthOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bin_count_limit: Optional[float] = None,
                 value: Optional[float] = None):
        DashboardBinWidthOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bin_count_limit=bin_count_limit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bin_count_limit: Optional[float] = None,
             value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bin_count_limit is not None:
            _setter("bin_count_limit", bin_count_limit)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="binCountLimit")
    def bin_count_limit(self) -> Optional[float]:
        return pulumi.get(self, "bin_count_limit")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardBodySectionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionId":
            suggest = "section_id"
        elif key == "pageBreakConfiguration":
            suggest = "page_break_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBodySectionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBodySectionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBodySectionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: 'outputs.DashboardBodySectionContent',
                 section_id: str,
                 page_break_configuration: Optional['outputs.DashboardSectionPageBreakConfiguration'] = None,
                 style: Optional['outputs.DashboardSectionStyle'] = None):
        DashboardBodySectionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            section_id=section_id,
            page_break_configuration=page_break_configuration,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: 'outputs.DashboardBodySectionContent',
             section_id: str,
             page_break_configuration: Optional['outputs.DashboardSectionPageBreakConfiguration'] = None,
             style: Optional['outputs.DashboardSectionStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        _setter("section_id", section_id)
        if page_break_configuration is not None:
            _setter("page_break_configuration", page_break_configuration)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter
    def content(self) -> 'outputs.DashboardBodySectionContent':
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="sectionId")
    def section_id(self) -> str:
        return pulumi.get(self, "section_id")

    @property
    @pulumi.getter(name="pageBreakConfiguration")
    def page_break_configuration(self) -> Optional['outputs.DashboardSectionPageBreakConfiguration']:
        return pulumi.get(self, "page_break_configuration")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardSectionStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardBodySectionContent(dict):
    def __init__(__self__, *,
                 layout: Optional['outputs.DashboardSectionLayoutConfiguration'] = None):
        DashboardBodySectionContent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            layout=layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             layout: Optional['outputs.DashboardSectionLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if layout is not None:
            _setter("layout", layout)

    @property
    @pulumi.getter
    def layout(self) -> Optional['outputs.DashboardSectionLayoutConfiguration']:
        return pulumi.get(self, "layout")


@pulumi.output_type
class DashboardBoxPlotAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBoxPlotAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBoxPlotAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBoxPlotAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_by: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardBoxPlotAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_by=group_by,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_by: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_by is not None:
            _setter("group_by", group_by)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardBoxPlotChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boxPlotOptions":
            suggest = "box_plot_options"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBoxPlotChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBoxPlotChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBoxPlotChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 box_plot_options: Optional['outputs.DashboardBoxPlotOptions'] = None,
                 category_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardBoxPlotFieldWells'] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 reference_lines: Optional[Sequence['outputs.DashboardReferenceLine']] = None,
                 sort_configuration: Optional['outputs.DashboardBoxPlotSortConfiguration'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None):
        DashboardBoxPlotChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            box_plot_options=box_plot_options,
            category_axis=category_axis,
            category_label_options=category_label_options,
            field_wells=field_wells,
            legend=legend,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            reference_lines=reference_lines,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             box_plot_options: Optional['outputs.DashboardBoxPlotOptions'] = None,
             category_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardBoxPlotFieldWells'] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             reference_lines: Optional[Sequence['outputs.DashboardReferenceLine']] = None,
             sort_configuration: Optional['outputs.DashboardBoxPlotSortConfiguration'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if box_plot_options is not None:
            _setter("box_plot_options", box_plot_options)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="boxPlotOptions")
    def box_plot_options(self) -> Optional['outputs.DashboardBoxPlotOptions']:
        return pulumi.get(self, "box_plot_options")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardBoxPlotFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.DashboardReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardBoxPlotSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class DashboardBoxPlotFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boxPlotAggregatedFieldWells":
            suggest = "box_plot_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBoxPlotFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBoxPlotFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBoxPlotFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 box_plot_aggregated_field_wells: Optional['outputs.DashboardBoxPlotAggregatedFieldWells'] = None):
        DashboardBoxPlotFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            box_plot_aggregated_field_wells=box_plot_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             box_plot_aggregated_field_wells: Optional['outputs.DashboardBoxPlotAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if box_plot_aggregated_field_wells is not None:
            _setter("box_plot_aggregated_field_wells", box_plot_aggregated_field_wells)

    @property
    @pulumi.getter(name="boxPlotAggregatedFieldWells")
    def box_plot_aggregated_field_wells(self) -> Optional['outputs.DashboardBoxPlotAggregatedFieldWells']:
        return pulumi.get(self, "box_plot_aggregated_field_wells")


@pulumi.output_type
class DashboardBoxPlotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allDataPointsVisibility":
            suggest = "all_data_points_visibility"
        elif key == "outlierVisibility":
            suggest = "outlier_visibility"
        elif key == "styleOptions":
            suggest = "style_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBoxPlotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBoxPlotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBoxPlotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_data_points_visibility: Optional['DashboardVisibility'] = None,
                 outlier_visibility: Optional['DashboardVisibility'] = None,
                 style_options: Optional['outputs.DashboardBoxPlotStyleOptions'] = None):
        DashboardBoxPlotOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_data_points_visibility=all_data_points_visibility,
            outlier_visibility=outlier_visibility,
            style_options=style_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_data_points_visibility: Optional['DashboardVisibility'] = None,
             outlier_visibility: Optional['DashboardVisibility'] = None,
             style_options: Optional['outputs.DashboardBoxPlotStyleOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_data_points_visibility is not None:
            _setter("all_data_points_visibility", all_data_points_visibility)
        if outlier_visibility is not None:
            _setter("outlier_visibility", outlier_visibility)
        if style_options is not None:
            _setter("style_options", style_options)

    @property
    @pulumi.getter(name="allDataPointsVisibility")
    def all_data_points_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "all_data_points_visibility")

    @property
    @pulumi.getter(name="outlierVisibility")
    def outlier_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "outlier_visibility")

    @property
    @pulumi.getter(name="styleOptions")
    def style_options(self) -> Optional['outputs.DashboardBoxPlotStyleOptions']:
        return pulumi.get(self, "style_options")


@pulumi.output_type
class DashboardBoxPlotSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categorySort":
            suggest = "category_sort"
        elif key == "paginationConfiguration":
            suggest = "pagination_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBoxPlotSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBoxPlotSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBoxPlotSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
                 pagination_configuration: Optional['outputs.DashboardPaginationConfiguration'] = None):
        DashboardBoxPlotSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_sort=category_sort,
            pagination_configuration=pagination_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             pagination_configuration: Optional['outputs.DashboardPaginationConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if pagination_configuration is not None:
            _setter("pagination_configuration", pagination_configuration)

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="paginationConfiguration")
    def pagination_configuration(self) -> Optional['outputs.DashboardPaginationConfiguration']:
        return pulumi.get(self, "pagination_configuration")


@pulumi.output_type
class DashboardBoxPlotStyleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillStyle":
            suggest = "fill_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBoxPlotStyleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBoxPlotStyleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBoxPlotStyleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fill_style: Optional['DashboardBoxPlotFillStyle'] = None):
        DashboardBoxPlotStyleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fill_style=fill_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fill_style: Optional['DashboardBoxPlotFillStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if fill_style is not None:
            _setter("fill_style", fill_style)

    @property
    @pulumi.getter(name="fillStyle")
    def fill_style(self) -> Optional['DashboardBoxPlotFillStyle']:
        return pulumi.get(self, "fill_style")


@pulumi.output_type
class DashboardBoxPlotVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardBoxPlotVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardBoxPlotVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardBoxPlotVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardBoxPlotChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardBoxPlotVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardBoxPlotChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardBoxPlotChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardCalculatedField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCalculatedField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCalculatedField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCalculatedField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 expression: str,
                 name: str):
        DashboardCalculatedField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            expression=expression,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             expression: str,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("expression", expression)
        _setter("name", name)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class DashboardCalculatedMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCalculatedMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCalculatedMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCalculatedMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 field_id: str):
        DashboardCalculatedMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        _setter("field_id", field_id)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class DashboardCascadingControlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceControls":
            suggest = "source_controls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCascadingControlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCascadingControlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCascadingControlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_controls: Optional[Sequence['outputs.DashboardCascadingControlSource']] = None):
        DashboardCascadingControlConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_controls=source_controls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_controls: Optional[Sequence['outputs.DashboardCascadingControlSource']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if source_controls is not None:
            _setter("source_controls", source_controls)

    @property
    @pulumi.getter(name="sourceControls")
    def source_controls(self) -> Optional[Sequence['outputs.DashboardCascadingControlSource']]:
        return pulumi.get(self, "source_controls")


@pulumi.output_type
class DashboardCascadingControlSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnToMatch":
            suggest = "column_to_match"
        elif key == "sourceSheetControlId":
            suggest = "source_sheet_control_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCascadingControlSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCascadingControlSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCascadingControlSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_to_match: Optional['outputs.DashboardColumnIdentifier'] = None,
                 source_sheet_control_id: Optional[str] = None):
        DashboardCascadingControlSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_to_match=column_to_match,
            source_sheet_control_id=source_sheet_control_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_to_match: Optional['outputs.DashboardColumnIdentifier'] = None,
             source_sheet_control_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_to_match is not None:
            _setter("column_to_match", column_to_match)
        if source_sheet_control_id is not None:
            _setter("source_sheet_control_id", source_sheet_control_id)

    @property
    @pulumi.getter(name="columnToMatch")
    def column_to_match(self) -> Optional['outputs.DashboardColumnIdentifier']:
        return pulumi.get(self, "column_to_match")

    @property
    @pulumi.getter(name="sourceSheetControlId")
    def source_sheet_control_id(self) -> Optional[str]:
        return pulumi.get(self, "source_sheet_control_id")


@pulumi.output_type
class DashboardCategoricalDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "hierarchyId":
            suggest = "hierarchy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCategoricalDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCategoricalDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCategoricalDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 field_id: str,
                 format_configuration: Optional['outputs.DashboardStringFormatConfiguration'] = None,
                 hierarchy_id: Optional[str] = None):
        DashboardCategoricalDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            format_configuration=format_configuration,
            hierarchy_id=hierarchy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             field_id: str,
             format_configuration: Optional['outputs.DashboardStringFormatConfiguration'] = None,
             hierarchy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if hierarchy_id is not None:
            _setter("hierarchy_id", hierarchy_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.DashboardStringFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> Optional[str]:
        return pulumi.get(self, "hierarchy_id")


@pulumi.output_type
class DashboardCategoricalMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCategoricalMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCategoricalMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCategoricalMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 field_id: str,
                 aggregation_function: Optional['DashboardCategoricalAggregationFunction'] = None,
                 format_configuration: Optional['outputs.DashboardStringFormatConfiguration'] = None):
        DashboardCategoricalMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            aggregation_function=aggregation_function,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             field_id: str,
             aggregation_function: Optional['DashboardCategoricalAggregationFunction'] = None,
             format_configuration: Optional['outputs.DashboardStringFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['DashboardCategoricalAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.DashboardStringFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class DashboardCategoryDrillDownFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryValues":
            suggest = "category_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCategoryDrillDownFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCategoryDrillDownFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCategoryDrillDownFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_values: Sequence[str],
                 column: 'outputs.DashboardColumnIdentifier'):
        DashboardCategoryDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_values=category_values,
            column=column,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_values: Sequence[str],
             column: 'outputs.DashboardColumnIdentifier',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("category_values", category_values)
        _setter("column", column)

    @property
    @pulumi.getter(name="categoryValues")
    def category_values(self) -> Sequence[str]:
        return pulumi.get(self, "category_values")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")


@pulumi.output_type
class DashboardCategoryFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCategoryFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCategoryFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCategoryFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 configuration: 'outputs.DashboardCategoryFilterConfiguration',
                 filter_id: str):
        DashboardCategoryFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            configuration=configuration,
            filter_id=filter_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             configuration: 'outputs.DashboardCategoryFilterConfiguration',
             filter_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("configuration", configuration)
        _setter("filter_id", filter_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.DashboardCategoryFilterConfiguration':
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")


@pulumi.output_type
class DashboardCategoryFilterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customFilterConfiguration":
            suggest = "custom_filter_configuration"
        elif key == "customFilterListConfiguration":
            suggest = "custom_filter_list_configuration"
        elif key == "filterListConfiguration":
            suggest = "filter_list_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCategoryFilterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCategoryFilterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCategoryFilterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_filter_configuration: Optional['outputs.DashboardCustomFilterConfiguration'] = None,
                 custom_filter_list_configuration: Optional['outputs.DashboardCustomFilterListConfiguration'] = None,
                 filter_list_configuration: Optional['outputs.DashboardFilterListConfiguration'] = None):
        DashboardCategoryFilterConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_filter_configuration=custom_filter_configuration,
            custom_filter_list_configuration=custom_filter_list_configuration,
            filter_list_configuration=filter_list_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_filter_configuration: Optional['outputs.DashboardCustomFilterConfiguration'] = None,
             custom_filter_list_configuration: Optional['outputs.DashboardCustomFilterListConfiguration'] = None,
             filter_list_configuration: Optional['outputs.DashboardFilterListConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_filter_configuration is not None:
            _setter("custom_filter_configuration", custom_filter_configuration)
        if custom_filter_list_configuration is not None:
            _setter("custom_filter_list_configuration", custom_filter_list_configuration)
        if filter_list_configuration is not None:
            _setter("filter_list_configuration", filter_list_configuration)

    @property
    @pulumi.getter(name="customFilterConfiguration")
    def custom_filter_configuration(self) -> Optional['outputs.DashboardCustomFilterConfiguration']:
        return pulumi.get(self, "custom_filter_configuration")

    @property
    @pulumi.getter(name="customFilterListConfiguration")
    def custom_filter_list_configuration(self) -> Optional['outputs.DashboardCustomFilterListConfiguration']:
        return pulumi.get(self, "custom_filter_list_configuration")

    @property
    @pulumi.getter(name="filterListConfiguration")
    def filter_list_configuration(self) -> Optional['outputs.DashboardFilterListConfiguration']:
        return pulumi.get(self, "filter_list_configuration")


@pulumi.output_type
class DashboardChartAxisLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisLabelOptions":
            suggest = "axis_label_options"
        elif key == "sortIconVisibility":
            suggest = "sort_icon_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardChartAxisLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardChartAxisLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardChartAxisLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_label_options: Optional[Sequence['outputs.DashboardAxisLabelOptions']] = None,
                 sort_icon_visibility: Optional['DashboardVisibility'] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardChartAxisLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_label_options=axis_label_options,
            sort_icon_visibility=sort_icon_visibility,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_label_options: Optional[Sequence['outputs.DashboardAxisLabelOptions']] = None,
             sort_icon_visibility: Optional['DashboardVisibility'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_label_options is not None:
            _setter("axis_label_options", axis_label_options)
        if sort_icon_visibility is not None:
            _setter("sort_icon_visibility", sort_icon_visibility)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="axisLabelOptions")
    def axis_label_options(self) -> Optional[Sequence['outputs.DashboardAxisLabelOptions']]:
        return pulumi.get(self, "axis_label_options")

    @property
    @pulumi.getter(name="sortIconVisibility")
    def sort_icon_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "sort_icon_visibility")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardClusterMarker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simpleClusterMarker":
            suggest = "simple_cluster_marker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardClusterMarker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardClusterMarker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardClusterMarker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 simple_cluster_marker: Optional['outputs.DashboardSimpleClusterMarker'] = None):
        DashboardClusterMarker._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            simple_cluster_marker=simple_cluster_marker,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             simple_cluster_marker: Optional['outputs.DashboardSimpleClusterMarker'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if simple_cluster_marker is not None:
            _setter("simple_cluster_marker", simple_cluster_marker)

    @property
    @pulumi.getter(name="simpleClusterMarker")
    def simple_cluster_marker(self) -> Optional['outputs.DashboardSimpleClusterMarker']:
        return pulumi.get(self, "simple_cluster_marker")


@pulumi.output_type
class DashboardClusterMarkerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterMarker":
            suggest = "cluster_marker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardClusterMarkerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardClusterMarkerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardClusterMarkerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_marker: Optional['outputs.DashboardClusterMarker'] = None):
        DashboardClusterMarkerConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_marker=cluster_marker,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_marker: Optional['outputs.DashboardClusterMarker'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cluster_marker is not None:
            _setter("cluster_marker", cluster_marker)

    @property
    @pulumi.getter(name="clusterMarker")
    def cluster_marker(self) -> Optional['outputs.DashboardClusterMarker']:
        return pulumi.get(self, "cluster_marker")


@pulumi.output_type
class DashboardColorScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorFillType":
            suggest = "color_fill_type"
        elif key == "nullValueColor":
            suggest = "null_value_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardColorScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardColorScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardColorScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_fill_type: 'DashboardColorFillType',
                 colors: Sequence['outputs.DashboardDataColor'],
                 null_value_color: Optional['outputs.DashboardDataColor'] = None):
        DashboardColorScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_fill_type=color_fill_type,
            colors=colors,
            null_value_color=null_value_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_fill_type: 'DashboardColorFillType',
             colors: Sequence['outputs.DashboardDataColor'],
             null_value_color: Optional['outputs.DashboardDataColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color_fill_type", color_fill_type)
        _setter("colors", colors)
        if null_value_color is not None:
            _setter("null_value_color", null_value_color)

    @property
    @pulumi.getter(name="colorFillType")
    def color_fill_type(self) -> 'DashboardColorFillType':
        return pulumi.get(self, "color_fill_type")

    @property
    @pulumi.getter
    def colors(self) -> Sequence['outputs.DashboardDataColor']:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="nullValueColor")
    def null_value_color(self) -> Optional['outputs.DashboardDataColor']:
        return pulumi.get(self, "null_value_color")


@pulumi.output_type
class DashboardColorsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customColors":
            suggest = "custom_colors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardColorsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardColorsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardColorsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_colors: Optional[Sequence['outputs.DashboardCustomColor']] = None):
        DashboardColorsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_colors=custom_colors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_colors: Optional[Sequence['outputs.DashboardCustomColor']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_colors is not None:
            _setter("custom_colors", custom_colors)

    @property
    @pulumi.getter(name="customColors")
    def custom_colors(self) -> Optional[Sequence['outputs.DashboardCustomColor']]:
        return pulumi.get(self, "custom_colors")


@pulumi.output_type
class DashboardColumnConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorsConfiguration":
            suggest = "colors_configuration"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardColumnConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardColumnConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardColumnConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 colors_configuration: Optional['outputs.DashboardColorsConfiguration'] = None,
                 format_configuration: Optional['outputs.DashboardFormatConfiguration'] = None,
                 role: Optional['DashboardColumnRole'] = None):
        DashboardColumnConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            colors_configuration=colors_configuration,
            format_configuration=format_configuration,
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             colors_configuration: Optional['outputs.DashboardColorsConfiguration'] = None,
             format_configuration: Optional['outputs.DashboardFormatConfiguration'] = None,
             role: Optional['DashboardColumnRole'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        if colors_configuration is not None:
            _setter("colors_configuration", colors_configuration)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if role is not None:
            _setter("role", role)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="colorsConfiguration")
    def colors_configuration(self) -> Optional['outputs.DashboardColorsConfiguration']:
        return pulumi.get(self, "colors_configuration")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.DashboardFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter
    def role(self) -> Optional['DashboardColumnRole']:
        return pulumi.get(self, "role")


@pulumi.output_type
class DashboardColumnHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeHierarchy":
            suggest = "date_time_hierarchy"
        elif key == "explicitHierarchy":
            suggest = "explicit_hierarchy"
        elif key == "predefinedHierarchy":
            suggest = "predefined_hierarchy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardColumnHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardColumnHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardColumnHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_hierarchy: Optional['outputs.DashboardDateTimeHierarchy'] = None,
                 explicit_hierarchy: Optional['outputs.DashboardExplicitHierarchy'] = None,
                 predefined_hierarchy: Optional['outputs.DashboardPredefinedHierarchy'] = None):
        DashboardColumnHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_hierarchy=date_time_hierarchy,
            explicit_hierarchy=explicit_hierarchy,
            predefined_hierarchy=predefined_hierarchy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_hierarchy: Optional['outputs.DashboardDateTimeHierarchy'] = None,
             explicit_hierarchy: Optional['outputs.DashboardExplicitHierarchy'] = None,
             predefined_hierarchy: Optional['outputs.DashboardPredefinedHierarchy'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_hierarchy is not None:
            _setter("date_time_hierarchy", date_time_hierarchy)
        if explicit_hierarchy is not None:
            _setter("explicit_hierarchy", explicit_hierarchy)
        if predefined_hierarchy is not None:
            _setter("predefined_hierarchy", predefined_hierarchy)

    @property
    @pulumi.getter(name="dateTimeHierarchy")
    def date_time_hierarchy(self) -> Optional['outputs.DashboardDateTimeHierarchy']:
        return pulumi.get(self, "date_time_hierarchy")

    @property
    @pulumi.getter(name="explicitHierarchy")
    def explicit_hierarchy(self) -> Optional['outputs.DashboardExplicitHierarchy']:
        return pulumi.get(self, "explicit_hierarchy")

    @property
    @pulumi.getter(name="predefinedHierarchy")
    def predefined_hierarchy(self) -> Optional['outputs.DashboardPredefinedHierarchy']:
        return pulumi.get(self, "predefined_hierarchy")


@pulumi.output_type
class DashboardColumnIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "dataSetIdentifier":
            suggest = "data_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardColumnIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardColumnIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardColumnIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 data_set_identifier: str):
        DashboardColumnIdentifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            data_set_identifier=data_set_identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: str,
             data_set_identifier: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column_name", column_name)
        _setter("data_set_identifier", data_set_identifier)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")


@pulumi.output_type
class DashboardColumnSort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortBy":
            suggest = "sort_by"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardColumnSort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardColumnSort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardColumnSort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: 'DashboardSortDirection',
                 sort_by: 'outputs.DashboardColumnIdentifier',
                 aggregation_function: Optional['outputs.DashboardAggregationFunction'] = None):
        DashboardColumnSort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            sort_by=sort_by,
            aggregation_function=aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: 'DashboardSortDirection',
             sort_by: 'outputs.DashboardColumnIdentifier',
             aggregation_function: Optional['outputs.DashboardAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("direction", direction)
        _setter("sort_by", sort_by)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)

    @property
    @pulumi.getter
    def direction(self) -> 'DashboardSortDirection':
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="sortBy")
    def sort_by(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "sort_by")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.DashboardAggregationFunction']:
        return pulumi.get(self, "aggregation_function")


@pulumi.output_type
class DashboardColumnTooltipItem(dict):
    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 aggregation: Optional['outputs.DashboardAggregationFunction'] = None,
                 label: Optional[str] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardColumnTooltipItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            aggregation=aggregation,
            label=label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             aggregation: Optional['outputs.DashboardAggregationFunction'] = None,
             label: Optional[str] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if label is not None:
            _setter("label", label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional['outputs.DashboardAggregationFunction']:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardComboChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barValues":
            suggest = "bar_values"
        elif key == "lineValues":
            suggest = "line_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardComboChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardComboChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardComboChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
                 category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 colors: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 line_values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardComboChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_values=bar_values,
            category=category,
            colors=colors,
            line_values=line_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             colors: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             line_values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_values is not None:
            _setter("bar_values", bar_values)
        if category is not None:
            _setter("category", category)
        if colors is not None:
            _setter("colors", colors)
        if line_values is not None:
            _setter("line_values", line_values)

    @property
    @pulumi.getter(name="barValues")
    def bar_values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "bar_values")

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="lineValues")
    def line_values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "line_values")


@pulumi.output_type
class DashboardComboChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barDataLabels":
            suggest = "bar_data_labels"
        elif key == "barsArrangement":
            suggest = "bars_arrangement"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "lineDataLabels":
            suggest = "line_data_labels"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "secondaryYAxisDisplayOptions":
            suggest = "secondary_y_axis_display_options"
        elif key == "secondaryYAxisLabelOptions":
            suggest = "secondary_y_axis_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardComboChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardComboChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardComboChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 bars_arrangement: Optional['DashboardBarsArrangement'] = None,
                 category_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 color_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardComboChartFieldWells'] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 line_data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 reference_lines: Optional[Sequence['outputs.DashboardReferenceLine']] = None,
                 secondary_y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 secondary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.DashboardComboChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None):
        DashboardComboChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_data_labels=bar_data_labels,
            bars_arrangement=bars_arrangement,
            category_axis=category_axis,
            category_label_options=category_label_options,
            color_label_options=color_label_options,
            field_wells=field_wells,
            legend=legend,
            line_data_labels=line_data_labels,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            reference_lines=reference_lines,
            secondary_y_axis_display_options=secondary_y_axis_display_options,
            secondary_y_axis_label_options=secondary_y_axis_label_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             bars_arrangement: Optional['DashboardBarsArrangement'] = None,
             category_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             color_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardComboChartFieldWells'] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             line_data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             reference_lines: Optional[Sequence['outputs.DashboardReferenceLine']] = None,
             secondary_y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             secondary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.DashboardComboChartSortConfiguration'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_data_labels is not None:
            _setter("bar_data_labels", bar_data_labels)
        if bars_arrangement is not None:
            _setter("bars_arrangement", bars_arrangement)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if line_data_labels is not None:
            _setter("line_data_labels", line_data_labels)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if secondary_y_axis_display_options is not None:
            _setter("secondary_y_axis_display_options", secondary_y_axis_display_options)
        if secondary_y_axis_label_options is not None:
            _setter("secondary_y_axis_label_options", secondary_y_axis_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="barDataLabels")
    def bar_data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "bar_data_labels")

    @property
    @pulumi.getter(name="barsArrangement")
    def bars_arrangement(self) -> Optional['DashboardBarsArrangement']:
        return pulumi.get(self, "bars_arrangement")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardComboChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="lineDataLabels")
    def line_data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "line_data_labels")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.DashboardReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="secondaryYAxisDisplayOptions")
    def secondary_y_axis_display_options(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "secondary_y_axis_display_options")

    @property
    @pulumi.getter(name="secondaryYAxisLabelOptions")
    def secondary_y_axis_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "secondary_y_axis_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardComboChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class DashboardComboChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comboChartAggregatedFieldWells":
            suggest = "combo_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardComboChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardComboChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardComboChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 combo_chart_aggregated_field_wells: Optional['outputs.DashboardComboChartAggregatedFieldWells'] = None):
        DashboardComboChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            combo_chart_aggregated_field_wells=combo_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             combo_chart_aggregated_field_wells: Optional['outputs.DashboardComboChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if combo_chart_aggregated_field_wells is not None:
            _setter("combo_chart_aggregated_field_wells", combo_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="comboChartAggregatedFieldWells")
    def combo_chart_aggregated_field_wells(self) -> Optional['outputs.DashboardComboChartAggregatedFieldWells']:
        return pulumi.get(self, "combo_chart_aggregated_field_wells")


@pulumi.output_type
class DashboardComboChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimit":
            suggest = "color_items_limit"
        elif key == "colorSort":
            suggest = "color_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardComboChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardComboChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardComboChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
                 color_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 color_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardComboChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            color_items_limit=color_items_limit,
            color_sort=color_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             color_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             color_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit is not None:
            _setter("color_items_limit", color_items_limit)
        if color_sort is not None:
            _setter("color_sort", color_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimit")
    def color_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit")

    @property
    @pulumi.getter(name="colorSort")
    def color_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "color_sort")


@pulumi.output_type
class DashboardComboChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardComboChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardComboChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardComboChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardComboChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardComboChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardComboChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardComboChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardComparisonConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonFormat":
            suggest = "comparison_format"
        elif key == "comparisonMethod":
            suggest = "comparison_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardComparisonConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardComparisonConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardComparisonConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_format: Optional['outputs.DashboardComparisonFormatConfiguration'] = None,
                 comparison_method: Optional['DashboardComparisonMethod'] = None):
        DashboardComparisonConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_format=comparison_format,
            comparison_method=comparison_method,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_format: Optional['outputs.DashboardComparisonFormatConfiguration'] = None,
             comparison_method: Optional['DashboardComparisonMethod'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if comparison_format is not None:
            _setter("comparison_format", comparison_format)
        if comparison_method is not None:
            _setter("comparison_method", comparison_method)

    @property
    @pulumi.getter(name="comparisonFormat")
    def comparison_format(self) -> Optional['outputs.DashboardComparisonFormatConfiguration']:
        return pulumi.get(self, "comparison_format")

    @property
    @pulumi.getter(name="comparisonMethod")
    def comparison_method(self) -> Optional['DashboardComparisonMethod']:
        return pulumi.get(self, "comparison_method")


@pulumi.output_type
class DashboardComparisonFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberDisplayFormatConfiguration":
            suggest = "number_display_format_configuration"
        elif key == "percentageDisplayFormatConfiguration":
            suggest = "percentage_display_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardComparisonFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardComparisonFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardComparisonFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_display_format_configuration: Optional['outputs.DashboardNumberDisplayFormatConfiguration'] = None,
                 percentage_display_format_configuration: Optional['outputs.DashboardPercentageDisplayFormatConfiguration'] = None):
        DashboardComparisonFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            number_display_format_configuration=number_display_format_configuration,
            percentage_display_format_configuration=percentage_display_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             number_display_format_configuration: Optional['outputs.DashboardNumberDisplayFormatConfiguration'] = None,
             percentage_display_format_configuration: Optional['outputs.DashboardPercentageDisplayFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if number_display_format_configuration is not None:
            _setter("number_display_format_configuration", number_display_format_configuration)
        if percentage_display_format_configuration is not None:
            _setter("percentage_display_format_configuration", percentage_display_format_configuration)

    @property
    @pulumi.getter(name="numberDisplayFormatConfiguration")
    def number_display_format_configuration(self) -> Optional['outputs.DashboardNumberDisplayFormatConfiguration']:
        return pulumi.get(self, "number_display_format_configuration")

    @property
    @pulumi.getter(name="percentageDisplayFormatConfiguration")
    def percentage_display_format_configuration(self) -> Optional['outputs.DashboardPercentageDisplayFormatConfiguration']:
        return pulumi.get(self, "percentage_display_format_configuration")


@pulumi.output_type
class DashboardComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "growthRate":
            suggest = "growth_rate"
        elif key == "maximumMinimum":
            suggest = "maximum_minimum"
        elif key == "metricComparison":
            suggest = "metric_comparison"
        elif key == "periodOverPeriod":
            suggest = "period_over_period"
        elif key == "periodToDate":
            suggest = "period_to_date"
        elif key == "topBottomMovers":
            suggest = "top_bottom_movers"
        elif key == "topBottomRanked":
            suggest = "top_bottom_ranked"
        elif key == "totalAggregation":
            suggest = "total_aggregation"
        elif key == "uniqueValues":
            suggest = "unique_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forecast: Optional['outputs.DashboardForecastComputation'] = None,
                 growth_rate: Optional['outputs.DashboardGrowthRateComputation'] = None,
                 maximum_minimum: Optional['outputs.DashboardMaximumMinimumComputation'] = None,
                 metric_comparison: Optional['outputs.DashboardMetricComparisonComputation'] = None,
                 period_over_period: Optional['outputs.DashboardPeriodOverPeriodComputation'] = None,
                 period_to_date: Optional['outputs.DashboardPeriodToDateComputation'] = None,
                 top_bottom_movers: Optional['outputs.DashboardTopBottomMoversComputation'] = None,
                 top_bottom_ranked: Optional['outputs.DashboardTopBottomRankedComputation'] = None,
                 total_aggregation: Optional['outputs.DashboardTotalAggregationComputation'] = None,
                 unique_values: Optional['outputs.DashboardUniqueValuesComputation'] = None):
        DashboardComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forecast=forecast,
            growth_rate=growth_rate,
            maximum_minimum=maximum_minimum,
            metric_comparison=metric_comparison,
            period_over_period=period_over_period,
            period_to_date=period_to_date,
            top_bottom_movers=top_bottom_movers,
            top_bottom_ranked=top_bottom_ranked,
            total_aggregation=total_aggregation,
            unique_values=unique_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forecast: Optional['outputs.DashboardForecastComputation'] = None,
             growth_rate: Optional['outputs.DashboardGrowthRateComputation'] = None,
             maximum_minimum: Optional['outputs.DashboardMaximumMinimumComputation'] = None,
             metric_comparison: Optional['outputs.DashboardMetricComparisonComputation'] = None,
             period_over_period: Optional['outputs.DashboardPeriodOverPeriodComputation'] = None,
             period_to_date: Optional['outputs.DashboardPeriodToDateComputation'] = None,
             top_bottom_movers: Optional['outputs.DashboardTopBottomMoversComputation'] = None,
             top_bottom_ranked: Optional['outputs.DashboardTopBottomRankedComputation'] = None,
             total_aggregation: Optional['outputs.DashboardTotalAggregationComputation'] = None,
             unique_values: Optional['outputs.DashboardUniqueValuesComputation'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if forecast is not None:
            _setter("forecast", forecast)
        if growth_rate is not None:
            _setter("growth_rate", growth_rate)
        if maximum_minimum is not None:
            _setter("maximum_minimum", maximum_minimum)
        if metric_comparison is not None:
            _setter("metric_comparison", metric_comparison)
        if period_over_period is not None:
            _setter("period_over_period", period_over_period)
        if period_to_date is not None:
            _setter("period_to_date", period_to_date)
        if top_bottom_movers is not None:
            _setter("top_bottom_movers", top_bottom_movers)
        if top_bottom_ranked is not None:
            _setter("top_bottom_ranked", top_bottom_ranked)
        if total_aggregation is not None:
            _setter("total_aggregation", total_aggregation)
        if unique_values is not None:
            _setter("unique_values", unique_values)

    @property
    @pulumi.getter
    def forecast(self) -> Optional['outputs.DashboardForecastComputation']:
        return pulumi.get(self, "forecast")

    @property
    @pulumi.getter(name="growthRate")
    def growth_rate(self) -> Optional['outputs.DashboardGrowthRateComputation']:
        return pulumi.get(self, "growth_rate")

    @property
    @pulumi.getter(name="maximumMinimum")
    def maximum_minimum(self) -> Optional['outputs.DashboardMaximumMinimumComputation']:
        return pulumi.get(self, "maximum_minimum")

    @property
    @pulumi.getter(name="metricComparison")
    def metric_comparison(self) -> Optional['outputs.DashboardMetricComparisonComputation']:
        return pulumi.get(self, "metric_comparison")

    @property
    @pulumi.getter(name="periodOverPeriod")
    def period_over_period(self) -> Optional['outputs.DashboardPeriodOverPeriodComputation']:
        return pulumi.get(self, "period_over_period")

    @property
    @pulumi.getter(name="periodToDate")
    def period_to_date(self) -> Optional['outputs.DashboardPeriodToDateComputation']:
        return pulumi.get(self, "period_to_date")

    @property
    @pulumi.getter(name="topBottomMovers")
    def top_bottom_movers(self) -> Optional['outputs.DashboardTopBottomMoversComputation']:
        return pulumi.get(self, "top_bottom_movers")

    @property
    @pulumi.getter(name="topBottomRanked")
    def top_bottom_ranked(self) -> Optional['outputs.DashboardTopBottomRankedComputation']:
        return pulumi.get(self, "top_bottom_ranked")

    @property
    @pulumi.getter(name="totalAggregation")
    def total_aggregation(self) -> Optional['outputs.DashboardTotalAggregationComputation']:
        return pulumi.get(self, "total_aggregation")

    @property
    @pulumi.getter(name="uniqueValues")
    def unique_values(self) -> Optional['outputs.DashboardUniqueValuesComputation']:
        return pulumi.get(self, "unique_values")


@pulumi.output_type
class DashboardConditionalFormattingColor(dict):
    def __init__(__self__, *,
                 gradient: Optional['outputs.DashboardConditionalFormattingGradientColor'] = None,
                 solid: Optional['outputs.DashboardConditionalFormattingSolidColor'] = None):
        DashboardConditionalFormattingColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gradient=gradient,
            solid=solid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gradient: Optional['outputs.DashboardConditionalFormattingGradientColor'] = None,
             solid: Optional['outputs.DashboardConditionalFormattingSolidColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if gradient is not None:
            _setter("gradient", gradient)
        if solid is not None:
            _setter("solid", solid)

    @property
    @pulumi.getter
    def gradient(self) -> Optional['outputs.DashboardConditionalFormattingGradientColor']:
        return pulumi.get(self, "gradient")

    @property
    @pulumi.getter
    def solid(self) -> Optional['outputs.DashboardConditionalFormattingSolidColor']:
        return pulumi.get(self, "solid")


@pulumi.output_type
class DashboardConditionalFormattingCustomIconCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iconOptions":
            suggest = "icon_options"
        elif key == "displayConfiguration":
            suggest = "display_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardConditionalFormattingCustomIconCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardConditionalFormattingCustomIconCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardConditionalFormattingCustomIconCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 icon_options: 'outputs.DashboardConditionalFormattingCustomIconOptions',
                 color: Optional[str] = None,
                 display_configuration: Optional['outputs.DashboardConditionalFormattingIconDisplayConfiguration'] = None):
        DashboardConditionalFormattingCustomIconCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            icon_options=icon_options,
            color=color,
            display_configuration=display_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             icon_options: 'outputs.DashboardConditionalFormattingCustomIconOptions',
             color: Optional[str] = None,
             display_configuration: Optional['outputs.DashboardConditionalFormattingIconDisplayConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        _setter("icon_options", icon_options)
        if color is not None:
            _setter("color", color)
        if display_configuration is not None:
            _setter("display_configuration", display_configuration)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="iconOptions")
    def icon_options(self) -> 'outputs.DashboardConditionalFormattingCustomIconOptions':
        return pulumi.get(self, "icon_options")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="displayConfiguration")
    def display_configuration(self) -> Optional['outputs.DashboardConditionalFormattingIconDisplayConfiguration']:
        return pulumi.get(self, "display_configuration")


@pulumi.output_type
class DashboardConditionalFormattingCustomIconOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unicodeIcon":
            suggest = "unicode_icon"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardConditionalFormattingCustomIconOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardConditionalFormattingCustomIconOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardConditionalFormattingCustomIconOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['DashboardIcon'] = None,
                 unicode_icon: Optional[str] = None):
        DashboardConditionalFormattingCustomIconOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            unicode_icon=unicode_icon,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['DashboardIcon'] = None,
             unicode_icon: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if unicode_icon is not None:
            _setter("unicode_icon", unicode_icon)

    @property
    @pulumi.getter
    def icon(self) -> Optional['DashboardIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="unicodeIcon")
    def unicode_icon(self) -> Optional[str]:
        return pulumi.get(self, "unicode_icon")


@pulumi.output_type
class DashboardConditionalFormattingGradientColor(dict):
    def __init__(__self__, *,
                 color: 'outputs.DashboardGradientColor',
                 expression: str):
        DashboardConditionalFormattingGradientColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: 'outputs.DashboardGradientColor',
             expression: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)
        _setter("expression", expression)

    @property
    @pulumi.getter
    def color(self) -> 'outputs.DashboardGradientColor':
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")


@pulumi.output_type
class DashboardConditionalFormattingIcon(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customCondition":
            suggest = "custom_condition"
        elif key == "iconSet":
            suggest = "icon_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardConditionalFormattingIcon. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardConditionalFormattingIcon.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardConditionalFormattingIcon.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_condition: Optional['outputs.DashboardConditionalFormattingCustomIconCondition'] = None,
                 icon_set: Optional['outputs.DashboardConditionalFormattingIconSet'] = None):
        DashboardConditionalFormattingIcon._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_condition=custom_condition,
            icon_set=icon_set,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_condition: Optional['outputs.DashboardConditionalFormattingCustomIconCondition'] = None,
             icon_set: Optional['outputs.DashboardConditionalFormattingIconSet'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_condition is not None:
            _setter("custom_condition", custom_condition)
        if icon_set is not None:
            _setter("icon_set", icon_set)

    @property
    @pulumi.getter(name="customCondition")
    def custom_condition(self) -> Optional['outputs.DashboardConditionalFormattingCustomIconCondition']:
        return pulumi.get(self, "custom_condition")

    @property
    @pulumi.getter(name="iconSet")
    def icon_set(self) -> Optional['outputs.DashboardConditionalFormattingIconSet']:
        return pulumi.get(self, "icon_set")


@pulumi.output_type
class DashboardConditionalFormattingIconDisplayConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iconDisplayOption":
            suggest = "icon_display_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardConditionalFormattingIconDisplayConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardConditionalFormattingIconDisplayConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardConditionalFormattingIconDisplayConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon_display_option: Optional['DashboardConditionalFormattingIconDisplayOption'] = None):
        DashboardConditionalFormattingIconDisplayConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon_display_option=icon_display_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon_display_option: Optional['DashboardConditionalFormattingIconDisplayOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon_display_option is not None:
            _setter("icon_display_option", icon_display_option)

    @property
    @pulumi.getter(name="iconDisplayOption")
    def icon_display_option(self) -> Optional['DashboardConditionalFormattingIconDisplayOption']:
        return pulumi.get(self, "icon_display_option")


@pulumi.output_type
class DashboardConditionalFormattingIconSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iconSetType":
            suggest = "icon_set_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardConditionalFormattingIconSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardConditionalFormattingIconSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardConditionalFormattingIconSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 icon_set_type: Optional['DashboardConditionalFormattingIconSetType'] = None):
        DashboardConditionalFormattingIconSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            icon_set_type=icon_set_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             icon_set_type: Optional['DashboardConditionalFormattingIconSetType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if icon_set_type is not None:
            _setter("icon_set_type", icon_set_type)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="iconSetType")
    def icon_set_type(self) -> Optional['DashboardConditionalFormattingIconSetType']:
        return pulumi.get(self, "icon_set_type")


@pulumi.output_type
class DashboardConditionalFormattingSolidColor(dict):
    def __init__(__self__, *,
                 expression: str,
                 color: Optional[str] = None):
        DashboardConditionalFormattingSolidColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            color=color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             color: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if color is not None:
            _setter("color", color)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")


@pulumi.output_type
class DashboardContributionAnalysisDefault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributorDimensions":
            suggest = "contributor_dimensions"
        elif key == "measureFieldId":
            suggest = "measure_field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardContributionAnalysisDefault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardContributionAnalysisDefault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardContributionAnalysisDefault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contributor_dimensions: Sequence['outputs.DashboardColumnIdentifier'],
                 measure_field_id: str):
        DashboardContributionAnalysisDefault._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contributor_dimensions=contributor_dimensions,
            measure_field_id=measure_field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contributor_dimensions: Sequence['outputs.DashboardColumnIdentifier'],
             measure_field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("contributor_dimensions", contributor_dimensions)
        _setter("measure_field_id", measure_field_id)

    @property
    @pulumi.getter(name="contributorDimensions")
    def contributor_dimensions(self) -> Sequence['outputs.DashboardColumnIdentifier']:
        return pulumi.get(self, "contributor_dimensions")

    @property
    @pulumi.getter(name="measureFieldId")
    def measure_field_id(self) -> str:
        return pulumi.get(self, "measure_field_id")


@pulumi.output_type
class DashboardCurrencyDisplayFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlacesConfiguration":
            suggest = "decimal_places_configuration"
        elif key == "negativeValueConfiguration":
            suggest = "negative_value_configuration"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numberScale":
            suggest = "number_scale"
        elif key == "separatorConfiguration":
            suggest = "separator_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCurrencyDisplayFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCurrencyDisplayFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCurrencyDisplayFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places_configuration: Optional['outputs.DashboardDecimalPlacesConfiguration'] = None,
                 negative_value_configuration: Optional['outputs.DashboardNegativeValueConfiguration'] = None,
                 null_value_format_configuration: Optional['outputs.DashboardNullValueFormatConfiguration'] = None,
                 number_scale: Optional['DashboardNumberScale'] = None,
                 prefix: Optional[str] = None,
                 separator_configuration: Optional['outputs.DashboardNumericSeparatorConfiguration'] = None,
                 suffix: Optional[str] = None,
                 symbol: Optional[str] = None):
        DashboardCurrencyDisplayFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places_configuration=decimal_places_configuration,
            negative_value_configuration=negative_value_configuration,
            null_value_format_configuration=null_value_format_configuration,
            number_scale=number_scale,
            prefix=prefix,
            separator_configuration=separator_configuration,
            suffix=suffix,
            symbol=symbol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places_configuration: Optional['outputs.DashboardDecimalPlacesConfiguration'] = None,
             negative_value_configuration: Optional['outputs.DashboardNegativeValueConfiguration'] = None,
             null_value_format_configuration: Optional['outputs.DashboardNullValueFormatConfiguration'] = None,
             number_scale: Optional['DashboardNumberScale'] = None,
             prefix: Optional[str] = None,
             separator_configuration: Optional['outputs.DashboardNumericSeparatorConfiguration'] = None,
             suffix: Optional[str] = None,
             symbol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_places_configuration is not None:
            _setter("decimal_places_configuration", decimal_places_configuration)
        if negative_value_configuration is not None:
            _setter("negative_value_configuration", negative_value_configuration)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if number_scale is not None:
            _setter("number_scale", number_scale)
        if prefix is not None:
            _setter("prefix", prefix)
        if separator_configuration is not None:
            _setter("separator_configuration", separator_configuration)
        if suffix is not None:
            _setter("suffix", suffix)
        if symbol is not None:
            _setter("symbol", symbol)

    @property
    @pulumi.getter(name="decimalPlacesConfiguration")
    def decimal_places_configuration(self) -> Optional['outputs.DashboardDecimalPlacesConfiguration']:
        return pulumi.get(self, "decimal_places_configuration")

    @property
    @pulumi.getter(name="negativeValueConfiguration")
    def negative_value_configuration(self) -> Optional['outputs.DashboardNegativeValueConfiguration']:
        return pulumi.get(self, "negative_value_configuration")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.DashboardNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numberScale")
    def number_scale(self) -> Optional['DashboardNumberScale']:
        return pulumi.get(self, "number_scale")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="separatorConfiguration")
    def separator_configuration(self) -> Optional['outputs.DashboardNumericSeparatorConfiguration']:
        return pulumi.get(self, "separator_configuration")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter
    def symbol(self) -> Optional[str]:
        return pulumi.get(self, "symbol")


@pulumi.output_type
class DashboardCustomActionFilterOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedFieldsConfiguration":
            suggest = "selected_fields_configuration"
        elif key == "targetVisualsConfiguration":
            suggest = "target_visuals_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCustomActionFilterOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCustomActionFilterOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCustomActionFilterOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_fields_configuration: 'outputs.DashboardFilterOperationSelectedFieldsConfiguration',
                 target_visuals_configuration: 'outputs.DashboardFilterOperationTargetVisualsConfiguration'):
        DashboardCustomActionFilterOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_fields_configuration=selected_fields_configuration,
            target_visuals_configuration=target_visuals_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_fields_configuration: 'outputs.DashboardFilterOperationSelectedFieldsConfiguration',
             target_visuals_configuration: 'outputs.DashboardFilterOperationTargetVisualsConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("selected_fields_configuration", selected_fields_configuration)
        _setter("target_visuals_configuration", target_visuals_configuration)

    @property
    @pulumi.getter(name="selectedFieldsConfiguration")
    def selected_fields_configuration(self) -> 'outputs.DashboardFilterOperationSelectedFieldsConfiguration':
        return pulumi.get(self, "selected_fields_configuration")

    @property
    @pulumi.getter(name="targetVisualsConfiguration")
    def target_visuals_configuration(self) -> 'outputs.DashboardFilterOperationTargetVisualsConfiguration':
        return pulumi.get(self, "target_visuals_configuration")


@pulumi.output_type
class DashboardCustomActionNavigationOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localNavigationConfiguration":
            suggest = "local_navigation_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCustomActionNavigationOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCustomActionNavigationOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCustomActionNavigationOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_navigation_configuration: Optional['outputs.DashboardLocalNavigationConfiguration'] = None):
        DashboardCustomActionNavigationOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_navigation_configuration=local_navigation_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_navigation_configuration: Optional['outputs.DashboardLocalNavigationConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if local_navigation_configuration is not None:
            _setter("local_navigation_configuration", local_navigation_configuration)

    @property
    @pulumi.getter(name="localNavigationConfiguration")
    def local_navigation_configuration(self) -> Optional['outputs.DashboardLocalNavigationConfiguration']:
        return pulumi.get(self, "local_navigation_configuration")


@pulumi.output_type
class DashboardCustomActionSetParametersOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueConfigurations":
            suggest = "parameter_value_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCustomActionSetParametersOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCustomActionSetParametersOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCustomActionSetParametersOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_value_configurations: Sequence['outputs.DashboardSetParameterValueConfiguration']):
        DashboardCustomActionSetParametersOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_value_configurations=parameter_value_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_value_configurations: Sequence['outputs.DashboardSetParameterValueConfiguration'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_value_configurations", parameter_value_configurations)

    @property
    @pulumi.getter(name="parameterValueConfigurations")
    def parameter_value_configurations(self) -> Sequence['outputs.DashboardSetParameterValueConfiguration']:
        return pulumi.get(self, "parameter_value_configurations")


@pulumi.output_type
class DashboardCustomActionUrlOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlTarget":
            suggest = "url_target"
        elif key == "urlTemplate":
            suggest = "url_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCustomActionUrlOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCustomActionUrlOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCustomActionUrlOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_target: 'DashboardUrlTargetConfiguration',
                 url_template: str):
        DashboardCustomActionUrlOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url_target=url_target,
            url_template=url_template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url_target: 'DashboardUrlTargetConfiguration',
             url_template: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url_target", url_target)
        _setter("url_template", url_template)

    @property
    @pulumi.getter(name="urlTarget")
    def url_target(self) -> 'DashboardUrlTargetConfiguration':
        return pulumi.get(self, "url_target")

    @property
    @pulumi.getter(name="urlTemplate")
    def url_template(self) -> str:
        return pulumi.get(self, "url_template")


@pulumi.output_type
class DashboardCustomColor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldValue":
            suggest = "field_value"
        elif key == "specialValue":
            suggest = "special_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCustomColor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCustomColor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCustomColor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: str,
                 field_value: Optional[str] = None,
                 special_value: Optional['DashboardSpecialValue'] = None):
        DashboardCustomColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            field_value=field_value,
            special_value=special_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: str,
             field_value: Optional[str] = None,
             special_value: Optional['DashboardSpecialValue'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)
        if field_value is not None:
            _setter("field_value", field_value)
        if special_value is not None:
            _setter("special_value", special_value)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[str]:
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter(name="specialValue")
    def special_value(self) -> Optional['DashboardSpecialValue']:
        return pulumi.get(self, "special_value")


@pulumi.output_type
class DashboardCustomContentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "contentUrl":
            suggest = "content_url"
        elif key == "imageScaling":
            suggest = "image_scaling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCustomContentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCustomContentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCustomContentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional['DashboardCustomContentType'] = None,
                 content_url: Optional[str] = None,
                 image_scaling: Optional['DashboardCustomContentImageScalingConfiguration'] = None):
        DashboardCustomContentConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_type=content_type,
            content_url=content_url,
            image_scaling=image_scaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_type: Optional['DashboardCustomContentType'] = None,
             content_url: Optional[str] = None,
             image_scaling: Optional['DashboardCustomContentImageScalingConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if content_type is not None:
            _setter("content_type", content_type)
        if content_url is not None:
            _setter("content_url", content_url)
        if image_scaling is not None:
            _setter("image_scaling", image_scaling)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional['DashboardCustomContentType']:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="contentUrl")
    def content_url(self) -> Optional[str]:
        return pulumi.get(self, "content_url")

    @property
    @pulumi.getter(name="imageScaling")
    def image_scaling(self) -> Optional['DashboardCustomContentImageScalingConfiguration']:
        return pulumi.get(self, "image_scaling")


@pulumi.output_type
class DashboardCustomContentVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCustomContentVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCustomContentVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCustomContentVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardCustomContentConfiguration'] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardCustomContentVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardCustomContentConfiguration'] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardCustomContentConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardCustomFilterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOperator":
            suggest = "match_operator"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "categoryValue":
            suggest = "category_value"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCustomFilterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCustomFilterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCustomFilterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_operator: 'DashboardCategoryFilterMatchOperator',
                 null_option: 'DashboardFilterNullOption',
                 category_value: Optional[str] = None,
                 parameter_name: Optional[str] = None,
                 select_all_options: Optional['DashboardCategoryFilterSelectAllOptions'] = None):
        DashboardCustomFilterConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_operator=match_operator,
            null_option=null_option,
            category_value=category_value,
            parameter_name=parameter_name,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_operator: 'DashboardCategoryFilterMatchOperator',
             null_option: 'DashboardFilterNullOption',
             category_value: Optional[str] = None,
             parameter_name: Optional[str] = None,
             select_all_options: Optional['DashboardCategoryFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("match_operator", match_operator)
        _setter("null_option", null_option)
        if category_value is not None:
            _setter("category_value", category_value)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'DashboardCategoryFilterMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'DashboardFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="categoryValue")
    def category_value(self) -> Optional[str]:
        return pulumi.get(self, "category_value")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['DashboardCategoryFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class DashboardCustomFilterListConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOperator":
            suggest = "match_operator"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "categoryValues":
            suggest = "category_values"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCustomFilterListConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCustomFilterListConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCustomFilterListConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_operator: 'DashboardCategoryFilterMatchOperator',
                 null_option: 'DashboardFilterNullOption',
                 category_values: Optional[Sequence[str]] = None,
                 select_all_options: Optional['DashboardCategoryFilterSelectAllOptions'] = None):
        DashboardCustomFilterListConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_operator=match_operator,
            null_option=null_option,
            category_values=category_values,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_operator: 'DashboardCategoryFilterMatchOperator',
             null_option: 'DashboardFilterNullOption',
             category_values: Optional[Sequence[str]] = None,
             select_all_options: Optional['DashboardCategoryFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("match_operator", match_operator)
        _setter("null_option", null_option)
        if category_values is not None:
            _setter("category_values", category_values)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'DashboardCategoryFilterMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'DashboardFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="categoryValues")
    def category_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "category_values")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['DashboardCategoryFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class DashboardCustomNarrativeOptions(dict):
    def __init__(__self__, *,
                 narrative: str):
        DashboardCustomNarrativeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            narrative=narrative,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             narrative: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("narrative", narrative)

    @property
    @pulumi.getter
    def narrative(self) -> str:
        return pulumi.get(self, "narrative")


@pulumi.output_type
class DashboardCustomParameterValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeValues":
            suggest = "date_time_values"
        elif key == "decimalValues":
            suggest = "decimal_values"
        elif key == "integerValues":
            suggest = "integer_values"
        elif key == "stringValues":
            suggest = "string_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCustomParameterValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCustomParameterValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCustomParameterValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_values: Optional[Sequence[str]] = None,
                 decimal_values: Optional[Sequence[float]] = None,
                 integer_values: Optional[Sequence[float]] = None,
                 string_values: Optional[Sequence[str]] = None):
        DashboardCustomParameterValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_values=date_time_values,
            decimal_values=decimal_values,
            integer_values=integer_values,
            string_values=string_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_values: Optional[Sequence[str]] = None,
             decimal_values: Optional[Sequence[float]] = None,
             integer_values: Optional[Sequence[float]] = None,
             string_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_values is not None:
            _setter("date_time_values", date_time_values)
        if decimal_values is not None:
            _setter("decimal_values", decimal_values)
        if integer_values is not None:
            _setter("integer_values", integer_values)
        if string_values is not None:
            _setter("string_values", string_values)

    @property
    @pulumi.getter(name="dateTimeValues")
    def date_time_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "date_time_values")

    @property
    @pulumi.getter(name="decimalValues")
    def decimal_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "decimal_values")

    @property
    @pulumi.getter(name="integerValues")
    def integer_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "integer_values")

    @property
    @pulumi.getter(name="stringValues")
    def string_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "string_values")


@pulumi.output_type
class DashboardCustomValuesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValues":
            suggest = "custom_values"
        elif key == "includeNullValue":
            suggest = "include_null_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardCustomValuesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardCustomValuesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardCustomValuesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_values: 'outputs.DashboardCustomParameterValues',
                 include_null_value: Optional[bool] = None):
        DashboardCustomValuesConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_values=custom_values,
            include_null_value=include_null_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_values: 'outputs.DashboardCustomParameterValues',
             include_null_value: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_values", custom_values)
        if include_null_value is not None:
            _setter("include_null_value", include_null_value)

    @property
    @pulumi.getter(name="customValues")
    def custom_values(self) -> 'outputs.DashboardCustomParameterValues':
        return pulumi.get(self, "custom_values")

    @property
    @pulumi.getter(name="includeNullValue")
    def include_null_value(self) -> Optional[bool]:
        return pulumi.get(self, "include_null_value")


@pulumi.output_type
class DashboardDataBarsOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "negativeColor":
            suggest = "negative_color"
        elif key == "positiveColor":
            suggest = "positive_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataBarsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataBarsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataBarsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 negative_color: Optional[str] = None,
                 positive_color: Optional[str] = None):
        DashboardDataBarsOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            negative_color=negative_color,
            positive_color=positive_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             negative_color: Optional[str] = None,
             positive_color: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if negative_color is not None:
            _setter("negative_color", negative_color)
        if positive_color is not None:
            _setter("positive_color", positive_color)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="negativeColor")
    def negative_color(self) -> Optional[str]:
        return pulumi.get(self, "negative_color")

    @property
    @pulumi.getter(name="positiveColor")
    def positive_color(self) -> Optional[str]:
        return pulumi.get(self, "positive_color")


@pulumi.output_type
class DashboardDataColor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataValue":
            suggest = "data_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataColor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataColor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataColor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: Optional[str] = None,
                 data_value: Optional[float] = None):
        DashboardDataColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            data_value=data_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             data_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if data_value is not None:
            _setter("data_value", data_value)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="dataValue")
    def data_value(self) -> Optional[float]:
        return pulumi.get(self, "data_value")


@pulumi.output_type
class DashboardDataFieldSeriesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "fieldId":
            suggest = "field_id"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataFieldSeriesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataFieldSeriesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataFieldSeriesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: 'DashboardAxisBinding',
                 field_id: str,
                 field_value: Optional[str] = None,
                 settings: Optional['outputs.DashboardLineChartSeriesSettings'] = None):
        DashboardDataFieldSeriesItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            field_id=field_id,
            field_value=field_value,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: 'DashboardAxisBinding',
             field_id: str,
             field_value: Optional[str] = None,
             settings: Optional['outputs.DashboardLineChartSeriesSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("axis_binding", axis_binding)
        _setter("field_id", field_id)
        if field_value is not None:
            _setter("field_value", field_value)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> 'DashboardAxisBinding':
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[str]:
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.DashboardLineChartSeriesSettings']:
        return pulumi.get(self, "settings")


@pulumi.output_type
class DashboardDataLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelVisibility":
            suggest = "category_label_visibility"
        elif key == "dataLabelTypes":
            suggest = "data_label_types"
        elif key == "labelColor":
            suggest = "label_color"
        elif key == "labelContent":
            suggest = "label_content"
        elif key == "labelFontConfiguration":
            suggest = "label_font_configuration"
        elif key == "measureLabelVisibility":
            suggest = "measure_label_visibility"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_visibility: Optional['DashboardVisibility'] = None,
                 data_label_types: Optional[Sequence['outputs.DashboardDataLabelType']] = None,
                 label_color: Optional[str] = None,
                 label_content: Optional['DashboardDataLabelContent'] = None,
                 label_font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
                 measure_label_visibility: Optional['DashboardVisibility'] = None,
                 overlap: Optional['DashboardDataLabelOverlap'] = None,
                 position: Optional['DashboardDataLabelPosition'] = None,
                 totals_visibility: Optional['DashboardVisibility'] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardDataLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_visibility=category_label_visibility,
            data_label_types=data_label_types,
            label_color=label_color,
            label_content=label_content,
            label_font_configuration=label_font_configuration,
            measure_label_visibility=measure_label_visibility,
            overlap=overlap,
            position=position,
            totals_visibility=totals_visibility,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_visibility: Optional['DashboardVisibility'] = None,
             data_label_types: Optional[Sequence['outputs.DashboardDataLabelType']] = None,
             label_color: Optional[str] = None,
             label_content: Optional['DashboardDataLabelContent'] = None,
             label_font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
             measure_label_visibility: Optional['DashboardVisibility'] = None,
             overlap: Optional['DashboardDataLabelOverlap'] = None,
             position: Optional['DashboardDataLabelPosition'] = None,
             totals_visibility: Optional['DashboardVisibility'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_visibility is not None:
            _setter("category_label_visibility", category_label_visibility)
        if data_label_types is not None:
            _setter("data_label_types", data_label_types)
        if label_color is not None:
            _setter("label_color", label_color)
        if label_content is not None:
            _setter("label_content", label_content)
        if label_font_configuration is not None:
            _setter("label_font_configuration", label_font_configuration)
        if measure_label_visibility is not None:
            _setter("measure_label_visibility", measure_label_visibility)
        if overlap is not None:
            _setter("overlap", overlap)
        if position is not None:
            _setter("position", position)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="categoryLabelVisibility")
    def category_label_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "category_label_visibility")

    @property
    @pulumi.getter(name="dataLabelTypes")
    def data_label_types(self) -> Optional[Sequence['outputs.DashboardDataLabelType']]:
        return pulumi.get(self, "data_label_types")

    @property
    @pulumi.getter(name="labelColor")
    def label_color(self) -> Optional[str]:
        return pulumi.get(self, "label_color")

    @property
    @pulumi.getter(name="labelContent")
    def label_content(self) -> Optional['DashboardDataLabelContent']:
        return pulumi.get(self, "label_content")

    @property
    @pulumi.getter(name="labelFontConfiguration")
    def label_font_configuration(self) -> Optional['outputs.DashboardFontConfiguration']:
        return pulumi.get(self, "label_font_configuration")

    @property
    @pulumi.getter(name="measureLabelVisibility")
    def measure_label_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "measure_label_visibility")

    @property
    @pulumi.getter
    def overlap(self) -> Optional['DashboardDataLabelOverlap']:
        return pulumi.get(self, "overlap")

    @property
    @pulumi.getter
    def position(self) -> Optional['DashboardDataLabelPosition']:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "totals_visibility")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardDataLabelType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPathLabelType":
            suggest = "data_path_label_type"
        elif key == "fieldLabelType":
            suggest = "field_label_type"
        elif key == "maximumLabelType":
            suggest = "maximum_label_type"
        elif key == "minimumLabelType":
            suggest = "minimum_label_type"
        elif key == "rangeEndsLabelType":
            suggest = "range_ends_label_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataLabelType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataLabelType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataLabelType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_path_label_type: Optional['outputs.DashboardDataPathLabelType'] = None,
                 field_label_type: Optional['outputs.DashboardFieldLabelType'] = None,
                 maximum_label_type: Optional['outputs.DashboardMaximumLabelType'] = None,
                 minimum_label_type: Optional['outputs.DashboardMinimumLabelType'] = None,
                 range_ends_label_type: Optional['outputs.DashboardRangeEndsLabelType'] = None):
        DashboardDataLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_path_label_type=data_path_label_type,
            field_label_type=field_label_type,
            maximum_label_type=maximum_label_type,
            minimum_label_type=minimum_label_type,
            range_ends_label_type=range_ends_label_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_path_label_type: Optional['outputs.DashboardDataPathLabelType'] = None,
             field_label_type: Optional['outputs.DashboardFieldLabelType'] = None,
             maximum_label_type: Optional['outputs.DashboardMaximumLabelType'] = None,
             minimum_label_type: Optional['outputs.DashboardMinimumLabelType'] = None,
             range_ends_label_type: Optional['outputs.DashboardRangeEndsLabelType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_path_label_type is not None:
            _setter("data_path_label_type", data_path_label_type)
        if field_label_type is not None:
            _setter("field_label_type", field_label_type)
        if maximum_label_type is not None:
            _setter("maximum_label_type", maximum_label_type)
        if minimum_label_type is not None:
            _setter("minimum_label_type", minimum_label_type)
        if range_ends_label_type is not None:
            _setter("range_ends_label_type", range_ends_label_type)

    @property
    @pulumi.getter(name="dataPathLabelType")
    def data_path_label_type(self) -> Optional['outputs.DashboardDataPathLabelType']:
        return pulumi.get(self, "data_path_label_type")

    @property
    @pulumi.getter(name="fieldLabelType")
    def field_label_type(self) -> Optional['outputs.DashboardFieldLabelType']:
        return pulumi.get(self, "field_label_type")

    @property
    @pulumi.getter(name="maximumLabelType")
    def maximum_label_type(self) -> Optional['outputs.DashboardMaximumLabelType']:
        return pulumi.get(self, "maximum_label_type")

    @property
    @pulumi.getter(name="minimumLabelType")
    def minimum_label_type(self) -> Optional['outputs.DashboardMinimumLabelType']:
        return pulumi.get(self, "minimum_label_type")

    @property
    @pulumi.getter(name="rangeEndsLabelType")
    def range_ends_label_type(self) -> Optional['outputs.DashboardRangeEndsLabelType']:
        return pulumi.get(self, "range_ends_label_type")


@pulumi.output_type
class DashboardDataPathColor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataPathColor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataPathColor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataPathColor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: str,
                 element: 'outputs.DashboardDataPathValue',
                 time_granularity: Optional['DashboardTimeGranularity'] = None):
        DashboardDataPathColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            element=element,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: str,
             element: 'outputs.DashboardDataPathValue',
             time_granularity: Optional['DashboardTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)
        _setter("element", element)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def element(self) -> 'outputs.DashboardDataPathValue':
        return pulumi.get(self, "element")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['DashboardTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class DashboardDataPathLabelType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataPathLabelType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataPathLabelType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataPathLabelType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: Optional[str] = None,
                 field_value: Optional[str] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardDataPathLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            field_value=field_value,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: Optional[str] = None,
             field_value: Optional[str] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_id is not None:
            _setter("field_id", field_id)
        if field_value is not None:
            _setter("field_value", field_value)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[str]:
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardDataPathSort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortPaths":
            suggest = "sort_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataPathSort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataPathSort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataPathSort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: 'DashboardSortDirection',
                 sort_paths: Sequence['outputs.DashboardDataPathValue']):
        DashboardDataPathSort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            sort_paths=sort_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: 'DashboardSortDirection',
             sort_paths: Sequence['outputs.DashboardDataPathValue'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("direction", direction)
        _setter("sort_paths", sort_paths)

    @property
    @pulumi.getter
    def direction(self) -> 'DashboardSortDirection':
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="sortPaths")
    def sort_paths(self) -> Sequence['outputs.DashboardDataPathValue']:
        return pulumi.get(self, "sort_paths")


@pulumi.output_type
class DashboardDataPathValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataPathValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataPathValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataPathValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 field_value: str):
        DashboardDataPathValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            field_value=field_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             field_value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        _setter("field_value", field_value)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> str:
        return pulumi.get(self, "field_value")


@pulumi.output_type
class DashboardDataPointDrillUpDownOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataPointDrillUpDownOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataPointDrillUpDownOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataPointDrillUpDownOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional['DashboardBehavior'] = None):
        DashboardDataPointDrillUpDownOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional['DashboardBehavior'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional['DashboardBehavior']:
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardDataPointMenuLabelOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataPointMenuLabelOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataPointMenuLabelOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataPointMenuLabelOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional['DashboardBehavior'] = None):
        DashboardDataPointMenuLabelOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional['DashboardBehavior'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional['DashboardBehavior']:
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardDataPointTooltipOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataPointTooltipOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataPointTooltipOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataPointTooltipOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional['DashboardBehavior'] = None):
        DashboardDataPointTooltipOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional['DashboardBehavior'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional['DashboardBehavior']:
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardDataSetIdentifierDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetArn":
            suggest = "data_set_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataSetIdentifierDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataSetIdentifierDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataSetIdentifierDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_arn: str,
                 identifier: str):
        DashboardDataSetIdentifierDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_arn=data_set_arn,
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_arn: str,
             identifier: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_arn", data_set_arn)
        _setter("identifier", identifier)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> str:
        return pulumi.get(self, "data_set_arn")

    @property
    @pulumi.getter
    def identifier(self) -> str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class DashboardDataSetReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetArn":
            suggest = "data_set_arn"
        elif key == "dataSetPlaceholder":
            suggest = "data_set_placeholder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDataSetReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDataSetReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDataSetReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_arn: str,
                 data_set_placeholder: str):
        DashboardDataSetReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_arn=data_set_arn,
            data_set_placeholder=data_set_placeholder,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_arn: str,
             data_set_placeholder: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_arn", data_set_arn)
        _setter("data_set_placeholder", data_set_placeholder)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> str:
        return pulumi.get(self, "data_set_arn")

    @property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> str:
        return pulumi.get(self, "data_set_placeholder")


@pulumi.output_type
class DashboardDateAxisOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "missingDateVisibility":
            suggest = "missing_date_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDateAxisOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDateAxisOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDateAxisOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 missing_date_visibility: Optional['DashboardVisibility'] = None):
        DashboardDateAxisOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            missing_date_visibility=missing_date_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             missing_date_visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if missing_date_visibility is not None:
            _setter("missing_date_visibility", missing_date_visibility)

    @property
    @pulumi.getter(name="missingDateVisibility")
    def missing_date_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "missing_date_visibility")


@pulumi.output_type
class DashboardDateDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "dateGranularity":
            suggest = "date_granularity"
        elif key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "hierarchyId":
            suggest = "hierarchy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDateDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDateDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDateDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 field_id: str,
                 date_granularity: Optional['DashboardTimeGranularity'] = None,
                 format_configuration: Optional['outputs.DashboardDateTimeFormatConfiguration'] = None,
                 hierarchy_id: Optional[str] = None):
        DashboardDateDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            date_granularity=date_granularity,
            format_configuration=format_configuration,
            hierarchy_id=hierarchy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             field_id: str,
             date_granularity: Optional['DashboardTimeGranularity'] = None,
             format_configuration: Optional['outputs.DashboardDateTimeFormatConfiguration'] = None,
             hierarchy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if date_granularity is not None:
            _setter("date_granularity", date_granularity)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if hierarchy_id is not None:
            _setter("hierarchy_id", hierarchy_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="dateGranularity")
    def date_granularity(self) -> Optional['DashboardTimeGranularity']:
        return pulumi.get(self, "date_granularity")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.DashboardDateTimeFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> Optional[str]:
        return pulumi.get(self, "hierarchy_id")


@pulumi.output_type
class DashboardDateMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDateMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDateMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDateMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 field_id: str,
                 aggregation_function: Optional['DashboardDateAggregationFunction'] = None,
                 format_configuration: Optional['outputs.DashboardDateTimeFormatConfiguration'] = None):
        DashboardDateMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            aggregation_function=aggregation_function,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             field_id: str,
             aggregation_function: Optional['DashboardDateAggregationFunction'] = None,
             format_configuration: Optional['outputs.DashboardDateTimeFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['DashboardDateAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.DashboardDateTimeFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class DashboardDateTimeDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "rollingDate":
            suggest = "rolling_date"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDateTimeDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDateTimeDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDateTimeDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.DashboardDynamicDefaultValue'] = None,
                 rolling_date: Optional['outputs.DashboardRollingDateConfiguration'] = None,
                 static_values: Optional[Sequence[str]] = None):
        DashboardDateTimeDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            rolling_date=rolling_date,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.DashboardDynamicDefaultValue'] = None,
             rolling_date: Optional['outputs.DashboardRollingDateConfiguration'] = None,
             static_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if rolling_date is not None:
            _setter("rolling_date", rolling_date)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.DashboardDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="rollingDate")
    def rolling_date(self) -> Optional['outputs.DashboardRollingDateConfiguration']:
        return pulumi.get(self, "rolling_date")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class DashboardDateTimeFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormat":
            suggest = "date_time_format"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numericFormatConfiguration":
            suggest = "numeric_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDateTimeFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDateTimeFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDateTimeFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format: Optional[str] = None,
                 null_value_format_configuration: Optional['outputs.DashboardNullValueFormatConfiguration'] = None,
                 numeric_format_configuration: Optional['outputs.DashboardNumericFormatConfiguration'] = None):
        DashboardDateTimeFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format=date_time_format,
            null_value_format_configuration=null_value_format_configuration,
            numeric_format_configuration=numeric_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format: Optional[str] = None,
             null_value_format_configuration: Optional['outputs.DashboardNullValueFormatConfiguration'] = None,
             numeric_format_configuration: Optional['outputs.DashboardNumericFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format is not None:
            _setter("date_time_format", date_time_format)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if numeric_format_configuration is not None:
            _setter("numeric_format_configuration", numeric_format_configuration)

    @property
    @pulumi.getter(name="dateTimeFormat")
    def date_time_format(self) -> Optional[str]:
        return pulumi.get(self, "date_time_format")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.DashboardNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numericFormatConfiguration")
    def numeric_format_configuration(self) -> Optional['outputs.DashboardNumericFormatConfiguration']:
        return pulumi.get(self, "numeric_format_configuration")


@pulumi.output_type
class DashboardDateTimeHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hierarchyId":
            suggest = "hierarchy_id"
        elif key == "drillDownFilters":
            suggest = "drill_down_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDateTimeHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDateTimeHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDateTimeHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hierarchy_id: str,
                 drill_down_filters: Optional[Sequence['outputs.DashboardDrillDownFilter']] = None):
        DashboardDateTimeHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hierarchy_id=hierarchy_id,
            drill_down_filters=drill_down_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hierarchy_id: str,
             drill_down_filters: Optional[Sequence['outputs.DashboardDrillDownFilter']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hierarchy_id", hierarchy_id)
        if drill_down_filters is not None:
            _setter("drill_down_filters", drill_down_filters)

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> str:
        return pulumi.get(self, "hierarchy_id")

    @property
    @pulumi.getter(name="drillDownFilters")
    def drill_down_filters(self) -> Optional[Sequence['outputs.DashboardDrillDownFilter']]:
        return pulumi.get(self, "drill_down_filters")


@pulumi.output_type
class DashboardDateTimeParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        DashboardDateTimeParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardDateTimeParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "timeGranularity":
            suggest = "time_granularity"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDateTimeParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDateTimeParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDateTimeParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 default_values: Optional['outputs.DashboardDateTimeDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.DashboardMappedDataSetParameter']] = None,
                 time_granularity: Optional['DashboardTimeGranularity'] = None,
                 value_when_unset: Optional['outputs.DashboardDateTimeValueWhenUnsetConfiguration'] = None):
        DashboardDateTimeParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            time_granularity=time_granularity,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             default_values: Optional['outputs.DashboardDateTimeDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.DashboardMappedDataSetParameter']] = None,
             time_granularity: Optional['DashboardTimeGranularity'] = None,
             value_when_unset: Optional['outputs.DashboardDateTimeValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.DashboardDateTimeDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.DashboardMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['DashboardTimeGranularity']:
        return pulumi.get(self, "time_granularity")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.DashboardDateTimeValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class DashboardDateTimePickerControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormat":
            suggest = "date_time_format"
        elif key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDateTimePickerControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDateTimePickerControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDateTimePickerControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format: Optional[str] = None,
                 info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
                 title_options: Optional['outputs.DashboardLabelOptions'] = None):
        DashboardDateTimePickerControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format=date_time_format,
            info_icon_label_options=info_icon_label_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format: Optional[str] = None,
             info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
             title_options: Optional['outputs.DashboardLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format is not None:
            _setter("date_time_format", date_time_format)
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="dateTimeFormat")
    def date_time_format(self) -> Optional[str]:
        return pulumi.get(self, "date_time_format")

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.DashboardSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.DashboardLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class DashboardDateTimeValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDateTimeValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDateTimeValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDateTimeValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[str] = None,
                 value_when_unset_option: Optional['DashboardValueWhenUnsetOption'] = None):
        DashboardDateTimeValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[str] = None,
             value_when_unset_option: Optional['DashboardValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[str]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['DashboardValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class DashboardDecimalDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDecimalDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDecimalDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDecimalDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.DashboardDynamicDefaultValue'] = None,
                 static_values: Optional[Sequence[float]] = None):
        DashboardDecimalDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.DashboardDynamicDefaultValue'] = None,
             static_values: Optional[Sequence[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.DashboardDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class DashboardDecimalParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[float]):
        DashboardDecimalParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[float],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[float]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardDecimalParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueType":
            suggest = "parameter_value_type"
        elif key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDecimalParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDecimalParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDecimalParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 parameter_value_type: 'DashboardParameterValueType',
                 default_values: Optional['outputs.DashboardDecimalDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.DashboardMappedDataSetParameter']] = None,
                 value_when_unset: Optional['outputs.DashboardDecimalValueWhenUnsetConfiguration'] = None):
        DashboardDecimalParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameter_value_type=parameter_value_type,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             parameter_value_type: 'DashboardParameterValueType',
             default_values: Optional['outputs.DashboardDecimalDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.DashboardMappedDataSetParameter']] = None,
             value_when_unset: Optional['outputs.DashboardDecimalValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("parameter_value_type", parameter_value_type)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterValueType")
    def parameter_value_type(self) -> 'DashboardParameterValueType':
        return pulumi.get(self, "parameter_value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.DashboardDecimalDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.DashboardMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.DashboardDecimalValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class DashboardDecimalPlacesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlaces":
            suggest = "decimal_places"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDecimalPlacesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDecimalPlacesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDecimalPlacesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places: float):
        DashboardDecimalPlacesConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places=decimal_places,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("decimal_places", decimal_places)

    @property
    @pulumi.getter(name="decimalPlaces")
    def decimal_places(self) -> float:
        return pulumi.get(self, "decimal_places")


@pulumi.output_type
class DashboardDecimalValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDecimalValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDecimalValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDecimalValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[float] = None,
                 value_when_unset_option: Optional['DashboardValueWhenUnsetOption'] = None):
        DashboardDecimalValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[float] = None,
             value_when_unset_option: Optional['DashboardValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[float]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['DashboardValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class DashboardDefaultFreeFormLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDefaultFreeFormLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDefaultFreeFormLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDefaultFreeFormLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canvas_size_options: 'outputs.DashboardFreeFormLayoutCanvasSizeOptions'):
        DashboardDefaultFreeFormLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canvas_size_options: 'outputs.DashboardFreeFormLayoutCanvasSizeOptions',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.DashboardFreeFormLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class DashboardDefaultGridLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDefaultGridLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDefaultGridLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDefaultGridLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canvas_size_options: 'outputs.DashboardGridLayoutCanvasSizeOptions'):
        DashboardDefaultGridLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canvas_size_options: 'outputs.DashboardGridLayoutCanvasSizeOptions',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.DashboardGridLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class DashboardDefaultInteractiveLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeForm":
            suggest = "free_form"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDefaultInteractiveLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDefaultInteractiveLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDefaultInteractiveLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_form: Optional['outputs.DashboardDefaultFreeFormLayoutConfiguration'] = None,
                 grid: Optional['outputs.DashboardDefaultGridLayoutConfiguration'] = None):
        DashboardDefaultInteractiveLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            free_form=free_form,
            grid=grid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             free_form: Optional['outputs.DashboardDefaultFreeFormLayoutConfiguration'] = None,
             grid: Optional['outputs.DashboardDefaultGridLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if free_form is not None:
            _setter("free_form", free_form)
        if grid is not None:
            _setter("grid", grid)

    @property
    @pulumi.getter(name="freeForm")
    def free_form(self) -> Optional['outputs.DashboardDefaultFreeFormLayoutConfiguration']:
        return pulumi.get(self, "free_form")

    @property
    @pulumi.getter
    def grid(self) -> Optional['outputs.DashboardDefaultGridLayoutConfiguration']:
        return pulumi.get(self, "grid")


@pulumi.output_type
class DashboardDefaultNewSheetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interactiveLayoutConfiguration":
            suggest = "interactive_layout_configuration"
        elif key == "paginatedLayoutConfiguration":
            suggest = "paginated_layout_configuration"
        elif key == "sheetContentType":
            suggest = "sheet_content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDefaultNewSheetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDefaultNewSheetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDefaultNewSheetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interactive_layout_configuration: Optional['outputs.DashboardDefaultInteractiveLayoutConfiguration'] = None,
                 paginated_layout_configuration: Optional['outputs.DashboardDefaultPaginatedLayoutConfiguration'] = None,
                 sheet_content_type: Optional['DashboardSheetContentType'] = None):
        DashboardDefaultNewSheetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interactive_layout_configuration=interactive_layout_configuration,
            paginated_layout_configuration=paginated_layout_configuration,
            sheet_content_type=sheet_content_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interactive_layout_configuration: Optional['outputs.DashboardDefaultInteractiveLayoutConfiguration'] = None,
             paginated_layout_configuration: Optional['outputs.DashboardDefaultPaginatedLayoutConfiguration'] = None,
             sheet_content_type: Optional['DashboardSheetContentType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if interactive_layout_configuration is not None:
            _setter("interactive_layout_configuration", interactive_layout_configuration)
        if paginated_layout_configuration is not None:
            _setter("paginated_layout_configuration", paginated_layout_configuration)
        if sheet_content_type is not None:
            _setter("sheet_content_type", sheet_content_type)

    @property
    @pulumi.getter(name="interactiveLayoutConfiguration")
    def interactive_layout_configuration(self) -> Optional['outputs.DashboardDefaultInteractiveLayoutConfiguration']:
        return pulumi.get(self, "interactive_layout_configuration")

    @property
    @pulumi.getter(name="paginatedLayoutConfiguration")
    def paginated_layout_configuration(self) -> Optional['outputs.DashboardDefaultPaginatedLayoutConfiguration']:
        return pulumi.get(self, "paginated_layout_configuration")

    @property
    @pulumi.getter(name="sheetContentType")
    def sheet_content_type(self) -> Optional['DashboardSheetContentType']:
        return pulumi.get(self, "sheet_content_type")


@pulumi.output_type
class DashboardDefaultPaginatedLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionBased":
            suggest = "section_based"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDefaultPaginatedLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDefaultPaginatedLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDefaultPaginatedLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 section_based: Optional['outputs.DashboardDefaultSectionBasedLayoutConfiguration'] = None):
        DashboardDefaultPaginatedLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            section_based=section_based,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             section_based: Optional['outputs.DashboardDefaultSectionBasedLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if section_based is not None:
            _setter("section_based", section_based)

    @property
    @pulumi.getter(name="sectionBased")
    def section_based(self) -> Optional['outputs.DashboardDefaultSectionBasedLayoutConfiguration']:
        return pulumi.get(self, "section_based")


@pulumi.output_type
class DashboardDefaultSectionBasedLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDefaultSectionBasedLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDefaultSectionBasedLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDefaultSectionBasedLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canvas_size_options: 'outputs.DashboardSectionBasedLayoutCanvasSizeOptions'):
        DashboardDefaultSectionBasedLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canvas_size_options: 'outputs.DashboardSectionBasedLayoutCanvasSizeOptions',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.DashboardSectionBasedLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class DashboardDestinationParameterValueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValuesConfiguration":
            suggest = "custom_values_configuration"
        elif key == "selectAllValueOptions":
            suggest = "select_all_value_options"
        elif key == "sourceColumn":
            suggest = "source_column"
        elif key == "sourceField":
            suggest = "source_field"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDestinationParameterValueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDestinationParameterValueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDestinationParameterValueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_values_configuration: Optional['outputs.DashboardCustomValuesConfiguration'] = None,
                 select_all_value_options: Optional['DashboardSelectAllValueOptions'] = None,
                 source_column: Optional['outputs.DashboardColumnIdentifier'] = None,
                 source_field: Optional[str] = None,
                 source_parameter_name: Optional[str] = None):
        DashboardDestinationParameterValueConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_values_configuration=custom_values_configuration,
            select_all_value_options=select_all_value_options,
            source_column=source_column,
            source_field=source_field,
            source_parameter_name=source_parameter_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_values_configuration: Optional['outputs.DashboardCustomValuesConfiguration'] = None,
             select_all_value_options: Optional['DashboardSelectAllValueOptions'] = None,
             source_column: Optional['outputs.DashboardColumnIdentifier'] = None,
             source_field: Optional[str] = None,
             source_parameter_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_values_configuration is not None:
            _setter("custom_values_configuration", custom_values_configuration)
        if select_all_value_options is not None:
            _setter("select_all_value_options", select_all_value_options)
        if source_column is not None:
            _setter("source_column", source_column)
        if source_field is not None:
            _setter("source_field", source_field)
        if source_parameter_name is not None:
            _setter("source_parameter_name", source_parameter_name)

    @property
    @pulumi.getter(name="customValuesConfiguration")
    def custom_values_configuration(self) -> Optional['outputs.DashboardCustomValuesConfiguration']:
        return pulumi.get(self, "custom_values_configuration")

    @property
    @pulumi.getter(name="selectAllValueOptions")
    def select_all_value_options(self) -> Optional['DashboardSelectAllValueOptions']:
        return pulumi.get(self, "select_all_value_options")

    @property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> Optional['outputs.DashboardColumnIdentifier']:
        return pulumi.get(self, "source_column")

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[str]:
        return pulumi.get(self, "source_field")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "source_parameter_name")


@pulumi.output_type
class DashboardDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoricalDimensionField":
            suggest = "categorical_dimension_field"
        elif key == "dateDimensionField":
            suggest = "date_dimension_field"
        elif key == "numericalDimensionField":
            suggest = "numerical_dimension_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categorical_dimension_field: Optional['outputs.DashboardCategoricalDimensionField'] = None,
                 date_dimension_field: Optional['outputs.DashboardDateDimensionField'] = None,
                 numerical_dimension_field: Optional['outputs.DashboardNumericalDimensionField'] = None):
        DashboardDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            categorical_dimension_field=categorical_dimension_field,
            date_dimension_field=date_dimension_field,
            numerical_dimension_field=numerical_dimension_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             categorical_dimension_field: Optional['outputs.DashboardCategoricalDimensionField'] = None,
             date_dimension_field: Optional['outputs.DashboardDateDimensionField'] = None,
             numerical_dimension_field: Optional['outputs.DashboardNumericalDimensionField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if categorical_dimension_field is not None:
            _setter("categorical_dimension_field", categorical_dimension_field)
        if date_dimension_field is not None:
            _setter("date_dimension_field", date_dimension_field)
        if numerical_dimension_field is not None:
            _setter("numerical_dimension_field", numerical_dimension_field)

    @property
    @pulumi.getter(name="categoricalDimensionField")
    def categorical_dimension_field(self) -> Optional['outputs.DashboardCategoricalDimensionField']:
        return pulumi.get(self, "categorical_dimension_field")

    @property
    @pulumi.getter(name="dateDimensionField")
    def date_dimension_field(self) -> Optional['outputs.DashboardDateDimensionField']:
        return pulumi.get(self, "date_dimension_field")

    @property
    @pulumi.getter(name="numericalDimensionField")
    def numerical_dimension_field(self) -> Optional['outputs.DashboardNumericalDimensionField']:
        return pulumi.get(self, "numerical_dimension_field")


@pulumi.output_type
class DashboardDonutCenterOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelVisibility":
            suggest = "label_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDonutCenterOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDonutCenterOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDonutCenterOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_visibility: Optional['DashboardVisibility'] = None):
        DashboardDonutCenterOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_visibility=label_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if label_visibility is not None:
            _setter("label_visibility", label_visibility)

    @property
    @pulumi.getter(name="labelVisibility")
    def label_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "label_visibility")


@pulumi.output_type
class DashboardDonutOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcOptions":
            suggest = "arc_options"
        elif key == "donutCenterOptions":
            suggest = "donut_center_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDonutOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDonutOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDonutOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc_options: Optional['outputs.DashboardArcOptions'] = None,
                 donut_center_options: Optional['outputs.DashboardDonutCenterOptions'] = None):
        DashboardDonutOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc_options=arc_options,
            donut_center_options=donut_center_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc_options: Optional['outputs.DashboardArcOptions'] = None,
             donut_center_options: Optional['outputs.DashboardDonutCenterOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc_options is not None:
            _setter("arc_options", arc_options)
        if donut_center_options is not None:
            _setter("donut_center_options", donut_center_options)

    @property
    @pulumi.getter(name="arcOptions")
    def arc_options(self) -> Optional['outputs.DashboardArcOptions']:
        return pulumi.get(self, "arc_options")

    @property
    @pulumi.getter(name="donutCenterOptions")
    def donut_center_options(self) -> Optional['outputs.DashboardDonutCenterOptions']:
        return pulumi.get(self, "donut_center_options")


@pulumi.output_type
class DashboardDrillDownFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryFilter":
            suggest = "category_filter"
        elif key == "numericEqualityFilter":
            suggest = "numeric_equality_filter"
        elif key == "timeRangeFilter":
            suggest = "time_range_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDrillDownFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDrillDownFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDrillDownFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_filter: Optional['outputs.DashboardCategoryDrillDownFilter'] = None,
                 numeric_equality_filter: Optional['outputs.DashboardNumericEqualityDrillDownFilter'] = None,
                 time_range_filter: Optional['outputs.DashboardTimeRangeDrillDownFilter'] = None):
        DashboardDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_filter=category_filter,
            numeric_equality_filter=numeric_equality_filter,
            time_range_filter=time_range_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_filter: Optional['outputs.DashboardCategoryDrillDownFilter'] = None,
             numeric_equality_filter: Optional['outputs.DashboardNumericEqualityDrillDownFilter'] = None,
             time_range_filter: Optional['outputs.DashboardTimeRangeDrillDownFilter'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_filter is not None:
            _setter("category_filter", category_filter)
        if numeric_equality_filter is not None:
            _setter("numeric_equality_filter", numeric_equality_filter)
        if time_range_filter is not None:
            _setter("time_range_filter", time_range_filter)

    @property
    @pulumi.getter(name="categoryFilter")
    def category_filter(self) -> Optional['outputs.DashboardCategoryDrillDownFilter']:
        return pulumi.get(self, "category_filter")

    @property
    @pulumi.getter(name="numericEqualityFilter")
    def numeric_equality_filter(self) -> Optional['outputs.DashboardNumericEqualityDrillDownFilter']:
        return pulumi.get(self, "numeric_equality_filter")

    @property
    @pulumi.getter(name="timeRangeFilter")
    def time_range_filter(self) -> Optional['outputs.DashboardTimeRangeDrillDownFilter']:
        return pulumi.get(self, "time_range_filter")


@pulumi.output_type
class DashboardDropDownControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "selectAllOptions":
            suggest = "select_all_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDropDownControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDropDownControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDropDownControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
                 select_all_options: Optional['outputs.DashboardListControlSelectAllOptions'] = None,
                 title_options: Optional['outputs.DashboardLabelOptions'] = None):
        DashboardDropDownControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            select_all_options=select_all_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
             select_all_options: Optional['outputs.DashboardListControlSelectAllOptions'] = None,
             title_options: Optional['outputs.DashboardLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.DashboardSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['outputs.DashboardListControlSelectAllOptions']:
        return pulumi.get(self, "select_all_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.DashboardLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class DashboardDynamicDefaultValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValueColumn":
            suggest = "default_value_column"
        elif key == "groupNameColumn":
            suggest = "group_name_column"
        elif key == "userNameColumn":
            suggest = "user_name_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDynamicDefaultValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDynamicDefaultValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDynamicDefaultValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value_column: 'outputs.DashboardColumnIdentifier',
                 group_name_column: Optional['outputs.DashboardColumnIdentifier'] = None,
                 user_name_column: Optional['outputs.DashboardColumnIdentifier'] = None):
        DashboardDynamicDefaultValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_value_column=default_value_column,
            group_name_column=group_name_column,
            user_name_column=user_name_column,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_value_column: 'outputs.DashboardColumnIdentifier',
             group_name_column: Optional['outputs.DashboardColumnIdentifier'] = None,
             user_name_column: Optional['outputs.DashboardColumnIdentifier'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_value_column", default_value_column)
        if group_name_column is not None:
            _setter("group_name_column", group_name_column)
        if user_name_column is not None:
            _setter("user_name_column", user_name_column)

    @property
    @pulumi.getter(name="defaultValueColumn")
    def default_value_column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "default_value_column")

    @property
    @pulumi.getter(name="groupNameColumn")
    def group_name_column(self) -> Optional['outputs.DashboardColumnIdentifier']:
        return pulumi.get(self, "group_name_column")

    @property
    @pulumi.getter(name="userNameColumn")
    def user_name_column(self) -> Optional['outputs.DashboardColumnIdentifier']:
        return pulumi.get(self, "user_name_column")


@pulumi.output_type
class DashboardEmptyVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "visualId":
            suggest = "visual_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardEmptyVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardEmptyVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardEmptyVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None):
        DashboardEmptyVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            visual_id=visual_id,
            actions=actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")


@pulumi.output_type
class DashboardEntity(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None):
        DashboardEntity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class DashboardError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "violatedEntities":
            suggest = "violated_entities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: Optional[str] = None,
                 type: Optional['DashboardErrorType'] = None,
                 violated_entities: Optional[Sequence['outputs.DashboardEntity']] = None):
        DashboardError._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
            type=type,
            violated_entities=violated_entities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: Optional[str] = None,
             type: Optional['DashboardErrorType'] = None,
             violated_entities: Optional[Sequence['outputs.DashboardEntity']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if message is not None:
            _setter("message", message)
        if type is not None:
            _setter("type", type)
        if violated_entities is not None:
            _setter("violated_entities", violated_entities)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def type(self) -> Optional['DashboardErrorType']:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="violatedEntities")
    def violated_entities(self) -> Optional[Sequence['outputs.DashboardEntity']]:
        return pulumi.get(self, "violated_entities")


@pulumi.output_type
class DashboardExcludePeriodConfiguration(dict):
    def __init__(__self__, *,
                 amount: float,
                 granularity: 'DashboardTimeGranularity',
                 status: Optional['DashboardWidgetStatus'] = None):
        DashboardExcludePeriodConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amount=amount,
            granularity=granularity,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amount: float,
             granularity: 'DashboardTimeGranularity',
             status: Optional['DashboardWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("amount", amount)
        _setter("granularity", granularity)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def amount(self) -> float:
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def granularity(self) -> 'DashboardTimeGranularity':
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter
    def status(self) -> Optional['DashboardWidgetStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class DashboardExplicitHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hierarchyId":
            suggest = "hierarchy_id"
        elif key == "drillDownFilters":
            suggest = "drill_down_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardExplicitHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardExplicitHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardExplicitHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence['outputs.DashboardColumnIdentifier'],
                 hierarchy_id: str,
                 drill_down_filters: Optional[Sequence['outputs.DashboardDrillDownFilter']] = None):
        DashboardExplicitHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            hierarchy_id=hierarchy_id,
            drill_down_filters=drill_down_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Sequence['outputs.DashboardColumnIdentifier'],
             hierarchy_id: str,
             drill_down_filters: Optional[Sequence['outputs.DashboardDrillDownFilter']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("columns", columns)
        _setter("hierarchy_id", hierarchy_id)
        if drill_down_filters is not None:
            _setter("drill_down_filters", drill_down_filters)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.DashboardColumnIdentifier']:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> str:
        return pulumi.get(self, "hierarchy_id")

    @property
    @pulumi.getter(name="drillDownFilters")
    def drill_down_filters(self) -> Optional[Sequence['outputs.DashboardDrillDownFilter']]:
        return pulumi.get(self, "drill_down_filters")


@pulumi.output_type
class DashboardExportHiddenFieldsOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardExportHiddenFieldsOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardExportHiddenFieldsOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardExportHiddenFieldsOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional['DashboardBehavior'] = None):
        DashboardExportHiddenFieldsOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional['DashboardBehavior'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional['DashboardBehavior']:
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardExportToCsvOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardExportToCsvOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardExportToCsvOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardExportToCsvOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional['DashboardBehavior'] = None):
        DashboardExportToCsvOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional['DashboardBehavior'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional['DashboardBehavior']:
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardExportWithHiddenFieldsOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardExportWithHiddenFieldsOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardExportWithHiddenFieldsOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardExportWithHiddenFieldsOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional['DashboardBehavior'] = None):
        DashboardExportWithHiddenFieldsOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional['DashboardBehavior'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional['DashboardBehavior']:
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardFieldBasedTooltip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationVisibility":
            suggest = "aggregation_visibility"
        elif key == "tooltipFields":
            suggest = "tooltip_fields"
        elif key == "tooltipTitleType":
            suggest = "tooltip_title_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFieldBasedTooltip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFieldBasedTooltip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFieldBasedTooltip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_visibility: Optional['DashboardVisibility'] = None,
                 tooltip_fields: Optional[Sequence['outputs.DashboardTooltipItem']] = None,
                 tooltip_title_type: Optional['DashboardTooltipTitleType'] = None):
        DashboardFieldBasedTooltip._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_visibility=aggregation_visibility,
            tooltip_fields=tooltip_fields,
            tooltip_title_type=tooltip_title_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_visibility: Optional['DashboardVisibility'] = None,
             tooltip_fields: Optional[Sequence['outputs.DashboardTooltipItem']] = None,
             tooltip_title_type: Optional['DashboardTooltipTitleType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregation_visibility is not None:
            _setter("aggregation_visibility", aggregation_visibility)
        if tooltip_fields is not None:
            _setter("tooltip_fields", tooltip_fields)
        if tooltip_title_type is not None:
            _setter("tooltip_title_type", tooltip_title_type)

    @property
    @pulumi.getter(name="aggregationVisibility")
    def aggregation_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "aggregation_visibility")

    @property
    @pulumi.getter(name="tooltipFields")
    def tooltip_fields(self) -> Optional[Sequence['outputs.DashboardTooltipItem']]:
        return pulumi.get(self, "tooltip_fields")

    @property
    @pulumi.getter(name="tooltipTitleType")
    def tooltip_title_type(self) -> Optional['DashboardTooltipTitleType']:
        return pulumi.get(self, "tooltip_title_type")


@pulumi.output_type
class DashboardFieldLabelType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFieldLabelType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFieldLabelType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFieldLabelType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: Optional[str] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardFieldLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: Optional[str] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_id is not None:
            _setter("field_id", field_id)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardFieldSeriesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFieldSeriesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFieldSeriesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFieldSeriesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: 'DashboardAxisBinding',
                 field_id: str,
                 settings: Optional['outputs.DashboardLineChartSeriesSettings'] = None):
        DashboardFieldSeriesItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            field_id=field_id,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: 'DashboardAxisBinding',
             field_id: str,
             settings: Optional['outputs.DashboardLineChartSeriesSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("axis_binding", axis_binding)
        _setter("field_id", field_id)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> 'DashboardAxisBinding':
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.DashboardLineChartSeriesSettings']:
        return pulumi.get(self, "settings")


@pulumi.output_type
class DashboardFieldSort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFieldSort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFieldSort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFieldSort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: 'DashboardSortDirection',
                 field_id: str):
        DashboardFieldSort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: 'DashboardSortDirection',
             field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("direction", direction)
        _setter("field_id", field_id)

    @property
    @pulumi.getter
    def direction(self) -> 'DashboardSortDirection':
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class DashboardFieldSortOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnSort":
            suggest = "column_sort"
        elif key == "fieldSort":
            suggest = "field_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFieldSortOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFieldSortOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFieldSortOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_sort: Optional['outputs.DashboardColumnSort'] = None,
                 field_sort: Optional['outputs.DashboardFieldSort'] = None):
        DashboardFieldSortOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_sort=column_sort,
            field_sort=field_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_sort: Optional['outputs.DashboardColumnSort'] = None,
             field_sort: Optional['outputs.DashboardFieldSort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_sort is not None:
            _setter("column_sort", column_sort)
        if field_sort is not None:
            _setter("field_sort", field_sort)

    @property
    @pulumi.getter(name="columnSort")
    def column_sort(self) -> Optional['outputs.DashboardColumnSort']:
        return pulumi.get(self, "column_sort")

    @property
    @pulumi.getter(name="fieldSort")
    def field_sort(self) -> Optional['outputs.DashboardFieldSort']:
        return pulumi.get(self, "field_sort")


@pulumi.output_type
class DashboardFieldTooltipItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFieldTooltipItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFieldTooltipItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFieldTooltipItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 label: Optional[str] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardFieldTooltipItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            label=label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             label: Optional[str] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if label is not None:
            _setter("label", label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardFilledMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 geospatial: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardFilledMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            geospatial=geospatial,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             geospatial: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if geospatial is not None:
            _setter("geospatial", geospatial)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def geospatial(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "geospatial")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardFilledMapConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilledMapConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilledMapConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilledMapConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Sequence['outputs.DashboardFilledMapConditionalFormattingOption']):
        DashboardFilledMapConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Sequence['outputs.DashboardFilledMapConditionalFormattingOption'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Sequence['outputs.DashboardFilledMapConditionalFormattingOption']:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class DashboardFilledMapConditionalFormattingOption(dict):
    def __init__(__self__, *,
                 shape: 'outputs.DashboardFilledMapShapeConditionalFormatting'):
        DashboardFilledMapConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            shape=shape,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             shape: 'outputs.DashboardFilledMapShapeConditionalFormatting',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("shape", shape)

    @property
    @pulumi.getter
    def shape(self) -> 'outputs.DashboardFilledMapShapeConditionalFormatting':
        return pulumi.get(self, "shape")


@pulumi.output_type
class DashboardFilledMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldWells":
            suggest = "field_wells"
        elif key == "mapStyleOptions":
            suggest = "map_style_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "windowOptions":
            suggest = "window_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilledMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilledMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilledMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_wells: Optional['outputs.DashboardFilledMapFieldWells'] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 map_style_options: Optional['outputs.DashboardGeospatialMapStyleOptions'] = None,
                 sort_configuration: Optional['outputs.DashboardFilledMapSortConfiguration'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
                 window_options: Optional['outputs.DashboardGeospatialWindowOptions'] = None):
        DashboardFilledMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_wells=field_wells,
            legend=legend,
            map_style_options=map_style_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            window_options=window_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_wells: Optional['outputs.DashboardFilledMapFieldWells'] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             map_style_options: Optional['outputs.DashboardGeospatialMapStyleOptions'] = None,
             sort_configuration: Optional['outputs.DashboardFilledMapSortConfiguration'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             window_options: Optional['outputs.DashboardGeospatialWindowOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if map_style_options is not None:
            _setter("map_style_options", map_style_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if window_options is not None:
            _setter("window_options", window_options)

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardFilledMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="mapStyleOptions")
    def map_style_options(self) -> Optional['outputs.DashboardGeospatialMapStyleOptions']:
        return pulumi.get(self, "map_style_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardFilledMapSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="windowOptions")
    def window_options(self) -> Optional['outputs.DashboardGeospatialWindowOptions']:
        return pulumi.get(self, "window_options")


@pulumi.output_type
class DashboardFilledMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filledMapAggregatedFieldWells":
            suggest = "filled_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilledMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilledMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilledMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filled_map_aggregated_field_wells: Optional['outputs.DashboardFilledMapAggregatedFieldWells'] = None):
        DashboardFilledMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filled_map_aggregated_field_wells=filled_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filled_map_aggregated_field_wells: Optional['outputs.DashboardFilledMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if filled_map_aggregated_field_wells is not None:
            _setter("filled_map_aggregated_field_wells", filled_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="filledMapAggregatedFieldWells")
    def filled_map_aggregated_field_wells(self) -> Optional['outputs.DashboardFilledMapAggregatedFieldWells']:
        return pulumi.get(self, "filled_map_aggregated_field_wells")


@pulumi.output_type
class DashboardFilledMapShapeConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilledMapShapeConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilledMapShapeConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilledMapShapeConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 format: Optional['outputs.DashboardShapeConditionalFormat'] = None):
        DashboardFilledMapShapeConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            format=format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             format: Optional['outputs.DashboardShapeConditionalFormat'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if format is not None:
            _setter("format", format)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def format(self) -> Optional['outputs.DashboardShapeConditionalFormat']:
        return pulumi.get(self, "format")


@pulumi.output_type
class DashboardFilledMapSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilledMapSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilledMapSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilledMapSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardFilledMapSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class DashboardFilledMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilledMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilledMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilledMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardFilledMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 conditional_formatting: Optional['outputs.DashboardFilledMapConditionalFormatting'] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardFilledMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardFilledMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             conditional_formatting: Optional['outputs.DashboardFilledMapConditionalFormatting'] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardFilledMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.DashboardFilledMapConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryFilter":
            suggest = "category_filter"
        elif key == "numericEqualityFilter":
            suggest = "numeric_equality_filter"
        elif key == "numericRangeFilter":
            suggest = "numeric_range_filter"
        elif key == "relativeDatesFilter":
            suggest = "relative_dates_filter"
        elif key == "timeEqualityFilter":
            suggest = "time_equality_filter"
        elif key == "timeRangeFilter":
            suggest = "time_range_filter"
        elif key == "topBottomFilter":
            suggest = "top_bottom_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_filter: Optional['outputs.DashboardCategoryFilter'] = None,
                 numeric_equality_filter: Optional['outputs.DashboardNumericEqualityFilter'] = None,
                 numeric_range_filter: Optional['outputs.DashboardNumericRangeFilter'] = None,
                 relative_dates_filter: Optional['outputs.DashboardRelativeDatesFilter'] = None,
                 time_equality_filter: Optional['outputs.DashboardTimeEqualityFilter'] = None,
                 time_range_filter: Optional['outputs.DashboardTimeRangeFilter'] = None,
                 top_bottom_filter: Optional['outputs.DashboardTopBottomFilter'] = None):
        DashboardFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_filter=category_filter,
            numeric_equality_filter=numeric_equality_filter,
            numeric_range_filter=numeric_range_filter,
            relative_dates_filter=relative_dates_filter,
            time_equality_filter=time_equality_filter,
            time_range_filter=time_range_filter,
            top_bottom_filter=top_bottom_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_filter: Optional['outputs.DashboardCategoryFilter'] = None,
             numeric_equality_filter: Optional['outputs.DashboardNumericEqualityFilter'] = None,
             numeric_range_filter: Optional['outputs.DashboardNumericRangeFilter'] = None,
             relative_dates_filter: Optional['outputs.DashboardRelativeDatesFilter'] = None,
             time_equality_filter: Optional['outputs.DashboardTimeEqualityFilter'] = None,
             time_range_filter: Optional['outputs.DashboardTimeRangeFilter'] = None,
             top_bottom_filter: Optional['outputs.DashboardTopBottomFilter'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_filter is not None:
            _setter("category_filter", category_filter)
        if numeric_equality_filter is not None:
            _setter("numeric_equality_filter", numeric_equality_filter)
        if numeric_range_filter is not None:
            _setter("numeric_range_filter", numeric_range_filter)
        if relative_dates_filter is not None:
            _setter("relative_dates_filter", relative_dates_filter)
        if time_equality_filter is not None:
            _setter("time_equality_filter", time_equality_filter)
        if time_range_filter is not None:
            _setter("time_range_filter", time_range_filter)
        if top_bottom_filter is not None:
            _setter("top_bottom_filter", top_bottom_filter)

    @property
    @pulumi.getter(name="categoryFilter")
    def category_filter(self) -> Optional['outputs.DashboardCategoryFilter']:
        return pulumi.get(self, "category_filter")

    @property
    @pulumi.getter(name="numericEqualityFilter")
    def numeric_equality_filter(self) -> Optional['outputs.DashboardNumericEqualityFilter']:
        return pulumi.get(self, "numeric_equality_filter")

    @property
    @pulumi.getter(name="numericRangeFilter")
    def numeric_range_filter(self) -> Optional['outputs.DashboardNumericRangeFilter']:
        return pulumi.get(self, "numeric_range_filter")

    @property
    @pulumi.getter(name="relativeDatesFilter")
    def relative_dates_filter(self) -> Optional['outputs.DashboardRelativeDatesFilter']:
        return pulumi.get(self, "relative_dates_filter")

    @property
    @pulumi.getter(name="timeEqualityFilter")
    def time_equality_filter(self) -> Optional['outputs.DashboardTimeEqualityFilter']:
        return pulumi.get(self, "time_equality_filter")

    @property
    @pulumi.getter(name="timeRangeFilter")
    def time_range_filter(self) -> Optional['outputs.DashboardTimeRangeFilter']:
        return pulumi.get(self, "time_range_filter")

    @property
    @pulumi.getter(name="topBottomFilter")
    def top_bottom_filter(self) -> Optional['outputs.DashboardTopBottomFilter']:
        return pulumi.get(self, "top_bottom_filter")


@pulumi.output_type
class DashboardFilterControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimePicker":
            suggest = "date_time_picker"
        elif key == "relativeDateTime":
            suggest = "relative_date_time"
        elif key == "textArea":
            suggest = "text_area"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_picker: Optional['outputs.DashboardFilterDateTimePickerControl'] = None,
                 dropdown: Optional['outputs.DashboardFilterDropDownControl'] = None,
                 list: Optional['outputs.DashboardFilterListControl'] = None,
                 relative_date_time: Optional['outputs.DashboardFilterRelativeDateTimeControl'] = None,
                 slider: Optional['outputs.DashboardFilterSliderControl'] = None,
                 text_area: Optional['outputs.DashboardFilterTextAreaControl'] = None,
                 text_field: Optional['outputs.DashboardFilterTextFieldControl'] = None):
        DashboardFilterControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_picker=date_time_picker,
            dropdown=dropdown,
            list=list,
            relative_date_time=relative_date_time,
            slider=slider,
            text_area=text_area,
            text_field=text_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_picker: Optional['outputs.DashboardFilterDateTimePickerControl'] = None,
             dropdown: Optional['outputs.DashboardFilterDropDownControl'] = None,
             list: Optional['outputs.DashboardFilterListControl'] = None,
             relative_date_time: Optional['outputs.DashboardFilterRelativeDateTimeControl'] = None,
             slider: Optional['outputs.DashboardFilterSliderControl'] = None,
             text_area: Optional['outputs.DashboardFilterTextAreaControl'] = None,
             text_field: Optional['outputs.DashboardFilterTextFieldControl'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_picker is not None:
            _setter("date_time_picker", date_time_picker)
        if dropdown is not None:
            _setter("dropdown", dropdown)
        if list is not None:
            _setter("list", list)
        if relative_date_time is not None:
            _setter("relative_date_time", relative_date_time)
        if slider is not None:
            _setter("slider", slider)
        if text_area is not None:
            _setter("text_area", text_area)
        if text_field is not None:
            _setter("text_field", text_field)

    @property
    @pulumi.getter(name="dateTimePicker")
    def date_time_picker(self) -> Optional['outputs.DashboardFilterDateTimePickerControl']:
        return pulumi.get(self, "date_time_picker")

    @property
    @pulumi.getter
    def dropdown(self) -> Optional['outputs.DashboardFilterDropDownControl']:
        return pulumi.get(self, "dropdown")

    @property
    @pulumi.getter
    def list(self) -> Optional['outputs.DashboardFilterListControl']:
        return pulumi.get(self, "list")

    @property
    @pulumi.getter(name="relativeDateTime")
    def relative_date_time(self) -> Optional['outputs.DashboardFilterRelativeDateTimeControl']:
        return pulumi.get(self, "relative_date_time")

    @property
    @pulumi.getter
    def slider(self) -> Optional['outputs.DashboardFilterSliderControl']:
        return pulumi.get(self, "slider")

    @property
    @pulumi.getter(name="textArea")
    def text_area(self) -> Optional['outputs.DashboardFilterTextAreaControl']:
        return pulumi.get(self, "text_area")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional['outputs.DashboardFilterTextFieldControl']:
        return pulumi.get(self, "text_field")


@pulumi.output_type
class DashboardFilterDateTimePickerControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterDateTimePickerControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterDateTimePickerControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterDateTimePickerControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 display_options: Optional['outputs.DashboardDateTimePickerControlDisplayOptions'] = None,
                 type: Optional['DashboardSheetControlDateTimePickerType'] = None):
        DashboardFilterDateTimePickerControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            display_options=display_options,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             display_options: Optional['outputs.DashboardDateTimePickerControlDisplayOptions'] = None,
             type: Optional['DashboardSheetControlDateTimePickerType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardDateTimePickerControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter
    def type(self) -> Optional['DashboardSheetControlDateTimePickerType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardFilterDropDownControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterDropDownControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterDropDownControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterDropDownControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.DashboardCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.DashboardDropDownControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.DashboardFilterSelectableValues'] = None,
                 type: Optional['DashboardSheetControlListType'] = None):
        DashboardFilterDropDownControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             cascading_control_configuration: Optional['outputs.DashboardCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.DashboardDropDownControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.DashboardFilterSelectableValues'] = None,
             type: Optional['DashboardSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.DashboardCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardDropDownControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.DashboardFilterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['DashboardSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardFilterGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossDataset":
            suggest = "cross_dataset"
        elif key == "filterGroupId":
            suggest = "filter_group_id"
        elif key == "scopeConfiguration":
            suggest = "scope_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cross_dataset: 'DashboardCrossDatasetTypes',
                 filter_group_id: str,
                 filters: Sequence['outputs.DashboardFilter'],
                 scope_configuration: 'outputs.DashboardFilterScopeConfiguration',
                 status: Optional['DashboardWidgetStatus'] = None):
        DashboardFilterGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cross_dataset=cross_dataset,
            filter_group_id=filter_group_id,
            filters=filters,
            scope_configuration=scope_configuration,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cross_dataset: 'DashboardCrossDatasetTypes',
             filter_group_id: str,
             filters: Sequence['outputs.DashboardFilter'],
             scope_configuration: 'outputs.DashboardFilterScopeConfiguration',
             status: Optional['DashboardWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cross_dataset", cross_dataset)
        _setter("filter_group_id", filter_group_id)
        _setter("filters", filters)
        _setter("scope_configuration", scope_configuration)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="crossDataset")
    def cross_dataset(self) -> 'DashboardCrossDatasetTypes':
        return pulumi.get(self, "cross_dataset")

    @property
    @pulumi.getter(name="filterGroupId")
    def filter_group_id(self) -> str:
        return pulumi.get(self, "filter_group_id")

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.DashboardFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="scopeConfiguration")
    def scope_configuration(self) -> 'outputs.DashboardFilterScopeConfiguration':
        return pulumi.get(self, "scope_configuration")

    @property
    @pulumi.getter
    def status(self) -> Optional['DashboardWidgetStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class DashboardFilterListConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOperator":
            suggest = "match_operator"
        elif key == "categoryValues":
            suggest = "category_values"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterListConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterListConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterListConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_operator: 'DashboardCategoryFilterMatchOperator',
                 category_values: Optional[Sequence[str]] = None,
                 select_all_options: Optional['DashboardCategoryFilterSelectAllOptions'] = None):
        DashboardFilterListConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_operator=match_operator,
            category_values=category_values,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_operator: 'DashboardCategoryFilterMatchOperator',
             category_values: Optional[Sequence[str]] = None,
             select_all_options: Optional['DashboardCategoryFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("match_operator", match_operator)
        if category_values is not None:
            _setter("category_values", category_values)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'DashboardCategoryFilterMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="categoryValues")
    def category_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "category_values")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['DashboardCategoryFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class DashboardFilterListControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterListControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterListControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterListControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.DashboardCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.DashboardListControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.DashboardFilterSelectableValues'] = None,
                 type: Optional['DashboardSheetControlListType'] = None):
        DashboardFilterListControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             cascading_control_configuration: Optional['outputs.DashboardCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.DashboardListControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.DashboardFilterSelectableValues'] = None,
             type: Optional['DashboardSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.DashboardCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardListControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.DashboardFilterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['DashboardSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardFilterOperationSelectedFieldsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedColumns":
            suggest = "selected_columns"
        elif key == "selectedFieldOptions":
            suggest = "selected_field_options"
        elif key == "selectedFields":
            suggest = "selected_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterOperationSelectedFieldsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterOperationSelectedFieldsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterOperationSelectedFieldsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_columns: Optional[Sequence['outputs.DashboardColumnIdentifier']] = None,
                 selected_field_options: Optional['DashboardSelectedFieldOptions'] = None,
                 selected_fields: Optional[Sequence[str]] = None):
        DashboardFilterOperationSelectedFieldsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_columns=selected_columns,
            selected_field_options=selected_field_options,
            selected_fields=selected_fields,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_columns: Optional[Sequence['outputs.DashboardColumnIdentifier']] = None,
             selected_field_options: Optional['DashboardSelectedFieldOptions'] = None,
             selected_fields: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if selected_columns is not None:
            _setter("selected_columns", selected_columns)
        if selected_field_options is not None:
            _setter("selected_field_options", selected_field_options)
        if selected_fields is not None:
            _setter("selected_fields", selected_fields)

    @property
    @pulumi.getter(name="selectedColumns")
    def selected_columns(self) -> Optional[Sequence['outputs.DashboardColumnIdentifier']]:
        return pulumi.get(self, "selected_columns")

    @property
    @pulumi.getter(name="selectedFieldOptions")
    def selected_field_options(self) -> Optional['DashboardSelectedFieldOptions']:
        return pulumi.get(self, "selected_field_options")

    @property
    @pulumi.getter(name="selectedFields")
    def selected_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "selected_fields")


@pulumi.output_type
class DashboardFilterOperationTargetVisualsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sameSheetTargetVisualConfiguration":
            suggest = "same_sheet_target_visual_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterOperationTargetVisualsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterOperationTargetVisualsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterOperationTargetVisualsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 same_sheet_target_visual_configuration: Optional['outputs.DashboardSameSheetTargetVisualConfiguration'] = None):
        DashboardFilterOperationTargetVisualsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            same_sheet_target_visual_configuration=same_sheet_target_visual_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             same_sheet_target_visual_configuration: Optional['outputs.DashboardSameSheetTargetVisualConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if same_sheet_target_visual_configuration is not None:
            _setter("same_sheet_target_visual_configuration", same_sheet_target_visual_configuration)

    @property
    @pulumi.getter(name="sameSheetTargetVisualConfiguration")
    def same_sheet_target_visual_configuration(self) -> Optional['outputs.DashboardSameSheetTargetVisualConfiguration']:
        return pulumi.get(self, "same_sheet_target_visual_configuration")


@pulumi.output_type
class DashboardFilterRelativeDateTimeControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterRelativeDateTimeControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterRelativeDateTimeControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterRelativeDateTimeControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 display_options: Optional['outputs.DashboardRelativeDateTimeControlDisplayOptions'] = None):
        DashboardFilterRelativeDateTimeControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             display_options: Optional['outputs.DashboardRelativeDateTimeControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardRelativeDateTimeControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class DashboardFilterScopeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allSheets":
            suggest = "all_sheets"
        elif key == "selectedSheets":
            suggest = "selected_sheets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterScopeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterScopeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterScopeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_sheets: Optional['outputs.DashboardAllSheetsFilterScopeConfiguration'] = None,
                 selected_sheets: Optional['outputs.DashboardSelectedSheetsFilterScopeConfiguration'] = None):
        DashboardFilterScopeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_sheets=all_sheets,
            selected_sheets=selected_sheets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_sheets: Optional['outputs.DashboardAllSheetsFilterScopeConfiguration'] = None,
             selected_sheets: Optional['outputs.DashboardSelectedSheetsFilterScopeConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_sheets is not None:
            _setter("all_sheets", all_sheets)
        if selected_sheets is not None:
            _setter("selected_sheets", selected_sheets)

    @property
    @pulumi.getter(name="allSheets")
    def all_sheets(self) -> Optional['outputs.DashboardAllSheetsFilterScopeConfiguration']:
        return pulumi.get(self, "all_sheets")

    @property
    @pulumi.getter(name="selectedSheets")
    def selected_sheets(self) -> Optional['outputs.DashboardSelectedSheetsFilterScopeConfiguration']:
        return pulumi.get(self, "selected_sheets")


@pulumi.output_type
class DashboardFilterSelectableValues(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence[str]] = None):
        DashboardFilterSelectableValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardFilterSliderControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "maximumValue":
            suggest = "maximum_value"
        elif key == "minimumValue":
            suggest = "minimum_value"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "stepSize":
            suggest = "step_size"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterSliderControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterSliderControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterSliderControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 maximum_value: float,
                 minimum_value: float,
                 source_filter_id: str,
                 step_size: float,
                 title: str,
                 display_options: Optional['outputs.DashboardSliderControlDisplayOptions'] = None,
                 type: Optional['DashboardSheetControlSliderType'] = None):
        DashboardFilterSliderControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            maximum_value=maximum_value,
            minimum_value=minimum_value,
            source_filter_id=source_filter_id,
            step_size=step_size,
            title=title,
            display_options=display_options,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             maximum_value: float,
             minimum_value: float,
             source_filter_id: str,
             step_size: float,
             title: str,
             display_options: Optional['outputs.DashboardSliderControlDisplayOptions'] = None,
             type: Optional['DashboardSheetControlSliderType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("maximum_value", maximum_value)
        _setter("minimum_value", minimum_value)
        _setter("source_filter_id", source_filter_id)
        _setter("step_size", step_size)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="maximumValue")
    def maximum_value(self) -> float:
        return pulumi.get(self, "maximum_value")

    @property
    @pulumi.getter(name="minimumValue")
    def minimum_value(self) -> float:
        return pulumi.get(self, "minimum_value")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> float:
        return pulumi.get(self, "step_size")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardSliderControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter
    def type(self) -> Optional['DashboardSheetControlSliderType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardFilterTextAreaControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterTextAreaControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterTextAreaControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterTextAreaControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 delimiter: Optional[str] = None,
                 display_options: Optional['outputs.DashboardTextAreaControlDisplayOptions'] = None):
        DashboardFilterTextAreaControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            delimiter=delimiter,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             delimiter: Optional[str] = None,
             display_options: Optional['outputs.DashboardTextAreaControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardTextAreaControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class DashboardFilterTextFieldControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFilterTextFieldControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFilterTextFieldControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFilterTextFieldControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 display_options: Optional['outputs.DashboardTextFieldControlDisplayOptions'] = None):
        DashboardFilterTextFieldControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             display_options: Optional['outputs.DashboardTextFieldControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardTextFieldControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class DashboardFontConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontColor":
            suggest = "font_color"
        elif key == "fontDecoration":
            suggest = "font_decoration"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "fontStyle":
            suggest = "font_style"
        elif key == "fontWeight":
            suggest = "font_weight"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFontConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFontConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFontConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_color: Optional[str] = None,
                 font_decoration: Optional['DashboardFontDecoration'] = None,
                 font_size: Optional['outputs.DashboardFontSize'] = None,
                 font_style: Optional['DashboardFontStyle'] = None,
                 font_weight: Optional['outputs.DashboardFontWeight'] = None):
        DashboardFontConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_color=font_color,
            font_decoration=font_decoration,
            font_size=font_size,
            font_style=font_style,
            font_weight=font_weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_color: Optional[str] = None,
             font_decoration: Optional['DashboardFontDecoration'] = None,
             font_size: Optional['outputs.DashboardFontSize'] = None,
             font_style: Optional['DashboardFontStyle'] = None,
             font_weight: Optional['outputs.DashboardFontWeight'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if font_color is not None:
            _setter("font_color", font_color)
        if font_decoration is not None:
            _setter("font_decoration", font_decoration)
        if font_size is not None:
            _setter("font_size", font_size)
        if font_style is not None:
            _setter("font_style", font_style)
        if font_weight is not None:
            _setter("font_weight", font_weight)

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[str]:
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontDecoration")
    def font_decoration(self) -> Optional['DashboardFontDecoration']:
        return pulumi.get(self, "font_decoration")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional['outputs.DashboardFontSize']:
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="fontStyle")
    def font_style(self) -> Optional['DashboardFontStyle']:
        return pulumi.get(self, "font_style")

    @property
    @pulumi.getter(name="fontWeight")
    def font_weight(self) -> Optional['outputs.DashboardFontWeight']:
        return pulumi.get(self, "font_weight")


@pulumi.output_type
class DashboardFontSize(dict):
    def __init__(__self__, *,
                 relative: Optional['DashboardRelativeFontSize'] = None):
        DashboardFontSize._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            relative=relative,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             relative: Optional['DashboardRelativeFontSize'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if relative is not None:
            _setter("relative", relative)

    @property
    @pulumi.getter
    def relative(self) -> Optional['DashboardRelativeFontSize']:
        return pulumi.get(self, "relative")


@pulumi.output_type
class DashboardFontWeight(dict):
    def __init__(__self__, *,
                 name: Optional['DashboardFontWeightName'] = None):
        DashboardFontWeight._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional['DashboardFontWeightName'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional['DashboardFontWeightName']:
        return pulumi.get(self, "name")


@pulumi.output_type
class DashboardForecastComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "customSeasonalityValue":
            suggest = "custom_seasonality_value"
        elif key == "lowerBoundary":
            suggest = "lower_boundary"
        elif key == "periodsBackward":
            suggest = "periods_backward"
        elif key == "periodsForward":
            suggest = "periods_forward"
        elif key == "predictionInterval":
            suggest = "prediction_interval"
        elif key == "upperBoundary":
            suggest = "upper_boundary"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardForecastComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardForecastComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardForecastComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 custom_seasonality_value: Optional[float] = None,
                 lower_boundary: Optional[float] = None,
                 name: Optional[str] = None,
                 periods_backward: Optional[float] = None,
                 periods_forward: Optional[float] = None,
                 prediction_interval: Optional[float] = None,
                 seasonality: Optional['DashboardForecastComputationSeasonality'] = None,
                 time: Optional['outputs.DashboardDimensionField'] = None,
                 upper_boundary: Optional[float] = None,
                 value: Optional['outputs.DashboardMeasureField'] = None):
        DashboardForecastComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            custom_seasonality_value=custom_seasonality_value,
            lower_boundary=lower_boundary,
            name=name,
            periods_backward=periods_backward,
            periods_forward=periods_forward,
            prediction_interval=prediction_interval,
            seasonality=seasonality,
            time=time,
            upper_boundary=upper_boundary,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             custom_seasonality_value: Optional[float] = None,
             lower_boundary: Optional[float] = None,
             name: Optional[str] = None,
             periods_backward: Optional[float] = None,
             periods_forward: Optional[float] = None,
             prediction_interval: Optional[float] = None,
             seasonality: Optional['DashboardForecastComputationSeasonality'] = None,
             time: Optional['outputs.DashboardDimensionField'] = None,
             upper_boundary: Optional[float] = None,
             value: Optional['outputs.DashboardMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if custom_seasonality_value is not None:
            _setter("custom_seasonality_value", custom_seasonality_value)
        if lower_boundary is not None:
            _setter("lower_boundary", lower_boundary)
        if name is not None:
            _setter("name", name)
        if periods_backward is not None:
            _setter("periods_backward", periods_backward)
        if periods_forward is not None:
            _setter("periods_forward", periods_forward)
        if prediction_interval is not None:
            _setter("prediction_interval", prediction_interval)
        if seasonality is not None:
            _setter("seasonality", seasonality)
        if time is not None:
            _setter("time", time)
        if upper_boundary is not None:
            _setter("upper_boundary", upper_boundary)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter(name="customSeasonalityValue")
    def custom_seasonality_value(self) -> Optional[float]:
        return pulumi.get(self, "custom_seasonality_value")

    @property
    @pulumi.getter(name="lowerBoundary")
    def lower_boundary(self) -> Optional[float]:
        return pulumi.get(self, "lower_boundary")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="periodsBackward")
    def periods_backward(self) -> Optional[float]:
        return pulumi.get(self, "periods_backward")

    @property
    @pulumi.getter(name="periodsForward")
    def periods_forward(self) -> Optional[float]:
        return pulumi.get(self, "periods_forward")

    @property
    @pulumi.getter(name="predictionInterval")
    def prediction_interval(self) -> Optional[float]:
        return pulumi.get(self, "prediction_interval")

    @property
    @pulumi.getter
    def seasonality(self) -> Optional['DashboardForecastComputationSeasonality']:
        return pulumi.get(self, "seasonality")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter(name="upperBoundary")
    def upper_boundary(self) -> Optional[float]:
        return pulumi.get(self, "upper_boundary")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.DashboardMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardForecastConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forecastProperties":
            suggest = "forecast_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardForecastConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardForecastConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardForecastConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forecast_properties: Optional['outputs.DashboardTimeBasedForecastProperties'] = None,
                 scenario: Optional['outputs.DashboardForecastScenario'] = None):
        DashboardForecastConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forecast_properties=forecast_properties,
            scenario=scenario,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forecast_properties: Optional['outputs.DashboardTimeBasedForecastProperties'] = None,
             scenario: Optional['outputs.DashboardForecastScenario'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if forecast_properties is not None:
            _setter("forecast_properties", forecast_properties)
        if scenario is not None:
            _setter("scenario", scenario)

    @property
    @pulumi.getter(name="forecastProperties")
    def forecast_properties(self) -> Optional['outputs.DashboardTimeBasedForecastProperties']:
        return pulumi.get(self, "forecast_properties")

    @property
    @pulumi.getter
    def scenario(self) -> Optional['outputs.DashboardForecastScenario']:
        return pulumi.get(self, "scenario")


@pulumi.output_type
class DashboardForecastScenario(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whatIfPointScenario":
            suggest = "what_if_point_scenario"
        elif key == "whatIfRangeScenario":
            suggest = "what_if_range_scenario"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardForecastScenario. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardForecastScenario.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardForecastScenario.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 what_if_point_scenario: Optional['outputs.DashboardWhatIfPointScenario'] = None,
                 what_if_range_scenario: Optional['outputs.DashboardWhatIfRangeScenario'] = None):
        DashboardForecastScenario._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            what_if_point_scenario=what_if_point_scenario,
            what_if_range_scenario=what_if_range_scenario,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             what_if_point_scenario: Optional['outputs.DashboardWhatIfPointScenario'] = None,
             what_if_range_scenario: Optional['outputs.DashboardWhatIfRangeScenario'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if what_if_point_scenario is not None:
            _setter("what_if_point_scenario", what_if_point_scenario)
        if what_if_range_scenario is not None:
            _setter("what_if_range_scenario", what_if_range_scenario)

    @property
    @pulumi.getter(name="whatIfPointScenario")
    def what_if_point_scenario(self) -> Optional['outputs.DashboardWhatIfPointScenario']:
        return pulumi.get(self, "what_if_point_scenario")

    @property
    @pulumi.getter(name="whatIfRangeScenario")
    def what_if_range_scenario(self) -> Optional['outputs.DashboardWhatIfRangeScenario']:
        return pulumi.get(self, "what_if_range_scenario")


@pulumi.output_type
class DashboardFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormatConfiguration":
            suggest = "date_time_format_configuration"
        elif key == "numberFormatConfiguration":
            suggest = "number_format_configuration"
        elif key == "stringFormatConfiguration":
            suggest = "string_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format_configuration: Optional['outputs.DashboardDateTimeFormatConfiguration'] = None,
                 number_format_configuration: Optional['outputs.DashboardNumberFormatConfiguration'] = None,
                 string_format_configuration: Optional['outputs.DashboardStringFormatConfiguration'] = None):
        DashboardFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format_configuration=date_time_format_configuration,
            number_format_configuration=number_format_configuration,
            string_format_configuration=string_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format_configuration: Optional['outputs.DashboardDateTimeFormatConfiguration'] = None,
             number_format_configuration: Optional['outputs.DashboardNumberFormatConfiguration'] = None,
             string_format_configuration: Optional['outputs.DashboardStringFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format_configuration is not None:
            _setter("date_time_format_configuration", date_time_format_configuration)
        if number_format_configuration is not None:
            _setter("number_format_configuration", number_format_configuration)
        if string_format_configuration is not None:
            _setter("string_format_configuration", string_format_configuration)

    @property
    @pulumi.getter(name="dateTimeFormatConfiguration")
    def date_time_format_configuration(self) -> Optional['outputs.DashboardDateTimeFormatConfiguration']:
        return pulumi.get(self, "date_time_format_configuration")

    @property
    @pulumi.getter(name="numberFormatConfiguration")
    def number_format_configuration(self) -> Optional['outputs.DashboardNumberFormatConfiguration']:
        return pulumi.get(self, "number_format_configuration")

    @property
    @pulumi.getter(name="stringFormatConfiguration")
    def string_format_configuration(self) -> Optional['outputs.DashboardStringFormatConfiguration']:
        return pulumi.get(self, "string_format_configuration")


@pulumi.output_type
class DashboardFreeFormLayoutCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "screenCanvasSizeOptions":
            suggest = "screen_canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFreeFormLayoutCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFreeFormLayoutCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFreeFormLayoutCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 screen_canvas_size_options: Optional['outputs.DashboardFreeFormLayoutScreenCanvasSizeOptions'] = None):
        DashboardFreeFormLayoutCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            screen_canvas_size_options=screen_canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             screen_canvas_size_options: Optional['outputs.DashboardFreeFormLayoutScreenCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if screen_canvas_size_options is not None:
            _setter("screen_canvas_size_options", screen_canvas_size_options)

    @property
    @pulumi.getter(name="screenCanvasSizeOptions")
    def screen_canvas_size_options(self) -> Optional['outputs.DashboardFreeFormLayoutScreenCanvasSizeOptions']:
        return pulumi.get(self, "screen_canvas_size_options")


@pulumi.output_type
class DashboardFreeFormLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFreeFormLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFreeFormLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFreeFormLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 elements: Sequence['outputs.DashboardFreeFormLayoutElement'],
                 canvas_size_options: Optional['outputs.DashboardFreeFormLayoutCanvasSizeOptions'] = None):
        DashboardFreeFormLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elements=elements,
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elements: Sequence['outputs.DashboardFreeFormLayoutElement'],
             canvas_size_options: Optional['outputs.DashboardFreeFormLayoutCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("elements", elements)
        if canvas_size_options is not None:
            _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter
    def elements(self) -> Sequence['outputs.DashboardFreeFormLayoutElement']:
        return pulumi.get(self, "elements")

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> Optional['outputs.DashboardFreeFormLayoutCanvasSizeOptions']:
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class DashboardFreeFormLayoutElement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elementId":
            suggest = "element_id"
        elif key == "elementType":
            suggest = "element_type"
        elif key == "xAxisLocation":
            suggest = "x_axis_location"
        elif key == "yAxisLocation":
            suggest = "y_axis_location"
        elif key == "backgroundStyle":
            suggest = "background_style"
        elif key == "borderStyle":
            suggest = "border_style"
        elif key == "loadingAnimation":
            suggest = "loading_animation"
        elif key == "renderingRules":
            suggest = "rendering_rules"
        elif key == "selectedBorderStyle":
            suggest = "selected_border_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFreeFormLayoutElement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFreeFormLayoutElement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFreeFormLayoutElement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 element_id: str,
                 element_type: 'DashboardLayoutElementType',
                 height: str,
                 width: str,
                 x_axis_location: str,
                 y_axis_location: str,
                 background_style: Optional['outputs.DashboardFreeFormLayoutElementBackgroundStyle'] = None,
                 border_style: Optional['outputs.DashboardFreeFormLayoutElementBorderStyle'] = None,
                 loading_animation: Optional['outputs.DashboardLoadingAnimation'] = None,
                 rendering_rules: Optional[Sequence['outputs.DashboardSheetElementRenderingRule']] = None,
                 selected_border_style: Optional['outputs.DashboardFreeFormLayoutElementBorderStyle'] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        """
        :param str height: String based length that is composed of value and unit in px
        :param str width: String based length that is composed of value and unit in px
        :param str x_axis_location: String based length that is composed of value and unit in px
        :param str y_axis_location: String based length that is composed of value and unit in px with Integer.MAX_VALUE as maximum value
        """
        DashboardFreeFormLayoutElement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            element_id=element_id,
            element_type=element_type,
            height=height,
            width=width,
            x_axis_location=x_axis_location,
            y_axis_location=y_axis_location,
            background_style=background_style,
            border_style=border_style,
            loading_animation=loading_animation,
            rendering_rules=rendering_rules,
            selected_border_style=selected_border_style,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             element_id: str,
             element_type: 'DashboardLayoutElementType',
             height: str,
             width: str,
             x_axis_location: str,
             y_axis_location: str,
             background_style: Optional['outputs.DashboardFreeFormLayoutElementBackgroundStyle'] = None,
             border_style: Optional['outputs.DashboardFreeFormLayoutElementBorderStyle'] = None,
             loading_animation: Optional['outputs.DashboardLoadingAnimation'] = None,
             rendering_rules: Optional[Sequence['outputs.DashboardSheetElementRenderingRule']] = None,
             selected_border_style: Optional['outputs.DashboardFreeFormLayoutElementBorderStyle'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("element_id", element_id)
        _setter("element_type", element_type)
        _setter("height", height)
        _setter("width", width)
        _setter("x_axis_location", x_axis_location)
        _setter("y_axis_location", y_axis_location)
        if background_style is not None:
            _setter("background_style", background_style)
        if border_style is not None:
            _setter("border_style", border_style)
        if loading_animation is not None:
            _setter("loading_animation", loading_animation)
        if rendering_rules is not None:
            _setter("rendering_rules", rendering_rules)
        if selected_border_style is not None:
            _setter("selected_border_style", selected_border_style)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="elementId")
    def element_id(self) -> str:
        return pulumi.get(self, "element_id")

    @property
    @pulumi.getter(name="elementType")
    def element_type(self) -> 'DashboardLayoutElementType':
        return pulumi.get(self, "element_type")

    @property
    @pulumi.getter
    def height(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter(name="xAxisLocation")
    def x_axis_location(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "x_axis_location")

    @property
    @pulumi.getter(name="yAxisLocation")
    def y_axis_location(self) -> str:
        """
        String based length that is composed of value and unit in px with Integer.MAX_VALUE as maximum value
        """
        return pulumi.get(self, "y_axis_location")

    @property
    @pulumi.getter(name="backgroundStyle")
    def background_style(self) -> Optional['outputs.DashboardFreeFormLayoutElementBackgroundStyle']:
        return pulumi.get(self, "background_style")

    @property
    @pulumi.getter(name="borderStyle")
    def border_style(self) -> Optional['outputs.DashboardFreeFormLayoutElementBorderStyle']:
        return pulumi.get(self, "border_style")

    @property
    @pulumi.getter(name="loadingAnimation")
    def loading_animation(self) -> Optional['outputs.DashboardLoadingAnimation']:
        return pulumi.get(self, "loading_animation")

    @property
    @pulumi.getter(name="renderingRules")
    def rendering_rules(self) -> Optional[Sequence['outputs.DashboardSheetElementRenderingRule']]:
        return pulumi.get(self, "rendering_rules")

    @property
    @pulumi.getter(name="selectedBorderStyle")
    def selected_border_style(self) -> Optional['outputs.DashboardFreeFormLayoutElementBorderStyle']:
        return pulumi.get(self, "selected_border_style")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardFreeFormLayoutElementBackgroundStyle(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardFreeFormLayoutElementBackgroundStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardFreeFormLayoutElementBorderStyle(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardFreeFormLayoutElementBorderStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardFreeFormLayoutScreenCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optimizedViewPortWidth":
            suggest = "optimized_view_port_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFreeFormLayoutScreenCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFreeFormLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFreeFormLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 optimized_view_port_width: str):
        """
        :param str optimized_view_port_width: String based length that is composed of value and unit in px
        """
        DashboardFreeFormLayoutScreenCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            optimized_view_port_width=optimized_view_port_width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             optimized_view_port_width: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("optimized_view_port_width", optimized_view_port_width)

    @property
    @pulumi.getter(name="optimizedViewPortWidth")
    def optimized_view_port_width(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "optimized_view_port_width")


@pulumi.output_type
class DashboardFreeFormSectionLayoutConfiguration(dict):
    def __init__(__self__, *,
                 elements: Sequence['outputs.DashboardFreeFormLayoutElement']):
        DashboardFreeFormSectionLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elements=elements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elements: Sequence['outputs.DashboardFreeFormLayoutElement'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("elements", elements)

    @property
    @pulumi.getter
    def elements(self) -> Sequence['outputs.DashboardFreeFormLayoutElement']:
        return pulumi.get(self, "elements")


@pulumi.output_type
class DashboardFunnelChartAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardFunnelChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardFunnelChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "dataLabelOptions":
            suggest = "data_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "valueLabelOptions":
            suggest = "value_label_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFunnelChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFunnelChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFunnelChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 data_label_options: Optional['outputs.DashboardFunnelChartDataLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardFunnelChartFieldWells'] = None,
                 sort_configuration: Optional['outputs.DashboardFunnelChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
                 value_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None):
        DashboardFunnelChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_options=category_label_options,
            data_label_options=data_label_options,
            field_wells=field_wells,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            value_label_options=value_label_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             data_label_options: Optional['outputs.DashboardFunnelChartDataLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardFunnelChartFieldWells'] = None,
             sort_configuration: Optional['outputs.DashboardFunnelChartSortConfiguration'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             value_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if data_label_options is not None:
            _setter("data_label_options", data_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if value_label_options is not None:
            _setter("value_label_options", value_label_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="dataLabelOptions")
    def data_label_options(self) -> Optional['outputs.DashboardFunnelChartDataLabelOptions']:
        return pulumi.get(self, "data_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardFunnelChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardFunnelChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="valueLabelOptions")
    def value_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "value_label_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class DashboardFunnelChartDataLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelVisibility":
            suggest = "category_label_visibility"
        elif key == "labelColor":
            suggest = "label_color"
        elif key == "labelFontConfiguration":
            suggest = "label_font_configuration"
        elif key == "measureDataLabelStyle":
            suggest = "measure_data_label_style"
        elif key == "measureLabelVisibility":
            suggest = "measure_label_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFunnelChartDataLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFunnelChartDataLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFunnelChartDataLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_visibility: Optional['DashboardVisibility'] = None,
                 label_color: Optional[str] = None,
                 label_font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
                 measure_data_label_style: Optional['DashboardFunnelChartMeasureDataLabelStyle'] = None,
                 measure_label_visibility: Optional['DashboardVisibility'] = None,
                 position: Optional['DashboardDataLabelPosition'] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardFunnelChartDataLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_visibility=category_label_visibility,
            label_color=label_color,
            label_font_configuration=label_font_configuration,
            measure_data_label_style=measure_data_label_style,
            measure_label_visibility=measure_label_visibility,
            position=position,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_visibility: Optional['DashboardVisibility'] = None,
             label_color: Optional[str] = None,
             label_font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
             measure_data_label_style: Optional['DashboardFunnelChartMeasureDataLabelStyle'] = None,
             measure_label_visibility: Optional['DashboardVisibility'] = None,
             position: Optional['DashboardDataLabelPosition'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_visibility is not None:
            _setter("category_label_visibility", category_label_visibility)
        if label_color is not None:
            _setter("label_color", label_color)
        if label_font_configuration is not None:
            _setter("label_font_configuration", label_font_configuration)
        if measure_data_label_style is not None:
            _setter("measure_data_label_style", measure_data_label_style)
        if measure_label_visibility is not None:
            _setter("measure_label_visibility", measure_label_visibility)
        if position is not None:
            _setter("position", position)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="categoryLabelVisibility")
    def category_label_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "category_label_visibility")

    @property
    @pulumi.getter(name="labelColor")
    def label_color(self) -> Optional[str]:
        return pulumi.get(self, "label_color")

    @property
    @pulumi.getter(name="labelFontConfiguration")
    def label_font_configuration(self) -> Optional['outputs.DashboardFontConfiguration']:
        return pulumi.get(self, "label_font_configuration")

    @property
    @pulumi.getter(name="measureDataLabelStyle")
    def measure_data_label_style(self) -> Optional['DashboardFunnelChartMeasureDataLabelStyle']:
        return pulumi.get(self, "measure_data_label_style")

    @property
    @pulumi.getter(name="measureLabelVisibility")
    def measure_label_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "measure_label_visibility")

    @property
    @pulumi.getter
    def position(self) -> Optional['DashboardDataLabelPosition']:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardFunnelChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "funnelChartAggregatedFieldWells":
            suggest = "funnel_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFunnelChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFunnelChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFunnelChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 funnel_chart_aggregated_field_wells: Optional['outputs.DashboardFunnelChartAggregatedFieldWells'] = None):
        DashboardFunnelChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            funnel_chart_aggregated_field_wells=funnel_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             funnel_chart_aggregated_field_wells: Optional['outputs.DashboardFunnelChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if funnel_chart_aggregated_field_wells is not None:
            _setter("funnel_chart_aggregated_field_wells", funnel_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="funnelChartAggregatedFieldWells")
    def funnel_chart_aggregated_field_wells(self) -> Optional['outputs.DashboardFunnelChartAggregatedFieldWells']:
        return pulumi.get(self, "funnel_chart_aggregated_field_wells")


@pulumi.output_type
class DashboardFunnelChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFunnelChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFunnelChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFunnelChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardFunnelChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class DashboardFunnelChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardFunnelChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardFunnelChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardFunnelChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardFunnelChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardFunnelChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardFunnelChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardFunnelChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardGaugeChartArcConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "foregroundColor":
            suggest = "foreground_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGaugeChartArcConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGaugeChartArcConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGaugeChartArcConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 foreground_color: Optional['outputs.DashboardConditionalFormattingColor'] = None):
        DashboardGaugeChartArcConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            foreground_color=foreground_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             foreground_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if foreground_color is not None:
            _setter("foreground_color", foreground_color)

    @property
    @pulumi.getter(name="foregroundColor")
    def foreground_color(self) -> Optional['outputs.DashboardConditionalFormattingColor']:
        return pulumi.get(self, "foreground_color")


@pulumi.output_type
class DashboardGaugeChartConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGaugeChartConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGaugeChartConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGaugeChartConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.DashboardGaugeChartConditionalFormattingOption']] = None):
        DashboardGaugeChartConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.DashboardGaugeChartConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.DashboardGaugeChartConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class DashboardGaugeChartConditionalFormattingOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryValue":
            suggest = "primary_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGaugeChartConditionalFormattingOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGaugeChartConditionalFormattingOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGaugeChartConditionalFormattingOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc: Optional['outputs.DashboardGaugeChartArcConditionalFormatting'] = None,
                 primary_value: Optional['outputs.DashboardGaugeChartPrimaryValueConditionalFormatting'] = None):
        DashboardGaugeChartConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc=arc,
            primary_value=primary_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc: Optional['outputs.DashboardGaugeChartArcConditionalFormatting'] = None,
             primary_value: Optional['outputs.DashboardGaugeChartPrimaryValueConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc is not None:
            _setter("arc", arc)
        if primary_value is not None:
            _setter("primary_value", primary_value)

    @property
    @pulumi.getter
    def arc(self) -> Optional['outputs.DashboardGaugeChartArcConditionalFormatting']:
        return pulumi.get(self, "arc")

    @property
    @pulumi.getter(name="primaryValue")
    def primary_value(self) -> Optional['outputs.DashboardGaugeChartPrimaryValueConditionalFormatting']:
        return pulumi.get(self, "primary_value")


@pulumi.output_type
class DashboardGaugeChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "gaugeChartOptions":
            suggest = "gauge_chart_options"
        elif key == "tooltipOptions":
            suggest = "tooltip_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGaugeChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGaugeChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGaugeChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardGaugeChartFieldWells'] = None,
                 gauge_chart_options: Optional['outputs.DashboardGaugeChartOptions'] = None,
                 tooltip_options: Optional['outputs.DashboardTooltipOptions'] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None):
        DashboardGaugeChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_labels=data_labels,
            field_wells=field_wells,
            gauge_chart_options=gauge_chart_options,
            tooltip_options=tooltip_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardGaugeChartFieldWells'] = None,
             gauge_chart_options: Optional['outputs.DashboardGaugeChartOptions'] = None,
             tooltip_options: Optional['outputs.DashboardTooltipOptions'] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if gauge_chart_options is not None:
            _setter("gauge_chart_options", gauge_chart_options)
        if tooltip_options is not None:
            _setter("tooltip_options", tooltip_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardGaugeChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="gaugeChartOptions")
    def gauge_chart_options(self) -> Optional['outputs.DashboardGaugeChartOptions']:
        return pulumi.get(self, "gauge_chart_options")

    @property
    @pulumi.getter(name="tooltipOptions")
    def tooltip_options(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class DashboardGaugeChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValues":
            suggest = "target_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGaugeChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGaugeChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGaugeChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardGaugeChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_values=target_values,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if target_values is not None:
            _setter("target_values", target_values)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="targetValues")
    def target_values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "target_values")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardGaugeChartOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcAxis":
            suggest = "arc_axis"
        elif key == "primaryValueDisplayType":
            suggest = "primary_value_display_type"
        elif key == "primaryValueFontConfiguration":
            suggest = "primary_value_font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGaugeChartOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGaugeChartOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGaugeChartOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc: Optional['outputs.DashboardArcConfiguration'] = None,
                 arc_axis: Optional['outputs.DashboardArcAxisConfiguration'] = None,
                 comparison: Optional['outputs.DashboardComparisonConfiguration'] = None,
                 primary_value_display_type: Optional['DashboardPrimaryValueDisplayType'] = None,
                 primary_value_font_configuration: Optional['outputs.DashboardFontConfiguration'] = None):
        DashboardGaugeChartOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc=arc,
            arc_axis=arc_axis,
            comparison=comparison,
            primary_value_display_type=primary_value_display_type,
            primary_value_font_configuration=primary_value_font_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc: Optional['outputs.DashboardArcConfiguration'] = None,
             arc_axis: Optional['outputs.DashboardArcAxisConfiguration'] = None,
             comparison: Optional['outputs.DashboardComparisonConfiguration'] = None,
             primary_value_display_type: Optional['DashboardPrimaryValueDisplayType'] = None,
             primary_value_font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc is not None:
            _setter("arc", arc)
        if arc_axis is not None:
            _setter("arc_axis", arc_axis)
        if comparison is not None:
            _setter("comparison", comparison)
        if primary_value_display_type is not None:
            _setter("primary_value_display_type", primary_value_display_type)
        if primary_value_font_configuration is not None:
            _setter("primary_value_font_configuration", primary_value_font_configuration)

    @property
    @pulumi.getter
    def arc(self) -> Optional['outputs.DashboardArcConfiguration']:
        return pulumi.get(self, "arc")

    @property
    @pulumi.getter(name="arcAxis")
    def arc_axis(self) -> Optional['outputs.DashboardArcAxisConfiguration']:
        return pulumi.get(self, "arc_axis")

    @property
    @pulumi.getter
    def comparison(self) -> Optional['outputs.DashboardComparisonConfiguration']:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter(name="primaryValueDisplayType")
    def primary_value_display_type(self) -> Optional['DashboardPrimaryValueDisplayType']:
        return pulumi.get(self, "primary_value_display_type")

    @property
    @pulumi.getter(name="primaryValueFontConfiguration")
    def primary_value_font_configuration(self) -> Optional['outputs.DashboardFontConfiguration']:
        return pulumi.get(self, "primary_value_font_configuration")


@pulumi.output_type
class DashboardGaugeChartPrimaryValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGaugeChartPrimaryValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGaugeChartPrimaryValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGaugeChartPrimaryValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.DashboardConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None):
        DashboardGaugeChartPrimaryValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.DashboardConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.DashboardConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.DashboardConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class DashboardGaugeChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGaugeChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGaugeChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGaugeChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardGaugeChartConfiguration'] = None,
                 conditional_formatting: Optional['outputs.DashboardGaugeChartConditionalFormatting'] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardGaugeChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardGaugeChartConfiguration'] = None,
             conditional_formatting: Optional['outputs.DashboardGaugeChartConditionalFormatting'] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardGaugeChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.DashboardGaugeChartConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardGeospatialCoordinateBounds(dict):
    def __init__(__self__, *,
                 east: float,
                 north: float,
                 south: float,
                 west: float):
        DashboardGeospatialCoordinateBounds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            east=east,
            north=north,
            south=south,
            west=west,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             east: float,
             north: float,
             south: float,
             west: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("east", east)
        _setter("north", north)
        _setter("south", south)
        _setter("west", west)

    @property
    @pulumi.getter
    def east(self) -> float:
        return pulumi.get(self, "east")

    @property
    @pulumi.getter
    def north(self) -> float:
        return pulumi.get(self, "north")

    @property
    @pulumi.getter
    def south(self) -> float:
        return pulumi.get(self, "south")

    @property
    @pulumi.getter
    def west(self) -> float:
        return pulumi.get(self, "west")


@pulumi.output_type
class DashboardGeospatialHeatmapColorScale(dict):
    def __init__(__self__, *,
                 colors: Optional[Sequence['outputs.DashboardGeospatialHeatmapDataColor']] = None):
        DashboardGeospatialHeatmapColorScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence['outputs.DashboardGeospatialHeatmapDataColor']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if colors is not None:
            _setter("colors", colors)

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.DashboardGeospatialHeatmapDataColor']]:
        return pulumi.get(self, "colors")


@pulumi.output_type
class DashboardGeospatialHeatmapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "heatmapColor":
            suggest = "heatmap_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGeospatialHeatmapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGeospatialHeatmapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGeospatialHeatmapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 heatmap_color: Optional['outputs.DashboardGeospatialHeatmapColorScale'] = None):
        DashboardGeospatialHeatmapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            heatmap_color=heatmap_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             heatmap_color: Optional['outputs.DashboardGeospatialHeatmapColorScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if heatmap_color is not None:
            _setter("heatmap_color", heatmap_color)

    @property
    @pulumi.getter(name="heatmapColor")
    def heatmap_color(self) -> Optional['outputs.DashboardGeospatialHeatmapColorScale']:
        return pulumi.get(self, "heatmap_color")


@pulumi.output_type
class DashboardGeospatialHeatmapDataColor(dict):
    def __init__(__self__, *,
                 color: str):
        DashboardGeospatialHeatmapDataColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")


@pulumi.output_type
class DashboardGeospatialMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 colors: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 geospatial: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardGeospatialMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
            geospatial=geospatial,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             geospatial: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if colors is not None:
            _setter("colors", colors)
        if geospatial is not None:
            _setter("geospatial", geospatial)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter
    def geospatial(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "geospatial")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardGeospatialMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldWells":
            suggest = "field_wells"
        elif key == "mapStyleOptions":
            suggest = "map_style_options"
        elif key == "pointStyleOptions":
            suggest = "point_style_options"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "windowOptions":
            suggest = "window_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGeospatialMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGeospatialMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGeospatialMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_wells: Optional['outputs.DashboardGeospatialMapFieldWells'] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 map_style_options: Optional['outputs.DashboardGeospatialMapStyleOptions'] = None,
                 point_style_options: Optional['outputs.DashboardGeospatialPointStyleOptions'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
                 window_options: Optional['outputs.DashboardGeospatialWindowOptions'] = None):
        DashboardGeospatialMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_wells=field_wells,
            legend=legend,
            map_style_options=map_style_options,
            point_style_options=point_style_options,
            tooltip=tooltip,
            visual_palette=visual_palette,
            window_options=window_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_wells: Optional['outputs.DashboardGeospatialMapFieldWells'] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             map_style_options: Optional['outputs.DashboardGeospatialMapStyleOptions'] = None,
             point_style_options: Optional['outputs.DashboardGeospatialPointStyleOptions'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             window_options: Optional['outputs.DashboardGeospatialWindowOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if map_style_options is not None:
            _setter("map_style_options", map_style_options)
        if point_style_options is not None:
            _setter("point_style_options", point_style_options)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if window_options is not None:
            _setter("window_options", window_options)

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardGeospatialMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="mapStyleOptions")
    def map_style_options(self) -> Optional['outputs.DashboardGeospatialMapStyleOptions']:
        return pulumi.get(self, "map_style_options")

    @property
    @pulumi.getter(name="pointStyleOptions")
    def point_style_options(self) -> Optional['outputs.DashboardGeospatialPointStyleOptions']:
        return pulumi.get(self, "point_style_options")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="windowOptions")
    def window_options(self) -> Optional['outputs.DashboardGeospatialWindowOptions']:
        return pulumi.get(self, "window_options")


@pulumi.output_type
class DashboardGeospatialMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geospatialMapAggregatedFieldWells":
            suggest = "geospatial_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGeospatialMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGeospatialMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGeospatialMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geospatial_map_aggregated_field_wells: Optional['outputs.DashboardGeospatialMapAggregatedFieldWells'] = None):
        DashboardGeospatialMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            geospatial_map_aggregated_field_wells=geospatial_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             geospatial_map_aggregated_field_wells: Optional['outputs.DashboardGeospatialMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if geospatial_map_aggregated_field_wells is not None:
            _setter("geospatial_map_aggregated_field_wells", geospatial_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="geospatialMapAggregatedFieldWells")
    def geospatial_map_aggregated_field_wells(self) -> Optional['outputs.DashboardGeospatialMapAggregatedFieldWells']:
        return pulumi.get(self, "geospatial_map_aggregated_field_wells")


@pulumi.output_type
class DashboardGeospatialMapStyleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseMapStyle":
            suggest = "base_map_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGeospatialMapStyleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGeospatialMapStyleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGeospatialMapStyleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_map_style: Optional['DashboardBaseMapStyleType'] = None):
        DashboardGeospatialMapStyleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base_map_style=base_map_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base_map_style: Optional['DashboardBaseMapStyleType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if base_map_style is not None:
            _setter("base_map_style", base_map_style)

    @property
    @pulumi.getter(name="baseMapStyle")
    def base_map_style(self) -> Optional['DashboardBaseMapStyleType']:
        return pulumi.get(self, "base_map_style")


@pulumi.output_type
class DashboardGeospatialMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGeospatialMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGeospatialMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGeospatialMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardGeospatialMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardGeospatialMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardGeospatialMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardGeospatialMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardGeospatialPointStyleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterMarkerConfiguration":
            suggest = "cluster_marker_configuration"
        elif key == "heatmapConfiguration":
            suggest = "heatmap_configuration"
        elif key == "selectedPointStyle":
            suggest = "selected_point_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGeospatialPointStyleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGeospatialPointStyleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGeospatialPointStyleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_marker_configuration: Optional['outputs.DashboardClusterMarkerConfiguration'] = None,
                 heatmap_configuration: Optional['outputs.DashboardGeospatialHeatmapConfiguration'] = None,
                 selected_point_style: Optional['DashboardGeospatialSelectedPointStyle'] = None):
        DashboardGeospatialPointStyleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_marker_configuration=cluster_marker_configuration,
            heatmap_configuration=heatmap_configuration,
            selected_point_style=selected_point_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_marker_configuration: Optional['outputs.DashboardClusterMarkerConfiguration'] = None,
             heatmap_configuration: Optional['outputs.DashboardGeospatialHeatmapConfiguration'] = None,
             selected_point_style: Optional['DashboardGeospatialSelectedPointStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cluster_marker_configuration is not None:
            _setter("cluster_marker_configuration", cluster_marker_configuration)
        if heatmap_configuration is not None:
            _setter("heatmap_configuration", heatmap_configuration)
        if selected_point_style is not None:
            _setter("selected_point_style", selected_point_style)

    @property
    @pulumi.getter(name="clusterMarkerConfiguration")
    def cluster_marker_configuration(self) -> Optional['outputs.DashboardClusterMarkerConfiguration']:
        return pulumi.get(self, "cluster_marker_configuration")

    @property
    @pulumi.getter(name="heatmapConfiguration")
    def heatmap_configuration(self) -> Optional['outputs.DashboardGeospatialHeatmapConfiguration']:
        return pulumi.get(self, "heatmap_configuration")

    @property
    @pulumi.getter(name="selectedPointStyle")
    def selected_point_style(self) -> Optional['DashboardGeospatialSelectedPointStyle']:
        return pulumi.get(self, "selected_point_style")


@pulumi.output_type
class DashboardGeospatialWindowOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mapZoomMode":
            suggest = "map_zoom_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGeospatialWindowOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGeospatialWindowOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGeospatialWindowOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bounds: Optional['outputs.DashboardGeospatialCoordinateBounds'] = None,
                 map_zoom_mode: Optional['DashboardMapZoomMode'] = None):
        DashboardGeospatialWindowOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bounds=bounds,
            map_zoom_mode=map_zoom_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bounds: Optional['outputs.DashboardGeospatialCoordinateBounds'] = None,
             map_zoom_mode: Optional['DashboardMapZoomMode'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bounds is not None:
            _setter("bounds", bounds)
        if map_zoom_mode is not None:
            _setter("map_zoom_mode", map_zoom_mode)

    @property
    @pulumi.getter
    def bounds(self) -> Optional['outputs.DashboardGeospatialCoordinateBounds']:
        return pulumi.get(self, "bounds")

    @property
    @pulumi.getter(name="mapZoomMode")
    def map_zoom_mode(self) -> Optional['DashboardMapZoomMode']:
        return pulumi.get(self, "map_zoom_mode")


@pulumi.output_type
class DashboardGlobalTableBorderOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sideSpecificBorder":
            suggest = "side_specific_border"
        elif key == "uniformBorder":
            suggest = "uniform_border"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGlobalTableBorderOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGlobalTableBorderOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGlobalTableBorderOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 side_specific_border: Optional['outputs.DashboardTableSideBorderOptions'] = None,
                 uniform_border: Optional['outputs.DashboardTableBorderOptions'] = None):
        DashboardGlobalTableBorderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            side_specific_border=side_specific_border,
            uniform_border=uniform_border,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             side_specific_border: Optional['outputs.DashboardTableSideBorderOptions'] = None,
             uniform_border: Optional['outputs.DashboardTableBorderOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if side_specific_border is not None:
            _setter("side_specific_border", side_specific_border)
        if uniform_border is not None:
            _setter("uniform_border", uniform_border)

    @property
    @pulumi.getter(name="sideSpecificBorder")
    def side_specific_border(self) -> Optional['outputs.DashboardTableSideBorderOptions']:
        return pulumi.get(self, "side_specific_border")

    @property
    @pulumi.getter(name="uniformBorder")
    def uniform_border(self) -> Optional['outputs.DashboardTableBorderOptions']:
        return pulumi.get(self, "uniform_border")


@pulumi.output_type
class DashboardGradientColor(dict):
    def __init__(__self__, *,
                 stops: Optional[Sequence['outputs.DashboardGradientStop']] = None):
        DashboardGradientColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stops=stops,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stops: Optional[Sequence['outputs.DashboardGradientStop']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if stops is not None:
            _setter("stops", stops)

    @property
    @pulumi.getter
    def stops(self) -> Optional[Sequence['outputs.DashboardGradientStop']]:
        return pulumi.get(self, "stops")


@pulumi.output_type
class DashboardGradientStop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gradientOffset":
            suggest = "gradient_offset"
        elif key == "dataValue":
            suggest = "data_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGradientStop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGradientStop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGradientStop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gradient_offset: float,
                 color: Optional[str] = None,
                 data_value: Optional[float] = None):
        DashboardGradientStop._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gradient_offset=gradient_offset,
            color=color,
            data_value=data_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gradient_offset: float,
             color: Optional[str] = None,
             data_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("gradient_offset", gradient_offset)
        if color is not None:
            _setter("color", color)
        if data_value is not None:
            _setter("data_value", data_value)

    @property
    @pulumi.getter(name="gradientOffset")
    def gradient_offset(self) -> float:
        return pulumi.get(self, "gradient_offset")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="dataValue")
    def data_value(self) -> Optional[float]:
        return pulumi.get(self, "data_value")


@pulumi.output_type
class DashboardGridLayoutCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "screenCanvasSizeOptions":
            suggest = "screen_canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGridLayoutCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGridLayoutCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGridLayoutCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 screen_canvas_size_options: Optional['outputs.DashboardGridLayoutScreenCanvasSizeOptions'] = None):
        DashboardGridLayoutCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            screen_canvas_size_options=screen_canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             screen_canvas_size_options: Optional['outputs.DashboardGridLayoutScreenCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if screen_canvas_size_options is not None:
            _setter("screen_canvas_size_options", screen_canvas_size_options)

    @property
    @pulumi.getter(name="screenCanvasSizeOptions")
    def screen_canvas_size_options(self) -> Optional['outputs.DashboardGridLayoutScreenCanvasSizeOptions']:
        return pulumi.get(self, "screen_canvas_size_options")


@pulumi.output_type
class DashboardGridLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGridLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGridLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGridLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 elements: Sequence['outputs.DashboardGridLayoutElement'],
                 canvas_size_options: Optional['outputs.DashboardGridLayoutCanvasSizeOptions'] = None):
        DashboardGridLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elements=elements,
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elements: Sequence['outputs.DashboardGridLayoutElement'],
             canvas_size_options: Optional['outputs.DashboardGridLayoutCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("elements", elements)
        if canvas_size_options is not None:
            _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter
    def elements(self) -> Sequence['outputs.DashboardGridLayoutElement']:
        return pulumi.get(self, "elements")

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> Optional['outputs.DashboardGridLayoutCanvasSizeOptions']:
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class DashboardGridLayoutElement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnSpan":
            suggest = "column_span"
        elif key == "elementId":
            suggest = "element_id"
        elif key == "elementType":
            suggest = "element_type"
        elif key == "rowSpan":
            suggest = "row_span"
        elif key == "columnIndex":
            suggest = "column_index"
        elif key == "rowIndex":
            suggest = "row_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGridLayoutElement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGridLayoutElement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGridLayoutElement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_span: float,
                 element_id: str,
                 element_type: 'DashboardLayoutElementType',
                 row_span: float,
                 column_index: Optional[float] = None,
                 row_index: Optional[float] = None):
        DashboardGridLayoutElement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_span=column_span,
            element_id=element_id,
            element_type=element_type,
            row_span=row_span,
            column_index=column_index,
            row_index=row_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_span: float,
             element_id: str,
             element_type: 'DashboardLayoutElementType',
             row_span: float,
             column_index: Optional[float] = None,
             row_index: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column_span", column_span)
        _setter("element_id", element_id)
        _setter("element_type", element_type)
        _setter("row_span", row_span)
        if column_index is not None:
            _setter("column_index", column_index)
        if row_index is not None:
            _setter("row_index", row_index)

    @property
    @pulumi.getter(name="columnSpan")
    def column_span(self) -> float:
        return pulumi.get(self, "column_span")

    @property
    @pulumi.getter(name="elementId")
    def element_id(self) -> str:
        return pulumi.get(self, "element_id")

    @property
    @pulumi.getter(name="elementType")
    def element_type(self) -> 'DashboardLayoutElementType':
        return pulumi.get(self, "element_type")

    @property
    @pulumi.getter(name="rowSpan")
    def row_span(self) -> float:
        return pulumi.get(self, "row_span")

    @property
    @pulumi.getter(name="columnIndex")
    def column_index(self) -> Optional[float]:
        return pulumi.get(self, "column_index")

    @property
    @pulumi.getter(name="rowIndex")
    def row_index(self) -> Optional[float]:
        return pulumi.get(self, "row_index")


@pulumi.output_type
class DashboardGridLayoutScreenCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resizeOption":
            suggest = "resize_option"
        elif key == "optimizedViewPortWidth":
            suggest = "optimized_view_port_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGridLayoutScreenCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGridLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGridLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resize_option: 'DashboardResizeOption',
                 optimized_view_port_width: Optional[str] = None):
        """
        :param str optimized_view_port_width: String based length that is composed of value and unit in px
        """
        DashboardGridLayoutScreenCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resize_option=resize_option,
            optimized_view_port_width=optimized_view_port_width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resize_option: 'DashboardResizeOption',
             optimized_view_port_width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("resize_option", resize_option)
        if optimized_view_port_width is not None:
            _setter("optimized_view_port_width", optimized_view_port_width)

    @property
    @pulumi.getter(name="resizeOption")
    def resize_option(self) -> 'DashboardResizeOption':
        return pulumi.get(self, "resize_option")

    @property
    @pulumi.getter(name="optimizedViewPortWidth")
    def optimized_view_port_width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "optimized_view_port_width")


@pulumi.output_type
class DashboardGrowthRateComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "periodSize":
            suggest = "period_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardGrowthRateComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardGrowthRateComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardGrowthRateComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 period_size: Optional[float] = None,
                 time: Optional['outputs.DashboardDimensionField'] = None,
                 value: Optional['outputs.DashboardMeasureField'] = None):
        DashboardGrowthRateComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            period_size=period_size,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             period_size: Optional[float] = None,
             time: Optional['outputs.DashboardDimensionField'] = None,
             value: Optional['outputs.DashboardMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if period_size is not None:
            _setter("period_size", period_size)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="periodSize")
    def period_size(self) -> Optional[float]:
        return pulumi.get(self, "period_size")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.DashboardMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardHeaderFooterSectionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionId":
            suggest = "section_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardHeaderFooterSectionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardHeaderFooterSectionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardHeaderFooterSectionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layout: 'outputs.DashboardSectionLayoutConfiguration',
                 section_id: str,
                 style: Optional['outputs.DashboardSectionStyle'] = None):
        DashboardHeaderFooterSectionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            layout=layout,
            section_id=section_id,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             layout: 'outputs.DashboardSectionLayoutConfiguration',
             section_id: str,
             style: Optional['outputs.DashboardSectionStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("layout", layout)
        _setter("section_id", section_id)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter
    def layout(self) -> 'outputs.DashboardSectionLayoutConfiguration':
        return pulumi.get(self, "layout")

    @property
    @pulumi.getter(name="sectionId")
    def section_id(self) -> str:
        return pulumi.get(self, "section_id")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardSectionStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardHeatMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 columns: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 rows: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardHeatMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            rows=rows,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             rows: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if columns is not None:
            _setter("columns", columns)
        if rows is not None:
            _setter("rows", rows)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def rows(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "rows")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardHeatMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorScale":
            suggest = "color_scale"
        elif key == "columnLabelOptions":
            suggest = "column_label_options"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "rowLabelOptions":
            suggest = "row_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardHeatMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardHeatMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardHeatMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_scale: Optional['outputs.DashboardColorScale'] = None,
                 column_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardHeatMapFieldWells'] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 row_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.DashboardHeatMapSortConfiguration'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None):
        DashboardHeatMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_scale=color_scale,
            column_label_options=column_label_options,
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            row_label_options=row_label_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_scale: Optional['outputs.DashboardColorScale'] = None,
             column_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardHeatMapFieldWells'] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             row_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.DashboardHeatMapSortConfiguration'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color_scale is not None:
            _setter("color_scale", color_scale)
        if column_label_options is not None:
            _setter("column_label_options", column_label_options)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if row_label_options is not None:
            _setter("row_label_options", row_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)

    @property
    @pulumi.getter(name="colorScale")
    def color_scale(self) -> Optional['outputs.DashboardColorScale']:
        return pulumi.get(self, "color_scale")

    @property
    @pulumi.getter(name="columnLabelOptions")
    def column_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "column_label_options")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardHeatMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="rowLabelOptions")
    def row_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "row_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardHeatMapSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")


@pulumi.output_type
class DashboardHeatMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "heatMapAggregatedFieldWells":
            suggest = "heat_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardHeatMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardHeatMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardHeatMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 heat_map_aggregated_field_wells: Optional['outputs.DashboardHeatMapAggregatedFieldWells'] = None):
        DashboardHeatMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            heat_map_aggregated_field_wells=heat_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             heat_map_aggregated_field_wells: Optional['outputs.DashboardHeatMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if heat_map_aggregated_field_wells is not None:
            _setter("heat_map_aggregated_field_wells", heat_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="heatMapAggregatedFieldWells")
    def heat_map_aggregated_field_wells(self) -> Optional['outputs.DashboardHeatMapAggregatedFieldWells']:
        return pulumi.get(self, "heat_map_aggregated_field_wells")


@pulumi.output_type
class DashboardHeatMapSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "heatMapColumnItemsLimitConfiguration":
            suggest = "heat_map_column_items_limit_configuration"
        elif key == "heatMapColumnSort":
            suggest = "heat_map_column_sort"
        elif key == "heatMapRowItemsLimitConfiguration":
            suggest = "heat_map_row_items_limit_configuration"
        elif key == "heatMapRowSort":
            suggest = "heat_map_row_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardHeatMapSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardHeatMapSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardHeatMapSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 heat_map_column_items_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 heat_map_column_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
                 heat_map_row_items_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 heat_map_row_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardHeatMapSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            heat_map_column_items_limit_configuration=heat_map_column_items_limit_configuration,
            heat_map_column_sort=heat_map_column_sort,
            heat_map_row_items_limit_configuration=heat_map_row_items_limit_configuration,
            heat_map_row_sort=heat_map_row_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             heat_map_column_items_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             heat_map_column_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             heat_map_row_items_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             heat_map_row_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if heat_map_column_items_limit_configuration is not None:
            _setter("heat_map_column_items_limit_configuration", heat_map_column_items_limit_configuration)
        if heat_map_column_sort is not None:
            _setter("heat_map_column_sort", heat_map_column_sort)
        if heat_map_row_items_limit_configuration is not None:
            _setter("heat_map_row_items_limit_configuration", heat_map_row_items_limit_configuration)
        if heat_map_row_sort is not None:
            _setter("heat_map_row_sort", heat_map_row_sort)

    @property
    @pulumi.getter(name="heatMapColumnItemsLimitConfiguration")
    def heat_map_column_items_limit_configuration(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "heat_map_column_items_limit_configuration")

    @property
    @pulumi.getter(name="heatMapColumnSort")
    def heat_map_column_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "heat_map_column_sort")

    @property
    @pulumi.getter(name="heatMapRowItemsLimitConfiguration")
    def heat_map_row_items_limit_configuration(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "heat_map_row_items_limit_configuration")

    @property
    @pulumi.getter(name="heatMapRowSort")
    def heat_map_row_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "heat_map_row_sort")


@pulumi.output_type
class DashboardHeatMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardHeatMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardHeatMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardHeatMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardHeatMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardHeatMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardHeatMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardHeatMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardHistogramAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardHistogramAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardHistogramBinOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binCount":
            suggest = "bin_count"
        elif key == "binWidth":
            suggest = "bin_width"
        elif key == "selectedBinType":
            suggest = "selected_bin_type"
        elif key == "startValue":
            suggest = "start_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardHistogramBinOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardHistogramBinOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardHistogramBinOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bin_count: Optional['outputs.DashboardBinCountOptions'] = None,
                 bin_width: Optional['outputs.DashboardBinWidthOptions'] = None,
                 selected_bin_type: Optional['DashboardHistogramBinType'] = None,
                 start_value: Optional[float] = None):
        DashboardHistogramBinOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bin_count=bin_count,
            bin_width=bin_width,
            selected_bin_type=selected_bin_type,
            start_value=start_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bin_count: Optional['outputs.DashboardBinCountOptions'] = None,
             bin_width: Optional['outputs.DashboardBinWidthOptions'] = None,
             selected_bin_type: Optional['DashboardHistogramBinType'] = None,
             start_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bin_count is not None:
            _setter("bin_count", bin_count)
        if bin_width is not None:
            _setter("bin_width", bin_width)
        if selected_bin_type is not None:
            _setter("selected_bin_type", selected_bin_type)
        if start_value is not None:
            _setter("start_value", start_value)

    @property
    @pulumi.getter(name="binCount")
    def bin_count(self) -> Optional['outputs.DashboardBinCountOptions']:
        return pulumi.get(self, "bin_count")

    @property
    @pulumi.getter(name="binWidth")
    def bin_width(self) -> Optional['outputs.DashboardBinWidthOptions']:
        return pulumi.get(self, "bin_width")

    @property
    @pulumi.getter(name="selectedBinType")
    def selected_bin_type(self) -> Optional['DashboardHistogramBinType']:
        return pulumi.get(self, "selected_bin_type")

    @property
    @pulumi.getter(name="startValue")
    def start_value(self) -> Optional[float]:
        return pulumi.get(self, "start_value")


@pulumi.output_type
class DashboardHistogramConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binOptions":
            suggest = "bin_options"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "xAxisDisplayOptions":
            suggest = "x_axis_display_options"
        elif key == "xAxisLabelOptions":
            suggest = "x_axis_label_options"
        elif key == "yAxisDisplayOptions":
            suggest = "y_axis_display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardHistogramConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardHistogramConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardHistogramConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bin_options: Optional['outputs.DashboardHistogramBinOptions'] = None,
                 data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardHistogramFieldWells'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
                 x_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 x_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None):
        DashboardHistogramConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bin_options=bin_options,
            data_labels=data_labels,
            field_wells=field_wells,
            tooltip=tooltip,
            visual_palette=visual_palette,
            x_axis_display_options=x_axis_display_options,
            x_axis_label_options=x_axis_label_options,
            y_axis_display_options=y_axis_display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bin_options: Optional['outputs.DashboardHistogramBinOptions'] = None,
             data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardHistogramFieldWells'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             x_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             x_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bin_options is not None:
            _setter("bin_options", bin_options)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if x_axis_display_options is not None:
            _setter("x_axis_display_options", x_axis_display_options)
        if x_axis_label_options is not None:
            _setter("x_axis_label_options", x_axis_label_options)
        if y_axis_display_options is not None:
            _setter("y_axis_display_options", y_axis_display_options)

    @property
    @pulumi.getter(name="binOptions")
    def bin_options(self) -> Optional['outputs.DashboardHistogramBinOptions']:
        return pulumi.get(self, "bin_options")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardHistogramFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="xAxisDisplayOptions")
    def x_axis_display_options(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "x_axis_display_options")

    @property
    @pulumi.getter(name="xAxisLabelOptions")
    def x_axis_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "x_axis_label_options")

    @property
    @pulumi.getter(name="yAxisDisplayOptions")
    def y_axis_display_options(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "y_axis_display_options")


@pulumi.output_type
class DashboardHistogramFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "histogramAggregatedFieldWells":
            suggest = "histogram_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardHistogramFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardHistogramFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardHistogramFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 histogram_aggregated_field_wells: Optional['outputs.DashboardHistogramAggregatedFieldWells'] = None):
        DashboardHistogramFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            histogram_aggregated_field_wells=histogram_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             histogram_aggregated_field_wells: Optional['outputs.DashboardHistogramAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if histogram_aggregated_field_wells is not None:
            _setter("histogram_aggregated_field_wells", histogram_aggregated_field_wells)

    @property
    @pulumi.getter(name="histogramAggregatedFieldWells")
    def histogram_aggregated_field_wells(self) -> Optional['outputs.DashboardHistogramAggregatedFieldWells']:
        return pulumi.get(self, "histogram_aggregated_field_wells")


@pulumi.output_type
class DashboardHistogramVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardHistogramVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardHistogramVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardHistogramVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardHistogramConfiguration'] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardHistogramVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardHistogramConfiguration'] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardHistogramConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardInsightConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customNarrative":
            suggest = "custom_narrative"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardInsightConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardInsightConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardInsightConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computations: Optional[Sequence['outputs.DashboardComputation']] = None,
                 custom_narrative: Optional['outputs.DashboardCustomNarrativeOptions'] = None):
        DashboardInsightConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computations=computations,
            custom_narrative=custom_narrative,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computations: Optional[Sequence['outputs.DashboardComputation']] = None,
             custom_narrative: Optional['outputs.DashboardCustomNarrativeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if computations is not None:
            _setter("computations", computations)
        if custom_narrative is not None:
            _setter("custom_narrative", custom_narrative)

    @property
    @pulumi.getter
    def computations(self) -> Optional[Sequence['outputs.DashboardComputation']]:
        return pulumi.get(self, "computations")

    @property
    @pulumi.getter(name="customNarrative")
    def custom_narrative(self) -> Optional['outputs.DashboardCustomNarrativeOptions']:
        return pulumi.get(self, "custom_narrative")


@pulumi.output_type
class DashboardInsightVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "visualId":
            suggest = "visual_id"
        elif key == "insightConfiguration":
            suggest = "insight_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardInsightVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardInsightVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardInsightVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 insight_configuration: Optional['outputs.DashboardInsightConfiguration'] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardInsightVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            visual_id=visual_id,
            actions=actions,
            insight_configuration=insight_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             insight_configuration: Optional['outputs.DashboardInsightConfiguration'] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if insight_configuration is not None:
            _setter("insight_configuration", insight_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="insightConfiguration")
    def insight_configuration(self) -> Optional['outputs.DashboardInsightConfiguration']:
        return pulumi.get(self, "insight_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardIntegerDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardIntegerDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardIntegerDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardIntegerDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.DashboardDynamicDefaultValue'] = None,
                 static_values: Optional[Sequence[float]] = None):
        DashboardIntegerDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.DashboardDynamicDefaultValue'] = None,
             static_values: Optional[Sequence[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.DashboardDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class DashboardIntegerParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[float]):
        DashboardIntegerParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[float],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[float]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardIntegerParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueType":
            suggest = "parameter_value_type"
        elif key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardIntegerParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardIntegerParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardIntegerParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 parameter_value_type: 'DashboardParameterValueType',
                 default_values: Optional['outputs.DashboardIntegerDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.DashboardMappedDataSetParameter']] = None,
                 value_when_unset: Optional['outputs.DashboardIntegerValueWhenUnsetConfiguration'] = None):
        DashboardIntegerParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameter_value_type=parameter_value_type,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             parameter_value_type: 'DashboardParameterValueType',
             default_values: Optional['outputs.DashboardIntegerDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.DashboardMappedDataSetParameter']] = None,
             value_when_unset: Optional['outputs.DashboardIntegerValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("parameter_value_type", parameter_value_type)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterValueType")
    def parameter_value_type(self) -> 'DashboardParameterValueType':
        return pulumi.get(self, "parameter_value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.DashboardIntegerDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.DashboardMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.DashboardIntegerValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class DashboardIntegerValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardIntegerValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardIntegerValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardIntegerValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[float] = None,
                 value_when_unset_option: Optional['DashboardValueWhenUnsetOption'] = None):
        DashboardIntegerValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[float] = None,
             value_when_unset_option: Optional['DashboardValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[float]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['DashboardValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class DashboardItemsLimitConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "itemsLimit":
            suggest = "items_limit"
        elif key == "otherCategories":
            suggest = "other_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardItemsLimitConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardItemsLimitConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardItemsLimitConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 items_limit: Optional[float] = None,
                 other_categories: Optional['DashboardOtherCategories'] = None):
        DashboardItemsLimitConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items_limit=items_limit,
            other_categories=other_categories,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items_limit: Optional[float] = None,
             other_categories: Optional['DashboardOtherCategories'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if items_limit is not None:
            _setter("items_limit", items_limit)
        if other_categories is not None:
            _setter("other_categories", other_categories)

    @property
    @pulumi.getter(name="itemsLimit")
    def items_limit(self) -> Optional[float]:
        return pulumi.get(self, "items_limit")

    @property
    @pulumi.getter(name="otherCategories")
    def other_categories(self) -> Optional['DashboardOtherCategories']:
        return pulumi.get(self, "other_categories")


@pulumi.output_type
class DashboardKpiActualValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiActualValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiActualValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiActualValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.DashboardConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None):
        DashboardKpiActualValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.DashboardConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.DashboardConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.DashboardConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class DashboardKpiComparisonValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiComparisonValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiComparisonValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiComparisonValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.DashboardConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None):
        DashboardKpiComparisonValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.DashboardConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.DashboardConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.DashboardConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class DashboardKpiConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.DashboardKpiConditionalFormattingOption']] = None):
        DashboardKpiConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.DashboardKpiConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.DashboardKpiConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class DashboardKpiConditionalFormattingOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actualValue":
            suggest = "actual_value"
        elif key == "comparisonValue":
            suggest = "comparison_value"
        elif key == "primaryValue":
            suggest = "primary_value"
        elif key == "progressBar":
            suggest = "progress_bar"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiConditionalFormattingOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiConditionalFormattingOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiConditionalFormattingOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actual_value: Optional['outputs.DashboardKpiActualValueConditionalFormatting'] = None,
                 comparison_value: Optional['outputs.DashboardKpiComparisonValueConditionalFormatting'] = None,
                 primary_value: Optional['outputs.DashboardKpiPrimaryValueConditionalFormatting'] = None,
                 progress_bar: Optional['outputs.DashboardKpiProgressBarConditionalFormatting'] = None):
        DashboardKpiConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actual_value=actual_value,
            comparison_value=comparison_value,
            primary_value=primary_value,
            progress_bar=progress_bar,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actual_value: Optional['outputs.DashboardKpiActualValueConditionalFormatting'] = None,
             comparison_value: Optional['outputs.DashboardKpiComparisonValueConditionalFormatting'] = None,
             primary_value: Optional['outputs.DashboardKpiPrimaryValueConditionalFormatting'] = None,
             progress_bar: Optional['outputs.DashboardKpiProgressBarConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if actual_value is not None:
            _setter("actual_value", actual_value)
        if comparison_value is not None:
            _setter("comparison_value", comparison_value)
        if primary_value is not None:
            _setter("primary_value", primary_value)
        if progress_bar is not None:
            _setter("progress_bar", progress_bar)

    @property
    @pulumi.getter(name="actualValue")
    def actual_value(self) -> Optional['outputs.DashboardKpiActualValueConditionalFormatting']:
        return pulumi.get(self, "actual_value")

    @property
    @pulumi.getter(name="comparisonValue")
    def comparison_value(self) -> Optional['outputs.DashboardKpiComparisonValueConditionalFormatting']:
        return pulumi.get(self, "comparison_value")

    @property
    @pulumi.getter(name="primaryValue")
    def primary_value(self) -> Optional['outputs.DashboardKpiPrimaryValueConditionalFormatting']:
        return pulumi.get(self, "primary_value")

    @property
    @pulumi.getter(name="progressBar")
    def progress_bar(self) -> Optional['outputs.DashboardKpiProgressBarConditionalFormatting']:
        return pulumi.get(self, "progress_bar")


@pulumi.output_type
class DashboardKpiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldWells":
            suggest = "field_wells"
        elif key == "kpiOptions":
            suggest = "kpi_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_wells: Optional['outputs.DashboardKpiFieldWells'] = None,
                 kpi_options: Optional['outputs.DashboardKpiOptions'] = None,
                 sort_configuration: Optional['outputs.DashboardKpiSortConfiguration'] = None):
        DashboardKpiConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_wells=field_wells,
            kpi_options=kpi_options,
            sort_configuration=sort_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_wells: Optional['outputs.DashboardKpiFieldWells'] = None,
             kpi_options: Optional['outputs.DashboardKpiOptions'] = None,
             sort_configuration: Optional['outputs.DashboardKpiSortConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if kpi_options is not None:
            _setter("kpi_options", kpi_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardKpiFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="kpiOptions")
    def kpi_options(self) -> Optional['outputs.DashboardKpiOptions']:
        return pulumi.get(self, "kpi_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardKpiSortConfiguration']:
        return pulumi.get(self, "sort_configuration")


@pulumi.output_type
class DashboardKpiFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValues":
            suggest = "target_values"
        elif key == "trendGroups":
            suggest = "trend_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
                 trend_groups: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardKpiFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_values=target_values,
            trend_groups=trend_groups,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             trend_groups: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if target_values is not None:
            _setter("target_values", target_values)
        if trend_groups is not None:
            _setter("trend_groups", trend_groups)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="targetValues")
    def target_values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "target_values")

    @property
    @pulumi.getter(name="trendGroups")
    def trend_groups(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "trend_groups")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardKpiOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryValueDisplayType":
            suggest = "primary_value_display_type"
        elif key == "primaryValueFontConfiguration":
            suggest = "primary_value_font_configuration"
        elif key == "progressBar":
            suggest = "progress_bar"
        elif key == "secondaryValue":
            suggest = "secondary_value"
        elif key == "secondaryValueFontConfiguration":
            suggest = "secondary_value_font_configuration"
        elif key == "trendArrows":
            suggest = "trend_arrows"
        elif key == "visualLayoutOptions":
            suggest = "visual_layout_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: Optional['outputs.DashboardComparisonConfiguration'] = None,
                 primary_value_display_type: Optional['DashboardPrimaryValueDisplayType'] = None,
                 primary_value_font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
                 progress_bar: Optional['outputs.DashboardProgressBarOptions'] = None,
                 secondary_value: Optional['outputs.DashboardSecondaryValueOptions'] = None,
                 secondary_value_font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
                 sparkline: Optional['outputs.DashboardKpiSparklineOptions'] = None,
                 trend_arrows: Optional['outputs.DashboardTrendArrowOptions'] = None,
                 visual_layout_options: Optional['outputs.DashboardKpiVisualLayoutOptions'] = None):
        DashboardKpiOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison=comparison,
            primary_value_display_type=primary_value_display_type,
            primary_value_font_configuration=primary_value_font_configuration,
            progress_bar=progress_bar,
            secondary_value=secondary_value,
            secondary_value_font_configuration=secondary_value_font_configuration,
            sparkline=sparkline,
            trend_arrows=trend_arrows,
            visual_layout_options=visual_layout_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison: Optional['outputs.DashboardComparisonConfiguration'] = None,
             primary_value_display_type: Optional['DashboardPrimaryValueDisplayType'] = None,
             primary_value_font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
             progress_bar: Optional['outputs.DashboardProgressBarOptions'] = None,
             secondary_value: Optional['outputs.DashboardSecondaryValueOptions'] = None,
             secondary_value_font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
             sparkline: Optional['outputs.DashboardKpiSparklineOptions'] = None,
             trend_arrows: Optional['outputs.DashboardTrendArrowOptions'] = None,
             visual_layout_options: Optional['outputs.DashboardKpiVisualLayoutOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if comparison is not None:
            _setter("comparison", comparison)
        if primary_value_display_type is not None:
            _setter("primary_value_display_type", primary_value_display_type)
        if primary_value_font_configuration is not None:
            _setter("primary_value_font_configuration", primary_value_font_configuration)
        if progress_bar is not None:
            _setter("progress_bar", progress_bar)
        if secondary_value is not None:
            _setter("secondary_value", secondary_value)
        if secondary_value_font_configuration is not None:
            _setter("secondary_value_font_configuration", secondary_value_font_configuration)
        if sparkline is not None:
            _setter("sparkline", sparkline)
        if trend_arrows is not None:
            _setter("trend_arrows", trend_arrows)
        if visual_layout_options is not None:
            _setter("visual_layout_options", visual_layout_options)

    @property
    @pulumi.getter
    def comparison(self) -> Optional['outputs.DashboardComparisonConfiguration']:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter(name="primaryValueDisplayType")
    def primary_value_display_type(self) -> Optional['DashboardPrimaryValueDisplayType']:
        return pulumi.get(self, "primary_value_display_type")

    @property
    @pulumi.getter(name="primaryValueFontConfiguration")
    def primary_value_font_configuration(self) -> Optional['outputs.DashboardFontConfiguration']:
        return pulumi.get(self, "primary_value_font_configuration")

    @property
    @pulumi.getter(name="progressBar")
    def progress_bar(self) -> Optional['outputs.DashboardProgressBarOptions']:
        return pulumi.get(self, "progress_bar")

    @property
    @pulumi.getter(name="secondaryValue")
    def secondary_value(self) -> Optional['outputs.DashboardSecondaryValueOptions']:
        return pulumi.get(self, "secondary_value")

    @property
    @pulumi.getter(name="secondaryValueFontConfiguration")
    def secondary_value_font_configuration(self) -> Optional['outputs.DashboardFontConfiguration']:
        return pulumi.get(self, "secondary_value_font_configuration")

    @property
    @pulumi.getter
    def sparkline(self) -> Optional['outputs.DashboardKpiSparklineOptions']:
        return pulumi.get(self, "sparkline")

    @property
    @pulumi.getter(name="trendArrows")
    def trend_arrows(self) -> Optional['outputs.DashboardTrendArrowOptions']:
        return pulumi.get(self, "trend_arrows")

    @property
    @pulumi.getter(name="visualLayoutOptions")
    def visual_layout_options(self) -> Optional['outputs.DashboardKpiVisualLayoutOptions']:
        return pulumi.get(self, "visual_layout_options")


@pulumi.output_type
class DashboardKpiPrimaryValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiPrimaryValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiPrimaryValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiPrimaryValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.DashboardConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None):
        DashboardKpiPrimaryValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.DashboardConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.DashboardConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.DashboardConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class DashboardKpiProgressBarConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "foregroundColor":
            suggest = "foreground_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiProgressBarConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiProgressBarConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiProgressBarConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 foreground_color: Optional['outputs.DashboardConditionalFormattingColor'] = None):
        DashboardKpiProgressBarConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            foreground_color=foreground_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             foreground_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if foreground_color is not None:
            _setter("foreground_color", foreground_color)

    @property
    @pulumi.getter(name="foregroundColor")
    def foreground_color(self) -> Optional['outputs.DashboardConditionalFormattingColor']:
        return pulumi.get(self, "foreground_color")


@pulumi.output_type
class DashboardKpiSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trendGroupSort":
            suggest = "trend_group_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trend_group_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardKpiSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trend_group_sort=trend_group_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trend_group_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if trend_group_sort is not None:
            _setter("trend_group_sort", trend_group_sort)

    @property
    @pulumi.getter(name="trendGroupSort")
    def trend_group_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "trend_group_sort")


@pulumi.output_type
class DashboardKpiSparklineOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tooltipVisibility":
            suggest = "tooltip_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiSparklineOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiSparklineOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiSparklineOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'DashboardKpiSparklineType',
                 color: Optional[str] = None,
                 tooltip_visibility: Optional['DashboardVisibility'] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardKpiSparklineOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            color=color,
            tooltip_visibility=tooltip_visibility,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: 'DashboardKpiSparklineType',
             color: Optional[str] = None,
             tooltip_visibility: Optional['DashboardVisibility'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if color is not None:
            _setter("color", color)
        if tooltip_visibility is not None:
            _setter("tooltip_visibility", tooltip_visibility)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def type(self) -> 'DashboardKpiSparklineType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="tooltipVisibility")
    def tooltip_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "tooltip_visibility")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardKpiVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardKpiConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 conditional_formatting: Optional['outputs.DashboardKpiConditionalFormatting'] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardKpiVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardKpiConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             conditional_formatting: Optional['outputs.DashboardKpiConditionalFormatting'] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardKpiConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.DashboardKpiConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardKpiVisualLayoutOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "standardLayout":
            suggest = "standard_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardKpiVisualLayoutOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardKpiVisualLayoutOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardKpiVisualLayoutOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 standard_layout: Optional['outputs.DashboardKpiVisualStandardLayout'] = None):
        DashboardKpiVisualLayoutOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            standard_layout=standard_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             standard_layout: Optional['outputs.DashboardKpiVisualStandardLayout'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if standard_layout is not None:
            _setter("standard_layout", standard_layout)

    @property
    @pulumi.getter(name="standardLayout")
    def standard_layout(self) -> Optional['outputs.DashboardKpiVisualStandardLayout']:
        return pulumi.get(self, "standard_layout")


@pulumi.output_type
class DashboardKpiVisualStandardLayout(dict):
    def __init__(__self__, *,
                 type: 'DashboardKpiVisualStandardLayoutType'):
        DashboardKpiVisualStandardLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: 'DashboardKpiVisualStandardLayoutType',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> 'DashboardKpiVisualStandardLayoutType':
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "fontConfiguration":
            suggest = "font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            font_configuration=font_configuration,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.DashboardFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardLayout(dict):
    def __init__(__self__, *,
                 configuration: 'outputs.DashboardLayoutConfiguration'):
        DashboardLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: 'outputs.DashboardLayoutConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("configuration", configuration)

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.DashboardLayoutConfiguration':
        return pulumi.get(self, "configuration")


@pulumi.output_type
class DashboardLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeFormLayout":
            suggest = "free_form_layout"
        elif key == "gridLayout":
            suggest = "grid_layout"
        elif key == "sectionBasedLayout":
            suggest = "section_based_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_form_layout: Optional['outputs.DashboardFreeFormLayoutConfiguration'] = None,
                 grid_layout: Optional['outputs.DashboardGridLayoutConfiguration'] = None,
                 section_based_layout: Optional['outputs.DashboardSectionBasedLayoutConfiguration'] = None):
        DashboardLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            free_form_layout=free_form_layout,
            grid_layout=grid_layout,
            section_based_layout=section_based_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             free_form_layout: Optional['outputs.DashboardFreeFormLayoutConfiguration'] = None,
             grid_layout: Optional['outputs.DashboardGridLayoutConfiguration'] = None,
             section_based_layout: Optional['outputs.DashboardSectionBasedLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if free_form_layout is not None:
            _setter("free_form_layout", free_form_layout)
        if grid_layout is not None:
            _setter("grid_layout", grid_layout)
        if section_based_layout is not None:
            _setter("section_based_layout", section_based_layout)

    @property
    @pulumi.getter(name="freeFormLayout")
    def free_form_layout(self) -> Optional['outputs.DashboardFreeFormLayoutConfiguration']:
        return pulumi.get(self, "free_form_layout")

    @property
    @pulumi.getter(name="gridLayout")
    def grid_layout(self) -> Optional['outputs.DashboardGridLayoutConfiguration']:
        return pulumi.get(self, "grid_layout")

    @property
    @pulumi.getter(name="sectionBasedLayout")
    def section_based_layout(self) -> Optional['outputs.DashboardSectionBasedLayoutConfiguration']:
        return pulumi.get(self, "section_based_layout")


@pulumi.output_type
class DashboardLegendOptions(dict):
    def __init__(__self__, *,
                 height: Optional[str] = None,
                 position: Optional['DashboardLegendPosition'] = None,
                 title: Optional['outputs.DashboardLabelOptions'] = None,
                 visibility: Optional['DashboardVisibility'] = None,
                 width: Optional[str] = None):
        """
        :param str height: String based length that is composed of value and unit in px
        :param str width: String based length that is composed of value and unit in px
        """
        DashboardLegendOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            height=height,
            position=position,
            title=title,
            visibility=visibility,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             height: Optional[str] = None,
             position: Optional['DashboardLegendPosition'] = None,
             title: Optional['outputs.DashboardLabelOptions'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if height is not None:
            _setter("height", height)
        if position is not None:
            _setter("position", position)
        if title is not None:
            _setter("title", title)
        if visibility is not None:
            _setter("visibility", visibility)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def position(self) -> Optional['DashboardLegendPosition']:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardLabelOptions']:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class DashboardLineChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "smallMultiples":
            suggest = "small_multiples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLineChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLineChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLineChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 colors: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 small_multiples: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardLineChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            colors=colors,
            small_multiples=small_multiples,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             colors: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             small_multiples: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if colors is not None:
            _setter("colors", colors)
        if small_multiples is not None:
            _setter("small_multiples", small_multiples)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="smallMultiples")
    def small_multiples(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "small_multiples")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardLineChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionAnalysisDefaults":
            suggest = "contribution_analysis_defaults"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "defaultSeriesSettings":
            suggest = "default_series_settings"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "forecastConfigurations":
            suggest = "forecast_configurations"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "secondaryYAxisDisplayOptions":
            suggest = "secondary_y_axis_display_options"
        elif key == "secondaryYAxisLabelOptions":
            suggest = "secondary_y_axis_label_options"
        elif key == "smallMultiplesOptions":
            suggest = "small_multiples_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "xAxisDisplayOptions":
            suggest = "x_axis_display_options"
        elif key == "xAxisLabelOptions":
            suggest = "x_axis_label_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLineChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLineChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLineChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_analysis_defaults: Optional[Sequence['outputs.DashboardContributionAnalysisDefault']] = None,
                 data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 default_series_settings: Optional['outputs.DashboardLineChartDefaultSeriesSettings'] = None,
                 field_wells: Optional['outputs.DashboardLineChartFieldWells'] = None,
                 forecast_configurations: Optional[Sequence['outputs.DashboardForecastConfiguration']] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.DashboardLineSeriesAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 reference_lines: Optional[Sequence['outputs.DashboardReferenceLine']] = None,
                 secondary_y_axis_display_options: Optional['outputs.DashboardLineSeriesAxisDisplayOptions'] = None,
                 secondary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 series: Optional[Sequence['outputs.DashboardSeriesItem']] = None,
                 small_multiples_options: Optional['outputs.DashboardSmallMultiplesOptions'] = None,
                 sort_configuration: Optional['outputs.DashboardLineChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
                 type: Optional['DashboardLineChartType'] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
                 x_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 x_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None):
        DashboardLineChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contribution_analysis_defaults=contribution_analysis_defaults,
            data_labels=data_labels,
            default_series_settings=default_series_settings,
            field_wells=field_wells,
            forecast_configurations=forecast_configurations,
            legend=legend,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            reference_lines=reference_lines,
            secondary_y_axis_display_options=secondary_y_axis_display_options,
            secondary_y_axis_label_options=secondary_y_axis_label_options,
            series=series,
            small_multiples_options=small_multiples_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            type=type,
            visual_palette=visual_palette,
            x_axis_display_options=x_axis_display_options,
            x_axis_label_options=x_axis_label_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contribution_analysis_defaults: Optional[Sequence['outputs.DashboardContributionAnalysisDefault']] = None,
             data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             default_series_settings: Optional['outputs.DashboardLineChartDefaultSeriesSettings'] = None,
             field_wells: Optional['outputs.DashboardLineChartFieldWells'] = None,
             forecast_configurations: Optional[Sequence['outputs.DashboardForecastConfiguration']] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.DashboardLineSeriesAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             reference_lines: Optional[Sequence['outputs.DashboardReferenceLine']] = None,
             secondary_y_axis_display_options: Optional['outputs.DashboardLineSeriesAxisDisplayOptions'] = None,
             secondary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             series: Optional[Sequence['outputs.DashboardSeriesItem']] = None,
             small_multiples_options: Optional['outputs.DashboardSmallMultiplesOptions'] = None,
             sort_configuration: Optional['outputs.DashboardLineChartSortConfiguration'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             type: Optional['DashboardLineChartType'] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             x_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             x_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if contribution_analysis_defaults is not None:
            _setter("contribution_analysis_defaults", contribution_analysis_defaults)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if default_series_settings is not None:
            _setter("default_series_settings", default_series_settings)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if forecast_configurations is not None:
            _setter("forecast_configurations", forecast_configurations)
        if legend is not None:
            _setter("legend", legend)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if secondary_y_axis_display_options is not None:
            _setter("secondary_y_axis_display_options", secondary_y_axis_display_options)
        if secondary_y_axis_label_options is not None:
            _setter("secondary_y_axis_label_options", secondary_y_axis_label_options)
        if series is not None:
            _setter("series", series)
        if small_multiples_options is not None:
            _setter("small_multiples_options", small_multiples_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if type is not None:
            _setter("type", type)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if x_axis_display_options is not None:
            _setter("x_axis_display_options", x_axis_display_options)
        if x_axis_label_options is not None:
            _setter("x_axis_label_options", x_axis_label_options)

    @property
    @pulumi.getter(name="contributionAnalysisDefaults")
    def contribution_analysis_defaults(self) -> Optional[Sequence['outputs.DashboardContributionAnalysisDefault']]:
        return pulumi.get(self, "contribution_analysis_defaults")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="defaultSeriesSettings")
    def default_series_settings(self) -> Optional['outputs.DashboardLineChartDefaultSeriesSettings']:
        return pulumi.get(self, "default_series_settings")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardLineChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="forecastConfigurations")
    def forecast_configurations(self) -> Optional[Sequence['outputs.DashboardForecastConfiguration']]:
        return pulumi.get(self, "forecast_configurations")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.DashboardLineSeriesAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.DashboardReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="secondaryYAxisDisplayOptions")
    def secondary_y_axis_display_options(self) -> Optional['outputs.DashboardLineSeriesAxisDisplayOptions']:
        return pulumi.get(self, "secondary_y_axis_display_options")

    @property
    @pulumi.getter(name="secondaryYAxisLabelOptions")
    def secondary_y_axis_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "secondary_y_axis_label_options")

    @property
    @pulumi.getter
    def series(self) -> Optional[Sequence['outputs.DashboardSeriesItem']]:
        return pulumi.get(self, "series")

    @property
    @pulumi.getter(name="smallMultiplesOptions")
    def small_multiples_options(self) -> Optional['outputs.DashboardSmallMultiplesOptions']:
        return pulumi.get(self, "small_multiples_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardLineChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter
    def type(self) -> Optional['DashboardLineChartType']:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="xAxisDisplayOptions")
    def x_axis_display_options(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "x_axis_display_options")

    @property
    @pulumi.getter(name="xAxisLabelOptions")
    def x_axis_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "x_axis_label_options")


@pulumi.output_type
class DashboardLineChartDefaultSeriesSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "lineStyleSettings":
            suggest = "line_style_settings"
        elif key == "markerStyleSettings":
            suggest = "marker_style_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLineChartDefaultSeriesSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLineChartDefaultSeriesSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLineChartDefaultSeriesSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: Optional['DashboardAxisBinding'] = None,
                 line_style_settings: Optional['outputs.DashboardLineChartLineStyleSettings'] = None,
                 marker_style_settings: Optional['outputs.DashboardLineChartMarkerStyleSettings'] = None):
        DashboardLineChartDefaultSeriesSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            line_style_settings=line_style_settings,
            marker_style_settings=marker_style_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: Optional['DashboardAxisBinding'] = None,
             line_style_settings: Optional['outputs.DashboardLineChartLineStyleSettings'] = None,
             marker_style_settings: Optional['outputs.DashboardLineChartMarkerStyleSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_binding is not None:
            _setter("axis_binding", axis_binding)
        if line_style_settings is not None:
            _setter("line_style_settings", line_style_settings)
        if marker_style_settings is not None:
            _setter("marker_style_settings", marker_style_settings)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> Optional['DashboardAxisBinding']:
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="lineStyleSettings")
    def line_style_settings(self) -> Optional['outputs.DashboardLineChartLineStyleSettings']:
        return pulumi.get(self, "line_style_settings")

    @property
    @pulumi.getter(name="markerStyleSettings")
    def marker_style_settings(self) -> Optional['outputs.DashboardLineChartMarkerStyleSettings']:
        return pulumi.get(self, "marker_style_settings")


@pulumi.output_type
class DashboardLineChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineChartAggregatedFieldWells":
            suggest = "line_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLineChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLineChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLineChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_chart_aggregated_field_wells: Optional['outputs.DashboardLineChartAggregatedFieldWells'] = None):
        DashboardLineChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            line_chart_aggregated_field_wells=line_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             line_chart_aggregated_field_wells: Optional['outputs.DashboardLineChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if line_chart_aggregated_field_wells is not None:
            _setter("line_chart_aggregated_field_wells", line_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="lineChartAggregatedFieldWells")
    def line_chart_aggregated_field_wells(self) -> Optional['outputs.DashboardLineChartAggregatedFieldWells']:
        return pulumi.get(self, "line_chart_aggregated_field_wells")


@pulumi.output_type
class DashboardLineChartLineStyleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineInterpolation":
            suggest = "line_interpolation"
        elif key == "lineStyle":
            suggest = "line_style"
        elif key == "lineVisibility":
            suggest = "line_visibility"
        elif key == "lineWidth":
            suggest = "line_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLineChartLineStyleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLineChartLineStyleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLineChartLineStyleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_interpolation: Optional['DashboardLineInterpolation'] = None,
                 line_style: Optional['DashboardLineChartLineStyle'] = None,
                 line_visibility: Optional['DashboardVisibility'] = None,
                 line_width: Optional[str] = None):
        """
        :param str line_width: String based length that is composed of value and unit in px
        """
        DashboardLineChartLineStyleSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            line_interpolation=line_interpolation,
            line_style=line_style,
            line_visibility=line_visibility,
            line_width=line_width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             line_interpolation: Optional['DashboardLineInterpolation'] = None,
             line_style: Optional['DashboardLineChartLineStyle'] = None,
             line_visibility: Optional['DashboardVisibility'] = None,
             line_width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if line_interpolation is not None:
            _setter("line_interpolation", line_interpolation)
        if line_style is not None:
            _setter("line_style", line_style)
        if line_visibility is not None:
            _setter("line_visibility", line_visibility)
        if line_width is not None:
            _setter("line_width", line_width)

    @property
    @pulumi.getter(name="lineInterpolation")
    def line_interpolation(self) -> Optional['DashboardLineInterpolation']:
        return pulumi.get(self, "line_interpolation")

    @property
    @pulumi.getter(name="lineStyle")
    def line_style(self) -> Optional['DashboardLineChartLineStyle']:
        return pulumi.get(self, "line_style")

    @property
    @pulumi.getter(name="lineVisibility")
    def line_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "line_visibility")

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "line_width")


@pulumi.output_type
class DashboardLineChartMarkerStyleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "markerColor":
            suggest = "marker_color"
        elif key == "markerShape":
            suggest = "marker_shape"
        elif key == "markerSize":
            suggest = "marker_size"
        elif key == "markerVisibility":
            suggest = "marker_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLineChartMarkerStyleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLineChartMarkerStyleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLineChartMarkerStyleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 marker_color: Optional[str] = None,
                 marker_shape: Optional['DashboardLineChartMarkerShape'] = None,
                 marker_size: Optional[str] = None,
                 marker_visibility: Optional['DashboardVisibility'] = None):
        """
        :param str marker_size: String based length that is composed of value and unit in px
        """
        DashboardLineChartMarkerStyleSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            marker_color=marker_color,
            marker_shape=marker_shape,
            marker_size=marker_size,
            marker_visibility=marker_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             marker_color: Optional[str] = None,
             marker_shape: Optional['DashboardLineChartMarkerShape'] = None,
             marker_size: Optional[str] = None,
             marker_visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if marker_color is not None:
            _setter("marker_color", marker_color)
        if marker_shape is not None:
            _setter("marker_shape", marker_shape)
        if marker_size is not None:
            _setter("marker_size", marker_size)
        if marker_visibility is not None:
            _setter("marker_visibility", marker_visibility)

    @property
    @pulumi.getter(name="markerColor")
    def marker_color(self) -> Optional[str]:
        return pulumi.get(self, "marker_color")

    @property
    @pulumi.getter(name="markerShape")
    def marker_shape(self) -> Optional['DashboardLineChartMarkerShape']:
        return pulumi.get(self, "marker_shape")

    @property
    @pulumi.getter(name="markerSize")
    def marker_size(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "marker_size")

    @property
    @pulumi.getter(name="markerVisibility")
    def marker_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "marker_visibility")


@pulumi.output_type
class DashboardLineChartSeriesSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineStyleSettings":
            suggest = "line_style_settings"
        elif key == "markerStyleSettings":
            suggest = "marker_style_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLineChartSeriesSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLineChartSeriesSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLineChartSeriesSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_style_settings: Optional['outputs.DashboardLineChartLineStyleSettings'] = None,
                 marker_style_settings: Optional['outputs.DashboardLineChartMarkerStyleSettings'] = None):
        DashboardLineChartSeriesSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            line_style_settings=line_style_settings,
            marker_style_settings=marker_style_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             line_style_settings: Optional['outputs.DashboardLineChartLineStyleSettings'] = None,
             marker_style_settings: Optional['outputs.DashboardLineChartMarkerStyleSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if line_style_settings is not None:
            _setter("line_style_settings", line_style_settings)
        if marker_style_settings is not None:
            _setter("marker_style_settings", marker_style_settings)

    @property
    @pulumi.getter(name="lineStyleSettings")
    def line_style_settings(self) -> Optional['outputs.DashboardLineChartLineStyleSettings']:
        return pulumi.get(self, "line_style_settings")

    @property
    @pulumi.getter(name="markerStyleSettings")
    def marker_style_settings(self) -> Optional['outputs.DashboardLineChartMarkerStyleSettings']:
        return pulumi.get(self, "marker_style_settings")


@pulumi.output_type
class DashboardLineChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimitConfiguration":
            suggest = "category_items_limit_configuration"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimitConfiguration":
            suggest = "color_items_limit_configuration"
        elif key == "smallMultiplesLimitConfiguration":
            suggest = "small_multiples_limit_configuration"
        elif key == "smallMultiplesSort":
            suggest = "small_multiples_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLineChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLineChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLineChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
                 color_items_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 small_multiples_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 small_multiples_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardLineChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit_configuration=category_items_limit_configuration,
            category_sort=category_sort,
            color_items_limit_configuration=color_items_limit_configuration,
            small_multiples_limit_configuration=small_multiples_limit_configuration,
            small_multiples_sort=small_multiples_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             color_items_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             small_multiples_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             small_multiples_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit_configuration is not None:
            _setter("category_items_limit_configuration", category_items_limit_configuration)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit_configuration is not None:
            _setter("color_items_limit_configuration", color_items_limit_configuration)
        if small_multiples_limit_configuration is not None:
            _setter("small_multiples_limit_configuration", small_multiples_limit_configuration)
        if small_multiples_sort is not None:
            _setter("small_multiples_sort", small_multiples_sort)

    @property
    @pulumi.getter(name="categoryItemsLimitConfiguration")
    def category_items_limit_configuration(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit_configuration")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimitConfiguration")
    def color_items_limit_configuration(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesLimitConfiguration")
    def small_multiples_limit_configuration(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "small_multiples_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesSort")
    def small_multiples_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "small_multiples_sort")


@pulumi.output_type
class DashboardLineChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLineChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLineChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLineChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardLineChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardLineChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardLineChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardLineChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardLineSeriesAxisDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisOptions":
            suggest = "axis_options"
        elif key == "missingDataConfigurations":
            suggest = "missing_data_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLineSeriesAxisDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLineSeriesAxisDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLineSeriesAxisDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 missing_data_configurations: Optional[Sequence['outputs.DashboardMissingDataConfiguration']] = None):
        DashboardLineSeriesAxisDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_options=axis_options,
            missing_data_configurations=missing_data_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             missing_data_configurations: Optional[Sequence['outputs.DashboardMissingDataConfiguration']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_options is not None:
            _setter("axis_options", axis_options)
        if missing_data_configurations is not None:
            _setter("missing_data_configurations", missing_data_configurations)

    @property
    @pulumi.getter(name="axisOptions")
    def axis_options(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "axis_options")

    @property
    @pulumi.getter(name="missingDataConfigurations")
    def missing_data_configurations(self) -> Optional[Sequence['outputs.DashboardMissingDataConfiguration']]:
        return pulumi.get(self, "missing_data_configurations")


@pulumi.output_type
class DashboardListControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "searchOptions":
            suggest = "search_options"
        elif key == "selectAllOptions":
            suggest = "select_all_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardListControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardListControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardListControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
                 search_options: Optional['outputs.DashboardListControlSearchOptions'] = None,
                 select_all_options: Optional['outputs.DashboardListControlSelectAllOptions'] = None,
                 title_options: Optional['outputs.DashboardLabelOptions'] = None):
        DashboardListControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            search_options=search_options,
            select_all_options=select_all_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
             search_options: Optional['outputs.DashboardListControlSearchOptions'] = None,
             select_all_options: Optional['outputs.DashboardListControlSelectAllOptions'] = None,
             title_options: Optional['outputs.DashboardLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if search_options is not None:
            _setter("search_options", search_options)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.DashboardSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="searchOptions")
    def search_options(self) -> Optional['outputs.DashboardListControlSearchOptions']:
        return pulumi.get(self, "search_options")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['outputs.DashboardListControlSelectAllOptions']:
        return pulumi.get(self, "select_all_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.DashboardLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class DashboardListControlSearchOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardListControlSearchOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardListControlSelectAllOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardListControlSelectAllOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardLoadingAnimation(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardLoadingAnimation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardLocalNavigationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetSheetId":
            suggest = "target_sheet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLocalNavigationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLocalNavigationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLocalNavigationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_sheet_id: str):
        DashboardLocalNavigationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_sheet_id=target_sheet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_sheet_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target_sheet_id", target_sheet_id)

    @property
    @pulumi.getter(name="targetSheetId")
    def target_sheet_id(self) -> str:
        return pulumi.get(self, "target_sheet_id")


@pulumi.output_type
class DashboardLongFormatText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "plainText":
            suggest = "plain_text"
        elif key == "richText":
            suggest = "rich_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLongFormatText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLongFormatText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLongFormatText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 plain_text: Optional[str] = None,
                 rich_text: Optional[str] = None):
        DashboardLongFormatText._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            plain_text=plain_text,
            rich_text=rich_text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             plain_text: Optional[str] = None,
             rich_text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if plain_text is not None:
            _setter("plain_text", plain_text)
        if rich_text is not None:
            _setter("rich_text", rich_text)

    @property
    @pulumi.getter(name="plainText")
    def plain_text(self) -> Optional[str]:
        return pulumi.get(self, "plain_text")

    @property
    @pulumi.getter(name="richText")
    def rich_text(self) -> Optional[str]:
        return pulumi.get(self, "rich_text")


@pulumi.output_type
class DashboardMappedDataSetParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "dataSetParameterName":
            suggest = "data_set_parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardMappedDataSetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardMappedDataSetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardMappedDataSetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 data_set_parameter_name: str):
        DashboardMappedDataSetParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            data_set_parameter_name=data_set_parameter_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             data_set_parameter_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("data_set_parameter_name", data_set_parameter_name)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="dataSetParameterName")
    def data_set_parameter_name(self) -> str:
        return pulumi.get(self, "data_set_parameter_name")


@pulumi.output_type
class DashboardMaximumLabelType(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardMaximumLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardMaximumMinimumComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardMaximumMinimumComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardMaximumMinimumComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardMaximumMinimumComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 type: 'DashboardMaximumMinimumComputationType',
                 name: Optional[str] = None,
                 time: Optional['outputs.DashboardDimensionField'] = None,
                 value: Optional['outputs.DashboardMeasureField'] = None):
        DashboardMaximumMinimumComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            type=type,
            name=name,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             type: 'DashboardMaximumMinimumComputationType',
             name: Optional[str] = None,
             time: Optional['outputs.DashboardDimensionField'] = None,
             value: Optional['outputs.DashboardMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        _setter("type", type)
        if name is not None:
            _setter("name", name)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def type(self) -> 'DashboardMaximumMinimumComputationType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.DashboardMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "calculatedMeasureField":
            suggest = "calculated_measure_field"
        elif key == "categoricalMeasureField":
            suggest = "categorical_measure_field"
        elif key == "dateMeasureField":
            suggest = "date_measure_field"
        elif key == "numericalMeasureField":
            suggest = "numerical_measure_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 calculated_measure_field: Optional['outputs.DashboardCalculatedMeasureField'] = None,
                 categorical_measure_field: Optional['outputs.DashboardCategoricalMeasureField'] = None,
                 date_measure_field: Optional['outputs.DashboardDateMeasureField'] = None,
                 numerical_measure_field: Optional['outputs.DashboardNumericalMeasureField'] = None):
        DashboardMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            calculated_measure_field=calculated_measure_field,
            categorical_measure_field=categorical_measure_field,
            date_measure_field=date_measure_field,
            numerical_measure_field=numerical_measure_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             calculated_measure_field: Optional['outputs.DashboardCalculatedMeasureField'] = None,
             categorical_measure_field: Optional['outputs.DashboardCategoricalMeasureField'] = None,
             date_measure_field: Optional['outputs.DashboardDateMeasureField'] = None,
             numerical_measure_field: Optional['outputs.DashboardNumericalMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if calculated_measure_field is not None:
            _setter("calculated_measure_field", calculated_measure_field)
        if categorical_measure_field is not None:
            _setter("categorical_measure_field", categorical_measure_field)
        if date_measure_field is not None:
            _setter("date_measure_field", date_measure_field)
        if numerical_measure_field is not None:
            _setter("numerical_measure_field", numerical_measure_field)

    @property
    @pulumi.getter(name="calculatedMeasureField")
    def calculated_measure_field(self) -> Optional['outputs.DashboardCalculatedMeasureField']:
        return pulumi.get(self, "calculated_measure_field")

    @property
    @pulumi.getter(name="categoricalMeasureField")
    def categorical_measure_field(self) -> Optional['outputs.DashboardCategoricalMeasureField']:
        return pulumi.get(self, "categorical_measure_field")

    @property
    @pulumi.getter(name="dateMeasureField")
    def date_measure_field(self) -> Optional['outputs.DashboardDateMeasureField']:
        return pulumi.get(self, "date_measure_field")

    @property
    @pulumi.getter(name="numericalMeasureField")
    def numerical_measure_field(self) -> Optional['outputs.DashboardNumericalMeasureField']:
        return pulumi.get(self, "numerical_measure_field")


@pulumi.output_type
class DashboardMetricComparisonComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "fromValue":
            suggest = "from_value"
        elif key == "targetValue":
            suggest = "target_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardMetricComparisonComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardMetricComparisonComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardMetricComparisonComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 from_value: Optional['outputs.DashboardMeasureField'] = None,
                 name: Optional[str] = None,
                 target_value: Optional['outputs.DashboardMeasureField'] = None,
                 time: Optional['outputs.DashboardDimensionField'] = None):
        DashboardMetricComparisonComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            from_value=from_value,
            name=name,
            target_value=target_value,
            time=time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             from_value: Optional['outputs.DashboardMeasureField'] = None,
             name: Optional[str] = None,
             target_value: Optional['outputs.DashboardMeasureField'] = None,
             time: Optional['outputs.DashboardDimensionField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if from_value is not None:
            _setter("from_value", from_value)
        if name is not None:
            _setter("name", name)
        if target_value is not None:
            _setter("target_value", target_value)
        if time is not None:
            _setter("time", time)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional['outputs.DashboardMeasureField']:
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> Optional['outputs.DashboardMeasureField']:
        return pulumi.get(self, "target_value")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardDimensionField']:
        return pulumi.get(self, "time")


@pulumi.output_type
class DashboardMinimumLabelType(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardMinimumLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardMissingDataConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "treatmentOption":
            suggest = "treatment_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardMissingDataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardMissingDataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardMissingDataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 treatment_option: Optional['DashboardMissingDataTreatmentOption'] = None):
        DashboardMissingDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            treatment_option=treatment_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             treatment_option: Optional['DashboardMissingDataTreatmentOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if treatment_option is not None:
            _setter("treatment_option", treatment_option)

    @property
    @pulumi.getter(name="treatmentOption")
    def treatment_option(self) -> Optional['DashboardMissingDataTreatmentOption']:
        return pulumi.get(self, "treatment_option")


@pulumi.output_type
class DashboardNegativeValueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayMode":
            suggest = "display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNegativeValueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNegativeValueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNegativeValueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_mode: 'DashboardNegativeValueDisplayMode'):
        DashboardNegativeValueConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_mode=display_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_mode: 'DashboardNegativeValueDisplayMode',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("display_mode", display_mode)

    @property
    @pulumi.getter(name="displayMode")
    def display_mode(self) -> 'DashboardNegativeValueDisplayMode':
        return pulumi.get(self, "display_mode")


@pulumi.output_type
class DashboardNullValueFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nullString":
            suggest = "null_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNullValueFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNullValueFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNullValueFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 null_string: str):
        DashboardNullValueFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            null_string=null_string,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             null_string: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("null_string", null_string)

    @property
    @pulumi.getter(name="nullString")
    def null_string(self) -> str:
        return pulumi.get(self, "null_string")


@pulumi.output_type
class DashboardNumberDisplayFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlacesConfiguration":
            suggest = "decimal_places_configuration"
        elif key == "negativeValueConfiguration":
            suggest = "negative_value_configuration"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numberScale":
            suggest = "number_scale"
        elif key == "separatorConfiguration":
            suggest = "separator_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNumberDisplayFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNumberDisplayFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNumberDisplayFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places_configuration: Optional['outputs.DashboardDecimalPlacesConfiguration'] = None,
                 negative_value_configuration: Optional['outputs.DashboardNegativeValueConfiguration'] = None,
                 null_value_format_configuration: Optional['outputs.DashboardNullValueFormatConfiguration'] = None,
                 number_scale: Optional['DashboardNumberScale'] = None,
                 prefix: Optional[str] = None,
                 separator_configuration: Optional['outputs.DashboardNumericSeparatorConfiguration'] = None,
                 suffix: Optional[str] = None):
        DashboardNumberDisplayFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places_configuration=decimal_places_configuration,
            negative_value_configuration=negative_value_configuration,
            null_value_format_configuration=null_value_format_configuration,
            number_scale=number_scale,
            prefix=prefix,
            separator_configuration=separator_configuration,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places_configuration: Optional['outputs.DashboardDecimalPlacesConfiguration'] = None,
             negative_value_configuration: Optional['outputs.DashboardNegativeValueConfiguration'] = None,
             null_value_format_configuration: Optional['outputs.DashboardNullValueFormatConfiguration'] = None,
             number_scale: Optional['DashboardNumberScale'] = None,
             prefix: Optional[str] = None,
             separator_configuration: Optional['outputs.DashboardNumericSeparatorConfiguration'] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_places_configuration is not None:
            _setter("decimal_places_configuration", decimal_places_configuration)
        if negative_value_configuration is not None:
            _setter("negative_value_configuration", negative_value_configuration)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if number_scale is not None:
            _setter("number_scale", number_scale)
        if prefix is not None:
            _setter("prefix", prefix)
        if separator_configuration is not None:
            _setter("separator_configuration", separator_configuration)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter(name="decimalPlacesConfiguration")
    def decimal_places_configuration(self) -> Optional['outputs.DashboardDecimalPlacesConfiguration']:
        return pulumi.get(self, "decimal_places_configuration")

    @property
    @pulumi.getter(name="negativeValueConfiguration")
    def negative_value_configuration(self) -> Optional['outputs.DashboardNegativeValueConfiguration']:
        return pulumi.get(self, "negative_value_configuration")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.DashboardNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numberScale")
    def number_scale(self) -> Optional['DashboardNumberScale']:
        return pulumi.get(self, "number_scale")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="separatorConfiguration")
    def separator_configuration(self) -> Optional['outputs.DashboardNumericSeparatorConfiguration']:
        return pulumi.get(self, "separator_configuration")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class DashboardNumberFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNumberFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNumberFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNumberFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_configuration: Optional['outputs.DashboardNumericFormatConfiguration'] = None):
        DashboardNumberFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_configuration: Optional['outputs.DashboardNumericFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.DashboardNumericFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class DashboardNumericAxisOptions(dict):
    def __init__(__self__, *,
                 range: Optional['outputs.DashboardAxisDisplayRange'] = None,
                 scale: Optional['outputs.DashboardAxisScale'] = None):
        DashboardNumericAxisOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            range=range,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             range: Optional['outputs.DashboardAxisDisplayRange'] = None,
             scale: Optional['outputs.DashboardAxisScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if range is not None:
            _setter("range", range)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.DashboardAxisDisplayRange']:
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def scale(self) -> Optional['outputs.DashboardAxisScale']:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardNumericEqualityDrillDownFilter(dict):
    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 value: float):
        DashboardNumericEqualityDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("value", value)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardNumericEqualityFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "matchOperator":
            suggest = "match_operator"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNumericEqualityFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNumericEqualityFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNumericEqualityFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 filter_id: str,
                 match_operator: 'DashboardNumericEqualityMatchOperator',
                 null_option: 'DashboardFilterNullOption',
                 aggregation_function: Optional['outputs.DashboardAggregationFunction'] = None,
                 parameter_name: Optional[str] = None,
                 select_all_options: Optional['DashboardNumericFilterSelectAllOptions'] = None,
                 value: Optional[float] = None):
        DashboardNumericEqualityFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            match_operator=match_operator,
            null_option=null_option,
            aggregation_function=aggregation_function,
            parameter_name=parameter_name,
            select_all_options=select_all_options,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             filter_id: str,
             match_operator: 'DashboardNumericEqualityMatchOperator',
             null_option: 'DashboardFilterNullOption',
             aggregation_function: Optional['outputs.DashboardAggregationFunction'] = None,
             parameter_name: Optional[str] = None,
             select_all_options: Optional['DashboardNumericFilterSelectAllOptions'] = None,
             value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("match_operator", match_operator)
        _setter("null_option", null_option)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'DashboardNumericEqualityMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'DashboardFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.DashboardAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['DashboardNumericFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardNumericFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currencyDisplayFormatConfiguration":
            suggest = "currency_display_format_configuration"
        elif key == "numberDisplayFormatConfiguration":
            suggest = "number_display_format_configuration"
        elif key == "percentageDisplayFormatConfiguration":
            suggest = "percentage_display_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNumericFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNumericFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNumericFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 currency_display_format_configuration: Optional['outputs.DashboardCurrencyDisplayFormatConfiguration'] = None,
                 number_display_format_configuration: Optional['outputs.DashboardNumberDisplayFormatConfiguration'] = None,
                 percentage_display_format_configuration: Optional['outputs.DashboardPercentageDisplayFormatConfiguration'] = None):
        DashboardNumericFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            currency_display_format_configuration=currency_display_format_configuration,
            number_display_format_configuration=number_display_format_configuration,
            percentage_display_format_configuration=percentage_display_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             currency_display_format_configuration: Optional['outputs.DashboardCurrencyDisplayFormatConfiguration'] = None,
             number_display_format_configuration: Optional['outputs.DashboardNumberDisplayFormatConfiguration'] = None,
             percentage_display_format_configuration: Optional['outputs.DashboardPercentageDisplayFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if currency_display_format_configuration is not None:
            _setter("currency_display_format_configuration", currency_display_format_configuration)
        if number_display_format_configuration is not None:
            _setter("number_display_format_configuration", number_display_format_configuration)
        if percentage_display_format_configuration is not None:
            _setter("percentage_display_format_configuration", percentage_display_format_configuration)

    @property
    @pulumi.getter(name="currencyDisplayFormatConfiguration")
    def currency_display_format_configuration(self) -> Optional['outputs.DashboardCurrencyDisplayFormatConfiguration']:
        return pulumi.get(self, "currency_display_format_configuration")

    @property
    @pulumi.getter(name="numberDisplayFormatConfiguration")
    def number_display_format_configuration(self) -> Optional['outputs.DashboardNumberDisplayFormatConfiguration']:
        return pulumi.get(self, "number_display_format_configuration")

    @property
    @pulumi.getter(name="percentageDisplayFormatConfiguration")
    def percentage_display_format_configuration(self) -> Optional['outputs.DashboardPercentageDisplayFormatConfiguration']:
        return pulumi.get(self, "percentage_display_format_configuration")


@pulumi.output_type
class DashboardNumericRangeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "includeMaximum":
            suggest = "include_maximum"
        elif key == "includeMinimum":
            suggest = "include_minimum"
        elif key == "rangeMaximum":
            suggest = "range_maximum"
        elif key == "rangeMinimum":
            suggest = "range_minimum"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNumericRangeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNumericRangeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNumericRangeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 filter_id: str,
                 null_option: 'DashboardFilterNullOption',
                 aggregation_function: Optional['outputs.DashboardAggregationFunction'] = None,
                 include_maximum: Optional[bool] = None,
                 include_minimum: Optional[bool] = None,
                 range_maximum: Optional['outputs.DashboardNumericRangeFilterValue'] = None,
                 range_minimum: Optional['outputs.DashboardNumericRangeFilterValue'] = None,
                 select_all_options: Optional['DashboardNumericFilterSelectAllOptions'] = None):
        DashboardNumericRangeFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            null_option=null_option,
            aggregation_function=aggregation_function,
            include_maximum=include_maximum,
            include_minimum=include_minimum,
            range_maximum=range_maximum,
            range_minimum=range_minimum,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             filter_id: str,
             null_option: 'DashboardFilterNullOption',
             aggregation_function: Optional['outputs.DashboardAggregationFunction'] = None,
             include_maximum: Optional[bool] = None,
             include_minimum: Optional[bool] = None,
             range_maximum: Optional['outputs.DashboardNumericRangeFilterValue'] = None,
             range_minimum: Optional['outputs.DashboardNumericRangeFilterValue'] = None,
             select_all_options: Optional['DashboardNumericFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("null_option", null_option)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if include_maximum is not None:
            _setter("include_maximum", include_maximum)
        if include_minimum is not None:
            _setter("include_minimum", include_minimum)
        if range_maximum is not None:
            _setter("range_maximum", range_maximum)
        if range_minimum is not None:
            _setter("range_minimum", range_minimum)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'DashboardFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.DashboardAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="includeMaximum")
    def include_maximum(self) -> Optional[bool]:
        return pulumi.get(self, "include_maximum")

    @property
    @pulumi.getter(name="includeMinimum")
    def include_minimum(self) -> Optional[bool]:
        return pulumi.get(self, "include_minimum")

    @property
    @pulumi.getter(name="rangeMaximum")
    def range_maximum(self) -> Optional['outputs.DashboardNumericRangeFilterValue']:
        return pulumi.get(self, "range_maximum")

    @property
    @pulumi.getter(name="rangeMinimum")
    def range_minimum(self) -> Optional['outputs.DashboardNumericRangeFilterValue']:
        return pulumi.get(self, "range_minimum")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['DashboardNumericFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class DashboardNumericRangeFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticValue":
            suggest = "static_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNumericRangeFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNumericRangeFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNumericRangeFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 static_value: Optional[float] = None):
        DashboardNumericRangeFilterValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter=parameter,
            static_value=static_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter: Optional[str] = None,
             static_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if parameter is not None:
            _setter("parameter", parameter)
        if static_value is not None:
            _setter("static_value", static_value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter(name="staticValue")
    def static_value(self) -> Optional[float]:
        return pulumi.get(self, "static_value")


@pulumi.output_type
class DashboardNumericSeparatorConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalSeparator":
            suggest = "decimal_separator"
        elif key == "thousandsSeparator":
            suggest = "thousands_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNumericSeparatorConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNumericSeparatorConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNumericSeparatorConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_separator: Optional['DashboardNumericSeparatorSymbol'] = None,
                 thousands_separator: Optional['outputs.DashboardThousandSeparatorOptions'] = None):
        DashboardNumericSeparatorConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_separator=decimal_separator,
            thousands_separator=thousands_separator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_separator: Optional['DashboardNumericSeparatorSymbol'] = None,
             thousands_separator: Optional['outputs.DashboardThousandSeparatorOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_separator is not None:
            _setter("decimal_separator", decimal_separator)
        if thousands_separator is not None:
            _setter("thousands_separator", thousands_separator)

    @property
    @pulumi.getter(name="decimalSeparator")
    def decimal_separator(self) -> Optional['DashboardNumericSeparatorSymbol']:
        return pulumi.get(self, "decimal_separator")

    @property
    @pulumi.getter(name="thousandsSeparator")
    def thousands_separator(self) -> Optional['outputs.DashboardThousandSeparatorOptions']:
        return pulumi.get(self, "thousands_separator")


@pulumi.output_type
class DashboardNumericalAggregationFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "percentileAggregation":
            suggest = "percentile_aggregation"
        elif key == "simpleNumericalAggregation":
            suggest = "simple_numerical_aggregation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNumericalAggregationFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNumericalAggregationFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNumericalAggregationFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentile_aggregation: Optional['outputs.DashboardPercentileAggregation'] = None,
                 simple_numerical_aggregation: Optional['DashboardSimpleNumericalAggregationFunction'] = None):
        DashboardNumericalAggregationFunction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            percentile_aggregation=percentile_aggregation,
            simple_numerical_aggregation=simple_numerical_aggregation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             percentile_aggregation: Optional['outputs.DashboardPercentileAggregation'] = None,
             simple_numerical_aggregation: Optional['DashboardSimpleNumericalAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if percentile_aggregation is not None:
            _setter("percentile_aggregation", percentile_aggregation)
        if simple_numerical_aggregation is not None:
            _setter("simple_numerical_aggregation", simple_numerical_aggregation)

    @property
    @pulumi.getter(name="percentileAggregation")
    def percentile_aggregation(self) -> Optional['outputs.DashboardPercentileAggregation']:
        return pulumi.get(self, "percentile_aggregation")

    @property
    @pulumi.getter(name="simpleNumericalAggregation")
    def simple_numerical_aggregation(self) -> Optional['DashboardSimpleNumericalAggregationFunction']:
        return pulumi.get(self, "simple_numerical_aggregation")


@pulumi.output_type
class DashboardNumericalDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "hierarchyId":
            suggest = "hierarchy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNumericalDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNumericalDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNumericalDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 field_id: str,
                 format_configuration: Optional['outputs.DashboardNumberFormatConfiguration'] = None,
                 hierarchy_id: Optional[str] = None):
        DashboardNumericalDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            format_configuration=format_configuration,
            hierarchy_id=hierarchy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             field_id: str,
             format_configuration: Optional['outputs.DashboardNumberFormatConfiguration'] = None,
             hierarchy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if hierarchy_id is not None:
            _setter("hierarchy_id", hierarchy_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.DashboardNumberFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> Optional[str]:
        return pulumi.get(self, "hierarchy_id")


@pulumi.output_type
class DashboardNumericalMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardNumericalMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardNumericalMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardNumericalMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 field_id: str,
                 aggregation_function: Optional['outputs.DashboardNumericalAggregationFunction'] = None,
                 format_configuration: Optional['outputs.DashboardNumberFormatConfiguration'] = None):
        DashboardNumericalMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            aggregation_function=aggregation_function,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             field_id: str,
             aggregation_function: Optional['outputs.DashboardNumericalAggregationFunction'] = None,
             format_configuration: Optional['outputs.DashboardNumberFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.DashboardNumericalAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.DashboardNumberFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class DashboardPaginationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageNumber":
            suggest = "page_number"
        elif key == "pageSize":
            suggest = "page_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPaginationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPaginationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPaginationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 page_number: float,
                 page_size: float):
        DashboardPaginationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            page_number=page_number,
            page_size=page_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             page_number: float,
             page_size: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("page_number", page_number)
        _setter("page_size", page_size)

    @property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> float:
        return pulumi.get(self, "page_number")

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> float:
        return pulumi.get(self, "page_size")


@pulumi.output_type
class DashboardPanelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "backgroundVisibility":
            suggest = "background_visibility"
        elif key == "borderColor":
            suggest = "border_color"
        elif key == "borderStyle":
            suggest = "border_style"
        elif key == "borderThickness":
            suggest = "border_thickness"
        elif key == "borderVisibility":
            suggest = "border_visibility"
        elif key == "gutterSpacing":
            suggest = "gutter_spacing"
        elif key == "gutterVisibility":
            suggest = "gutter_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[str] = None,
                 background_visibility: Optional['DashboardVisibility'] = None,
                 border_color: Optional[str] = None,
                 border_style: Optional['DashboardPanelBorderStyle'] = None,
                 border_thickness: Optional[str] = None,
                 border_visibility: Optional['DashboardVisibility'] = None,
                 gutter_spacing: Optional[str] = None,
                 gutter_visibility: Optional['DashboardVisibility'] = None,
                 title: Optional['outputs.DashboardPanelTitleOptions'] = None):
        """
        :param str border_thickness: String based length that is composed of value and unit in px
        :param str gutter_spacing: String based length that is composed of value and unit in px
        """
        DashboardPanelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            background_visibility=background_visibility,
            border_color=border_color,
            border_style=border_style,
            border_thickness=border_thickness,
            border_visibility=border_visibility,
            gutter_spacing=gutter_spacing,
            gutter_visibility=gutter_visibility,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional[str] = None,
             background_visibility: Optional['DashboardVisibility'] = None,
             border_color: Optional[str] = None,
             border_style: Optional['DashboardPanelBorderStyle'] = None,
             border_thickness: Optional[str] = None,
             border_visibility: Optional['DashboardVisibility'] = None,
             gutter_spacing: Optional[str] = None,
             gutter_visibility: Optional['DashboardVisibility'] = None,
             title: Optional['outputs.DashboardPanelTitleOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if background_visibility is not None:
            _setter("background_visibility", background_visibility)
        if border_color is not None:
            _setter("border_color", border_color)
        if border_style is not None:
            _setter("border_style", border_style)
        if border_thickness is not None:
            _setter("border_thickness", border_thickness)
        if border_visibility is not None:
            _setter("border_visibility", border_visibility)
        if gutter_spacing is not None:
            _setter("gutter_spacing", gutter_spacing)
        if gutter_visibility is not None:
            _setter("gutter_visibility", gutter_visibility)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="backgroundVisibility")
    def background_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "background_visibility")

    @property
    @pulumi.getter(name="borderColor")
    def border_color(self) -> Optional[str]:
        return pulumi.get(self, "border_color")

    @property
    @pulumi.getter(name="borderStyle")
    def border_style(self) -> Optional['DashboardPanelBorderStyle']:
        return pulumi.get(self, "border_style")

    @property
    @pulumi.getter(name="borderThickness")
    def border_thickness(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "border_thickness")

    @property
    @pulumi.getter(name="borderVisibility")
    def border_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "border_visibility")

    @property
    @pulumi.getter(name="gutterSpacing")
    def gutter_spacing(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "gutter_spacing")

    @property
    @pulumi.getter(name="gutterVisibility")
    def gutter_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "gutter_visibility")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardPanelTitleOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardPanelTitleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontConfiguration":
            suggest = "font_configuration"
        elif key == "horizontalTextAlignment":
            suggest = "horizontal_text_alignment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTitleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTitleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTitleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
                 horizontal_text_alignment: Optional['DashboardHorizontalTextAlignment'] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardPanelTitleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_configuration=font_configuration,
            horizontal_text_alignment=horizontal_text_alignment,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
             horizontal_text_alignment: Optional['DashboardHorizontalTextAlignment'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if horizontal_text_alignment is not None:
            _setter("horizontal_text_alignment", horizontal_text_alignment)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.DashboardFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter(name="horizontalTextAlignment")
    def horizontal_text_alignment(self) -> Optional['DashboardHorizontalTextAlignment']:
        return pulumi.get(self, "horizontal_text_alignment")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardParameterControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimePicker":
            suggest = "date_time_picker"
        elif key == "textArea":
            suggest = "text_area"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardParameterControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardParameterControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardParameterControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_picker: Optional['outputs.DashboardParameterDateTimePickerControl'] = None,
                 dropdown: Optional['outputs.DashboardParameterDropDownControl'] = None,
                 list: Optional['outputs.DashboardParameterListControl'] = None,
                 slider: Optional['outputs.DashboardParameterSliderControl'] = None,
                 text_area: Optional['outputs.DashboardParameterTextAreaControl'] = None,
                 text_field: Optional['outputs.DashboardParameterTextFieldControl'] = None):
        DashboardParameterControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_picker=date_time_picker,
            dropdown=dropdown,
            list=list,
            slider=slider,
            text_area=text_area,
            text_field=text_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_picker: Optional['outputs.DashboardParameterDateTimePickerControl'] = None,
             dropdown: Optional['outputs.DashboardParameterDropDownControl'] = None,
             list: Optional['outputs.DashboardParameterListControl'] = None,
             slider: Optional['outputs.DashboardParameterSliderControl'] = None,
             text_area: Optional['outputs.DashboardParameterTextAreaControl'] = None,
             text_field: Optional['outputs.DashboardParameterTextFieldControl'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_picker is not None:
            _setter("date_time_picker", date_time_picker)
        if dropdown is not None:
            _setter("dropdown", dropdown)
        if list is not None:
            _setter("list", list)
        if slider is not None:
            _setter("slider", slider)
        if text_area is not None:
            _setter("text_area", text_area)
        if text_field is not None:
            _setter("text_field", text_field)

    @property
    @pulumi.getter(name="dateTimePicker")
    def date_time_picker(self) -> Optional['outputs.DashboardParameterDateTimePickerControl']:
        return pulumi.get(self, "date_time_picker")

    @property
    @pulumi.getter
    def dropdown(self) -> Optional['outputs.DashboardParameterDropDownControl']:
        return pulumi.get(self, "dropdown")

    @property
    @pulumi.getter
    def list(self) -> Optional['outputs.DashboardParameterListControl']:
        return pulumi.get(self, "list")

    @property
    @pulumi.getter
    def slider(self) -> Optional['outputs.DashboardParameterSliderControl']:
        return pulumi.get(self, "slider")

    @property
    @pulumi.getter(name="textArea")
    def text_area(self) -> Optional['outputs.DashboardParameterTextAreaControl']:
        return pulumi.get(self, "text_area")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional['outputs.DashboardParameterTextFieldControl']:
        return pulumi.get(self, "text_field")


@pulumi.output_type
class DashboardParameterDateTimePickerControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardParameterDateTimePickerControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardParameterDateTimePickerControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardParameterDateTimePickerControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 display_options: Optional['outputs.DashboardDateTimePickerControlDisplayOptions'] = None):
        DashboardParameterDateTimePickerControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             display_options: Optional['outputs.DashboardDateTimePickerControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardDateTimePickerControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class DashboardParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeParameterDeclaration":
            suggest = "date_time_parameter_declaration"
        elif key == "decimalParameterDeclaration":
            suggest = "decimal_parameter_declaration"
        elif key == "integerParameterDeclaration":
            suggest = "integer_parameter_declaration"
        elif key == "stringParameterDeclaration":
            suggest = "string_parameter_declaration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_parameter_declaration: Optional['outputs.DashboardDateTimeParameterDeclaration'] = None,
                 decimal_parameter_declaration: Optional['outputs.DashboardDecimalParameterDeclaration'] = None,
                 integer_parameter_declaration: Optional['outputs.DashboardIntegerParameterDeclaration'] = None,
                 string_parameter_declaration: Optional['outputs.DashboardStringParameterDeclaration'] = None):
        DashboardParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_parameter_declaration=date_time_parameter_declaration,
            decimal_parameter_declaration=decimal_parameter_declaration,
            integer_parameter_declaration=integer_parameter_declaration,
            string_parameter_declaration=string_parameter_declaration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_parameter_declaration: Optional['outputs.DashboardDateTimeParameterDeclaration'] = None,
             decimal_parameter_declaration: Optional['outputs.DashboardDecimalParameterDeclaration'] = None,
             integer_parameter_declaration: Optional['outputs.DashboardIntegerParameterDeclaration'] = None,
             string_parameter_declaration: Optional['outputs.DashboardStringParameterDeclaration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_parameter_declaration is not None:
            _setter("date_time_parameter_declaration", date_time_parameter_declaration)
        if decimal_parameter_declaration is not None:
            _setter("decimal_parameter_declaration", decimal_parameter_declaration)
        if integer_parameter_declaration is not None:
            _setter("integer_parameter_declaration", integer_parameter_declaration)
        if string_parameter_declaration is not None:
            _setter("string_parameter_declaration", string_parameter_declaration)

    @property
    @pulumi.getter(name="dateTimeParameterDeclaration")
    def date_time_parameter_declaration(self) -> Optional['outputs.DashboardDateTimeParameterDeclaration']:
        return pulumi.get(self, "date_time_parameter_declaration")

    @property
    @pulumi.getter(name="decimalParameterDeclaration")
    def decimal_parameter_declaration(self) -> Optional['outputs.DashboardDecimalParameterDeclaration']:
        return pulumi.get(self, "decimal_parameter_declaration")

    @property
    @pulumi.getter(name="integerParameterDeclaration")
    def integer_parameter_declaration(self) -> Optional['outputs.DashboardIntegerParameterDeclaration']:
        return pulumi.get(self, "integer_parameter_declaration")

    @property
    @pulumi.getter(name="stringParameterDeclaration")
    def string_parameter_declaration(self) -> Optional['outputs.DashboardStringParameterDeclaration']:
        return pulumi.get(self, "string_parameter_declaration")


@pulumi.output_type
class DashboardParameterDropDownControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardParameterDropDownControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardParameterDropDownControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardParameterDropDownControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.DashboardCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.DashboardDropDownControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.DashboardParameterSelectableValues'] = None,
                 type: Optional['DashboardSheetControlListType'] = None):
        DashboardParameterDropDownControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             cascading_control_configuration: Optional['outputs.DashboardCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.DashboardDropDownControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.DashboardParameterSelectableValues'] = None,
             type: Optional['DashboardSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.DashboardCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardDropDownControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.DashboardParameterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['DashboardSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardParameterListControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardParameterListControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardParameterListControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardParameterListControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.DashboardCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.DashboardListControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.DashboardParameterSelectableValues'] = None,
                 type: Optional['DashboardSheetControlListType'] = None):
        DashboardParameterListControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             cascading_control_configuration: Optional['outputs.DashboardCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.DashboardListControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.DashboardParameterSelectableValues'] = None,
             type: Optional['DashboardSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.DashboardCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardListControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.DashboardParameterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['DashboardSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardParameterSelectableValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkToDataSetColumn":
            suggest = "link_to_data_set_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardParameterSelectableValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardParameterSelectableValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardParameterSelectableValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 link_to_data_set_column: Optional['outputs.DashboardColumnIdentifier'] = None,
                 values: Optional[Sequence[str]] = None):
        DashboardParameterSelectableValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            link_to_data_set_column=link_to_data_set_column,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             link_to_data_set_column: Optional['outputs.DashboardColumnIdentifier'] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if link_to_data_set_column is not None:
            _setter("link_to_data_set_column", link_to_data_set_column)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="linkToDataSetColumn")
    def link_to_data_set_column(self) -> Optional['outputs.DashboardColumnIdentifier']:
        return pulumi.get(self, "link_to_data_set_column")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardParameterSliderControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumValue":
            suggest = "maximum_value"
        elif key == "minimumValue":
            suggest = "minimum_value"
        elif key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "stepSize":
            suggest = "step_size"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardParameterSliderControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardParameterSliderControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardParameterSliderControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_value: float,
                 minimum_value: float,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 step_size: float,
                 title: str,
                 display_options: Optional['outputs.DashboardSliderControlDisplayOptions'] = None):
        DashboardParameterSliderControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_value=maximum_value,
            minimum_value=minimum_value,
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            step_size=step_size,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_value: float,
             minimum_value: float,
             parameter_control_id: str,
             source_parameter_name: str,
             step_size: float,
             title: str,
             display_options: Optional['outputs.DashboardSliderControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("maximum_value", maximum_value)
        _setter("minimum_value", minimum_value)
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("step_size", step_size)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="maximumValue")
    def maximum_value(self) -> float:
        return pulumi.get(self, "maximum_value")

    @property
    @pulumi.getter(name="minimumValue")
    def minimum_value(self) -> float:
        return pulumi.get(self, "minimum_value")

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> float:
        return pulumi.get(self, "step_size")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardSliderControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class DashboardParameterTextAreaControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardParameterTextAreaControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardParameterTextAreaControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardParameterTextAreaControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 delimiter: Optional[str] = None,
                 display_options: Optional['outputs.DashboardTextAreaControlDisplayOptions'] = None):
        DashboardParameterTextAreaControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            delimiter=delimiter,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             delimiter: Optional[str] = None,
             display_options: Optional['outputs.DashboardTextAreaControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardTextAreaControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class DashboardParameterTextFieldControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardParameterTextFieldControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardParameterTextFieldControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardParameterTextFieldControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 display_options: Optional['outputs.DashboardTextFieldControlDisplayOptions'] = None):
        DashboardParameterTextFieldControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             display_options: Optional['outputs.DashboardTextFieldControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.DashboardTextFieldControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class DashboardParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeParameters":
            suggest = "date_time_parameters"
        elif key == "decimalParameters":
            suggest = "decimal_parameters"
        elif key == "integerParameters":
            suggest = "integer_parameters"
        elif key == "stringParameters":
            suggest = "string_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_parameters: Optional[Sequence['outputs.DashboardDateTimeParameter']] = None,
                 decimal_parameters: Optional[Sequence['outputs.DashboardDecimalParameter']] = None,
                 integer_parameters: Optional[Sequence['outputs.DashboardIntegerParameter']] = None,
                 string_parameters: Optional[Sequence['outputs.DashboardStringParameter']] = None):
        DashboardParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_parameters=date_time_parameters,
            decimal_parameters=decimal_parameters,
            integer_parameters=integer_parameters,
            string_parameters=string_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_parameters: Optional[Sequence['outputs.DashboardDateTimeParameter']] = None,
             decimal_parameters: Optional[Sequence['outputs.DashboardDecimalParameter']] = None,
             integer_parameters: Optional[Sequence['outputs.DashboardIntegerParameter']] = None,
             string_parameters: Optional[Sequence['outputs.DashboardStringParameter']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_parameters is not None:
            _setter("date_time_parameters", date_time_parameters)
        if decimal_parameters is not None:
            _setter("decimal_parameters", decimal_parameters)
        if integer_parameters is not None:
            _setter("integer_parameters", integer_parameters)
        if string_parameters is not None:
            _setter("string_parameters", string_parameters)

    @property
    @pulumi.getter(name="dateTimeParameters")
    def date_time_parameters(self) -> Optional[Sequence['outputs.DashboardDateTimeParameter']]:
        return pulumi.get(self, "date_time_parameters")

    @property
    @pulumi.getter(name="decimalParameters")
    def decimal_parameters(self) -> Optional[Sequence['outputs.DashboardDecimalParameter']]:
        return pulumi.get(self, "decimal_parameters")

    @property
    @pulumi.getter(name="integerParameters")
    def integer_parameters(self) -> Optional[Sequence['outputs.DashboardIntegerParameter']]:
        return pulumi.get(self, "integer_parameters")

    @property
    @pulumi.getter(name="stringParameters")
    def string_parameters(self) -> Optional[Sequence['outputs.DashboardStringParameter']]:
        return pulumi.get(self, "string_parameters")


@pulumi.output_type
class DashboardPercentVisibleRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPercentVisibleRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPercentVisibleRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPercentVisibleRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[float] = None,
                 to: Optional[float] = None):
        DashboardPercentVisibleRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[float] = None,
             to: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[float]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[float]:
        return pulumi.get(self, "to")


@pulumi.output_type
class DashboardPercentageDisplayFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlacesConfiguration":
            suggest = "decimal_places_configuration"
        elif key == "negativeValueConfiguration":
            suggest = "negative_value_configuration"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "separatorConfiguration":
            suggest = "separator_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPercentageDisplayFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPercentageDisplayFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPercentageDisplayFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places_configuration: Optional['outputs.DashboardDecimalPlacesConfiguration'] = None,
                 negative_value_configuration: Optional['outputs.DashboardNegativeValueConfiguration'] = None,
                 null_value_format_configuration: Optional['outputs.DashboardNullValueFormatConfiguration'] = None,
                 prefix: Optional[str] = None,
                 separator_configuration: Optional['outputs.DashboardNumericSeparatorConfiguration'] = None,
                 suffix: Optional[str] = None):
        DashboardPercentageDisplayFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places_configuration=decimal_places_configuration,
            negative_value_configuration=negative_value_configuration,
            null_value_format_configuration=null_value_format_configuration,
            prefix=prefix,
            separator_configuration=separator_configuration,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places_configuration: Optional['outputs.DashboardDecimalPlacesConfiguration'] = None,
             negative_value_configuration: Optional['outputs.DashboardNegativeValueConfiguration'] = None,
             null_value_format_configuration: Optional['outputs.DashboardNullValueFormatConfiguration'] = None,
             prefix: Optional[str] = None,
             separator_configuration: Optional['outputs.DashboardNumericSeparatorConfiguration'] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_places_configuration is not None:
            _setter("decimal_places_configuration", decimal_places_configuration)
        if negative_value_configuration is not None:
            _setter("negative_value_configuration", negative_value_configuration)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if prefix is not None:
            _setter("prefix", prefix)
        if separator_configuration is not None:
            _setter("separator_configuration", separator_configuration)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter(name="decimalPlacesConfiguration")
    def decimal_places_configuration(self) -> Optional['outputs.DashboardDecimalPlacesConfiguration']:
        return pulumi.get(self, "decimal_places_configuration")

    @property
    @pulumi.getter(name="negativeValueConfiguration")
    def negative_value_configuration(self) -> Optional['outputs.DashboardNegativeValueConfiguration']:
        return pulumi.get(self, "negative_value_configuration")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.DashboardNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="separatorConfiguration")
    def separator_configuration(self) -> Optional['outputs.DashboardNumericSeparatorConfiguration']:
        return pulumi.get(self, "separator_configuration")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class DashboardPercentileAggregation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "percentileValue":
            suggest = "percentile_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPercentileAggregation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPercentileAggregation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPercentileAggregation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentile_value: Optional[float] = None):
        DashboardPercentileAggregation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            percentile_value=percentile_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             percentile_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if percentile_value is not None:
            _setter("percentile_value", percentile_value)

    @property
    @pulumi.getter(name="percentileValue")
    def percentile_value(self) -> Optional[float]:
        return pulumi.get(self, "percentile_value")


@pulumi.output_type
class DashboardPeriodOverPeriodComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPeriodOverPeriodComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPeriodOverPeriodComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPeriodOverPeriodComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 time: Optional['outputs.DashboardDimensionField'] = None,
                 value: Optional['outputs.DashboardMeasureField'] = None):
        DashboardPeriodOverPeriodComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             time: Optional['outputs.DashboardDimensionField'] = None,
             value: Optional['outputs.DashboardMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.DashboardMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardPeriodToDateComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "periodTimeGranularity":
            suggest = "period_time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPeriodToDateComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPeriodToDateComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPeriodToDateComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 period_time_granularity: Optional['DashboardTimeGranularity'] = None,
                 time: Optional['outputs.DashboardDimensionField'] = None,
                 value: Optional['outputs.DashboardMeasureField'] = None):
        DashboardPeriodToDateComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            period_time_granularity=period_time_granularity,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             period_time_granularity: Optional['DashboardTimeGranularity'] = None,
             time: Optional['outputs.DashboardDimensionField'] = None,
             value: Optional['outputs.DashboardMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if period_time_granularity is not None:
            _setter("period_time_granularity", period_time_granularity)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="periodTimeGranularity")
    def period_time_granularity(self) -> Optional['DashboardTimeGranularity']:
        return pulumi.get(self, "period_time_granularity")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.DashboardMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardPieChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "smallMultiples":
            suggest = "small_multiples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPieChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPieChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPieChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 small_multiples: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardPieChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            small_multiples=small_multiples,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             small_multiples: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if small_multiples is not None:
            _setter("small_multiples", small_multiples)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="smallMultiples")
    def small_multiples(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "small_multiples")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardPieChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "contributionAnalysisDefaults":
            suggest = "contribution_analysis_defaults"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "donutOptions":
            suggest = "donut_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "smallMultiplesOptions":
            suggest = "small_multiples_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "valueLabelOptions":
            suggest = "value_label_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPieChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPieChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPieChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 contribution_analysis_defaults: Optional[Sequence['outputs.DashboardContributionAnalysisDefault']] = None,
                 data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 donut_options: Optional['outputs.DashboardDonutOptions'] = None,
                 field_wells: Optional['outputs.DashboardPieChartFieldWells'] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 small_multiples_options: Optional['outputs.DashboardSmallMultiplesOptions'] = None,
                 sort_configuration: Optional['outputs.DashboardPieChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
                 value_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None):
        DashboardPieChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_options=category_label_options,
            contribution_analysis_defaults=contribution_analysis_defaults,
            data_labels=data_labels,
            donut_options=donut_options,
            field_wells=field_wells,
            legend=legend,
            small_multiples_options=small_multiples_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            value_label_options=value_label_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             contribution_analysis_defaults: Optional[Sequence['outputs.DashboardContributionAnalysisDefault']] = None,
             data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             donut_options: Optional['outputs.DashboardDonutOptions'] = None,
             field_wells: Optional['outputs.DashboardPieChartFieldWells'] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             small_multiples_options: Optional['outputs.DashboardSmallMultiplesOptions'] = None,
             sort_configuration: Optional['outputs.DashboardPieChartSortConfiguration'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             value_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if contribution_analysis_defaults is not None:
            _setter("contribution_analysis_defaults", contribution_analysis_defaults)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if donut_options is not None:
            _setter("donut_options", donut_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if small_multiples_options is not None:
            _setter("small_multiples_options", small_multiples_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if value_label_options is not None:
            _setter("value_label_options", value_label_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="contributionAnalysisDefaults")
    def contribution_analysis_defaults(self) -> Optional[Sequence['outputs.DashboardContributionAnalysisDefault']]:
        return pulumi.get(self, "contribution_analysis_defaults")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="donutOptions")
    def donut_options(self) -> Optional['outputs.DashboardDonutOptions']:
        return pulumi.get(self, "donut_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardPieChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="smallMultiplesOptions")
    def small_multiples_options(self) -> Optional['outputs.DashboardSmallMultiplesOptions']:
        return pulumi.get(self, "small_multiples_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardPieChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="valueLabelOptions")
    def value_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "value_label_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class DashboardPieChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pieChartAggregatedFieldWells":
            suggest = "pie_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPieChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPieChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPieChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pie_chart_aggregated_field_wells: Optional['outputs.DashboardPieChartAggregatedFieldWells'] = None):
        DashboardPieChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pie_chart_aggregated_field_wells=pie_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pie_chart_aggregated_field_wells: Optional['outputs.DashboardPieChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pie_chart_aggregated_field_wells is not None:
            _setter("pie_chart_aggregated_field_wells", pie_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="pieChartAggregatedFieldWells")
    def pie_chart_aggregated_field_wells(self) -> Optional['outputs.DashboardPieChartAggregatedFieldWells']:
        return pulumi.get(self, "pie_chart_aggregated_field_wells")


@pulumi.output_type
class DashboardPieChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "smallMultiplesLimitConfiguration":
            suggest = "small_multiples_limit_configuration"
        elif key == "smallMultiplesSort":
            suggest = "small_multiples_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPieChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPieChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPieChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
                 small_multiples_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 small_multiples_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardPieChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            small_multiples_limit_configuration=small_multiples_limit_configuration,
            small_multiples_sort=small_multiples_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             small_multiples_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             small_multiples_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if small_multiples_limit_configuration is not None:
            _setter("small_multiples_limit_configuration", small_multiples_limit_configuration)
        if small_multiples_sort is not None:
            _setter("small_multiples_sort", small_multiples_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="smallMultiplesLimitConfiguration")
    def small_multiples_limit_configuration(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "small_multiples_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesSort")
    def small_multiples_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "small_multiples_sort")


@pulumi.output_type
class DashboardPieChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPieChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPieChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPieChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardPieChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardPieChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardPieChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardPieChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardPivotFieldSortOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "sortBy":
            suggest = "sort_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotFieldSortOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotFieldSortOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotFieldSortOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 sort_by: 'outputs.DashboardPivotTableSortBy'):
        DashboardPivotFieldSortOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            sort_by=sort_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             sort_by: 'outputs.DashboardPivotTableSortBy',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        _setter("sort_by", sort_by)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="sortBy")
    def sort_by(self) -> 'outputs.DashboardPivotTableSortBy':
        return pulumi.get(self, "sort_by")


@pulumi.output_type
class DashboardPivotTableAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 columns: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 rows: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardPivotTableAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            rows=rows,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             rows: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if columns is not None:
            _setter("columns", columns)
        if rows is not None:
            _setter("rows", rows)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def rows(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "rows")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardPivotTableCellConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "textFormat":
            suggest = "text_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableCellConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableCellConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableCellConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 scope: Optional['outputs.DashboardPivotTableConditionalFormattingScope'] = None,
                 scopes: Optional[Sequence['outputs.DashboardPivotTableConditionalFormattingScope']] = None,
                 text_format: Optional['outputs.DashboardTextConditionalFormat'] = None):
        DashboardPivotTableCellConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            scope=scope,
            scopes=scopes,
            text_format=text_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             scope: Optional['outputs.DashboardPivotTableConditionalFormattingScope'] = None,
             scopes: Optional[Sequence['outputs.DashboardPivotTableConditionalFormattingScope']] = None,
             text_format: Optional['outputs.DashboardTextConditionalFormat'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if scope is not None:
            _setter("scope", scope)
        if scopes is not None:
            _setter("scopes", scopes)
        if text_format is not None:
            _setter("text_format", text_format)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.DashboardPivotTableConditionalFormattingScope']:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence['outputs.DashboardPivotTableConditionalFormattingScope']]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="textFormat")
    def text_format(self) -> Optional['outputs.DashboardTextConditionalFormat']:
        return pulumi.get(self, "text_format")


@pulumi.output_type
class DashboardPivotTableConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.DashboardPivotTableConditionalFormattingOption']] = None):
        DashboardPivotTableConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.DashboardPivotTableConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.DashboardPivotTableConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class DashboardPivotTableConditionalFormattingOption(dict):
    def __init__(__self__, *,
                 cell: Optional['outputs.DashboardPivotTableCellConditionalFormatting'] = None):
        DashboardPivotTableConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell=cell,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell: Optional['outputs.DashboardPivotTableCellConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell is not None:
            _setter("cell", cell)

    @property
    @pulumi.getter
    def cell(self) -> Optional['outputs.DashboardPivotTableCellConditionalFormatting']:
        return pulumi.get(self, "cell")


@pulumi.output_type
class DashboardPivotTableConditionalFormattingScope(dict):
    def __init__(__self__, *,
                 role: Optional['DashboardPivotTableConditionalFormattingScopeRole'] = None):
        DashboardPivotTableConditionalFormattingScope._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role: Optional['DashboardPivotTableConditionalFormattingScopeRole'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if role is not None:
            _setter("role", role)

    @property
    @pulumi.getter
    def role(self) -> Optional['DashboardPivotTableConditionalFormattingScopeRole']:
        return pulumi.get(self, "role")


@pulumi.output_type
class DashboardPivotTableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldOptions":
            suggest = "field_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "paginatedReportOptions":
            suggest = "paginated_report_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "tableOptions":
            suggest = "table_options"
        elif key == "totalOptions":
            suggest = "total_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_options: Optional['outputs.DashboardPivotTableFieldOptions'] = None,
                 field_wells: Optional['outputs.DashboardPivotTableFieldWells'] = None,
                 paginated_report_options: Optional['outputs.DashboardPivotTablePaginatedReportOptions'] = None,
                 sort_configuration: Optional['outputs.DashboardPivotTableSortConfiguration'] = None,
                 table_options: Optional['outputs.DashboardPivotTableOptions'] = None,
                 total_options: Optional['outputs.DashboardPivotTableTotalOptions'] = None):
        DashboardPivotTableConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_options=field_options,
            field_wells=field_wells,
            paginated_report_options=paginated_report_options,
            sort_configuration=sort_configuration,
            table_options=table_options,
            total_options=total_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_options: Optional['outputs.DashboardPivotTableFieldOptions'] = None,
             field_wells: Optional['outputs.DashboardPivotTableFieldWells'] = None,
             paginated_report_options: Optional['outputs.DashboardPivotTablePaginatedReportOptions'] = None,
             sort_configuration: Optional['outputs.DashboardPivotTableSortConfiguration'] = None,
             table_options: Optional['outputs.DashboardPivotTableOptions'] = None,
             total_options: Optional['outputs.DashboardPivotTableTotalOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_options is not None:
            _setter("field_options", field_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if paginated_report_options is not None:
            _setter("paginated_report_options", paginated_report_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if table_options is not None:
            _setter("table_options", table_options)
        if total_options is not None:
            _setter("total_options", total_options)

    @property
    @pulumi.getter(name="fieldOptions")
    def field_options(self) -> Optional['outputs.DashboardPivotTableFieldOptions']:
        return pulumi.get(self, "field_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardPivotTableFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="paginatedReportOptions")
    def paginated_report_options(self) -> Optional['outputs.DashboardPivotTablePaginatedReportOptions']:
        return pulumi.get(self, "paginated_report_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardPivotTableSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="tableOptions")
    def table_options(self) -> Optional['outputs.DashboardPivotTableOptions']:
        return pulumi.get(self, "table_options")

    @property
    @pulumi.getter(name="totalOptions")
    def total_options(self) -> Optional['outputs.DashboardPivotTableTotalOptions']:
        return pulumi.get(self, "total_options")


@pulumi.output_type
class DashboardPivotTableDataPathOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPathList":
            suggest = "data_path_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableDataPathOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableDataPathOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableDataPathOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_path_list: Sequence['outputs.DashboardDataPathValue'],
                 width: Optional[str] = None):
        """
        :param str width: String based length that is composed of value and unit in px
        """
        DashboardPivotTableDataPathOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_path_list=data_path_list,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_path_list: Sequence['outputs.DashboardDataPathValue'],
             width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_path_list", data_path_list)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter(name="dataPathList")
    def data_path_list(self) -> Sequence['outputs.DashboardDataPathValue']:
        return pulumi.get(self, "data_path_list")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class DashboardPivotTableFieldCollapseStateOption(dict):
    def __init__(__self__, *,
                 target: 'outputs.DashboardPivotTableFieldCollapseStateTarget',
                 state: Optional['DashboardPivotTableFieldCollapseState'] = None):
        DashboardPivotTableFieldCollapseStateOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: 'outputs.DashboardPivotTableFieldCollapseStateTarget',
             state: Optional['DashboardPivotTableFieldCollapseState'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def target(self) -> 'outputs.DashboardPivotTableFieldCollapseStateTarget':
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def state(self) -> Optional['DashboardPivotTableFieldCollapseState']:
        return pulumi.get(self, "state")


@pulumi.output_type
class DashboardPivotTableFieldCollapseStateTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldDataPathValues":
            suggest = "field_data_path_values"
        elif key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableFieldCollapseStateTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableFieldCollapseStateTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableFieldCollapseStateTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_data_path_values: Optional[Sequence['outputs.DashboardDataPathValue']] = None,
                 field_id: Optional[str] = None):
        DashboardPivotTableFieldCollapseStateTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_data_path_values=field_data_path_values,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_data_path_values: Optional[Sequence['outputs.DashboardDataPathValue']] = None,
             field_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_data_path_values is not None:
            _setter("field_data_path_values", field_data_path_values)
        if field_id is not None:
            _setter("field_id", field_id)

    @property
    @pulumi.getter(name="fieldDataPathValues")
    def field_data_path_values(self) -> Optional[Sequence['outputs.DashboardDataPathValue']]:
        return pulumi.get(self, "field_data_path_values")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class DashboardPivotTableFieldOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "customLabel":
            suggest = "custom_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableFieldOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableFieldOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableFieldOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 custom_label: Optional[str] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardPivotTableFieldOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            custom_label=custom_label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             custom_label: Optional[str] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardPivotTableFieldOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collapseStateOptions":
            suggest = "collapse_state_options"
        elif key == "dataPathOptions":
            suggest = "data_path_options"
        elif key == "selectedFieldOptions":
            suggest = "selected_field_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableFieldOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableFieldOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableFieldOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collapse_state_options: Optional[Sequence['outputs.DashboardPivotTableFieldCollapseStateOption']] = None,
                 data_path_options: Optional[Sequence['outputs.DashboardPivotTableDataPathOption']] = None,
                 selected_field_options: Optional[Sequence['outputs.DashboardPivotTableFieldOption']] = None):
        DashboardPivotTableFieldOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collapse_state_options=collapse_state_options,
            data_path_options=data_path_options,
            selected_field_options=selected_field_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collapse_state_options: Optional[Sequence['outputs.DashboardPivotTableFieldCollapseStateOption']] = None,
             data_path_options: Optional[Sequence['outputs.DashboardPivotTableDataPathOption']] = None,
             selected_field_options: Optional[Sequence['outputs.DashboardPivotTableFieldOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if collapse_state_options is not None:
            _setter("collapse_state_options", collapse_state_options)
        if data_path_options is not None:
            _setter("data_path_options", data_path_options)
        if selected_field_options is not None:
            _setter("selected_field_options", selected_field_options)

    @property
    @pulumi.getter(name="collapseStateOptions")
    def collapse_state_options(self) -> Optional[Sequence['outputs.DashboardPivotTableFieldCollapseStateOption']]:
        return pulumi.get(self, "collapse_state_options")

    @property
    @pulumi.getter(name="dataPathOptions")
    def data_path_options(self) -> Optional[Sequence['outputs.DashboardPivotTableDataPathOption']]:
        return pulumi.get(self, "data_path_options")

    @property
    @pulumi.getter(name="selectedFieldOptions")
    def selected_field_options(self) -> Optional[Sequence['outputs.DashboardPivotTableFieldOption']]:
        return pulumi.get(self, "selected_field_options")


@pulumi.output_type
class DashboardPivotTableFieldSubtotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableFieldSubtotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableFieldSubtotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableFieldSubtotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: Optional[str] = None):
        DashboardPivotTableFieldSubtotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_id is not None:
            _setter("field_id", field_id)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class DashboardPivotTableFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pivotTableAggregatedFieldWells":
            suggest = "pivot_table_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pivot_table_aggregated_field_wells: Optional['outputs.DashboardPivotTableAggregatedFieldWells'] = None):
        DashboardPivotTableFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pivot_table_aggregated_field_wells=pivot_table_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pivot_table_aggregated_field_wells: Optional['outputs.DashboardPivotTableAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pivot_table_aggregated_field_wells is not None:
            _setter("pivot_table_aggregated_field_wells", pivot_table_aggregated_field_wells)

    @property
    @pulumi.getter(name="pivotTableAggregatedFieldWells")
    def pivot_table_aggregated_field_wells(self) -> Optional['outputs.DashboardPivotTableAggregatedFieldWells']:
        return pulumi.get(self, "pivot_table_aggregated_field_wells")


@pulumi.output_type
class DashboardPivotTableOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellStyle":
            suggest = "cell_style"
        elif key == "collapsedRowDimensionsVisibility":
            suggest = "collapsed_row_dimensions_visibility"
        elif key == "columnHeaderStyle":
            suggest = "column_header_style"
        elif key == "columnNamesVisibility":
            suggest = "column_names_visibility"
        elif key == "defaultCellWidth":
            suggest = "default_cell_width"
        elif key == "metricPlacement":
            suggest = "metric_placement"
        elif key == "rowAlternateColorOptions":
            suggest = "row_alternate_color_options"
        elif key == "rowFieldNamesStyle":
            suggest = "row_field_names_style"
        elif key == "rowHeaderStyle":
            suggest = "row_header_style"
        elif key == "rowsLabelOptions":
            suggest = "rows_label_options"
        elif key == "rowsLayout":
            suggest = "rows_layout"
        elif key == "singleMetricVisibility":
            suggest = "single_metric_visibility"
        elif key == "toggleButtonsVisibility":
            suggest = "toggle_buttons_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
                 collapsed_row_dimensions_visibility: Optional['DashboardVisibility'] = None,
                 column_header_style: Optional['outputs.DashboardTableCellStyle'] = None,
                 column_names_visibility: Optional['DashboardVisibility'] = None,
                 default_cell_width: Optional[str] = None,
                 metric_placement: Optional['DashboardPivotTableMetricPlacement'] = None,
                 row_alternate_color_options: Optional['outputs.DashboardRowAlternateColorOptions'] = None,
                 row_field_names_style: Optional['outputs.DashboardTableCellStyle'] = None,
                 row_header_style: Optional['outputs.DashboardTableCellStyle'] = None,
                 rows_label_options: Optional['outputs.DashboardPivotTableRowsLabelOptions'] = None,
                 rows_layout: Optional['DashboardPivotTableRowsLayout'] = None,
                 single_metric_visibility: Optional['DashboardVisibility'] = None,
                 toggle_buttons_visibility: Optional['DashboardVisibility'] = None):
        """
        :param str default_cell_width: String based length that is composed of value and unit in px
        """
        DashboardPivotTableOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell_style=cell_style,
            collapsed_row_dimensions_visibility=collapsed_row_dimensions_visibility,
            column_header_style=column_header_style,
            column_names_visibility=column_names_visibility,
            default_cell_width=default_cell_width,
            metric_placement=metric_placement,
            row_alternate_color_options=row_alternate_color_options,
            row_field_names_style=row_field_names_style,
            row_header_style=row_header_style,
            rows_label_options=rows_label_options,
            rows_layout=rows_layout,
            single_metric_visibility=single_metric_visibility,
            toggle_buttons_visibility=toggle_buttons_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
             collapsed_row_dimensions_visibility: Optional['DashboardVisibility'] = None,
             column_header_style: Optional['outputs.DashboardTableCellStyle'] = None,
             column_names_visibility: Optional['DashboardVisibility'] = None,
             default_cell_width: Optional[str] = None,
             metric_placement: Optional['DashboardPivotTableMetricPlacement'] = None,
             row_alternate_color_options: Optional['outputs.DashboardRowAlternateColorOptions'] = None,
             row_field_names_style: Optional['outputs.DashboardTableCellStyle'] = None,
             row_header_style: Optional['outputs.DashboardTableCellStyle'] = None,
             rows_label_options: Optional['outputs.DashboardPivotTableRowsLabelOptions'] = None,
             rows_layout: Optional['DashboardPivotTableRowsLayout'] = None,
             single_metric_visibility: Optional['DashboardVisibility'] = None,
             toggle_buttons_visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell_style is not None:
            _setter("cell_style", cell_style)
        if collapsed_row_dimensions_visibility is not None:
            _setter("collapsed_row_dimensions_visibility", collapsed_row_dimensions_visibility)
        if column_header_style is not None:
            _setter("column_header_style", column_header_style)
        if column_names_visibility is not None:
            _setter("column_names_visibility", column_names_visibility)
        if default_cell_width is not None:
            _setter("default_cell_width", default_cell_width)
        if metric_placement is not None:
            _setter("metric_placement", metric_placement)
        if row_alternate_color_options is not None:
            _setter("row_alternate_color_options", row_alternate_color_options)
        if row_field_names_style is not None:
            _setter("row_field_names_style", row_field_names_style)
        if row_header_style is not None:
            _setter("row_header_style", row_header_style)
        if rows_label_options is not None:
            _setter("rows_label_options", rows_label_options)
        if rows_layout is not None:
            _setter("rows_layout", rows_layout)
        if single_metric_visibility is not None:
            _setter("single_metric_visibility", single_metric_visibility)
        if toggle_buttons_visibility is not None:
            _setter("toggle_buttons_visibility", toggle_buttons_visibility)

    @property
    @pulumi.getter(name="cellStyle")
    def cell_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "cell_style")

    @property
    @pulumi.getter(name="collapsedRowDimensionsVisibility")
    def collapsed_row_dimensions_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "collapsed_row_dimensions_visibility")

    @property
    @pulumi.getter(name="columnHeaderStyle")
    def column_header_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "column_header_style")

    @property
    @pulumi.getter(name="columnNamesVisibility")
    def column_names_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "column_names_visibility")

    @property
    @pulumi.getter(name="defaultCellWidth")
    def default_cell_width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "default_cell_width")

    @property
    @pulumi.getter(name="metricPlacement")
    def metric_placement(self) -> Optional['DashboardPivotTableMetricPlacement']:
        return pulumi.get(self, "metric_placement")

    @property
    @pulumi.getter(name="rowAlternateColorOptions")
    def row_alternate_color_options(self) -> Optional['outputs.DashboardRowAlternateColorOptions']:
        return pulumi.get(self, "row_alternate_color_options")

    @property
    @pulumi.getter(name="rowFieldNamesStyle")
    def row_field_names_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "row_field_names_style")

    @property
    @pulumi.getter(name="rowHeaderStyle")
    def row_header_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "row_header_style")

    @property
    @pulumi.getter(name="rowsLabelOptions")
    def rows_label_options(self) -> Optional['outputs.DashboardPivotTableRowsLabelOptions']:
        return pulumi.get(self, "rows_label_options")

    @property
    @pulumi.getter(name="rowsLayout")
    def rows_layout(self) -> Optional['DashboardPivotTableRowsLayout']:
        return pulumi.get(self, "rows_layout")

    @property
    @pulumi.getter(name="singleMetricVisibility")
    def single_metric_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "single_metric_visibility")

    @property
    @pulumi.getter(name="toggleButtonsVisibility")
    def toggle_buttons_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "toggle_buttons_visibility")


@pulumi.output_type
class DashboardPivotTablePaginatedReportOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overflowColumnHeaderVisibility":
            suggest = "overflow_column_header_visibility"
        elif key == "verticalOverflowVisibility":
            suggest = "vertical_overflow_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTablePaginatedReportOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTablePaginatedReportOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTablePaginatedReportOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 overflow_column_header_visibility: Optional['DashboardVisibility'] = None,
                 vertical_overflow_visibility: Optional['DashboardVisibility'] = None):
        DashboardPivotTablePaginatedReportOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            overflow_column_header_visibility=overflow_column_header_visibility,
            vertical_overflow_visibility=vertical_overflow_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             overflow_column_header_visibility: Optional['DashboardVisibility'] = None,
             vertical_overflow_visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if overflow_column_header_visibility is not None:
            _setter("overflow_column_header_visibility", overflow_column_header_visibility)
        if vertical_overflow_visibility is not None:
            _setter("vertical_overflow_visibility", vertical_overflow_visibility)

    @property
    @pulumi.getter(name="overflowColumnHeaderVisibility")
    def overflow_column_header_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "overflow_column_header_visibility")

    @property
    @pulumi.getter(name="verticalOverflowVisibility")
    def vertical_overflow_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "vertical_overflow_visibility")


@pulumi.output_type
class DashboardPivotTableRowsLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableRowsLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableRowsLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableRowsLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardPivotTableRowsLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardPivotTableSortBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPath":
            suggest = "data_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableSortBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableSortBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableSortBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional['outputs.DashboardColumnSort'] = None,
                 data_path: Optional['outputs.DashboardDataPathSort'] = None,
                 field: Optional['outputs.DashboardFieldSort'] = None):
        DashboardPivotTableSortBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            data_path=data_path,
            field=field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: Optional['outputs.DashboardColumnSort'] = None,
             data_path: Optional['outputs.DashboardDataPathSort'] = None,
             field: Optional['outputs.DashboardFieldSort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column is not None:
            _setter("column", column)
        if data_path is not None:
            _setter("data_path", data_path)
        if field is not None:
            _setter("field", field)

    @property
    @pulumi.getter
    def column(self) -> Optional['outputs.DashboardColumnSort']:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="dataPath")
    def data_path(self) -> Optional['outputs.DashboardDataPathSort']:
        return pulumi.get(self, "data_path")

    @property
    @pulumi.getter
    def field(self) -> Optional['outputs.DashboardFieldSort']:
        return pulumi.get(self, "field")


@pulumi.output_type
class DashboardPivotTableSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldSortOptions":
            suggest = "field_sort_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_sort_options: Optional[Sequence['outputs.DashboardPivotFieldSortOptions']] = None):
        DashboardPivotTableSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_sort_options=field_sort_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_sort_options: Optional[Sequence['outputs.DashboardPivotFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_sort_options is not None:
            _setter("field_sort_options", field_sort_options)

    @property
    @pulumi.getter(name="fieldSortOptions")
    def field_sort_options(self) -> Optional[Sequence['outputs.DashboardPivotFieldSortOptions']]:
        return pulumi.get(self, "field_sort_options")


@pulumi.output_type
class DashboardPivotTableTotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnSubtotalOptions":
            suggest = "column_subtotal_options"
        elif key == "columnTotalOptions":
            suggest = "column_total_options"
        elif key == "rowSubtotalOptions":
            suggest = "row_subtotal_options"
        elif key == "rowTotalOptions":
            suggest = "row_total_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableTotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableTotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableTotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_subtotal_options: Optional['outputs.DashboardSubtotalOptions'] = None,
                 column_total_options: Optional['outputs.DashboardPivotTotalOptions'] = None,
                 row_subtotal_options: Optional['outputs.DashboardSubtotalOptions'] = None,
                 row_total_options: Optional['outputs.DashboardPivotTotalOptions'] = None):
        DashboardPivotTableTotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_subtotal_options=column_subtotal_options,
            column_total_options=column_total_options,
            row_subtotal_options=row_subtotal_options,
            row_total_options=row_total_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_subtotal_options: Optional['outputs.DashboardSubtotalOptions'] = None,
             column_total_options: Optional['outputs.DashboardPivotTotalOptions'] = None,
             row_subtotal_options: Optional['outputs.DashboardSubtotalOptions'] = None,
             row_total_options: Optional['outputs.DashboardPivotTotalOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_subtotal_options is not None:
            _setter("column_subtotal_options", column_subtotal_options)
        if column_total_options is not None:
            _setter("column_total_options", column_total_options)
        if row_subtotal_options is not None:
            _setter("row_subtotal_options", row_subtotal_options)
        if row_total_options is not None:
            _setter("row_total_options", row_total_options)

    @property
    @pulumi.getter(name="columnSubtotalOptions")
    def column_subtotal_options(self) -> Optional['outputs.DashboardSubtotalOptions']:
        return pulumi.get(self, "column_subtotal_options")

    @property
    @pulumi.getter(name="columnTotalOptions")
    def column_total_options(self) -> Optional['outputs.DashboardPivotTotalOptions']:
        return pulumi.get(self, "column_total_options")

    @property
    @pulumi.getter(name="rowSubtotalOptions")
    def row_subtotal_options(self) -> Optional['outputs.DashboardSubtotalOptions']:
        return pulumi.get(self, "row_subtotal_options")

    @property
    @pulumi.getter(name="rowTotalOptions")
    def row_total_options(self) -> Optional['outputs.DashboardPivotTotalOptions']:
        return pulumi.get(self, "row_total_options")


@pulumi.output_type
class DashboardPivotTableVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTableVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTableVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTableVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardPivotTableConfiguration'] = None,
                 conditional_formatting: Optional['outputs.DashboardPivotTableConditionalFormatting'] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardPivotTableVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardPivotTableConfiguration'] = None,
             conditional_formatting: Optional['outputs.DashboardPivotTableConditionalFormatting'] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardPivotTableConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.DashboardPivotTableConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardPivotTotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "metricHeaderCellStyle":
            suggest = "metric_header_cell_style"
        elif key == "scrollStatus":
            suggest = "scroll_status"
        elif key == "totalCellStyle":
            suggest = "total_cell_style"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"
        elif key == "valueCellStyle":
            suggest = "value_cell_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPivotTotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPivotTotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPivotTotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 metric_header_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
                 placement: Optional['DashboardTableTotalsPlacement'] = None,
                 scroll_status: Optional['DashboardTableTotalsScrollStatus'] = None,
                 total_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
                 totals_visibility: Optional['DashboardVisibility'] = None,
                 value_cell_style: Optional['outputs.DashboardTableCellStyle'] = None):
        DashboardPivotTotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            metric_header_cell_style=metric_header_cell_style,
            placement=placement,
            scroll_status=scroll_status,
            total_cell_style=total_cell_style,
            totals_visibility=totals_visibility,
            value_cell_style=value_cell_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             metric_header_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
             placement: Optional['DashboardTableTotalsPlacement'] = None,
             scroll_status: Optional['DashboardTableTotalsScrollStatus'] = None,
             total_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
             totals_visibility: Optional['DashboardVisibility'] = None,
             value_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if metric_header_cell_style is not None:
            _setter("metric_header_cell_style", metric_header_cell_style)
        if placement is not None:
            _setter("placement", placement)
        if scroll_status is not None:
            _setter("scroll_status", scroll_status)
        if total_cell_style is not None:
            _setter("total_cell_style", total_cell_style)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)
        if value_cell_style is not None:
            _setter("value_cell_style", value_cell_style)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="metricHeaderCellStyle")
    def metric_header_cell_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "metric_header_cell_style")

    @property
    @pulumi.getter
    def placement(self) -> Optional['DashboardTableTotalsPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="scrollStatus")
    def scroll_status(self) -> Optional['DashboardTableTotalsScrollStatus']:
        return pulumi.get(self, "scroll_status")

    @property
    @pulumi.getter(name="totalCellStyle")
    def total_cell_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "total_cell_style")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "totals_visibility")

    @property
    @pulumi.getter(name="valueCellStyle")
    def value_cell_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "value_cell_style")


@pulumi.output_type
class DashboardPredefinedHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hierarchyId":
            suggest = "hierarchy_id"
        elif key == "drillDownFilters":
            suggest = "drill_down_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPredefinedHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPredefinedHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPredefinedHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence['outputs.DashboardColumnIdentifier'],
                 hierarchy_id: str,
                 drill_down_filters: Optional[Sequence['outputs.DashboardDrillDownFilter']] = None):
        DashboardPredefinedHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            hierarchy_id=hierarchy_id,
            drill_down_filters=drill_down_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Sequence['outputs.DashboardColumnIdentifier'],
             hierarchy_id: str,
             drill_down_filters: Optional[Sequence['outputs.DashboardDrillDownFilter']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("columns", columns)
        _setter("hierarchy_id", hierarchy_id)
        if drill_down_filters is not None:
            _setter("drill_down_filters", drill_down_filters)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.DashboardColumnIdentifier']:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> str:
        return pulumi.get(self, "hierarchy_id")

    @property
    @pulumi.getter(name="drillDownFilters")
    def drill_down_filters(self) -> Optional[Sequence['outputs.DashboardDrillDownFilter']]:
        return pulumi.get(self, "drill_down_filters")


@pulumi.output_type
class DashboardProgressBarOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardProgressBarOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardPublishOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adHocFilteringOption":
            suggest = "ad_hoc_filtering_option"
        elif key == "dataPointDrillUpDownOption":
            suggest = "data_point_drill_up_down_option"
        elif key == "dataPointMenuLabelOption":
            suggest = "data_point_menu_label_option"
        elif key == "dataPointTooltipOption":
            suggest = "data_point_tooltip_option"
        elif key == "exportToCsvOption":
            suggest = "export_to_csv_option"
        elif key == "exportWithHiddenFieldsOption":
            suggest = "export_with_hidden_fields_option"
        elif key == "sheetControlsOption":
            suggest = "sheet_controls_option"
        elif key == "sheetLayoutElementMaximizationOption":
            suggest = "sheet_layout_element_maximization_option"
        elif key == "visualAxisSortOption":
            suggest = "visual_axis_sort_option"
        elif key == "visualMenuOption":
            suggest = "visual_menu_option"
        elif key == "visualPublishOptions":
            suggest = "visual_publish_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPublishOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPublishOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPublishOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ad_hoc_filtering_option: Optional['outputs.DashboardAdHocFilteringOption'] = None,
                 data_point_drill_up_down_option: Optional['outputs.DashboardDataPointDrillUpDownOption'] = None,
                 data_point_menu_label_option: Optional['outputs.DashboardDataPointMenuLabelOption'] = None,
                 data_point_tooltip_option: Optional['outputs.DashboardDataPointTooltipOption'] = None,
                 export_to_csv_option: Optional['outputs.DashboardExportToCsvOption'] = None,
                 export_with_hidden_fields_option: Optional['outputs.DashboardExportWithHiddenFieldsOption'] = None,
                 sheet_controls_option: Optional['outputs.DashboardSheetControlsOption'] = None,
                 sheet_layout_element_maximization_option: Optional['outputs.DashboardSheetLayoutElementMaximizationOption'] = None,
                 visual_axis_sort_option: Optional['outputs.DashboardVisualAxisSortOption'] = None,
                 visual_menu_option: Optional['outputs.DashboardVisualMenuOption'] = None,
                 visual_publish_options: Optional['outputs.DashboardVisualPublishOptions'] = None):
        DashboardPublishOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ad_hoc_filtering_option=ad_hoc_filtering_option,
            data_point_drill_up_down_option=data_point_drill_up_down_option,
            data_point_menu_label_option=data_point_menu_label_option,
            data_point_tooltip_option=data_point_tooltip_option,
            export_to_csv_option=export_to_csv_option,
            export_with_hidden_fields_option=export_with_hidden_fields_option,
            sheet_controls_option=sheet_controls_option,
            sheet_layout_element_maximization_option=sheet_layout_element_maximization_option,
            visual_axis_sort_option=visual_axis_sort_option,
            visual_menu_option=visual_menu_option,
            visual_publish_options=visual_publish_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ad_hoc_filtering_option: Optional['outputs.DashboardAdHocFilteringOption'] = None,
             data_point_drill_up_down_option: Optional['outputs.DashboardDataPointDrillUpDownOption'] = None,
             data_point_menu_label_option: Optional['outputs.DashboardDataPointMenuLabelOption'] = None,
             data_point_tooltip_option: Optional['outputs.DashboardDataPointTooltipOption'] = None,
             export_to_csv_option: Optional['outputs.DashboardExportToCsvOption'] = None,
             export_with_hidden_fields_option: Optional['outputs.DashboardExportWithHiddenFieldsOption'] = None,
             sheet_controls_option: Optional['outputs.DashboardSheetControlsOption'] = None,
             sheet_layout_element_maximization_option: Optional['outputs.DashboardSheetLayoutElementMaximizationOption'] = None,
             visual_axis_sort_option: Optional['outputs.DashboardVisualAxisSortOption'] = None,
             visual_menu_option: Optional['outputs.DashboardVisualMenuOption'] = None,
             visual_publish_options: Optional['outputs.DashboardVisualPublishOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ad_hoc_filtering_option is not None:
            _setter("ad_hoc_filtering_option", ad_hoc_filtering_option)
        if data_point_drill_up_down_option is not None:
            _setter("data_point_drill_up_down_option", data_point_drill_up_down_option)
        if data_point_menu_label_option is not None:
            _setter("data_point_menu_label_option", data_point_menu_label_option)
        if data_point_tooltip_option is not None:
            _setter("data_point_tooltip_option", data_point_tooltip_option)
        if export_to_csv_option is not None:
            _setter("export_to_csv_option", export_to_csv_option)
        if export_with_hidden_fields_option is not None:
            _setter("export_with_hidden_fields_option", export_with_hidden_fields_option)
        if sheet_controls_option is not None:
            _setter("sheet_controls_option", sheet_controls_option)
        if sheet_layout_element_maximization_option is not None:
            _setter("sheet_layout_element_maximization_option", sheet_layout_element_maximization_option)
        if visual_axis_sort_option is not None:
            _setter("visual_axis_sort_option", visual_axis_sort_option)
        if visual_menu_option is not None:
            _setter("visual_menu_option", visual_menu_option)
        if visual_publish_options is not None:
            _setter("visual_publish_options", visual_publish_options)

    @property
    @pulumi.getter(name="adHocFilteringOption")
    def ad_hoc_filtering_option(self) -> Optional['outputs.DashboardAdHocFilteringOption']:
        return pulumi.get(self, "ad_hoc_filtering_option")

    @property
    @pulumi.getter(name="dataPointDrillUpDownOption")
    def data_point_drill_up_down_option(self) -> Optional['outputs.DashboardDataPointDrillUpDownOption']:
        return pulumi.get(self, "data_point_drill_up_down_option")

    @property
    @pulumi.getter(name="dataPointMenuLabelOption")
    def data_point_menu_label_option(self) -> Optional['outputs.DashboardDataPointMenuLabelOption']:
        return pulumi.get(self, "data_point_menu_label_option")

    @property
    @pulumi.getter(name="dataPointTooltipOption")
    def data_point_tooltip_option(self) -> Optional['outputs.DashboardDataPointTooltipOption']:
        return pulumi.get(self, "data_point_tooltip_option")

    @property
    @pulumi.getter(name="exportToCsvOption")
    def export_to_csv_option(self) -> Optional['outputs.DashboardExportToCsvOption']:
        return pulumi.get(self, "export_to_csv_option")

    @property
    @pulumi.getter(name="exportWithHiddenFieldsOption")
    def export_with_hidden_fields_option(self) -> Optional['outputs.DashboardExportWithHiddenFieldsOption']:
        return pulumi.get(self, "export_with_hidden_fields_option")

    @property
    @pulumi.getter(name="sheetControlsOption")
    def sheet_controls_option(self) -> Optional['outputs.DashboardSheetControlsOption']:
        return pulumi.get(self, "sheet_controls_option")

    @property
    @pulumi.getter(name="sheetLayoutElementMaximizationOption")
    def sheet_layout_element_maximization_option(self) -> Optional['outputs.DashboardSheetLayoutElementMaximizationOption']:
        return pulumi.get(self, "sheet_layout_element_maximization_option")

    @property
    @pulumi.getter(name="visualAxisSortOption")
    def visual_axis_sort_option(self) -> Optional['outputs.DashboardVisualAxisSortOption']:
        return pulumi.get(self, "visual_axis_sort_option")

    @property
    @pulumi.getter(name="visualMenuOption")
    def visual_menu_option(self) -> Optional['outputs.DashboardVisualMenuOption']:
        return pulumi.get(self, "visual_menu_option")

    @property
    @pulumi.getter(name="visualPublishOptions")
    def visual_publish_options(self) -> Optional['outputs.DashboardVisualPublishOptions']:
        return pulumi.get(self, "visual_publish_options")


@pulumi.output_type
class DashboardRadarChartAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 color: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardRadarChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            color=color,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             color: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if color is not None:
            _setter("color", color)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def color(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardRadarChartAreaStyleSettings(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardRadarChartAreaStyleSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardRadarChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alternateBandColorsVisibility":
            suggest = "alternate_band_colors_visibility"
        elif key == "alternateBandEvenColor":
            suggest = "alternate_band_even_color"
        elif key == "alternateBandOddColor":
            suggest = "alternate_band_odd_color"
        elif key == "axesRangeScale":
            suggest = "axes_range_scale"
        elif key == "baseSeriesSettings":
            suggest = "base_series_settings"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "colorAxis":
            suggest = "color_axis"
        elif key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "startAngle":
            suggest = "start_angle"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardRadarChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardRadarChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardRadarChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alternate_band_colors_visibility: Optional['DashboardVisibility'] = None,
                 alternate_band_even_color: Optional[str] = None,
                 alternate_band_odd_color: Optional[str] = None,
                 axes_range_scale: Optional['DashboardRadarChartAxesRangeScale'] = None,
                 base_series_settings: Optional['outputs.DashboardRadarChartSeriesSettings'] = None,
                 category_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 color_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 color_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardRadarChartFieldWells'] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 shape: Optional['DashboardRadarChartShape'] = None,
                 sort_configuration: Optional['outputs.DashboardRadarChartSortConfiguration'] = None,
                 start_angle: Optional[float] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None):
        DashboardRadarChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alternate_band_colors_visibility=alternate_band_colors_visibility,
            alternate_band_even_color=alternate_band_even_color,
            alternate_band_odd_color=alternate_band_odd_color,
            axes_range_scale=axes_range_scale,
            base_series_settings=base_series_settings,
            category_axis=category_axis,
            category_label_options=category_label_options,
            color_axis=color_axis,
            color_label_options=color_label_options,
            field_wells=field_wells,
            legend=legend,
            shape=shape,
            sort_configuration=sort_configuration,
            start_angle=start_angle,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alternate_band_colors_visibility: Optional['DashboardVisibility'] = None,
             alternate_band_even_color: Optional[str] = None,
             alternate_band_odd_color: Optional[str] = None,
             axes_range_scale: Optional['DashboardRadarChartAxesRangeScale'] = None,
             base_series_settings: Optional['outputs.DashboardRadarChartSeriesSettings'] = None,
             category_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             color_axis: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             color_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardRadarChartFieldWells'] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             shape: Optional['DashboardRadarChartShape'] = None,
             sort_configuration: Optional['outputs.DashboardRadarChartSortConfiguration'] = None,
             start_angle: Optional[float] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if alternate_band_colors_visibility is not None:
            _setter("alternate_band_colors_visibility", alternate_band_colors_visibility)
        if alternate_band_even_color is not None:
            _setter("alternate_band_even_color", alternate_band_even_color)
        if alternate_band_odd_color is not None:
            _setter("alternate_band_odd_color", alternate_band_odd_color)
        if axes_range_scale is not None:
            _setter("axes_range_scale", axes_range_scale)
        if base_series_settings is not None:
            _setter("base_series_settings", base_series_settings)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if color_axis is not None:
            _setter("color_axis", color_axis)
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if shape is not None:
            _setter("shape", shape)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if start_angle is not None:
            _setter("start_angle", start_angle)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="alternateBandColorsVisibility")
    def alternate_band_colors_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "alternate_band_colors_visibility")

    @property
    @pulumi.getter(name="alternateBandEvenColor")
    def alternate_band_even_color(self) -> Optional[str]:
        return pulumi.get(self, "alternate_band_even_color")

    @property
    @pulumi.getter(name="alternateBandOddColor")
    def alternate_band_odd_color(self) -> Optional[str]:
        return pulumi.get(self, "alternate_band_odd_color")

    @property
    @pulumi.getter(name="axesRangeScale")
    def axes_range_scale(self) -> Optional['DashboardRadarChartAxesRangeScale']:
        return pulumi.get(self, "axes_range_scale")

    @property
    @pulumi.getter(name="baseSeriesSettings")
    def base_series_settings(self) -> Optional['outputs.DashboardRadarChartSeriesSettings']:
        return pulumi.get(self, "base_series_settings")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="colorAxis")
    def color_axis(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "color_axis")

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardRadarChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter
    def shape(self) -> Optional['DashboardRadarChartShape']:
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardRadarChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="startAngle")
    def start_angle(self) -> Optional[float]:
        return pulumi.get(self, "start_angle")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class DashboardRadarChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "radarChartAggregatedFieldWells":
            suggest = "radar_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardRadarChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardRadarChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardRadarChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 radar_chart_aggregated_field_wells: Optional['outputs.DashboardRadarChartAggregatedFieldWells'] = None):
        DashboardRadarChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            radar_chart_aggregated_field_wells=radar_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             radar_chart_aggregated_field_wells: Optional['outputs.DashboardRadarChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if radar_chart_aggregated_field_wells is not None:
            _setter("radar_chart_aggregated_field_wells", radar_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="radarChartAggregatedFieldWells")
    def radar_chart_aggregated_field_wells(self) -> Optional['outputs.DashboardRadarChartAggregatedFieldWells']:
        return pulumi.get(self, "radar_chart_aggregated_field_wells")


@pulumi.output_type
class DashboardRadarChartSeriesSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "areaStyleSettings":
            suggest = "area_style_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardRadarChartSeriesSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardRadarChartSeriesSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardRadarChartSeriesSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area_style_settings: Optional['outputs.DashboardRadarChartAreaStyleSettings'] = None):
        DashboardRadarChartSeriesSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            area_style_settings=area_style_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             area_style_settings: Optional['outputs.DashboardRadarChartAreaStyleSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if area_style_settings is not None:
            _setter("area_style_settings", area_style_settings)

    @property
    @pulumi.getter(name="areaStyleSettings")
    def area_style_settings(self) -> Optional['outputs.DashboardRadarChartAreaStyleSettings']:
        return pulumi.get(self, "area_style_settings")


@pulumi.output_type
class DashboardRadarChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimit":
            suggest = "color_items_limit"
        elif key == "colorSort":
            suggest = "color_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardRadarChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardRadarChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardRadarChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
                 color_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 color_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardRadarChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            color_items_limit=color_items_limit,
            color_sort=color_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             color_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             color_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit is not None:
            _setter("color_items_limit", color_items_limit)
        if color_sort is not None:
            _setter("color_sort", color_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimit")
    def color_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit")

    @property
    @pulumi.getter(name="colorSort")
    def color_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "color_sort")


@pulumi.output_type
class DashboardRadarChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardRadarChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardRadarChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardRadarChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardRadarChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardRadarChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardRadarChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardRadarChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardRangeEndsLabelType(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardRangeEndsLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardReferenceLine(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataConfiguration":
            suggest = "data_configuration"
        elif key == "labelConfiguration":
            suggest = "label_configuration"
        elif key == "styleConfiguration":
            suggest = "style_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardReferenceLine. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardReferenceLine.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardReferenceLine.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_configuration: 'outputs.DashboardReferenceLineDataConfiguration',
                 label_configuration: Optional['outputs.DashboardReferenceLineLabelConfiguration'] = None,
                 status: Optional['DashboardWidgetStatus'] = None,
                 style_configuration: Optional['outputs.DashboardReferenceLineStyleConfiguration'] = None):
        DashboardReferenceLine._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_configuration=data_configuration,
            label_configuration=label_configuration,
            status=status,
            style_configuration=style_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_configuration: 'outputs.DashboardReferenceLineDataConfiguration',
             label_configuration: Optional['outputs.DashboardReferenceLineLabelConfiguration'] = None,
             status: Optional['DashboardWidgetStatus'] = None,
             style_configuration: Optional['outputs.DashboardReferenceLineStyleConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_configuration", data_configuration)
        if label_configuration is not None:
            _setter("label_configuration", label_configuration)
        if status is not None:
            _setter("status", status)
        if style_configuration is not None:
            _setter("style_configuration", style_configuration)

    @property
    @pulumi.getter(name="dataConfiguration")
    def data_configuration(self) -> 'outputs.DashboardReferenceLineDataConfiguration':
        return pulumi.get(self, "data_configuration")

    @property
    @pulumi.getter(name="labelConfiguration")
    def label_configuration(self) -> Optional['outputs.DashboardReferenceLineLabelConfiguration']:
        return pulumi.get(self, "label_configuration")

    @property
    @pulumi.getter
    def status(self) -> Optional['DashboardWidgetStatus']:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="styleConfiguration")
    def style_configuration(self) -> Optional['outputs.DashboardReferenceLineStyleConfiguration']:
        return pulumi.get(self, "style_configuration")


@pulumi.output_type
class DashboardReferenceLineCustomLabelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardReferenceLineCustomLabelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardReferenceLineCustomLabelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardReferenceLineCustomLabelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: str):
        DashboardReferenceLineCustomLabelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_label", custom_label)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> str:
        return pulumi.get(self, "custom_label")


@pulumi.output_type
class DashboardReferenceLineDataConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "dynamicConfiguration":
            suggest = "dynamic_configuration"
        elif key == "staticConfiguration":
            suggest = "static_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardReferenceLineDataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardReferenceLineDataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardReferenceLineDataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: Optional['DashboardAxisBinding'] = None,
                 dynamic_configuration: Optional['outputs.DashboardReferenceLineDynamicDataConfiguration'] = None,
                 static_configuration: Optional['outputs.DashboardReferenceLineStaticDataConfiguration'] = None):
        DashboardReferenceLineDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            dynamic_configuration=dynamic_configuration,
            static_configuration=static_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: Optional['DashboardAxisBinding'] = None,
             dynamic_configuration: Optional['outputs.DashboardReferenceLineDynamicDataConfiguration'] = None,
             static_configuration: Optional['outputs.DashboardReferenceLineStaticDataConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_binding is not None:
            _setter("axis_binding", axis_binding)
        if dynamic_configuration is not None:
            _setter("dynamic_configuration", dynamic_configuration)
        if static_configuration is not None:
            _setter("static_configuration", static_configuration)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> Optional['DashboardAxisBinding']:
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="dynamicConfiguration")
    def dynamic_configuration(self) -> Optional['outputs.DashboardReferenceLineDynamicDataConfiguration']:
        return pulumi.get(self, "dynamic_configuration")

    @property
    @pulumi.getter(name="staticConfiguration")
    def static_configuration(self) -> Optional['outputs.DashboardReferenceLineStaticDataConfiguration']:
        return pulumi.get(self, "static_configuration")


@pulumi.output_type
class DashboardReferenceLineDynamicDataConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "measureAggregationFunction":
            suggest = "measure_aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardReferenceLineDynamicDataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardReferenceLineDynamicDataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardReferenceLineDynamicDataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 calculation: 'outputs.DashboardNumericalAggregationFunction',
                 column: 'outputs.DashboardColumnIdentifier',
                 measure_aggregation_function: Optional['outputs.DashboardAggregationFunction'] = None):
        DashboardReferenceLineDynamicDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            calculation=calculation,
            column=column,
            measure_aggregation_function=measure_aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             calculation: 'outputs.DashboardNumericalAggregationFunction',
             column: 'outputs.DashboardColumnIdentifier',
             measure_aggregation_function: Optional['outputs.DashboardAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("calculation", calculation)
        _setter("column", column)
        if measure_aggregation_function is not None:
            _setter("measure_aggregation_function", measure_aggregation_function)

    @property
    @pulumi.getter
    def calculation(self) -> 'outputs.DashboardNumericalAggregationFunction':
        return pulumi.get(self, "calculation")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="measureAggregationFunction")
    def measure_aggregation_function(self) -> Optional['outputs.DashboardAggregationFunction']:
        return pulumi.get(self, "measure_aggregation_function")


@pulumi.output_type
class DashboardReferenceLineLabelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabelConfiguration":
            suggest = "custom_label_configuration"
        elif key == "fontColor":
            suggest = "font_color"
        elif key == "fontConfiguration":
            suggest = "font_configuration"
        elif key == "horizontalPosition":
            suggest = "horizontal_position"
        elif key == "valueLabelConfiguration":
            suggest = "value_label_configuration"
        elif key == "verticalPosition":
            suggest = "vertical_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardReferenceLineLabelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardReferenceLineLabelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardReferenceLineLabelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label_configuration: Optional['outputs.DashboardReferenceLineCustomLabelConfiguration'] = None,
                 font_color: Optional[str] = None,
                 font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
                 horizontal_position: Optional['DashboardReferenceLineLabelHorizontalPosition'] = None,
                 value_label_configuration: Optional['outputs.DashboardReferenceLineValueLabelConfiguration'] = None,
                 vertical_position: Optional['DashboardReferenceLineLabelVerticalPosition'] = None):
        DashboardReferenceLineLabelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label_configuration=custom_label_configuration,
            font_color=font_color,
            font_configuration=font_configuration,
            horizontal_position=horizontal_position,
            value_label_configuration=value_label_configuration,
            vertical_position=vertical_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label_configuration: Optional['outputs.DashboardReferenceLineCustomLabelConfiguration'] = None,
             font_color: Optional[str] = None,
             font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
             horizontal_position: Optional['DashboardReferenceLineLabelHorizontalPosition'] = None,
             value_label_configuration: Optional['outputs.DashboardReferenceLineValueLabelConfiguration'] = None,
             vertical_position: Optional['DashboardReferenceLineLabelVerticalPosition'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label_configuration is not None:
            _setter("custom_label_configuration", custom_label_configuration)
        if font_color is not None:
            _setter("font_color", font_color)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if horizontal_position is not None:
            _setter("horizontal_position", horizontal_position)
        if value_label_configuration is not None:
            _setter("value_label_configuration", value_label_configuration)
        if vertical_position is not None:
            _setter("vertical_position", vertical_position)

    @property
    @pulumi.getter(name="customLabelConfiguration")
    def custom_label_configuration(self) -> Optional['outputs.DashboardReferenceLineCustomLabelConfiguration']:
        return pulumi.get(self, "custom_label_configuration")

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[str]:
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.DashboardFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter(name="horizontalPosition")
    def horizontal_position(self) -> Optional['DashboardReferenceLineLabelHorizontalPosition']:
        return pulumi.get(self, "horizontal_position")

    @property
    @pulumi.getter(name="valueLabelConfiguration")
    def value_label_configuration(self) -> Optional['outputs.DashboardReferenceLineValueLabelConfiguration']:
        return pulumi.get(self, "value_label_configuration")

    @property
    @pulumi.getter(name="verticalPosition")
    def vertical_position(self) -> Optional['DashboardReferenceLineLabelVerticalPosition']:
        return pulumi.get(self, "vertical_position")


@pulumi.output_type
class DashboardReferenceLineStaticDataConfiguration(dict):
    def __init__(__self__, *,
                 value: float):
        DashboardReferenceLineStaticDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardReferenceLineStyleConfiguration(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 pattern: Optional['DashboardReferenceLinePatternType'] = None):
        DashboardReferenceLineStyleConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            pattern=pattern,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             pattern: Optional['DashboardReferenceLinePatternType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if pattern is not None:
            _setter("pattern", pattern)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def pattern(self) -> Optional['DashboardReferenceLinePatternType']:
        return pulumi.get(self, "pattern")


@pulumi.output_type
class DashboardReferenceLineValueLabelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "relativePosition":
            suggest = "relative_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardReferenceLineValueLabelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardReferenceLineValueLabelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardReferenceLineValueLabelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_configuration: Optional['outputs.DashboardNumericFormatConfiguration'] = None,
                 relative_position: Optional['DashboardReferenceLineValueLabelRelativePosition'] = None):
        DashboardReferenceLineValueLabelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_configuration=format_configuration,
            relative_position=relative_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_configuration: Optional['outputs.DashboardNumericFormatConfiguration'] = None,
             relative_position: Optional['DashboardReferenceLineValueLabelRelativePosition'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if relative_position is not None:
            _setter("relative_position", relative_position)

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.DashboardNumericFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="relativePosition")
    def relative_position(self) -> Optional['DashboardReferenceLineValueLabelRelativePosition']:
        return pulumi.get(self, "relative_position")


@pulumi.output_type
class DashboardRelativeDateTimeControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormat":
            suggest = "date_time_format"
        elif key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardRelativeDateTimeControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardRelativeDateTimeControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardRelativeDateTimeControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format: Optional[str] = None,
                 info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
                 title_options: Optional['outputs.DashboardLabelOptions'] = None):
        DashboardRelativeDateTimeControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format=date_time_format,
            info_icon_label_options=info_icon_label_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format: Optional[str] = None,
             info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
             title_options: Optional['outputs.DashboardLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format is not None:
            _setter("date_time_format", date_time_format)
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="dateTimeFormat")
    def date_time_format(self) -> Optional[str]:
        return pulumi.get(self, "date_time_format")

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.DashboardSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.DashboardLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class DashboardRelativeDatesFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anchorDateConfiguration":
            suggest = "anchor_date_configuration"
        elif key == "filterId":
            suggest = "filter_id"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "relativeDateType":
            suggest = "relative_date_type"
        elif key == "timeGranularity":
            suggest = "time_granularity"
        elif key == "excludePeriodConfiguration":
            suggest = "exclude_period_configuration"
        elif key == "minimumGranularity":
            suggest = "minimum_granularity"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "relativeDateValue":
            suggest = "relative_date_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardRelativeDatesFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardRelativeDatesFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardRelativeDatesFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anchor_date_configuration: 'outputs.DashboardAnchorDateConfiguration',
                 column: 'outputs.DashboardColumnIdentifier',
                 filter_id: str,
                 null_option: 'DashboardFilterNullOption',
                 relative_date_type: 'DashboardRelativeDateType',
                 time_granularity: 'DashboardTimeGranularity',
                 exclude_period_configuration: Optional['outputs.DashboardExcludePeriodConfiguration'] = None,
                 minimum_granularity: Optional['DashboardTimeGranularity'] = None,
                 parameter_name: Optional[str] = None,
                 relative_date_value: Optional[float] = None):
        DashboardRelativeDatesFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            anchor_date_configuration=anchor_date_configuration,
            column=column,
            filter_id=filter_id,
            null_option=null_option,
            relative_date_type=relative_date_type,
            time_granularity=time_granularity,
            exclude_period_configuration=exclude_period_configuration,
            minimum_granularity=minimum_granularity,
            parameter_name=parameter_name,
            relative_date_value=relative_date_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             anchor_date_configuration: 'outputs.DashboardAnchorDateConfiguration',
             column: 'outputs.DashboardColumnIdentifier',
             filter_id: str,
             null_option: 'DashboardFilterNullOption',
             relative_date_type: 'DashboardRelativeDateType',
             time_granularity: 'DashboardTimeGranularity',
             exclude_period_configuration: Optional['outputs.DashboardExcludePeriodConfiguration'] = None,
             minimum_granularity: Optional['DashboardTimeGranularity'] = None,
             parameter_name: Optional[str] = None,
             relative_date_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("anchor_date_configuration", anchor_date_configuration)
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("null_option", null_option)
        _setter("relative_date_type", relative_date_type)
        _setter("time_granularity", time_granularity)
        if exclude_period_configuration is not None:
            _setter("exclude_period_configuration", exclude_period_configuration)
        if minimum_granularity is not None:
            _setter("minimum_granularity", minimum_granularity)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if relative_date_value is not None:
            _setter("relative_date_value", relative_date_value)

    @property
    @pulumi.getter(name="anchorDateConfiguration")
    def anchor_date_configuration(self) -> 'outputs.DashboardAnchorDateConfiguration':
        return pulumi.get(self, "anchor_date_configuration")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'DashboardFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="relativeDateType")
    def relative_date_type(self) -> 'DashboardRelativeDateType':
        return pulumi.get(self, "relative_date_type")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> 'DashboardTimeGranularity':
        return pulumi.get(self, "time_granularity")

    @property
    @pulumi.getter(name="excludePeriodConfiguration")
    def exclude_period_configuration(self) -> Optional['outputs.DashboardExcludePeriodConfiguration']:
        return pulumi.get(self, "exclude_period_configuration")

    @property
    @pulumi.getter(name="minimumGranularity")
    def minimum_granularity(self) -> Optional['DashboardTimeGranularity']:
        return pulumi.get(self, "minimum_granularity")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="relativeDateValue")
    def relative_date_value(self) -> Optional[float]:
        return pulumi.get(self, "relative_date_value")


@pulumi.output_type
class DashboardResourcePermission(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str,
                 resource: Optional[str] = None):
        DashboardResourcePermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
            resource=resource,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Sequence[str],
             principal: str,
             resource: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        _setter("principal", principal)
        if resource is not None:
            _setter("resource", resource)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        return pulumi.get(self, "principal")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")


@pulumi.output_type
class DashboardRollingDateConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardRollingDateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardRollingDateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardRollingDateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 data_set_identifier: Optional[str] = None):
        DashboardRollingDateConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            data_set_identifier=data_set_identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             data_set_identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if data_set_identifier is not None:
            _setter("data_set_identifier", data_set_identifier)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> Optional[str]:
        return pulumi.get(self, "data_set_identifier")


@pulumi.output_type
class DashboardRowAlternateColorOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowAlternateColors":
            suggest = "row_alternate_colors"
        elif key == "usePrimaryBackgroundColor":
            suggest = "use_primary_background_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardRowAlternateColorOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardRowAlternateColorOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardRowAlternateColorOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 row_alternate_colors: Optional[Sequence[str]] = None,
                 status: Optional['DashboardWidgetStatus'] = None,
                 use_primary_background_color: Optional['DashboardWidgetStatus'] = None):
        DashboardRowAlternateColorOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            row_alternate_colors=row_alternate_colors,
            status=status,
            use_primary_background_color=use_primary_background_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             row_alternate_colors: Optional[Sequence[str]] = None,
             status: Optional['DashboardWidgetStatus'] = None,
             use_primary_background_color: Optional['DashboardWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if row_alternate_colors is not None:
            _setter("row_alternate_colors", row_alternate_colors)
        if status is not None:
            _setter("status", status)
        if use_primary_background_color is not None:
            _setter("use_primary_background_color", use_primary_background_color)

    @property
    @pulumi.getter(name="rowAlternateColors")
    def row_alternate_colors(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "row_alternate_colors")

    @property
    @pulumi.getter
    def status(self) -> Optional['DashboardWidgetStatus']:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="usePrimaryBackgroundColor")
    def use_primary_background_color(self) -> Optional['DashboardWidgetStatus']:
        return pulumi.get(self, "use_primary_background_color")


@pulumi.output_type
class DashboardSameSheetTargetVisualConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetVisualOptions":
            suggest = "target_visual_options"
        elif key == "targetVisuals":
            suggest = "target_visuals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSameSheetTargetVisualConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSameSheetTargetVisualConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSameSheetTargetVisualConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_visual_options: Optional['DashboardTargetVisualOptions'] = None,
                 target_visuals: Optional[Sequence[str]] = None):
        DashboardSameSheetTargetVisualConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_visual_options=target_visual_options,
            target_visuals=target_visuals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_visual_options: Optional['DashboardTargetVisualOptions'] = None,
             target_visuals: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if target_visual_options is not None:
            _setter("target_visual_options", target_visual_options)
        if target_visuals is not None:
            _setter("target_visuals", target_visuals)

    @property
    @pulumi.getter(name="targetVisualOptions")
    def target_visual_options(self) -> Optional['DashboardTargetVisualOptions']:
        return pulumi.get(self, "target_visual_options")

    @property
    @pulumi.getter(name="targetVisuals")
    def target_visuals(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "target_visuals")


@pulumi.output_type
class DashboardSankeyDiagramAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 destination: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 source: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 weight: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardSankeyDiagramAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            source=source,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             source: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             weight: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination is not None:
            _setter("destination", destination)
        if source is not None:
            _setter("source", source)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter
    def destination(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def source(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def weight(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class DashboardSankeyDiagramChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSankeyDiagramChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSankeyDiagramChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSankeyDiagramChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardSankeyDiagramFieldWells'] = None,
                 sort_configuration: Optional['outputs.DashboardSankeyDiagramSortConfiguration'] = None):
        DashboardSankeyDiagramChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_labels=data_labels,
            field_wells=field_wells,
            sort_configuration=sort_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardSankeyDiagramFieldWells'] = None,
             sort_configuration: Optional['outputs.DashboardSankeyDiagramSortConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardSankeyDiagramFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardSankeyDiagramSortConfiguration']:
        return pulumi.get(self, "sort_configuration")


@pulumi.output_type
class DashboardSankeyDiagramFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sankeyDiagramAggregatedFieldWells":
            suggest = "sankey_diagram_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSankeyDiagramFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSankeyDiagramFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSankeyDiagramFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sankey_diagram_aggregated_field_wells: Optional['outputs.DashboardSankeyDiagramAggregatedFieldWells'] = None):
        DashboardSankeyDiagramFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sankey_diagram_aggregated_field_wells=sankey_diagram_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sankey_diagram_aggregated_field_wells: Optional['outputs.DashboardSankeyDiagramAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sankey_diagram_aggregated_field_wells is not None:
            _setter("sankey_diagram_aggregated_field_wells", sankey_diagram_aggregated_field_wells)

    @property
    @pulumi.getter(name="sankeyDiagramAggregatedFieldWells")
    def sankey_diagram_aggregated_field_wells(self) -> Optional['outputs.DashboardSankeyDiagramAggregatedFieldWells']:
        return pulumi.get(self, "sankey_diagram_aggregated_field_wells")


@pulumi.output_type
class DashboardSankeyDiagramSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationItemsLimit":
            suggest = "destination_items_limit"
        elif key == "sourceItemsLimit":
            suggest = "source_items_limit"
        elif key == "weightSort":
            suggest = "weight_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSankeyDiagramSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSankeyDiagramSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSankeyDiagramSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 source_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 weight_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardSankeyDiagramSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_items_limit=destination_items_limit,
            source_items_limit=source_items_limit,
            weight_sort=weight_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             source_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             weight_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination_items_limit is not None:
            _setter("destination_items_limit", destination_items_limit)
        if source_items_limit is not None:
            _setter("source_items_limit", source_items_limit)
        if weight_sort is not None:
            _setter("weight_sort", weight_sort)

    @property
    @pulumi.getter(name="destinationItemsLimit")
    def destination_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "destination_items_limit")

    @property
    @pulumi.getter(name="sourceItemsLimit")
    def source_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "source_items_limit")

    @property
    @pulumi.getter(name="weightSort")
    def weight_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "weight_sort")


@pulumi.output_type
class DashboardSankeyDiagramVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSankeyDiagramVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSankeyDiagramVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSankeyDiagramVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardSankeyDiagramChartConfiguration'] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardSankeyDiagramVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardSankeyDiagramChartConfiguration'] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardSankeyDiagramChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardScatterPlotCategoricallyAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAxis":
            suggest = "x_axis"
        elif key == "yAxis":
            suggest = "y_axis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardScatterPlotCategoricallyAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardScatterPlotCategoricallyAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardScatterPlotCategoricallyAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 label: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 size: Optional[Sequence['outputs.DashboardMeasureField']] = None,
                 x_axis: Optional[Sequence['outputs.DashboardMeasureField']] = None,
                 y_axis: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardScatterPlotCategoricallyAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            label=label,
            size=size,
            x_axis=x_axis,
            y_axis=y_axis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             label: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             size: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             x_axis: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             y_axis: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if label is not None:
            _setter("label", label)
        if size is not None:
            _setter("size", size)
        if x_axis is not None:
            _setter("x_axis", x_axis)
        if y_axis is not None:
            _setter("y_axis", y_axis)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def label(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def size(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="xAxis")
    def x_axis(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "x_axis")

    @property
    @pulumi.getter(name="yAxis")
    def y_axis(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "y_axis")


@pulumi.output_type
class DashboardScatterPlotConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "xAxisDisplayOptions":
            suggest = "x_axis_display_options"
        elif key == "xAxisLabelOptions":
            suggest = "x_axis_label_options"
        elif key == "yAxisDisplayOptions":
            suggest = "y_axis_display_options"
        elif key == "yAxisLabelOptions":
            suggest = "y_axis_label_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardScatterPlotConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardScatterPlotConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardScatterPlotConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardScatterPlotFieldWells'] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
                 x_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 x_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None):
        DashboardScatterPlotConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            tooltip=tooltip,
            visual_palette=visual_palette,
            x_axis_display_options=x_axis_display_options,
            x_axis_label_options=x_axis_label_options,
            y_axis_display_options=y_axis_display_options,
            y_axis_label_options=y_axis_label_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardScatterPlotFieldWells'] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             x_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             x_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if x_axis_display_options is not None:
            _setter("x_axis_display_options", x_axis_display_options)
        if x_axis_label_options is not None:
            _setter("x_axis_label_options", x_axis_label_options)
        if y_axis_display_options is not None:
            _setter("y_axis_display_options", y_axis_display_options)
        if y_axis_label_options is not None:
            _setter("y_axis_label_options", y_axis_label_options)

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardScatterPlotFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="xAxisDisplayOptions")
    def x_axis_display_options(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "x_axis_display_options")

    @property
    @pulumi.getter(name="xAxisLabelOptions")
    def x_axis_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "x_axis_label_options")

    @property
    @pulumi.getter(name="yAxisDisplayOptions")
    def y_axis_display_options(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "y_axis_display_options")

    @property
    @pulumi.getter(name="yAxisLabelOptions")
    def y_axis_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "y_axis_label_options")


@pulumi.output_type
class DashboardScatterPlotFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scatterPlotCategoricallyAggregatedFieldWells":
            suggest = "scatter_plot_categorically_aggregated_field_wells"
        elif key == "scatterPlotUnaggregatedFieldWells":
            suggest = "scatter_plot_unaggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardScatterPlotFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardScatterPlotFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardScatterPlotFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scatter_plot_categorically_aggregated_field_wells: Optional['outputs.DashboardScatterPlotCategoricallyAggregatedFieldWells'] = None,
                 scatter_plot_unaggregated_field_wells: Optional['outputs.DashboardScatterPlotUnaggregatedFieldWells'] = None):
        DashboardScatterPlotFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scatter_plot_categorically_aggregated_field_wells=scatter_plot_categorically_aggregated_field_wells,
            scatter_plot_unaggregated_field_wells=scatter_plot_unaggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scatter_plot_categorically_aggregated_field_wells: Optional['outputs.DashboardScatterPlotCategoricallyAggregatedFieldWells'] = None,
             scatter_plot_unaggregated_field_wells: Optional['outputs.DashboardScatterPlotUnaggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if scatter_plot_categorically_aggregated_field_wells is not None:
            _setter("scatter_plot_categorically_aggregated_field_wells", scatter_plot_categorically_aggregated_field_wells)
        if scatter_plot_unaggregated_field_wells is not None:
            _setter("scatter_plot_unaggregated_field_wells", scatter_plot_unaggregated_field_wells)

    @property
    @pulumi.getter(name="scatterPlotCategoricallyAggregatedFieldWells")
    def scatter_plot_categorically_aggregated_field_wells(self) -> Optional['outputs.DashboardScatterPlotCategoricallyAggregatedFieldWells']:
        return pulumi.get(self, "scatter_plot_categorically_aggregated_field_wells")

    @property
    @pulumi.getter(name="scatterPlotUnaggregatedFieldWells")
    def scatter_plot_unaggregated_field_wells(self) -> Optional['outputs.DashboardScatterPlotUnaggregatedFieldWells']:
        return pulumi.get(self, "scatter_plot_unaggregated_field_wells")


@pulumi.output_type
class DashboardScatterPlotUnaggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAxis":
            suggest = "x_axis"
        elif key == "yAxis":
            suggest = "y_axis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardScatterPlotUnaggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardScatterPlotUnaggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardScatterPlotUnaggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 label: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 size: Optional[Sequence['outputs.DashboardMeasureField']] = None,
                 x_axis: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 y_axis: Optional[Sequence['outputs.DashboardDimensionField']] = None):
        DashboardScatterPlotUnaggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            label=label,
            size=size,
            x_axis=x_axis,
            y_axis=y_axis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             label: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             size: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             x_axis: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             y_axis: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if label is not None:
            _setter("label", label)
        if size is not None:
            _setter("size", size)
        if x_axis is not None:
            _setter("x_axis", x_axis)
        if y_axis is not None:
            _setter("y_axis", y_axis)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def label(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def size(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="xAxis")
    def x_axis(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "x_axis")

    @property
    @pulumi.getter(name="yAxis")
    def y_axis(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "y_axis")


@pulumi.output_type
class DashboardScatterPlotVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardScatterPlotVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardScatterPlotVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardScatterPlotVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardScatterPlotConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardScatterPlotVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardScatterPlotConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardScatterPlotConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardScrollBarOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibleRange":
            suggest = "visible_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardScrollBarOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardScrollBarOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardScrollBarOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None,
                 visible_range: Optional['outputs.DashboardVisibleRangeOptions'] = None):
        DashboardScrollBarOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
            visible_range=visible_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             visible_range: Optional['outputs.DashboardVisibleRangeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)
        if visible_range is not None:
            _setter("visible_range", visible_range)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter(name="visibleRange")
    def visible_range(self) -> Optional['outputs.DashboardVisibleRangeOptions']:
        return pulumi.get(self, "visible_range")


@pulumi.output_type
class DashboardSecondaryValueOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardSecondaryValueOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardSectionAfterPageBreak(dict):
    def __init__(__self__, *,
                 status: Optional['DashboardSectionPageBreakStatus'] = None):
        DashboardSectionAfterPageBreak._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: Optional['DashboardSectionPageBreakStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional['DashboardSectionPageBreakStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class DashboardSectionBasedLayoutCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paperCanvasSizeOptions":
            suggest = "paper_canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSectionBasedLayoutCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSectionBasedLayoutCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSectionBasedLayoutCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paper_canvas_size_options: Optional['outputs.DashboardSectionBasedLayoutPaperCanvasSizeOptions'] = None):
        DashboardSectionBasedLayoutCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            paper_canvas_size_options=paper_canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             paper_canvas_size_options: Optional['outputs.DashboardSectionBasedLayoutPaperCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if paper_canvas_size_options is not None:
            _setter("paper_canvas_size_options", paper_canvas_size_options)

    @property
    @pulumi.getter(name="paperCanvasSizeOptions")
    def paper_canvas_size_options(self) -> Optional['outputs.DashboardSectionBasedLayoutPaperCanvasSizeOptions']:
        return pulumi.get(self, "paper_canvas_size_options")


@pulumi.output_type
class DashboardSectionBasedLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodySections":
            suggest = "body_sections"
        elif key == "canvasSizeOptions":
            suggest = "canvas_size_options"
        elif key == "footerSections":
            suggest = "footer_sections"
        elif key == "headerSections":
            suggest = "header_sections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSectionBasedLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSectionBasedLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSectionBasedLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_sections: Sequence['outputs.DashboardBodySectionConfiguration'],
                 canvas_size_options: 'outputs.DashboardSectionBasedLayoutCanvasSizeOptions',
                 footer_sections: Sequence['outputs.DashboardHeaderFooterSectionConfiguration'],
                 header_sections: Sequence['outputs.DashboardHeaderFooterSectionConfiguration']):
        DashboardSectionBasedLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            body_sections=body_sections,
            canvas_size_options=canvas_size_options,
            footer_sections=footer_sections,
            header_sections=header_sections,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             body_sections: Sequence['outputs.DashboardBodySectionConfiguration'],
             canvas_size_options: 'outputs.DashboardSectionBasedLayoutCanvasSizeOptions',
             footer_sections: Sequence['outputs.DashboardHeaderFooterSectionConfiguration'],
             header_sections: Sequence['outputs.DashboardHeaderFooterSectionConfiguration'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("body_sections", body_sections)
        _setter("canvas_size_options", canvas_size_options)
        _setter("footer_sections", footer_sections)
        _setter("header_sections", header_sections)

    @property
    @pulumi.getter(name="bodySections")
    def body_sections(self) -> Sequence['outputs.DashboardBodySectionConfiguration']:
        return pulumi.get(self, "body_sections")

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.DashboardSectionBasedLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")

    @property
    @pulumi.getter(name="footerSections")
    def footer_sections(self) -> Sequence['outputs.DashboardHeaderFooterSectionConfiguration']:
        return pulumi.get(self, "footer_sections")

    @property
    @pulumi.getter(name="headerSections")
    def header_sections(self) -> Sequence['outputs.DashboardHeaderFooterSectionConfiguration']:
        return pulumi.get(self, "header_sections")


@pulumi.output_type
class DashboardSectionBasedLayoutPaperCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paperMargin":
            suggest = "paper_margin"
        elif key == "paperOrientation":
            suggest = "paper_orientation"
        elif key == "paperSize":
            suggest = "paper_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSectionBasedLayoutPaperCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSectionBasedLayoutPaperCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSectionBasedLayoutPaperCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paper_margin: Optional['outputs.DashboardSpacing'] = None,
                 paper_orientation: Optional['DashboardPaperOrientation'] = None,
                 paper_size: Optional['DashboardPaperSize'] = None):
        DashboardSectionBasedLayoutPaperCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            paper_margin=paper_margin,
            paper_orientation=paper_orientation,
            paper_size=paper_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             paper_margin: Optional['outputs.DashboardSpacing'] = None,
             paper_orientation: Optional['DashboardPaperOrientation'] = None,
             paper_size: Optional['DashboardPaperSize'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if paper_margin is not None:
            _setter("paper_margin", paper_margin)
        if paper_orientation is not None:
            _setter("paper_orientation", paper_orientation)
        if paper_size is not None:
            _setter("paper_size", paper_size)

    @property
    @pulumi.getter(name="paperMargin")
    def paper_margin(self) -> Optional['outputs.DashboardSpacing']:
        return pulumi.get(self, "paper_margin")

    @property
    @pulumi.getter(name="paperOrientation")
    def paper_orientation(self) -> Optional['DashboardPaperOrientation']:
        return pulumi.get(self, "paper_orientation")

    @property
    @pulumi.getter(name="paperSize")
    def paper_size(self) -> Optional['DashboardPaperSize']:
        return pulumi.get(self, "paper_size")


@pulumi.output_type
class DashboardSectionLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeFormLayout":
            suggest = "free_form_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSectionLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSectionLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSectionLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_form_layout: 'outputs.DashboardFreeFormSectionLayoutConfiguration'):
        DashboardSectionLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            free_form_layout=free_form_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             free_form_layout: 'outputs.DashboardFreeFormSectionLayoutConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("free_form_layout", free_form_layout)

    @property
    @pulumi.getter(name="freeFormLayout")
    def free_form_layout(self) -> 'outputs.DashboardFreeFormSectionLayoutConfiguration':
        return pulumi.get(self, "free_form_layout")


@pulumi.output_type
class DashboardSectionPageBreakConfiguration(dict):
    def __init__(__self__, *,
                 after: Optional['outputs.DashboardSectionAfterPageBreak'] = None):
        DashboardSectionPageBreakConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            after=after,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             after: Optional['outputs.DashboardSectionAfterPageBreak'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if after is not None:
            _setter("after", after)

    @property
    @pulumi.getter
    def after(self) -> Optional['outputs.DashboardSectionAfterPageBreak']:
        return pulumi.get(self, "after")


@pulumi.output_type
class DashboardSectionStyle(dict):
    def __init__(__self__, *,
                 height: Optional[str] = None,
                 padding: Optional['outputs.DashboardSpacing'] = None):
        """
        :param str height: String based length that is composed of value and unit in px
        """
        DashboardSectionStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            height=height,
            padding=padding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             height: Optional[str] = None,
             padding: Optional['outputs.DashboardSpacing'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if height is not None:
            _setter("height", height)
        if padding is not None:
            _setter("padding", padding)

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def padding(self) -> Optional['outputs.DashboardSpacing']:
        return pulumi.get(self, "padding")


@pulumi.output_type
class DashboardSelectedSheetsFilterScopeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetVisualScopingConfigurations":
            suggest = "sheet_visual_scoping_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSelectedSheetsFilterScopeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSelectedSheetsFilterScopeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSelectedSheetsFilterScopeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sheet_visual_scoping_configurations: Optional[Sequence['outputs.DashboardSheetVisualScopingConfiguration']] = None):
        DashboardSelectedSheetsFilterScopeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sheet_visual_scoping_configurations=sheet_visual_scoping_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sheet_visual_scoping_configurations: Optional[Sequence['outputs.DashboardSheetVisualScopingConfiguration']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sheet_visual_scoping_configurations is not None:
            _setter("sheet_visual_scoping_configurations", sheet_visual_scoping_configurations)

    @property
    @pulumi.getter(name="sheetVisualScopingConfigurations")
    def sheet_visual_scoping_configurations(self) -> Optional[Sequence['outputs.DashboardSheetVisualScopingConfiguration']]:
        return pulumi.get(self, "sheet_visual_scoping_configurations")


@pulumi.output_type
class DashboardSeriesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataFieldSeriesItem":
            suggest = "data_field_series_item"
        elif key == "fieldSeriesItem":
            suggest = "field_series_item"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSeriesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSeriesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSeriesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_field_series_item: Optional['outputs.DashboardDataFieldSeriesItem'] = None,
                 field_series_item: Optional['outputs.DashboardFieldSeriesItem'] = None):
        DashboardSeriesItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_field_series_item=data_field_series_item,
            field_series_item=field_series_item,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_field_series_item: Optional['outputs.DashboardDataFieldSeriesItem'] = None,
             field_series_item: Optional['outputs.DashboardFieldSeriesItem'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_field_series_item is not None:
            _setter("data_field_series_item", data_field_series_item)
        if field_series_item is not None:
            _setter("field_series_item", field_series_item)

    @property
    @pulumi.getter(name="dataFieldSeriesItem")
    def data_field_series_item(self) -> Optional['outputs.DashboardDataFieldSeriesItem']:
        return pulumi.get(self, "data_field_series_item")

    @property
    @pulumi.getter(name="fieldSeriesItem")
    def field_series_item(self) -> Optional['outputs.DashboardFieldSeriesItem']:
        return pulumi.get(self, "field_series_item")


@pulumi.output_type
class DashboardSetParameterValueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationParameterName":
            suggest = "destination_parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSetParameterValueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSetParameterValueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSetParameterValueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_parameter_name: str,
                 value: 'outputs.DashboardDestinationParameterValueConfiguration'):
        DashboardSetParameterValueConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_parameter_name=destination_parameter_name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_parameter_name: str,
             value: 'outputs.DashboardDestinationParameterValueConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("destination_parameter_name", destination_parameter_name)
        _setter("value", value)

    @property
    @pulumi.getter(name="destinationParameterName")
    def destination_parameter_name(self) -> str:
        return pulumi.get(self, "destination_parameter_name")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.DashboardDestinationParameterValueConfiguration':
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardShapeConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardShapeConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardShapeConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardShapeConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: 'outputs.DashboardConditionalFormattingColor'):
        DashboardShapeConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: 'outputs.DashboardConditionalFormattingColor',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("background_color", background_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> 'outputs.DashboardConditionalFormattingColor':
        return pulumi.get(self, "background_color")


@pulumi.output_type
class DashboardSheet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetId":
            suggest = "sheet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSheet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSheet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSheet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 sheet_id: Optional[str] = None):
        DashboardSheet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            sheet_id=sheet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             sheet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if sheet_id is not None:
            _setter("sheet_id", sheet_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sheetId")
    def sheet_id(self) -> Optional[str]:
        return pulumi.get(self, "sheet_id")


@pulumi.output_type
class DashboardSheetControlInfoIconLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconText":
            suggest = "info_icon_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSheetControlInfoIconLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSheetControlInfoIconLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSheetControlInfoIconLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_text: Optional[str] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardSheetControlInfoIconLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_text=info_icon_text,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_text: Optional[str] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_text is not None:
            _setter("info_icon_text", info_icon_text)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="infoIconText")
    def info_icon_text(self) -> Optional[str]:
        return pulumi.get(self, "info_icon_text")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardSheetControlLayout(dict):
    def __init__(__self__, *,
                 configuration: 'outputs.DashboardSheetControlLayoutConfiguration'):
        DashboardSheetControlLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: 'outputs.DashboardSheetControlLayoutConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("configuration", configuration)

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.DashboardSheetControlLayoutConfiguration':
        return pulumi.get(self, "configuration")


@pulumi.output_type
class DashboardSheetControlLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gridLayout":
            suggest = "grid_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSheetControlLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSheetControlLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSheetControlLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grid_layout: Optional['outputs.DashboardGridLayoutConfiguration'] = None):
        DashboardSheetControlLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grid_layout=grid_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grid_layout: Optional['outputs.DashboardGridLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if grid_layout is not None:
            _setter("grid_layout", grid_layout)

    @property
    @pulumi.getter(name="gridLayout")
    def grid_layout(self) -> Optional['outputs.DashboardGridLayoutConfiguration']:
        return pulumi.get(self, "grid_layout")


@pulumi.output_type
class DashboardSheetControlsOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityState":
            suggest = "visibility_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSheetControlsOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSheetControlsOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSheetControlsOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visibility_state: Optional['DashboardUiState'] = None):
        DashboardSheetControlsOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility_state=visibility_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility_state: Optional['DashboardUiState'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility_state is not None:
            _setter("visibility_state", visibility_state)

    @property
    @pulumi.getter(name="visibilityState")
    def visibility_state(self) -> Optional['DashboardUiState']:
        return pulumi.get(self, "visibility_state")


@pulumi.output_type
class DashboardSheetDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetId":
            suggest = "sheet_id"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "filterControls":
            suggest = "filter_controls"
        elif key == "parameterControls":
            suggest = "parameter_controls"
        elif key == "sheetControlLayouts":
            suggest = "sheet_control_layouts"
        elif key == "textBoxes":
            suggest = "text_boxes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSheetDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSheetDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSheetDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sheet_id: str,
                 content_type: Optional['DashboardSheetContentType'] = None,
                 description: Optional[str] = None,
                 filter_controls: Optional[Sequence['outputs.DashboardFilterControl']] = None,
                 layouts: Optional[Sequence['outputs.DashboardLayout']] = None,
                 name: Optional[str] = None,
                 parameter_controls: Optional[Sequence['outputs.DashboardParameterControl']] = None,
                 sheet_control_layouts: Optional[Sequence['outputs.DashboardSheetControlLayout']] = None,
                 text_boxes: Optional[Sequence['outputs.DashboardSheetTextBox']] = None,
                 title: Optional[str] = None,
                 visuals: Optional[Sequence['outputs.DashboardVisual']] = None):
        DashboardSheetDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sheet_id=sheet_id,
            content_type=content_type,
            description=description,
            filter_controls=filter_controls,
            layouts=layouts,
            name=name,
            parameter_controls=parameter_controls,
            sheet_control_layouts=sheet_control_layouts,
            text_boxes=text_boxes,
            title=title,
            visuals=visuals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sheet_id: str,
             content_type: Optional['DashboardSheetContentType'] = None,
             description: Optional[str] = None,
             filter_controls: Optional[Sequence['outputs.DashboardFilterControl']] = None,
             layouts: Optional[Sequence['outputs.DashboardLayout']] = None,
             name: Optional[str] = None,
             parameter_controls: Optional[Sequence['outputs.DashboardParameterControl']] = None,
             sheet_control_layouts: Optional[Sequence['outputs.DashboardSheetControlLayout']] = None,
             text_boxes: Optional[Sequence['outputs.DashboardSheetTextBox']] = None,
             title: Optional[str] = None,
             visuals: Optional[Sequence['outputs.DashboardVisual']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sheet_id", sheet_id)
        if content_type is not None:
            _setter("content_type", content_type)
        if description is not None:
            _setter("description", description)
        if filter_controls is not None:
            _setter("filter_controls", filter_controls)
        if layouts is not None:
            _setter("layouts", layouts)
        if name is not None:
            _setter("name", name)
        if parameter_controls is not None:
            _setter("parameter_controls", parameter_controls)
        if sheet_control_layouts is not None:
            _setter("sheet_control_layouts", sheet_control_layouts)
        if text_boxes is not None:
            _setter("text_boxes", text_boxes)
        if title is not None:
            _setter("title", title)
        if visuals is not None:
            _setter("visuals", visuals)

    @property
    @pulumi.getter(name="sheetId")
    def sheet_id(self) -> str:
        return pulumi.get(self, "sheet_id")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional['DashboardSheetContentType']:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="filterControls")
    def filter_controls(self) -> Optional[Sequence['outputs.DashboardFilterControl']]:
        return pulumi.get(self, "filter_controls")

    @property
    @pulumi.getter
    def layouts(self) -> Optional[Sequence['outputs.DashboardLayout']]:
        return pulumi.get(self, "layouts")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterControls")
    def parameter_controls(self) -> Optional[Sequence['outputs.DashboardParameterControl']]:
        return pulumi.get(self, "parameter_controls")

    @property
    @pulumi.getter(name="sheetControlLayouts")
    def sheet_control_layouts(self) -> Optional[Sequence['outputs.DashboardSheetControlLayout']]:
        return pulumi.get(self, "sheet_control_layouts")

    @property
    @pulumi.getter(name="textBoxes")
    def text_boxes(self) -> Optional[Sequence['outputs.DashboardSheetTextBox']]:
        return pulumi.get(self, "text_boxes")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def visuals(self) -> Optional[Sequence['outputs.DashboardVisual']]:
        return pulumi.get(self, "visuals")


@pulumi.output_type
class DashboardSheetElementConfigurationOverrides(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardSheetElementConfigurationOverrides._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardSheetElementRenderingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationOverrides":
            suggest = "configuration_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSheetElementRenderingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSheetElementRenderingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSheetElementRenderingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_overrides: 'outputs.DashboardSheetElementConfigurationOverrides',
                 expression: str):
        DashboardSheetElementRenderingRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration_overrides=configuration_overrides,
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration_overrides: 'outputs.DashboardSheetElementConfigurationOverrides',
             expression: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("configuration_overrides", configuration_overrides)
        _setter("expression", expression)

    @property
    @pulumi.getter(name="configurationOverrides")
    def configuration_overrides(self) -> 'outputs.DashboardSheetElementConfigurationOverrides':
        return pulumi.get(self, "configuration_overrides")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")


@pulumi.output_type
class DashboardSheetLayoutElementMaximizationOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSheetLayoutElementMaximizationOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSheetLayoutElementMaximizationOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSheetLayoutElementMaximizationOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional['DashboardBehavior'] = None):
        DashboardSheetLayoutElementMaximizationOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional['DashboardBehavior'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional['DashboardBehavior']:
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardSheetTextBox(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetTextBoxId":
            suggest = "sheet_text_box_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSheetTextBox. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSheetTextBox.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSheetTextBox.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sheet_text_box_id: str,
                 content: Optional[str] = None):
        DashboardSheetTextBox._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sheet_text_box_id=sheet_text_box_id,
            content=content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sheet_text_box_id: str,
             content: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sheet_text_box_id", sheet_text_box_id)
        if content is not None:
            _setter("content", content)

    @property
    @pulumi.getter(name="sheetTextBoxId")
    def sheet_text_box_id(self) -> str:
        return pulumi.get(self, "sheet_text_box_id")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")


@pulumi.output_type
class DashboardSheetVisualScopingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetId":
            suggest = "sheet_id"
        elif key == "visualIds":
            suggest = "visual_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSheetVisualScopingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSheetVisualScopingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSheetVisualScopingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scope: 'DashboardFilterVisualScope',
                 sheet_id: str,
                 visual_ids: Optional[Sequence[str]] = None):
        DashboardSheetVisualScopingConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scope=scope,
            sheet_id=sheet_id,
            visual_ids=visual_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scope: 'DashboardFilterVisualScope',
             sheet_id: str,
             visual_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("scope", scope)
        _setter("sheet_id", sheet_id)
        if visual_ids is not None:
            _setter("visual_ids", visual_ids)

    @property
    @pulumi.getter
    def scope(self) -> 'DashboardFilterVisualScope':
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="sheetId")
    def sheet_id(self) -> str:
        return pulumi.get(self, "sheet_id")

    @property
    @pulumi.getter(name="visualIds")
    def visual_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "visual_ids")


@pulumi.output_type
class DashboardShortFormatText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "plainText":
            suggest = "plain_text"
        elif key == "richText":
            suggest = "rich_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardShortFormatText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardShortFormatText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardShortFormatText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 plain_text: Optional[str] = None,
                 rich_text: Optional[str] = None):
        DashboardShortFormatText._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            plain_text=plain_text,
            rich_text=rich_text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             plain_text: Optional[str] = None,
             rich_text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if plain_text is not None:
            _setter("plain_text", plain_text)
        if rich_text is not None:
            _setter("rich_text", rich_text)

    @property
    @pulumi.getter(name="plainText")
    def plain_text(self) -> Optional[str]:
        return pulumi.get(self, "plain_text")

    @property
    @pulumi.getter(name="richText")
    def rich_text(self) -> Optional[str]:
        return pulumi.get(self, "rich_text")


@pulumi.output_type
class DashboardSimpleClusterMarker(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None):
        DashboardSimpleClusterMarker._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")


@pulumi.output_type
class DashboardSliderControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSliderControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSliderControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSliderControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
                 title_options: Optional['outputs.DashboardLabelOptions'] = None):
        DashboardSliderControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
             title_options: Optional['outputs.DashboardLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.DashboardSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.DashboardLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class DashboardSmallMultiplesAxisProperties(dict):
    def __init__(__self__, *,
                 placement: Optional['DashboardSmallMultiplesAxisPlacement'] = None,
                 scale: Optional['DashboardSmallMultiplesAxisScale'] = None):
        DashboardSmallMultiplesAxisProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            placement=placement,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             placement: Optional['DashboardSmallMultiplesAxisPlacement'] = None,
             scale: Optional['DashboardSmallMultiplesAxisScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if placement is not None:
            _setter("placement", placement)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter
    def placement(self) -> Optional['DashboardSmallMultiplesAxisPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter
    def scale(self) -> Optional['DashboardSmallMultiplesAxisScale']:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardSmallMultiplesOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVisibleColumns":
            suggest = "max_visible_columns"
        elif key == "maxVisibleRows":
            suggest = "max_visible_rows"
        elif key == "panelConfiguration":
            suggest = "panel_configuration"
        elif key == "xAxis":
            suggest = "x_axis"
        elif key == "yAxis":
            suggest = "y_axis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSmallMultiplesOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSmallMultiplesOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSmallMultiplesOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_visible_columns: Optional[float] = None,
                 max_visible_rows: Optional[float] = None,
                 panel_configuration: Optional['outputs.DashboardPanelConfiguration'] = None,
                 x_axis: Optional['outputs.DashboardSmallMultiplesAxisProperties'] = None,
                 y_axis: Optional['outputs.DashboardSmallMultiplesAxisProperties'] = None):
        DashboardSmallMultiplesOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_visible_columns=max_visible_columns,
            max_visible_rows=max_visible_rows,
            panel_configuration=panel_configuration,
            x_axis=x_axis,
            y_axis=y_axis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_visible_columns: Optional[float] = None,
             max_visible_rows: Optional[float] = None,
             panel_configuration: Optional['outputs.DashboardPanelConfiguration'] = None,
             x_axis: Optional['outputs.DashboardSmallMultiplesAxisProperties'] = None,
             y_axis: Optional['outputs.DashboardSmallMultiplesAxisProperties'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_visible_columns is not None:
            _setter("max_visible_columns", max_visible_columns)
        if max_visible_rows is not None:
            _setter("max_visible_rows", max_visible_rows)
        if panel_configuration is not None:
            _setter("panel_configuration", panel_configuration)
        if x_axis is not None:
            _setter("x_axis", x_axis)
        if y_axis is not None:
            _setter("y_axis", y_axis)

    @property
    @pulumi.getter(name="maxVisibleColumns")
    def max_visible_columns(self) -> Optional[float]:
        return pulumi.get(self, "max_visible_columns")

    @property
    @pulumi.getter(name="maxVisibleRows")
    def max_visible_rows(self) -> Optional[float]:
        return pulumi.get(self, "max_visible_rows")

    @property
    @pulumi.getter(name="panelConfiguration")
    def panel_configuration(self) -> Optional['outputs.DashboardPanelConfiguration']:
        return pulumi.get(self, "panel_configuration")

    @property
    @pulumi.getter(name="xAxis")
    def x_axis(self) -> Optional['outputs.DashboardSmallMultiplesAxisProperties']:
        return pulumi.get(self, "x_axis")

    @property
    @pulumi.getter(name="yAxis")
    def y_axis(self) -> Optional['outputs.DashboardSmallMultiplesAxisProperties']:
        return pulumi.get(self, "y_axis")


@pulumi.output_type
class DashboardSourceEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceTemplate":
            suggest = "source_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSourceEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSourceEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSourceEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_template: Optional['outputs.DashboardSourceTemplate'] = None):
        DashboardSourceEntity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_template=source_template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_template: Optional['outputs.DashboardSourceTemplate'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if source_template is not None:
            _setter("source_template", source_template)

    @property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional['outputs.DashboardSourceTemplate']:
        return pulumi.get(self, "source_template")


@pulumi.output_type
class DashboardSourceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetReferences":
            suggest = "data_set_references"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSourceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSourceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSourceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 data_set_references: Sequence['outputs.DashboardDataSetReference']):
        DashboardSourceTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            data_set_references=data_set_references,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: str,
             data_set_references: Sequence['outputs.DashboardDataSetReference'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("arn", arn)
        _setter("data_set_references", data_set_references)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> Sequence['outputs.DashboardDataSetReference']:
        return pulumi.get(self, "data_set_references")


@pulumi.output_type
class DashboardSpacing(dict):
    def __init__(__self__, *,
                 bottom: Optional[str] = None,
                 left: Optional[str] = None,
                 right: Optional[str] = None,
                 top: Optional[str] = None):
        """
        :param str bottom: String based length that is composed of value and unit
        :param str left: String based length that is composed of value and unit
        :param str right: String based length that is composed of value and unit
        :param str top: String based length that is composed of value and unit
        """
        DashboardSpacing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bottom=bottom,
            left=left,
            right=right,
            top=top,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bottom: Optional[str] = None,
             left: Optional[str] = None,
             right: Optional[str] = None,
             top: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bottom is not None:
            _setter("bottom", bottom)
        if left is not None:
            _setter("left", left)
        if right is not None:
            _setter("right", right)
        if top is not None:
            _setter("top", top)

    @property
    @pulumi.getter
    def bottom(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "bottom")

    @property
    @pulumi.getter
    def left(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "left")

    @property
    @pulumi.getter
    def right(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "right")

    @property
    @pulumi.getter
    def top(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "top")


@pulumi.output_type
class DashboardStringDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardStringDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardStringDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardStringDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.DashboardDynamicDefaultValue'] = None,
                 static_values: Optional[Sequence[str]] = None):
        DashboardStringDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.DashboardDynamicDefaultValue'] = None,
             static_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.DashboardDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class DashboardStringFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numericFormatConfiguration":
            suggest = "numeric_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardStringFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardStringFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardStringFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 null_value_format_configuration: Optional['outputs.DashboardNullValueFormatConfiguration'] = None,
                 numeric_format_configuration: Optional['outputs.DashboardNumericFormatConfiguration'] = None):
        DashboardStringFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            null_value_format_configuration=null_value_format_configuration,
            numeric_format_configuration=numeric_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             null_value_format_configuration: Optional['outputs.DashboardNullValueFormatConfiguration'] = None,
             numeric_format_configuration: Optional['outputs.DashboardNumericFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if numeric_format_configuration is not None:
            _setter("numeric_format_configuration", numeric_format_configuration)

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.DashboardNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numericFormatConfiguration")
    def numeric_format_configuration(self) -> Optional['outputs.DashboardNumericFormatConfiguration']:
        return pulumi.get(self, "numeric_format_configuration")


@pulumi.output_type
class DashboardStringParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        DashboardStringParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardStringParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueType":
            suggest = "parameter_value_type"
        elif key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardStringParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardStringParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardStringParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 parameter_value_type: 'DashboardParameterValueType',
                 default_values: Optional['outputs.DashboardStringDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.DashboardMappedDataSetParameter']] = None,
                 value_when_unset: Optional['outputs.DashboardStringValueWhenUnsetConfiguration'] = None):
        DashboardStringParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameter_value_type=parameter_value_type,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             parameter_value_type: 'DashboardParameterValueType',
             default_values: Optional['outputs.DashboardStringDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.DashboardMappedDataSetParameter']] = None,
             value_when_unset: Optional['outputs.DashboardStringValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("parameter_value_type", parameter_value_type)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterValueType")
    def parameter_value_type(self) -> 'DashboardParameterValueType':
        return pulumi.get(self, "parameter_value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.DashboardStringDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.DashboardMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.DashboardStringValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class DashboardStringValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardStringValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardStringValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardStringValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[str] = None,
                 value_when_unset_option: Optional['DashboardValueWhenUnsetOption'] = None):
        DashboardStringValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[str] = None,
             value_when_unset_option: Optional['DashboardValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[str]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['DashboardValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class DashboardSubtotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "fieldLevel":
            suggest = "field_level"
        elif key == "fieldLevelOptions":
            suggest = "field_level_options"
        elif key == "metricHeaderCellStyle":
            suggest = "metric_header_cell_style"
        elif key == "styleTargets":
            suggest = "style_targets"
        elif key == "totalCellStyle":
            suggest = "total_cell_style"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"
        elif key == "valueCellStyle":
            suggest = "value_cell_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSubtotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSubtotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSubtotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 field_level: Optional['DashboardPivotTableSubtotalLevel'] = None,
                 field_level_options: Optional[Sequence['outputs.DashboardPivotTableFieldSubtotalOptions']] = None,
                 metric_header_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
                 style_targets: Optional[Sequence['outputs.DashboardTableStyleTarget']] = None,
                 total_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
                 totals_visibility: Optional['DashboardVisibility'] = None,
                 value_cell_style: Optional['outputs.DashboardTableCellStyle'] = None):
        DashboardSubtotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            field_level=field_level,
            field_level_options=field_level_options,
            metric_header_cell_style=metric_header_cell_style,
            style_targets=style_targets,
            total_cell_style=total_cell_style,
            totals_visibility=totals_visibility,
            value_cell_style=value_cell_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             field_level: Optional['DashboardPivotTableSubtotalLevel'] = None,
             field_level_options: Optional[Sequence['outputs.DashboardPivotTableFieldSubtotalOptions']] = None,
             metric_header_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
             style_targets: Optional[Sequence['outputs.DashboardTableStyleTarget']] = None,
             total_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
             totals_visibility: Optional['DashboardVisibility'] = None,
             value_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if field_level is not None:
            _setter("field_level", field_level)
        if field_level_options is not None:
            _setter("field_level_options", field_level_options)
        if metric_header_cell_style is not None:
            _setter("metric_header_cell_style", metric_header_cell_style)
        if style_targets is not None:
            _setter("style_targets", style_targets)
        if total_cell_style is not None:
            _setter("total_cell_style", total_cell_style)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)
        if value_cell_style is not None:
            _setter("value_cell_style", value_cell_style)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="fieldLevel")
    def field_level(self) -> Optional['DashboardPivotTableSubtotalLevel']:
        return pulumi.get(self, "field_level")

    @property
    @pulumi.getter(name="fieldLevelOptions")
    def field_level_options(self) -> Optional[Sequence['outputs.DashboardPivotTableFieldSubtotalOptions']]:
        return pulumi.get(self, "field_level_options")

    @property
    @pulumi.getter(name="metricHeaderCellStyle")
    def metric_header_cell_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "metric_header_cell_style")

    @property
    @pulumi.getter(name="styleTargets")
    def style_targets(self) -> Optional[Sequence['outputs.DashboardTableStyleTarget']]:
        return pulumi.get(self, "style_targets")

    @property
    @pulumi.getter(name="totalCellStyle")
    def total_cell_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "total_cell_style")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "totals_visibility")

    @property
    @pulumi.getter(name="valueCellStyle")
    def value_cell_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "value_cell_style")


@pulumi.output_type
class DashboardTableAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_by: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardTableAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_by=group_by,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_by: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_by is not None:
            _setter("group_by", group_by)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardTableBorderOptions(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 style: Optional['DashboardTableBorderStyle'] = None,
                 thickness: Optional[float] = None):
        DashboardTableBorderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            style=style,
            thickness=thickness,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             style: Optional['DashboardTableBorderStyle'] = None,
             thickness: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if style is not None:
            _setter("style", style)
        if thickness is not None:
            _setter("thickness", thickness)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def style(self) -> Optional['DashboardTableBorderStyle']:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def thickness(self) -> Optional[float]:
        return pulumi.get(self, "thickness")


@pulumi.output_type
class DashboardTableCellConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "textFormat":
            suggest = "text_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableCellConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableCellConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableCellConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 text_format: Optional['outputs.DashboardTextConditionalFormat'] = None):
        DashboardTableCellConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            text_format=text_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             text_format: Optional['outputs.DashboardTextConditionalFormat'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if text_format is not None:
            _setter("text_format", text_format)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="textFormat")
    def text_format(self) -> Optional['outputs.DashboardTextConditionalFormat']:
        return pulumi.get(self, "text_format")


@pulumi.output_type
class DashboardTableCellImageSizingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableCellImageScalingConfiguration":
            suggest = "table_cell_image_scaling_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableCellImageSizingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableCellImageSizingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableCellImageSizingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_cell_image_scaling_configuration: Optional['DashboardTableCellImageScalingConfiguration'] = None):
        DashboardTableCellImageSizingConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            table_cell_image_scaling_configuration=table_cell_image_scaling_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             table_cell_image_scaling_configuration: Optional['DashboardTableCellImageScalingConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if table_cell_image_scaling_configuration is not None:
            _setter("table_cell_image_scaling_configuration", table_cell_image_scaling_configuration)

    @property
    @pulumi.getter(name="tableCellImageScalingConfiguration")
    def table_cell_image_scaling_configuration(self) -> Optional['DashboardTableCellImageScalingConfiguration']:
        return pulumi.get(self, "table_cell_image_scaling_configuration")


@pulumi.output_type
class DashboardTableCellStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "fontConfiguration":
            suggest = "font_configuration"
        elif key == "horizontalTextAlignment":
            suggest = "horizontal_text_alignment"
        elif key == "textWrap":
            suggest = "text_wrap"
        elif key == "verticalTextAlignment":
            suggest = "vertical_text_alignment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableCellStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableCellStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableCellStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[str] = None,
                 border: Optional['outputs.DashboardGlobalTableBorderOptions'] = None,
                 font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
                 height: Optional[float] = None,
                 horizontal_text_alignment: Optional['DashboardHorizontalTextAlignment'] = None,
                 text_wrap: Optional['DashboardTextWrap'] = None,
                 vertical_text_alignment: Optional['DashboardVerticalTextAlignment'] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardTableCellStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            border=border,
            font_configuration=font_configuration,
            height=height,
            horizontal_text_alignment=horizontal_text_alignment,
            text_wrap=text_wrap,
            vertical_text_alignment=vertical_text_alignment,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional[str] = None,
             border: Optional['outputs.DashboardGlobalTableBorderOptions'] = None,
             font_configuration: Optional['outputs.DashboardFontConfiguration'] = None,
             height: Optional[float] = None,
             horizontal_text_alignment: Optional['DashboardHorizontalTextAlignment'] = None,
             text_wrap: Optional['DashboardTextWrap'] = None,
             vertical_text_alignment: Optional['DashboardVerticalTextAlignment'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if border is not None:
            _setter("border", border)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if height is not None:
            _setter("height", height)
        if horizontal_text_alignment is not None:
            _setter("horizontal_text_alignment", horizontal_text_alignment)
        if text_wrap is not None:
            _setter("text_wrap", text_wrap)
        if vertical_text_alignment is not None:
            _setter("vertical_text_alignment", vertical_text_alignment)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def border(self) -> Optional['outputs.DashboardGlobalTableBorderOptions']:
        return pulumi.get(self, "border")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.DashboardFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter
    def height(self) -> Optional[float]:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="horizontalTextAlignment")
    def horizontal_text_alignment(self) -> Optional['DashboardHorizontalTextAlignment']:
        return pulumi.get(self, "horizontal_text_alignment")

    @property
    @pulumi.getter(name="textWrap")
    def text_wrap(self) -> Optional['DashboardTextWrap']:
        return pulumi.get(self, "text_wrap")

    @property
    @pulumi.getter(name="verticalTextAlignment")
    def vertical_text_alignment(self) -> Optional['DashboardVerticalTextAlignment']:
        return pulumi.get(self, "vertical_text_alignment")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardTableConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.DashboardTableConditionalFormattingOption']] = None):
        DashboardTableConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.DashboardTableConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.DashboardTableConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class DashboardTableConditionalFormattingOption(dict):
    def __init__(__self__, *,
                 cell: Optional['outputs.DashboardTableCellConditionalFormatting'] = None,
                 row: Optional['outputs.DashboardTableRowConditionalFormatting'] = None):
        DashboardTableConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell=cell,
            row=row,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell: Optional['outputs.DashboardTableCellConditionalFormatting'] = None,
             row: Optional['outputs.DashboardTableRowConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell is not None:
            _setter("cell", cell)
        if row is not None:
            _setter("row", row)

    @property
    @pulumi.getter
    def cell(self) -> Optional['outputs.DashboardTableCellConditionalFormatting']:
        return pulumi.get(self, "cell")

    @property
    @pulumi.getter
    def row(self) -> Optional['outputs.DashboardTableRowConditionalFormatting']:
        return pulumi.get(self, "row")


@pulumi.output_type
class DashboardTableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldOptions":
            suggest = "field_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "paginatedReportOptions":
            suggest = "paginated_report_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "tableInlineVisualizations":
            suggest = "table_inline_visualizations"
        elif key == "tableOptions":
            suggest = "table_options"
        elif key == "totalOptions":
            suggest = "total_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_options: Optional['outputs.DashboardTableFieldOptions'] = None,
                 field_wells: Optional['outputs.DashboardTableFieldWells'] = None,
                 paginated_report_options: Optional['outputs.DashboardTablePaginatedReportOptions'] = None,
                 sort_configuration: Optional['outputs.DashboardTableSortConfiguration'] = None,
                 table_inline_visualizations: Optional[Sequence['outputs.DashboardTableInlineVisualization']] = None,
                 table_options: Optional['outputs.DashboardTableOptions'] = None,
                 total_options: Optional['outputs.DashboardTotalOptions'] = None):
        DashboardTableConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_options=field_options,
            field_wells=field_wells,
            paginated_report_options=paginated_report_options,
            sort_configuration=sort_configuration,
            table_inline_visualizations=table_inline_visualizations,
            table_options=table_options,
            total_options=total_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_options: Optional['outputs.DashboardTableFieldOptions'] = None,
             field_wells: Optional['outputs.DashboardTableFieldWells'] = None,
             paginated_report_options: Optional['outputs.DashboardTablePaginatedReportOptions'] = None,
             sort_configuration: Optional['outputs.DashboardTableSortConfiguration'] = None,
             table_inline_visualizations: Optional[Sequence['outputs.DashboardTableInlineVisualization']] = None,
             table_options: Optional['outputs.DashboardTableOptions'] = None,
             total_options: Optional['outputs.DashboardTotalOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_options is not None:
            _setter("field_options", field_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if paginated_report_options is not None:
            _setter("paginated_report_options", paginated_report_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if table_inline_visualizations is not None:
            _setter("table_inline_visualizations", table_inline_visualizations)
        if table_options is not None:
            _setter("table_options", table_options)
        if total_options is not None:
            _setter("total_options", total_options)

    @property
    @pulumi.getter(name="fieldOptions")
    def field_options(self) -> Optional['outputs.DashboardTableFieldOptions']:
        return pulumi.get(self, "field_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardTableFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="paginatedReportOptions")
    def paginated_report_options(self) -> Optional['outputs.DashboardTablePaginatedReportOptions']:
        return pulumi.get(self, "paginated_report_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardTableSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="tableInlineVisualizations")
    def table_inline_visualizations(self) -> Optional[Sequence['outputs.DashboardTableInlineVisualization']]:
        return pulumi.get(self, "table_inline_visualizations")

    @property
    @pulumi.getter(name="tableOptions")
    def table_options(self) -> Optional['outputs.DashboardTableOptions']:
        return pulumi.get(self, "table_options")

    @property
    @pulumi.getter(name="totalOptions")
    def total_options(self) -> Optional['outputs.DashboardTotalOptions']:
        return pulumi.get(self, "total_options")


@pulumi.output_type
class DashboardTableFieldCustomIconContent(dict):
    def __init__(__self__, *,
                 icon: Optional['DashboardTableFieldIconSetType'] = None):
        DashboardTableFieldCustomIconContent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['DashboardTableFieldIconSetType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)

    @property
    @pulumi.getter
    def icon(self) -> Optional['DashboardTableFieldIconSetType']:
        return pulumi.get(self, "icon")


@pulumi.output_type
class DashboardTableFieldCustomTextContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontConfiguration":
            suggest = "font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableFieldCustomTextContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableFieldCustomTextContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableFieldCustomTextContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_configuration: 'outputs.DashboardFontConfiguration',
                 value: Optional[str] = None):
        DashboardTableFieldCustomTextContent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_configuration=font_configuration,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_configuration: 'outputs.DashboardFontConfiguration',
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("font_configuration", font_configuration)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> 'outputs.DashboardFontConfiguration':
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardTableFieldImageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizingOptions":
            suggest = "sizing_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableFieldImageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableFieldImageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableFieldImageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sizing_options: Optional['outputs.DashboardTableCellImageSizingConfiguration'] = None):
        DashboardTableFieldImageConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sizing_options=sizing_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sizing_options: Optional['outputs.DashboardTableCellImageSizingConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sizing_options is not None:
            _setter("sizing_options", sizing_options)

    @property
    @pulumi.getter(name="sizingOptions")
    def sizing_options(self) -> Optional['outputs.DashboardTableCellImageSizingConfiguration']:
        return pulumi.get(self, "sizing_options")


@pulumi.output_type
class DashboardTableFieldLinkConfiguration(dict):
    def __init__(__self__, *,
                 content: 'outputs.DashboardTableFieldLinkContentConfiguration',
                 target: 'DashboardUrlTargetConfiguration'):
        DashboardTableFieldLinkConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: 'outputs.DashboardTableFieldLinkContentConfiguration',
             target: 'DashboardUrlTargetConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        _setter("target", target)

    @property
    @pulumi.getter
    def content(self) -> 'outputs.DashboardTableFieldLinkContentConfiguration':
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def target(self) -> 'DashboardUrlTargetConfiguration':
        return pulumi.get(self, "target")


@pulumi.output_type
class DashboardTableFieldLinkContentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customIconContent":
            suggest = "custom_icon_content"
        elif key == "customTextContent":
            suggest = "custom_text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableFieldLinkContentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableFieldLinkContentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableFieldLinkContentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_icon_content: Optional['outputs.DashboardTableFieldCustomIconContent'] = None,
                 custom_text_content: Optional['outputs.DashboardTableFieldCustomTextContent'] = None):
        DashboardTableFieldLinkContentConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_icon_content=custom_icon_content,
            custom_text_content=custom_text_content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_icon_content: Optional['outputs.DashboardTableFieldCustomIconContent'] = None,
             custom_text_content: Optional['outputs.DashboardTableFieldCustomTextContent'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_icon_content is not None:
            _setter("custom_icon_content", custom_icon_content)
        if custom_text_content is not None:
            _setter("custom_text_content", custom_text_content)

    @property
    @pulumi.getter(name="customIconContent")
    def custom_icon_content(self) -> Optional['outputs.DashboardTableFieldCustomIconContent']:
        return pulumi.get(self, "custom_icon_content")

    @property
    @pulumi.getter(name="customTextContent")
    def custom_text_content(self) -> Optional['outputs.DashboardTableFieldCustomTextContent']:
        return pulumi.get(self, "custom_text_content")


@pulumi.output_type
class DashboardTableFieldOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "customLabel":
            suggest = "custom_label"
        elif key == "urlStyling":
            suggest = "url_styling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableFieldOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableFieldOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableFieldOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 custom_label: Optional[str] = None,
                 url_styling: Optional['outputs.DashboardTableFieldUrlConfiguration'] = None,
                 visibility: Optional['DashboardVisibility'] = None,
                 width: Optional[str] = None):
        """
        :param str width: String based length that is composed of value and unit in px
        """
        DashboardTableFieldOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            custom_label=custom_label,
            url_styling=url_styling,
            visibility=visibility,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             custom_label: Optional[str] = None,
             url_styling: Optional['outputs.DashboardTableFieldUrlConfiguration'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if url_styling is not None:
            _setter("url_styling", url_styling)
        if visibility is not None:
            _setter("visibility", visibility)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="urlStyling")
    def url_styling(self) -> Optional['outputs.DashboardTableFieldUrlConfiguration']:
        return pulumi.get(self, "url_styling")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class DashboardTableFieldOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pinnedFieldOptions":
            suggest = "pinned_field_options"
        elif key == "selectedFieldOptions":
            suggest = "selected_field_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableFieldOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableFieldOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableFieldOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 order: Optional[Sequence[str]] = None,
                 pinned_field_options: Optional['outputs.DashboardTablePinnedFieldOptions'] = None,
                 selected_field_options: Optional[Sequence['outputs.DashboardTableFieldOption']] = None):
        DashboardTableFieldOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            order=order,
            pinned_field_options=pinned_field_options,
            selected_field_options=selected_field_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             order: Optional[Sequence[str]] = None,
             pinned_field_options: Optional['outputs.DashboardTablePinnedFieldOptions'] = None,
             selected_field_options: Optional[Sequence['outputs.DashboardTableFieldOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if order is not None:
            _setter("order", order)
        if pinned_field_options is not None:
            _setter("pinned_field_options", pinned_field_options)
        if selected_field_options is not None:
            _setter("selected_field_options", selected_field_options)

    @property
    @pulumi.getter
    def order(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="pinnedFieldOptions")
    def pinned_field_options(self) -> Optional['outputs.DashboardTablePinnedFieldOptions']:
        return pulumi.get(self, "pinned_field_options")

    @property
    @pulumi.getter(name="selectedFieldOptions")
    def selected_field_options(self) -> Optional[Sequence['outputs.DashboardTableFieldOption']]:
        return pulumi.get(self, "selected_field_options")


@pulumi.output_type
class DashboardTableFieldUrlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageConfiguration":
            suggest = "image_configuration"
        elif key == "linkConfiguration":
            suggest = "link_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableFieldUrlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableFieldUrlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableFieldUrlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_configuration: Optional['outputs.DashboardTableFieldImageConfiguration'] = None,
                 link_configuration: Optional['outputs.DashboardTableFieldLinkConfiguration'] = None):
        DashboardTableFieldUrlConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            image_configuration=image_configuration,
            link_configuration=link_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             image_configuration: Optional['outputs.DashboardTableFieldImageConfiguration'] = None,
             link_configuration: Optional['outputs.DashboardTableFieldLinkConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if image_configuration is not None:
            _setter("image_configuration", image_configuration)
        if link_configuration is not None:
            _setter("link_configuration", link_configuration)

    @property
    @pulumi.getter(name="imageConfiguration")
    def image_configuration(self) -> Optional['outputs.DashboardTableFieldImageConfiguration']:
        return pulumi.get(self, "image_configuration")

    @property
    @pulumi.getter(name="linkConfiguration")
    def link_configuration(self) -> Optional['outputs.DashboardTableFieldLinkConfiguration']:
        return pulumi.get(self, "link_configuration")


@pulumi.output_type
class DashboardTableFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableAggregatedFieldWells":
            suggest = "table_aggregated_field_wells"
        elif key == "tableUnaggregatedFieldWells":
            suggest = "table_unaggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_aggregated_field_wells: Optional['outputs.DashboardTableAggregatedFieldWells'] = None,
                 table_unaggregated_field_wells: Optional['outputs.DashboardTableUnaggregatedFieldWells'] = None):
        DashboardTableFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            table_aggregated_field_wells=table_aggregated_field_wells,
            table_unaggregated_field_wells=table_unaggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             table_aggregated_field_wells: Optional['outputs.DashboardTableAggregatedFieldWells'] = None,
             table_unaggregated_field_wells: Optional['outputs.DashboardTableUnaggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if table_aggregated_field_wells is not None:
            _setter("table_aggregated_field_wells", table_aggregated_field_wells)
        if table_unaggregated_field_wells is not None:
            _setter("table_unaggregated_field_wells", table_unaggregated_field_wells)

    @property
    @pulumi.getter(name="tableAggregatedFieldWells")
    def table_aggregated_field_wells(self) -> Optional['outputs.DashboardTableAggregatedFieldWells']:
        return pulumi.get(self, "table_aggregated_field_wells")

    @property
    @pulumi.getter(name="tableUnaggregatedFieldWells")
    def table_unaggregated_field_wells(self) -> Optional['outputs.DashboardTableUnaggregatedFieldWells']:
        return pulumi.get(self, "table_unaggregated_field_wells")


@pulumi.output_type
class DashboardTableInlineVisualization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataBars":
            suggest = "data_bars"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableInlineVisualization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableInlineVisualization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableInlineVisualization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_bars: Optional['outputs.DashboardDataBarsOptions'] = None):
        DashboardTableInlineVisualization._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_bars=data_bars,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_bars: Optional['outputs.DashboardDataBarsOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_bars is not None:
            _setter("data_bars", data_bars)

    @property
    @pulumi.getter(name="dataBars")
    def data_bars(self) -> Optional['outputs.DashboardDataBarsOptions']:
        return pulumi.get(self, "data_bars")


@pulumi.output_type
class DashboardTableOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellStyle":
            suggest = "cell_style"
        elif key == "headerStyle":
            suggest = "header_style"
        elif key == "rowAlternateColorOptions":
            suggest = "row_alternate_color_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
                 header_style: Optional['outputs.DashboardTableCellStyle'] = None,
                 orientation: Optional['DashboardTableOrientation'] = None,
                 row_alternate_color_options: Optional['outputs.DashboardRowAlternateColorOptions'] = None):
        DashboardTableOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell_style=cell_style,
            header_style=header_style,
            orientation=orientation,
            row_alternate_color_options=row_alternate_color_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
             header_style: Optional['outputs.DashboardTableCellStyle'] = None,
             orientation: Optional['DashboardTableOrientation'] = None,
             row_alternate_color_options: Optional['outputs.DashboardRowAlternateColorOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell_style is not None:
            _setter("cell_style", cell_style)
        if header_style is not None:
            _setter("header_style", header_style)
        if orientation is not None:
            _setter("orientation", orientation)
        if row_alternate_color_options is not None:
            _setter("row_alternate_color_options", row_alternate_color_options)

    @property
    @pulumi.getter(name="cellStyle")
    def cell_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "cell_style")

    @property
    @pulumi.getter(name="headerStyle")
    def header_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "header_style")

    @property
    @pulumi.getter
    def orientation(self) -> Optional['DashboardTableOrientation']:
        return pulumi.get(self, "orientation")

    @property
    @pulumi.getter(name="rowAlternateColorOptions")
    def row_alternate_color_options(self) -> Optional['outputs.DashboardRowAlternateColorOptions']:
        return pulumi.get(self, "row_alternate_color_options")


@pulumi.output_type
class DashboardTablePaginatedReportOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overflowColumnHeaderVisibility":
            suggest = "overflow_column_header_visibility"
        elif key == "verticalOverflowVisibility":
            suggest = "vertical_overflow_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTablePaginatedReportOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTablePaginatedReportOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTablePaginatedReportOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 overflow_column_header_visibility: Optional['DashboardVisibility'] = None,
                 vertical_overflow_visibility: Optional['DashboardVisibility'] = None):
        DashboardTablePaginatedReportOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            overflow_column_header_visibility=overflow_column_header_visibility,
            vertical_overflow_visibility=vertical_overflow_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             overflow_column_header_visibility: Optional['DashboardVisibility'] = None,
             vertical_overflow_visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if overflow_column_header_visibility is not None:
            _setter("overflow_column_header_visibility", overflow_column_header_visibility)
        if vertical_overflow_visibility is not None:
            _setter("vertical_overflow_visibility", vertical_overflow_visibility)

    @property
    @pulumi.getter(name="overflowColumnHeaderVisibility")
    def overflow_column_header_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "overflow_column_header_visibility")

    @property
    @pulumi.getter(name="verticalOverflowVisibility")
    def vertical_overflow_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "vertical_overflow_visibility")


@pulumi.output_type
class DashboardTablePinnedFieldOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pinnedLeftFields":
            suggest = "pinned_left_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTablePinnedFieldOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTablePinnedFieldOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTablePinnedFieldOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pinned_left_fields: Optional[Sequence[str]] = None):
        DashboardTablePinnedFieldOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pinned_left_fields=pinned_left_fields,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pinned_left_fields: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pinned_left_fields is not None:
            _setter("pinned_left_fields", pinned_left_fields)

    @property
    @pulumi.getter(name="pinnedLeftFields")
    def pinned_left_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "pinned_left_fields")


@pulumi.output_type
class DashboardTableRowConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableRowConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableRowConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableRowConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
                 text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None):
        DashboardTableRowConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
             text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional['outputs.DashboardConditionalFormattingColor']:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.DashboardConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class DashboardTableSideBorderOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "innerHorizontal":
            suggest = "inner_horizontal"
        elif key == "innerVertical":
            suggest = "inner_vertical"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableSideBorderOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableSideBorderOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableSideBorderOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bottom: Optional['outputs.DashboardTableBorderOptions'] = None,
                 inner_horizontal: Optional['outputs.DashboardTableBorderOptions'] = None,
                 inner_vertical: Optional['outputs.DashboardTableBorderOptions'] = None,
                 left: Optional['outputs.DashboardTableBorderOptions'] = None,
                 right: Optional['outputs.DashboardTableBorderOptions'] = None,
                 top: Optional['outputs.DashboardTableBorderOptions'] = None):
        DashboardTableSideBorderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bottom=bottom,
            inner_horizontal=inner_horizontal,
            inner_vertical=inner_vertical,
            left=left,
            right=right,
            top=top,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bottom: Optional['outputs.DashboardTableBorderOptions'] = None,
             inner_horizontal: Optional['outputs.DashboardTableBorderOptions'] = None,
             inner_vertical: Optional['outputs.DashboardTableBorderOptions'] = None,
             left: Optional['outputs.DashboardTableBorderOptions'] = None,
             right: Optional['outputs.DashboardTableBorderOptions'] = None,
             top: Optional['outputs.DashboardTableBorderOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bottom is not None:
            _setter("bottom", bottom)
        if inner_horizontal is not None:
            _setter("inner_horizontal", inner_horizontal)
        if inner_vertical is not None:
            _setter("inner_vertical", inner_vertical)
        if left is not None:
            _setter("left", left)
        if right is not None:
            _setter("right", right)
        if top is not None:
            _setter("top", top)

    @property
    @pulumi.getter
    def bottom(self) -> Optional['outputs.DashboardTableBorderOptions']:
        return pulumi.get(self, "bottom")

    @property
    @pulumi.getter(name="innerHorizontal")
    def inner_horizontal(self) -> Optional['outputs.DashboardTableBorderOptions']:
        return pulumi.get(self, "inner_horizontal")

    @property
    @pulumi.getter(name="innerVertical")
    def inner_vertical(self) -> Optional['outputs.DashboardTableBorderOptions']:
        return pulumi.get(self, "inner_vertical")

    @property
    @pulumi.getter
    def left(self) -> Optional['outputs.DashboardTableBorderOptions']:
        return pulumi.get(self, "left")

    @property
    @pulumi.getter
    def right(self) -> Optional['outputs.DashboardTableBorderOptions']:
        return pulumi.get(self, "right")

    @property
    @pulumi.getter
    def top(self) -> Optional['outputs.DashboardTableBorderOptions']:
        return pulumi.get(self, "top")


@pulumi.output_type
class DashboardTableSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paginationConfiguration":
            suggest = "pagination_configuration"
        elif key == "rowSort":
            suggest = "row_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pagination_configuration: Optional['outputs.DashboardPaginationConfiguration'] = None,
                 row_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardTableSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pagination_configuration=pagination_configuration,
            row_sort=row_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pagination_configuration: Optional['outputs.DashboardPaginationConfiguration'] = None,
             row_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pagination_configuration is not None:
            _setter("pagination_configuration", pagination_configuration)
        if row_sort is not None:
            _setter("row_sort", row_sort)

    @property
    @pulumi.getter(name="paginationConfiguration")
    def pagination_configuration(self) -> Optional['outputs.DashboardPaginationConfiguration']:
        return pulumi.get(self, "pagination_configuration")

    @property
    @pulumi.getter(name="rowSort")
    def row_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "row_sort")


@pulumi.output_type
class DashboardTableStyleTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellType":
            suggest = "cell_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableStyleTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableStyleTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableStyleTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cell_type: 'DashboardStyledCellType'):
        DashboardTableStyleTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell_type=cell_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell_type: 'DashboardStyledCellType',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cell_type", cell_type)

    @property
    @pulumi.getter(name="cellType")
    def cell_type(self) -> 'DashboardStyledCellType':
        return pulumi.get(self, "cell_type")


@pulumi.output_type
class DashboardTableUnaggregatedFieldWells(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.DashboardUnaggregatedField']] = None):
        DashboardTableUnaggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Optional[Sequence['outputs.DashboardUnaggregatedField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardUnaggregatedField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardTableVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTableVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTableVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTableVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardTableConfiguration'] = None,
                 conditional_formatting: Optional['outputs.DashboardTableConditionalFormatting'] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardTableVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardTableConfiguration'] = None,
             conditional_formatting: Optional['outputs.DashboardTableConditionalFormatting'] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardTableConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.DashboardTableConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        DashboardTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardTextAreaControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "placeholderOptions":
            suggest = "placeholder_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTextAreaControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTextAreaControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTextAreaControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
                 placeholder_options: Optional['outputs.DashboardTextControlPlaceholderOptions'] = None,
                 title_options: Optional['outputs.DashboardLabelOptions'] = None):
        DashboardTextAreaControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            placeholder_options=placeholder_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
             placeholder_options: Optional['outputs.DashboardTextControlPlaceholderOptions'] = None,
             title_options: Optional['outputs.DashboardLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if placeholder_options is not None:
            _setter("placeholder_options", placeholder_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.DashboardSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="placeholderOptions")
    def placeholder_options(self) -> Optional['outputs.DashboardTextControlPlaceholderOptions']:
        return pulumi.get(self, "placeholder_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.DashboardLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class DashboardTextConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTextConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTextConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTextConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
                 icon: Optional['outputs.DashboardConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None):
        DashboardTextConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
             icon: Optional['outputs.DashboardConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.DashboardConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional['outputs.DashboardConditionalFormattingColor']:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.DashboardConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.DashboardConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class DashboardTextControlPlaceholderOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardTextControlPlaceholderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardTextFieldControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "placeholderOptions":
            suggest = "placeholder_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTextFieldControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTextFieldControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTextFieldControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
                 placeholder_options: Optional['outputs.DashboardTextControlPlaceholderOptions'] = None,
                 title_options: Optional['outputs.DashboardLabelOptions'] = None):
        DashboardTextFieldControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            placeholder_options=placeholder_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.DashboardSheetControlInfoIconLabelOptions'] = None,
             placeholder_options: Optional['outputs.DashboardTextControlPlaceholderOptions'] = None,
             title_options: Optional['outputs.DashboardLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if placeholder_options is not None:
            _setter("placeholder_options", placeholder_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.DashboardSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="placeholderOptions")
    def placeholder_options(self) -> Optional['outputs.DashboardTextControlPlaceholderOptions']:
        return pulumi.get(self, "placeholder_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.DashboardLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class DashboardThousandSeparatorOptions(dict):
    def __init__(__self__, *,
                 symbol: Optional['DashboardNumericSeparatorSymbol'] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardThousandSeparatorOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            symbol=symbol,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             symbol: Optional['DashboardNumericSeparatorSymbol'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if symbol is not None:
            _setter("symbol", symbol)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def symbol(self) -> Optional['DashboardNumericSeparatorSymbol']:
        return pulumi.get(self, "symbol")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardTimeBasedForecastProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lowerBoundary":
            suggest = "lower_boundary"
        elif key == "periodsBackward":
            suggest = "periods_backward"
        elif key == "periodsForward":
            suggest = "periods_forward"
        elif key == "predictionInterval":
            suggest = "prediction_interval"
        elif key == "upperBoundary":
            suggest = "upper_boundary"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeBasedForecastProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeBasedForecastProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeBasedForecastProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lower_boundary: Optional[float] = None,
                 periods_backward: Optional[float] = None,
                 periods_forward: Optional[float] = None,
                 prediction_interval: Optional[float] = None,
                 seasonality: Optional[float] = None,
                 upper_boundary: Optional[float] = None):
        DashboardTimeBasedForecastProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lower_boundary=lower_boundary,
            periods_backward=periods_backward,
            periods_forward=periods_forward,
            prediction_interval=prediction_interval,
            seasonality=seasonality,
            upper_boundary=upper_boundary,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lower_boundary: Optional[float] = None,
             periods_backward: Optional[float] = None,
             periods_forward: Optional[float] = None,
             prediction_interval: Optional[float] = None,
             seasonality: Optional[float] = None,
             upper_boundary: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if lower_boundary is not None:
            _setter("lower_boundary", lower_boundary)
        if periods_backward is not None:
            _setter("periods_backward", periods_backward)
        if periods_forward is not None:
            _setter("periods_forward", periods_forward)
        if prediction_interval is not None:
            _setter("prediction_interval", prediction_interval)
        if seasonality is not None:
            _setter("seasonality", seasonality)
        if upper_boundary is not None:
            _setter("upper_boundary", upper_boundary)

    @property
    @pulumi.getter(name="lowerBoundary")
    def lower_boundary(self) -> Optional[float]:
        return pulumi.get(self, "lower_boundary")

    @property
    @pulumi.getter(name="periodsBackward")
    def periods_backward(self) -> Optional[float]:
        return pulumi.get(self, "periods_backward")

    @property
    @pulumi.getter(name="periodsForward")
    def periods_forward(self) -> Optional[float]:
        return pulumi.get(self, "periods_forward")

    @property
    @pulumi.getter(name="predictionInterval")
    def prediction_interval(self) -> Optional[float]:
        return pulumi.get(self, "prediction_interval")

    @property
    @pulumi.getter
    def seasonality(self) -> Optional[float]:
        return pulumi.get(self, "seasonality")

    @property
    @pulumi.getter(name="upperBoundary")
    def upper_boundary(self) -> Optional[float]:
        return pulumi.get(self, "upper_boundary")


@pulumi.output_type
class DashboardTimeEqualityFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeEqualityFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeEqualityFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeEqualityFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 filter_id: str,
                 parameter_name: Optional[str] = None,
                 time_granularity: Optional['DashboardTimeGranularity'] = None,
                 value: Optional[str] = None):
        DashboardTimeEqualityFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            parameter_name=parameter_name,
            time_granularity=time_granularity,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             filter_id: str,
             parameter_name: Optional[str] = None,
             time_granularity: Optional['DashboardTimeGranularity'] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['DashboardTimeGranularity']:
        return pulumi.get(self, "time_granularity")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardTimeRangeDrillDownFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeMaximum":
            suggest = "range_maximum"
        elif key == "rangeMinimum":
            suggest = "range_minimum"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeDrillDownFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeDrillDownFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeDrillDownFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 range_maximum: str,
                 range_minimum: str,
                 time_granularity: 'DashboardTimeGranularity'):
        DashboardTimeRangeDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            range_maximum=range_maximum,
            range_minimum=range_minimum,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             range_maximum: str,
             range_minimum: str,
             time_granularity: 'DashboardTimeGranularity',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("range_maximum", range_maximum)
        _setter("range_minimum", range_minimum)
        _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="rangeMaximum")
    def range_maximum(self) -> str:
        return pulumi.get(self, "range_maximum")

    @property
    @pulumi.getter(name="rangeMinimum")
    def range_minimum(self) -> str:
        return pulumi.get(self, "range_minimum")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> 'DashboardTimeGranularity':
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class DashboardTimeRangeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "excludePeriodConfiguration":
            suggest = "exclude_period_configuration"
        elif key == "includeMaximum":
            suggest = "include_maximum"
        elif key == "includeMinimum":
            suggest = "include_minimum"
        elif key == "rangeMaximumValue":
            suggest = "range_maximum_value"
        elif key == "rangeMinimumValue":
            suggest = "range_minimum_value"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 filter_id: str,
                 null_option: 'DashboardFilterNullOption',
                 exclude_period_configuration: Optional['outputs.DashboardExcludePeriodConfiguration'] = None,
                 include_maximum: Optional[bool] = None,
                 include_minimum: Optional[bool] = None,
                 range_maximum_value: Optional['outputs.DashboardTimeRangeFilterValue'] = None,
                 range_minimum_value: Optional['outputs.DashboardTimeRangeFilterValue'] = None,
                 time_granularity: Optional['DashboardTimeGranularity'] = None):
        DashboardTimeRangeFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            null_option=null_option,
            exclude_period_configuration=exclude_period_configuration,
            include_maximum=include_maximum,
            include_minimum=include_minimum,
            range_maximum_value=range_maximum_value,
            range_minimum_value=range_minimum_value,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             filter_id: str,
             null_option: 'DashboardFilterNullOption',
             exclude_period_configuration: Optional['outputs.DashboardExcludePeriodConfiguration'] = None,
             include_maximum: Optional[bool] = None,
             include_minimum: Optional[bool] = None,
             range_maximum_value: Optional['outputs.DashboardTimeRangeFilterValue'] = None,
             range_minimum_value: Optional['outputs.DashboardTimeRangeFilterValue'] = None,
             time_granularity: Optional['DashboardTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("null_option", null_option)
        if exclude_period_configuration is not None:
            _setter("exclude_period_configuration", exclude_period_configuration)
        if include_maximum is not None:
            _setter("include_maximum", include_maximum)
        if include_minimum is not None:
            _setter("include_minimum", include_minimum)
        if range_maximum_value is not None:
            _setter("range_maximum_value", range_maximum_value)
        if range_minimum_value is not None:
            _setter("range_minimum_value", range_minimum_value)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'DashboardFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="excludePeriodConfiguration")
    def exclude_period_configuration(self) -> Optional['outputs.DashboardExcludePeriodConfiguration']:
        return pulumi.get(self, "exclude_period_configuration")

    @property
    @pulumi.getter(name="includeMaximum")
    def include_maximum(self) -> Optional[bool]:
        return pulumi.get(self, "include_maximum")

    @property
    @pulumi.getter(name="includeMinimum")
    def include_minimum(self) -> Optional[bool]:
        return pulumi.get(self, "include_minimum")

    @property
    @pulumi.getter(name="rangeMaximumValue")
    def range_maximum_value(self) -> Optional['outputs.DashboardTimeRangeFilterValue']:
        return pulumi.get(self, "range_maximum_value")

    @property
    @pulumi.getter(name="rangeMinimumValue")
    def range_minimum_value(self) -> Optional['outputs.DashboardTimeRangeFilterValue']:
        return pulumi.get(self, "range_minimum_value")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['DashboardTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class DashboardTimeRangeFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollingDate":
            suggest = "rolling_date"
        elif key == "staticValue":
            suggest = "static_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 rolling_date: Optional['outputs.DashboardRollingDateConfiguration'] = None,
                 static_value: Optional[str] = None):
        DashboardTimeRangeFilterValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter=parameter,
            rolling_date=rolling_date,
            static_value=static_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter: Optional[str] = None,
             rolling_date: Optional['outputs.DashboardRollingDateConfiguration'] = None,
             static_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if parameter is not None:
            _setter("parameter", parameter)
        if rolling_date is not None:
            _setter("rolling_date", rolling_date)
        if static_value is not None:
            _setter("static_value", static_value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter(name="rollingDate")
    def rolling_date(self) -> Optional['outputs.DashboardRollingDateConfiguration']:
        return pulumi.get(self, "rolling_date")

    @property
    @pulumi.getter(name="staticValue")
    def static_value(self) -> Optional[str]:
        return pulumi.get(self, "static_value")


@pulumi.output_type
class DashboardTooltipItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnTooltipItem":
            suggest = "column_tooltip_item"
        elif key == "fieldTooltipItem":
            suggest = "field_tooltip_item"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTooltipItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTooltipItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTooltipItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_tooltip_item: Optional['outputs.DashboardColumnTooltipItem'] = None,
                 field_tooltip_item: Optional['outputs.DashboardFieldTooltipItem'] = None):
        DashboardTooltipItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_tooltip_item=column_tooltip_item,
            field_tooltip_item=field_tooltip_item,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_tooltip_item: Optional['outputs.DashboardColumnTooltipItem'] = None,
             field_tooltip_item: Optional['outputs.DashboardFieldTooltipItem'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_tooltip_item is not None:
            _setter("column_tooltip_item", column_tooltip_item)
        if field_tooltip_item is not None:
            _setter("field_tooltip_item", field_tooltip_item)

    @property
    @pulumi.getter(name="columnTooltipItem")
    def column_tooltip_item(self) -> Optional['outputs.DashboardColumnTooltipItem']:
        return pulumi.get(self, "column_tooltip_item")

    @property
    @pulumi.getter(name="fieldTooltipItem")
    def field_tooltip_item(self) -> Optional['outputs.DashboardFieldTooltipItem']:
        return pulumi.get(self, "field_tooltip_item")


@pulumi.output_type
class DashboardTooltipOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldBasedTooltip":
            suggest = "field_based_tooltip"
        elif key == "selectedTooltipType":
            suggest = "selected_tooltip_type"
        elif key == "tooltipVisibility":
            suggest = "tooltip_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTooltipOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTooltipOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTooltipOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_based_tooltip: Optional['outputs.DashboardFieldBasedTooltip'] = None,
                 selected_tooltip_type: Optional['DashboardSelectedTooltipType'] = None,
                 tooltip_visibility: Optional['DashboardVisibility'] = None):
        DashboardTooltipOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_based_tooltip=field_based_tooltip,
            selected_tooltip_type=selected_tooltip_type,
            tooltip_visibility=tooltip_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_based_tooltip: Optional['outputs.DashboardFieldBasedTooltip'] = None,
             selected_tooltip_type: Optional['DashboardSelectedTooltipType'] = None,
             tooltip_visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_based_tooltip is not None:
            _setter("field_based_tooltip", field_based_tooltip)
        if selected_tooltip_type is not None:
            _setter("selected_tooltip_type", selected_tooltip_type)
        if tooltip_visibility is not None:
            _setter("tooltip_visibility", tooltip_visibility)

    @property
    @pulumi.getter(name="fieldBasedTooltip")
    def field_based_tooltip(self) -> Optional['outputs.DashboardFieldBasedTooltip']:
        return pulumi.get(self, "field_based_tooltip")

    @property
    @pulumi.getter(name="selectedTooltipType")
    def selected_tooltip_type(self) -> Optional['DashboardSelectedTooltipType']:
        return pulumi.get(self, "selected_tooltip_type")

    @property
    @pulumi.getter(name="tooltipVisibility")
    def tooltip_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "tooltip_visibility")


@pulumi.output_type
class DashboardTopBottomFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationSortConfigurations":
            suggest = "aggregation_sort_configurations"
        elif key == "filterId":
            suggest = "filter_id"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTopBottomFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTopBottomFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTopBottomFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_sort_configurations: Sequence['outputs.DashboardAggregationSortConfiguration'],
                 column: 'outputs.DashboardColumnIdentifier',
                 filter_id: str,
                 limit: Optional[float] = None,
                 parameter_name: Optional[str] = None,
                 time_granularity: Optional['DashboardTimeGranularity'] = None):
        DashboardTopBottomFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_sort_configurations=aggregation_sort_configurations,
            column=column,
            filter_id=filter_id,
            limit=limit,
            parameter_name=parameter_name,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_sort_configurations: Sequence['outputs.DashboardAggregationSortConfiguration'],
             column: 'outputs.DashboardColumnIdentifier',
             filter_id: str,
             limit: Optional[float] = None,
             parameter_name: Optional[str] = None,
             time_granularity: Optional['DashboardTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation_sort_configurations", aggregation_sort_configurations)
        _setter("column", column)
        _setter("filter_id", filter_id)
        if limit is not None:
            _setter("limit", limit)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter(name="aggregationSortConfigurations")
    def aggregation_sort_configurations(self) -> Sequence['outputs.DashboardAggregationSortConfiguration']:
        return pulumi.get(self, "aggregation_sort_configurations")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['DashboardTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class DashboardTopBottomMoversComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "moverSize":
            suggest = "mover_size"
        elif key == "sortOrder":
            suggest = "sort_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTopBottomMoversComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTopBottomMoversComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTopBottomMoversComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 type: 'DashboardTopBottomComputationType',
                 category: Optional['outputs.DashboardDimensionField'] = None,
                 mover_size: Optional[float] = None,
                 name: Optional[str] = None,
                 sort_order: Optional['DashboardTopBottomSortOrder'] = None,
                 time: Optional['outputs.DashboardDimensionField'] = None,
                 value: Optional['outputs.DashboardMeasureField'] = None):
        DashboardTopBottomMoversComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            type=type,
            category=category,
            mover_size=mover_size,
            name=name,
            sort_order=sort_order,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             type: 'DashboardTopBottomComputationType',
             category: Optional['outputs.DashboardDimensionField'] = None,
             mover_size: Optional[float] = None,
             name: Optional[str] = None,
             sort_order: Optional['DashboardTopBottomSortOrder'] = None,
             time: Optional['outputs.DashboardDimensionField'] = None,
             value: Optional['outputs.DashboardMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        _setter("type", type)
        if category is not None:
            _setter("category", category)
        if mover_size is not None:
            _setter("mover_size", mover_size)
        if name is not None:
            _setter("name", name)
        if sort_order is not None:
            _setter("sort_order", sort_order)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def type(self) -> 'DashboardTopBottomComputationType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional['outputs.DashboardDimensionField']:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="moverSize")
    def mover_size(self) -> Optional[float]:
        return pulumi.get(self, "mover_size")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> Optional['DashboardTopBottomSortOrder']:
        return pulumi.get(self, "sort_order")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.DashboardMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardTopBottomRankedComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "resultSize":
            suggest = "result_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTopBottomRankedComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTopBottomRankedComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTopBottomRankedComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 type: 'DashboardTopBottomComputationType',
                 category: Optional['outputs.DashboardDimensionField'] = None,
                 name: Optional[str] = None,
                 result_size: Optional[float] = None,
                 value: Optional['outputs.DashboardMeasureField'] = None):
        DashboardTopBottomRankedComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            type=type,
            category=category,
            name=name,
            result_size=result_size,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             type: 'DashboardTopBottomComputationType',
             category: Optional['outputs.DashboardDimensionField'] = None,
             name: Optional[str] = None,
             result_size: Optional[float] = None,
             value: Optional['outputs.DashboardMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        _setter("type", type)
        if category is not None:
            _setter("category", category)
        if name is not None:
            _setter("name", name)
        if result_size is not None:
            _setter("result_size", result_size)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def type(self) -> 'DashboardTopBottomComputationType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional['outputs.DashboardDimensionField']:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resultSize")
    def result_size(self) -> Optional[float]:
        return pulumi.get(self, "result_size")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.DashboardMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardTotalAggregationComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTotalAggregationComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTotalAggregationComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTotalAggregationComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 value: Optional['outputs.DashboardMeasureField'] = None):
        DashboardTotalAggregationComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             value: Optional['outputs.DashboardMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.DashboardMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardTotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "scrollStatus":
            suggest = "scroll_status"
        elif key == "totalCellStyle":
            suggest = "total_cell_style"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 placement: Optional['DashboardTableTotalsPlacement'] = None,
                 scroll_status: Optional['DashboardTableTotalsScrollStatus'] = None,
                 total_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
                 totals_visibility: Optional['DashboardVisibility'] = None):
        DashboardTotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            placement=placement,
            scroll_status=scroll_status,
            total_cell_style=total_cell_style,
            totals_visibility=totals_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             placement: Optional['DashboardTableTotalsPlacement'] = None,
             scroll_status: Optional['DashboardTableTotalsScrollStatus'] = None,
             total_cell_style: Optional['outputs.DashboardTableCellStyle'] = None,
             totals_visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if placement is not None:
            _setter("placement", placement)
        if scroll_status is not None:
            _setter("scroll_status", scroll_status)
        if total_cell_style is not None:
            _setter("total_cell_style", total_cell_style)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter
    def placement(self) -> Optional['DashboardTableTotalsPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="scrollStatus")
    def scroll_status(self) -> Optional['DashboardTableTotalsScrollStatus']:
        return pulumi.get(self, "scroll_status")

    @property
    @pulumi.getter(name="totalCellStyle")
    def total_cell_style(self) -> Optional['outputs.DashboardTableCellStyle']:
        return pulumi.get(self, "total_cell_style")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "totals_visibility")


@pulumi.output_type
class DashboardTreeMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 colors: Optional[Sequence['outputs.DashboardMeasureField']] = None,
                 groups: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 sizes: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardTreeMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
            groups=groups,
            sizes=sizes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             groups: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             sizes: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if colors is not None:
            _setter("colors", colors)
        if groups is not None:
            _setter("groups", groups)
        if sizes is not None:
            _setter("sizes", sizes)

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def sizes(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "sizes")


@pulumi.output_type
class DashboardTreeMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "colorScale":
            suggest = "color_scale"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "groupLabelOptions":
            suggest = "group_label_options"
        elif key == "sizeLabelOptions":
            suggest = "size_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTreeMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTreeMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTreeMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 color_scale: Optional['outputs.DashboardColorScale'] = None,
                 data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardTreeMapFieldWells'] = None,
                 group_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 size_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.DashboardTreeMapSortConfiguration'] = None,
                 tooltip: Optional['outputs.DashboardTooltipOptions'] = None):
        DashboardTreeMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_label_options=color_label_options,
            color_scale=color_scale,
            data_labels=data_labels,
            field_wells=field_wells,
            group_label_options=group_label_options,
            legend=legend,
            size_label_options=size_label_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             color_scale: Optional['outputs.DashboardColorScale'] = None,
             data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardTreeMapFieldWells'] = None,
             group_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             size_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.DashboardTreeMapSortConfiguration'] = None,
             tooltip: Optional['outputs.DashboardTooltipOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if color_scale is not None:
            _setter("color_scale", color_scale)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if group_label_options is not None:
            _setter("group_label_options", group_label_options)
        if legend is not None:
            _setter("legend", legend)
        if size_label_options is not None:
            _setter("size_label_options", size_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="colorScale")
    def color_scale(self) -> Optional['outputs.DashboardColorScale']:
        return pulumi.get(self, "color_scale")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardTreeMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="groupLabelOptions")
    def group_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "group_label_options")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="sizeLabelOptions")
    def size_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "size_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardTreeMapSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.DashboardTooltipOptions']:
        return pulumi.get(self, "tooltip")


@pulumi.output_type
class DashboardTreeMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "treeMapAggregatedFieldWells":
            suggest = "tree_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTreeMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTreeMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTreeMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tree_map_aggregated_field_wells: Optional['outputs.DashboardTreeMapAggregatedFieldWells'] = None):
        DashboardTreeMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tree_map_aggregated_field_wells=tree_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tree_map_aggregated_field_wells: Optional['outputs.DashboardTreeMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if tree_map_aggregated_field_wells is not None:
            _setter("tree_map_aggregated_field_wells", tree_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="treeMapAggregatedFieldWells")
    def tree_map_aggregated_field_wells(self) -> Optional['outputs.DashboardTreeMapAggregatedFieldWells']:
        return pulumi.get(self, "tree_map_aggregated_field_wells")


@pulumi.output_type
class DashboardTreeMapSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "treeMapGroupItemsLimitConfiguration":
            suggest = "tree_map_group_items_limit_configuration"
        elif key == "treeMapSort":
            suggest = "tree_map_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTreeMapSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTreeMapSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTreeMapSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tree_map_group_items_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 tree_map_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardTreeMapSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tree_map_group_items_limit_configuration=tree_map_group_items_limit_configuration,
            tree_map_sort=tree_map_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tree_map_group_items_limit_configuration: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             tree_map_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if tree_map_group_items_limit_configuration is not None:
            _setter("tree_map_group_items_limit_configuration", tree_map_group_items_limit_configuration)
        if tree_map_sort is not None:
            _setter("tree_map_sort", tree_map_sort)

    @property
    @pulumi.getter(name="treeMapGroupItemsLimitConfiguration")
    def tree_map_group_items_limit_configuration(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "tree_map_group_items_limit_configuration")

    @property
    @pulumi.getter(name="treeMapSort")
    def tree_map_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "tree_map_sort")


@pulumi.output_type
class DashboardTreeMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTreeMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTreeMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTreeMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardTreeMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardTreeMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardTreeMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardTreeMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardTrendArrowOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardTrendArrowOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardUnaggregatedField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardUnaggregatedField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardUnaggregatedField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardUnaggregatedField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.DashboardColumnIdentifier',
                 field_id: str,
                 format_configuration: Optional['outputs.DashboardFormatConfiguration'] = None):
        DashboardUnaggregatedField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.DashboardColumnIdentifier',
             field_id: str,
             format_configuration: Optional['outputs.DashboardFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.DashboardColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.DashboardFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class DashboardUniqueValuesComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardUniqueValuesComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardUniqueValuesComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardUniqueValuesComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 category: Optional['outputs.DashboardDimensionField'] = None,
                 name: Optional[str] = None):
        DashboardUniqueValuesComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            category=category,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             category: Optional['outputs.DashboardDimensionField'] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if category is not None:
            _setter("category", category)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def category(self) -> Optional['outputs.DashboardDimensionField']:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class DashboardVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdTime":
            suggest = "created_time"
        elif key == "dataSetArns":
            suggest = "data_set_arns"
        elif key == "sourceEntityArn":
            suggest = "source_entity_arn"
        elif key == "themeArn":
            suggest = "theme_arn"
        elif key == "versionNumber":
            suggest = "version_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 created_time: Optional[str] = None,
                 data_set_arns: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 errors: Optional[Sequence['outputs.DashboardError']] = None,
                 sheets: Optional[Sequence['outputs.DashboardSheet']] = None,
                 source_entity_arn: Optional[str] = None,
                 status: Optional['DashboardResourceStatus'] = None,
                 theme_arn: Optional[str] = None,
                 version_number: Optional[float] = None):
        DashboardVersion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            created_time=created_time,
            data_set_arns=data_set_arns,
            description=description,
            errors=errors,
            sheets=sheets,
            source_entity_arn=source_entity_arn,
            status=status,
            theme_arn=theme_arn,
            version_number=version_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             created_time: Optional[str] = None,
             data_set_arns: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             errors: Optional[Sequence['outputs.DashboardError']] = None,
             sheets: Optional[Sequence['outputs.DashboardSheet']] = None,
             source_entity_arn: Optional[str] = None,
             status: Optional['DashboardResourceStatus'] = None,
             theme_arn: Optional[str] = None,
             version_number: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arn is not None:
            _setter("arn", arn)
        if created_time is not None:
            _setter("created_time", created_time)
        if data_set_arns is not None:
            _setter("data_set_arns", data_set_arns)
        if description is not None:
            _setter("description", description)
        if errors is not None:
            _setter("errors", errors)
        if sheets is not None:
            _setter("sheets", sheets)
        if source_entity_arn is not None:
            _setter("source_entity_arn", source_entity_arn)
        if status is not None:
            _setter("status", status)
        if theme_arn is not None:
            _setter("theme_arn", theme_arn)
        if version_number is not None:
            _setter("version_number", version_number)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[str]:
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="dataSetArns")
    def data_set_arns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "data_set_arns")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.DashboardError']]:
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def sheets(self) -> Optional[Sequence['outputs.DashboardSheet']]:
        return pulumi.get(self, "sheets")

    @property
    @pulumi.getter(name="sourceEntityArn")
    def source_entity_arn(self) -> Optional[str]:
        return pulumi.get(self, "source_entity_arn")

    @property
    @pulumi.getter
    def status(self) -> Optional['DashboardResourceStatus']:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="themeArn")
    def theme_arn(self) -> Optional[str]:
        return pulumi.get(self, "theme_arn")

    @property
    @pulumi.getter(name="versionNumber")
    def version_number(self) -> Optional[float]:
        return pulumi.get(self, "version_number")


@pulumi.output_type
class DashboardVersionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifierDeclarations":
            suggest = "data_set_identifier_declarations"
        elif key == "analysisDefaults":
            suggest = "analysis_defaults"
        elif key == "calculatedFields":
            suggest = "calculated_fields"
        elif key == "columnConfigurations":
            suggest = "column_configurations"
        elif key == "filterGroups":
            suggest = "filter_groups"
        elif key == "parameterDeclarations":
            suggest = "parameter_declarations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVersionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVersionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVersionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier_declarations: Sequence['outputs.DashboardDataSetIdentifierDeclaration'],
                 analysis_defaults: Optional['outputs.DashboardAnalysisDefaults'] = None,
                 calculated_fields: Optional[Sequence['outputs.DashboardCalculatedField']] = None,
                 column_configurations: Optional[Sequence['outputs.DashboardColumnConfiguration']] = None,
                 filter_groups: Optional[Sequence['outputs.DashboardFilterGroup']] = None,
                 parameter_declarations: Optional[Sequence['outputs.DashboardParameterDeclaration']] = None,
                 sheets: Optional[Sequence['outputs.DashboardSheetDefinition']] = None):
        DashboardVersionDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier_declarations=data_set_identifier_declarations,
            analysis_defaults=analysis_defaults,
            calculated_fields=calculated_fields,
            column_configurations=column_configurations,
            filter_groups=filter_groups,
            parameter_declarations=parameter_declarations,
            sheets=sheets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier_declarations: Sequence['outputs.DashboardDataSetIdentifierDeclaration'],
             analysis_defaults: Optional['outputs.DashboardAnalysisDefaults'] = None,
             calculated_fields: Optional[Sequence['outputs.DashboardCalculatedField']] = None,
             column_configurations: Optional[Sequence['outputs.DashboardColumnConfiguration']] = None,
             filter_groups: Optional[Sequence['outputs.DashboardFilterGroup']] = None,
             parameter_declarations: Optional[Sequence['outputs.DashboardParameterDeclaration']] = None,
             sheets: Optional[Sequence['outputs.DashboardSheetDefinition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier_declarations", data_set_identifier_declarations)
        if analysis_defaults is not None:
            _setter("analysis_defaults", analysis_defaults)
        if calculated_fields is not None:
            _setter("calculated_fields", calculated_fields)
        if column_configurations is not None:
            _setter("column_configurations", column_configurations)
        if filter_groups is not None:
            _setter("filter_groups", filter_groups)
        if parameter_declarations is not None:
            _setter("parameter_declarations", parameter_declarations)
        if sheets is not None:
            _setter("sheets", sheets)

    @property
    @pulumi.getter(name="dataSetIdentifierDeclarations")
    def data_set_identifier_declarations(self) -> Sequence['outputs.DashboardDataSetIdentifierDeclaration']:
        return pulumi.get(self, "data_set_identifier_declarations")

    @property
    @pulumi.getter(name="analysisDefaults")
    def analysis_defaults(self) -> Optional['outputs.DashboardAnalysisDefaults']:
        return pulumi.get(self, "analysis_defaults")

    @property
    @pulumi.getter(name="calculatedFields")
    def calculated_fields(self) -> Optional[Sequence['outputs.DashboardCalculatedField']]:
        return pulumi.get(self, "calculated_fields")

    @property
    @pulumi.getter(name="columnConfigurations")
    def column_configurations(self) -> Optional[Sequence['outputs.DashboardColumnConfiguration']]:
        return pulumi.get(self, "column_configurations")

    @property
    @pulumi.getter(name="filterGroups")
    def filter_groups(self) -> Optional[Sequence['outputs.DashboardFilterGroup']]:
        return pulumi.get(self, "filter_groups")

    @property
    @pulumi.getter(name="parameterDeclarations")
    def parameter_declarations(self) -> Optional[Sequence['outputs.DashboardParameterDeclaration']]:
        return pulumi.get(self, "parameter_declarations")

    @property
    @pulumi.getter
    def sheets(self) -> Optional[Sequence['outputs.DashboardSheetDefinition']]:
        return pulumi.get(self, "sheets")


@pulumi.output_type
class DashboardVisibleRangeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "percentRange":
            suggest = "percent_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVisibleRangeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVisibleRangeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVisibleRangeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percent_range: Optional['outputs.DashboardPercentVisibleRange'] = None):
        DashboardVisibleRangeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            percent_range=percent_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             percent_range: Optional['outputs.DashboardPercentVisibleRange'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if percent_range is not None:
            _setter("percent_range", percent_range)

    @property
    @pulumi.getter(name="percentRange")
    def percent_range(self) -> Optional['outputs.DashboardPercentVisibleRange']:
        return pulumi.get(self, "percent_range")


@pulumi.output_type
class DashboardVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barChartVisual":
            suggest = "bar_chart_visual"
        elif key == "boxPlotVisual":
            suggest = "box_plot_visual"
        elif key == "comboChartVisual":
            suggest = "combo_chart_visual"
        elif key == "customContentVisual":
            suggest = "custom_content_visual"
        elif key == "emptyVisual":
            suggest = "empty_visual"
        elif key == "filledMapVisual":
            suggest = "filled_map_visual"
        elif key == "funnelChartVisual":
            suggest = "funnel_chart_visual"
        elif key == "gaugeChartVisual":
            suggest = "gauge_chart_visual"
        elif key == "geospatialMapVisual":
            suggest = "geospatial_map_visual"
        elif key == "heatMapVisual":
            suggest = "heat_map_visual"
        elif key == "histogramVisual":
            suggest = "histogram_visual"
        elif key == "insightVisual":
            suggest = "insight_visual"
        elif key == "kpiVisual":
            suggest = "kpi_visual"
        elif key == "lineChartVisual":
            suggest = "line_chart_visual"
        elif key == "pieChartVisual":
            suggest = "pie_chart_visual"
        elif key == "pivotTableVisual":
            suggest = "pivot_table_visual"
        elif key == "radarChartVisual":
            suggest = "radar_chart_visual"
        elif key == "sankeyDiagramVisual":
            suggest = "sankey_diagram_visual"
        elif key == "scatterPlotVisual":
            suggest = "scatter_plot_visual"
        elif key == "tableVisual":
            suggest = "table_visual"
        elif key == "treeMapVisual":
            suggest = "tree_map_visual"
        elif key == "waterfallVisual":
            suggest = "waterfall_visual"
        elif key == "wordCloudVisual":
            suggest = "word_cloud_visual"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_chart_visual: Optional['outputs.DashboardBarChartVisual'] = None,
                 box_plot_visual: Optional['outputs.DashboardBoxPlotVisual'] = None,
                 combo_chart_visual: Optional['outputs.DashboardComboChartVisual'] = None,
                 custom_content_visual: Optional['outputs.DashboardCustomContentVisual'] = None,
                 empty_visual: Optional['outputs.DashboardEmptyVisual'] = None,
                 filled_map_visual: Optional['outputs.DashboardFilledMapVisual'] = None,
                 funnel_chart_visual: Optional['outputs.DashboardFunnelChartVisual'] = None,
                 gauge_chart_visual: Optional['outputs.DashboardGaugeChartVisual'] = None,
                 geospatial_map_visual: Optional['outputs.DashboardGeospatialMapVisual'] = None,
                 heat_map_visual: Optional['outputs.DashboardHeatMapVisual'] = None,
                 histogram_visual: Optional['outputs.DashboardHistogramVisual'] = None,
                 insight_visual: Optional['outputs.DashboardInsightVisual'] = None,
                 kpi_visual: Optional['outputs.DashboardKpiVisual'] = None,
                 line_chart_visual: Optional['outputs.DashboardLineChartVisual'] = None,
                 pie_chart_visual: Optional['outputs.DashboardPieChartVisual'] = None,
                 pivot_table_visual: Optional['outputs.DashboardPivotTableVisual'] = None,
                 radar_chart_visual: Optional['outputs.DashboardRadarChartVisual'] = None,
                 sankey_diagram_visual: Optional['outputs.DashboardSankeyDiagramVisual'] = None,
                 scatter_plot_visual: Optional['outputs.DashboardScatterPlotVisual'] = None,
                 table_visual: Optional['outputs.DashboardTableVisual'] = None,
                 tree_map_visual: Optional['outputs.DashboardTreeMapVisual'] = None,
                 waterfall_visual: Optional['outputs.DashboardWaterfallVisual'] = None,
                 word_cloud_visual: Optional['outputs.DashboardWordCloudVisual'] = None):
        DashboardVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_chart_visual=bar_chart_visual,
            box_plot_visual=box_plot_visual,
            combo_chart_visual=combo_chart_visual,
            custom_content_visual=custom_content_visual,
            empty_visual=empty_visual,
            filled_map_visual=filled_map_visual,
            funnel_chart_visual=funnel_chart_visual,
            gauge_chart_visual=gauge_chart_visual,
            geospatial_map_visual=geospatial_map_visual,
            heat_map_visual=heat_map_visual,
            histogram_visual=histogram_visual,
            insight_visual=insight_visual,
            kpi_visual=kpi_visual,
            line_chart_visual=line_chart_visual,
            pie_chart_visual=pie_chart_visual,
            pivot_table_visual=pivot_table_visual,
            radar_chart_visual=radar_chart_visual,
            sankey_diagram_visual=sankey_diagram_visual,
            scatter_plot_visual=scatter_plot_visual,
            table_visual=table_visual,
            tree_map_visual=tree_map_visual,
            waterfall_visual=waterfall_visual,
            word_cloud_visual=word_cloud_visual,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_chart_visual: Optional['outputs.DashboardBarChartVisual'] = None,
             box_plot_visual: Optional['outputs.DashboardBoxPlotVisual'] = None,
             combo_chart_visual: Optional['outputs.DashboardComboChartVisual'] = None,
             custom_content_visual: Optional['outputs.DashboardCustomContentVisual'] = None,
             empty_visual: Optional['outputs.DashboardEmptyVisual'] = None,
             filled_map_visual: Optional['outputs.DashboardFilledMapVisual'] = None,
             funnel_chart_visual: Optional['outputs.DashboardFunnelChartVisual'] = None,
             gauge_chart_visual: Optional['outputs.DashboardGaugeChartVisual'] = None,
             geospatial_map_visual: Optional['outputs.DashboardGeospatialMapVisual'] = None,
             heat_map_visual: Optional['outputs.DashboardHeatMapVisual'] = None,
             histogram_visual: Optional['outputs.DashboardHistogramVisual'] = None,
             insight_visual: Optional['outputs.DashboardInsightVisual'] = None,
             kpi_visual: Optional['outputs.DashboardKpiVisual'] = None,
             line_chart_visual: Optional['outputs.DashboardLineChartVisual'] = None,
             pie_chart_visual: Optional['outputs.DashboardPieChartVisual'] = None,
             pivot_table_visual: Optional['outputs.DashboardPivotTableVisual'] = None,
             radar_chart_visual: Optional['outputs.DashboardRadarChartVisual'] = None,
             sankey_diagram_visual: Optional['outputs.DashboardSankeyDiagramVisual'] = None,
             scatter_plot_visual: Optional['outputs.DashboardScatterPlotVisual'] = None,
             table_visual: Optional['outputs.DashboardTableVisual'] = None,
             tree_map_visual: Optional['outputs.DashboardTreeMapVisual'] = None,
             waterfall_visual: Optional['outputs.DashboardWaterfallVisual'] = None,
             word_cloud_visual: Optional['outputs.DashboardWordCloudVisual'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_chart_visual is not None:
            _setter("bar_chart_visual", bar_chart_visual)
        if box_plot_visual is not None:
            _setter("box_plot_visual", box_plot_visual)
        if combo_chart_visual is not None:
            _setter("combo_chart_visual", combo_chart_visual)
        if custom_content_visual is not None:
            _setter("custom_content_visual", custom_content_visual)
        if empty_visual is not None:
            _setter("empty_visual", empty_visual)
        if filled_map_visual is not None:
            _setter("filled_map_visual", filled_map_visual)
        if funnel_chart_visual is not None:
            _setter("funnel_chart_visual", funnel_chart_visual)
        if gauge_chart_visual is not None:
            _setter("gauge_chart_visual", gauge_chart_visual)
        if geospatial_map_visual is not None:
            _setter("geospatial_map_visual", geospatial_map_visual)
        if heat_map_visual is not None:
            _setter("heat_map_visual", heat_map_visual)
        if histogram_visual is not None:
            _setter("histogram_visual", histogram_visual)
        if insight_visual is not None:
            _setter("insight_visual", insight_visual)
        if kpi_visual is not None:
            _setter("kpi_visual", kpi_visual)
        if line_chart_visual is not None:
            _setter("line_chart_visual", line_chart_visual)
        if pie_chart_visual is not None:
            _setter("pie_chart_visual", pie_chart_visual)
        if pivot_table_visual is not None:
            _setter("pivot_table_visual", pivot_table_visual)
        if radar_chart_visual is not None:
            _setter("radar_chart_visual", radar_chart_visual)
        if sankey_diagram_visual is not None:
            _setter("sankey_diagram_visual", sankey_diagram_visual)
        if scatter_plot_visual is not None:
            _setter("scatter_plot_visual", scatter_plot_visual)
        if table_visual is not None:
            _setter("table_visual", table_visual)
        if tree_map_visual is not None:
            _setter("tree_map_visual", tree_map_visual)
        if waterfall_visual is not None:
            _setter("waterfall_visual", waterfall_visual)
        if word_cloud_visual is not None:
            _setter("word_cloud_visual", word_cloud_visual)

    @property
    @pulumi.getter(name="barChartVisual")
    def bar_chart_visual(self) -> Optional['outputs.DashboardBarChartVisual']:
        return pulumi.get(self, "bar_chart_visual")

    @property
    @pulumi.getter(name="boxPlotVisual")
    def box_plot_visual(self) -> Optional['outputs.DashboardBoxPlotVisual']:
        return pulumi.get(self, "box_plot_visual")

    @property
    @pulumi.getter(name="comboChartVisual")
    def combo_chart_visual(self) -> Optional['outputs.DashboardComboChartVisual']:
        return pulumi.get(self, "combo_chart_visual")

    @property
    @pulumi.getter(name="customContentVisual")
    def custom_content_visual(self) -> Optional['outputs.DashboardCustomContentVisual']:
        return pulumi.get(self, "custom_content_visual")

    @property
    @pulumi.getter(name="emptyVisual")
    def empty_visual(self) -> Optional['outputs.DashboardEmptyVisual']:
        return pulumi.get(self, "empty_visual")

    @property
    @pulumi.getter(name="filledMapVisual")
    def filled_map_visual(self) -> Optional['outputs.DashboardFilledMapVisual']:
        return pulumi.get(self, "filled_map_visual")

    @property
    @pulumi.getter(name="funnelChartVisual")
    def funnel_chart_visual(self) -> Optional['outputs.DashboardFunnelChartVisual']:
        return pulumi.get(self, "funnel_chart_visual")

    @property
    @pulumi.getter(name="gaugeChartVisual")
    def gauge_chart_visual(self) -> Optional['outputs.DashboardGaugeChartVisual']:
        return pulumi.get(self, "gauge_chart_visual")

    @property
    @pulumi.getter(name="geospatialMapVisual")
    def geospatial_map_visual(self) -> Optional['outputs.DashboardGeospatialMapVisual']:
        return pulumi.get(self, "geospatial_map_visual")

    @property
    @pulumi.getter(name="heatMapVisual")
    def heat_map_visual(self) -> Optional['outputs.DashboardHeatMapVisual']:
        return pulumi.get(self, "heat_map_visual")

    @property
    @pulumi.getter(name="histogramVisual")
    def histogram_visual(self) -> Optional['outputs.DashboardHistogramVisual']:
        return pulumi.get(self, "histogram_visual")

    @property
    @pulumi.getter(name="insightVisual")
    def insight_visual(self) -> Optional['outputs.DashboardInsightVisual']:
        return pulumi.get(self, "insight_visual")

    @property
    @pulumi.getter(name="kpiVisual")
    def kpi_visual(self) -> Optional['outputs.DashboardKpiVisual']:
        return pulumi.get(self, "kpi_visual")

    @property
    @pulumi.getter(name="lineChartVisual")
    def line_chart_visual(self) -> Optional['outputs.DashboardLineChartVisual']:
        return pulumi.get(self, "line_chart_visual")

    @property
    @pulumi.getter(name="pieChartVisual")
    def pie_chart_visual(self) -> Optional['outputs.DashboardPieChartVisual']:
        return pulumi.get(self, "pie_chart_visual")

    @property
    @pulumi.getter(name="pivotTableVisual")
    def pivot_table_visual(self) -> Optional['outputs.DashboardPivotTableVisual']:
        return pulumi.get(self, "pivot_table_visual")

    @property
    @pulumi.getter(name="radarChartVisual")
    def radar_chart_visual(self) -> Optional['outputs.DashboardRadarChartVisual']:
        return pulumi.get(self, "radar_chart_visual")

    @property
    @pulumi.getter(name="sankeyDiagramVisual")
    def sankey_diagram_visual(self) -> Optional['outputs.DashboardSankeyDiagramVisual']:
        return pulumi.get(self, "sankey_diagram_visual")

    @property
    @pulumi.getter(name="scatterPlotVisual")
    def scatter_plot_visual(self) -> Optional['outputs.DashboardScatterPlotVisual']:
        return pulumi.get(self, "scatter_plot_visual")

    @property
    @pulumi.getter(name="tableVisual")
    def table_visual(self) -> Optional['outputs.DashboardTableVisual']:
        return pulumi.get(self, "table_visual")

    @property
    @pulumi.getter(name="treeMapVisual")
    def tree_map_visual(self) -> Optional['outputs.DashboardTreeMapVisual']:
        return pulumi.get(self, "tree_map_visual")

    @property
    @pulumi.getter(name="waterfallVisual")
    def waterfall_visual(self) -> Optional['outputs.DashboardWaterfallVisual']:
        return pulumi.get(self, "waterfall_visual")

    @property
    @pulumi.getter(name="wordCloudVisual")
    def word_cloud_visual(self) -> Optional['outputs.DashboardWordCloudVisual']:
        return pulumi.get(self, "word_cloud_visual")


@pulumi.output_type
class DashboardVisualAxisSortOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVisualAxisSortOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVisualAxisSortOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVisualAxisSortOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional['DashboardBehavior'] = None):
        DashboardVisualAxisSortOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional['DashboardBehavior'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional['DashboardBehavior']:
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardVisualCustomAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionOperations":
            suggest = "action_operations"
        elif key == "customActionId":
            suggest = "custom_action_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVisualCustomAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVisualCustomAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVisualCustomAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_operations: Sequence['outputs.DashboardVisualCustomActionOperation'],
                 custom_action_id: str,
                 name: str,
                 trigger: 'DashboardVisualCustomActionTrigger',
                 status: Optional['DashboardWidgetStatus'] = None):
        DashboardVisualCustomAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_operations=action_operations,
            custom_action_id=custom_action_id,
            name=name,
            trigger=trigger,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_operations: Sequence['outputs.DashboardVisualCustomActionOperation'],
             custom_action_id: str,
             name: str,
             trigger: 'DashboardVisualCustomActionTrigger',
             status: Optional['DashboardWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action_operations", action_operations)
        _setter("custom_action_id", custom_action_id)
        _setter("name", name)
        _setter("trigger", trigger)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="actionOperations")
    def action_operations(self) -> Sequence['outputs.DashboardVisualCustomActionOperation']:
        return pulumi.get(self, "action_operations")

    @property
    @pulumi.getter(name="customActionId")
    def custom_action_id(self) -> str:
        return pulumi.get(self, "custom_action_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def trigger(self) -> 'DashboardVisualCustomActionTrigger':
        return pulumi.get(self, "trigger")

    @property
    @pulumi.getter
    def status(self) -> Optional['DashboardWidgetStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class DashboardVisualCustomActionOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterOperation":
            suggest = "filter_operation"
        elif key == "navigationOperation":
            suggest = "navigation_operation"
        elif key == "setParametersOperation":
            suggest = "set_parameters_operation"
        elif key == "urlOperation":
            suggest = "url_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVisualCustomActionOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVisualCustomActionOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVisualCustomActionOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_operation: Optional['outputs.DashboardCustomActionFilterOperation'] = None,
                 navigation_operation: Optional['outputs.DashboardCustomActionNavigationOperation'] = None,
                 set_parameters_operation: Optional['outputs.DashboardCustomActionSetParametersOperation'] = None,
                 url_operation: Optional['outputs.DashboardCustomActionUrlOperation'] = None):
        DashboardVisualCustomActionOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_operation=filter_operation,
            navigation_operation=navigation_operation,
            set_parameters_operation=set_parameters_operation,
            url_operation=url_operation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_operation: Optional['outputs.DashboardCustomActionFilterOperation'] = None,
             navigation_operation: Optional['outputs.DashboardCustomActionNavigationOperation'] = None,
             set_parameters_operation: Optional['outputs.DashboardCustomActionSetParametersOperation'] = None,
             url_operation: Optional['outputs.DashboardCustomActionUrlOperation'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if filter_operation is not None:
            _setter("filter_operation", filter_operation)
        if navigation_operation is not None:
            _setter("navigation_operation", navigation_operation)
        if set_parameters_operation is not None:
            _setter("set_parameters_operation", set_parameters_operation)
        if url_operation is not None:
            _setter("url_operation", url_operation)

    @property
    @pulumi.getter(name="filterOperation")
    def filter_operation(self) -> Optional['outputs.DashboardCustomActionFilterOperation']:
        return pulumi.get(self, "filter_operation")

    @property
    @pulumi.getter(name="navigationOperation")
    def navigation_operation(self) -> Optional['outputs.DashboardCustomActionNavigationOperation']:
        return pulumi.get(self, "navigation_operation")

    @property
    @pulumi.getter(name="setParametersOperation")
    def set_parameters_operation(self) -> Optional['outputs.DashboardCustomActionSetParametersOperation']:
        return pulumi.get(self, "set_parameters_operation")

    @property
    @pulumi.getter(name="urlOperation")
    def url_operation(self) -> Optional['outputs.DashboardCustomActionUrlOperation']:
        return pulumi.get(self, "url_operation")


@pulumi.output_type
class DashboardVisualMenuOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVisualMenuOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVisualMenuOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVisualMenuOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional['DashboardBehavior'] = None):
        DashboardVisualMenuOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional['DashboardBehavior'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional['DashboardBehavior']:
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardVisualPalette(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chartColor":
            suggest = "chart_color"
        elif key == "colorMap":
            suggest = "color_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVisualPalette. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVisualPalette.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVisualPalette.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chart_color: Optional[str] = None,
                 color_map: Optional[Sequence['outputs.DashboardDataPathColor']] = None):
        DashboardVisualPalette._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            chart_color=chart_color,
            color_map=color_map,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             chart_color: Optional[str] = None,
             color_map: Optional[Sequence['outputs.DashboardDataPathColor']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if chart_color is not None:
            _setter("chart_color", chart_color)
        if color_map is not None:
            _setter("color_map", color_map)

    @property
    @pulumi.getter(name="chartColor")
    def chart_color(self) -> Optional[str]:
        return pulumi.get(self, "chart_color")

    @property
    @pulumi.getter(name="colorMap")
    def color_map(self) -> Optional[Sequence['outputs.DashboardDataPathColor']]:
        return pulumi.get(self, "color_map")


@pulumi.output_type
class DashboardVisualPublishOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportHiddenFieldsOption":
            suggest = "export_hidden_fields_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVisualPublishOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVisualPublishOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVisualPublishOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_hidden_fields_option: Optional['outputs.DashboardExportHiddenFieldsOption'] = None):
        DashboardVisualPublishOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_hidden_fields_option=export_hidden_fields_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_hidden_fields_option: Optional['outputs.DashboardExportHiddenFieldsOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if export_hidden_fields_option is not None:
            _setter("export_hidden_fields_option", export_hidden_fields_option)

    @property
    @pulumi.getter(name="exportHiddenFieldsOption")
    def export_hidden_fields_option(self) -> Optional['outputs.DashboardExportHiddenFieldsOption']:
        return pulumi.get(self, "export_hidden_fields_option")


@pulumi.output_type
class DashboardVisualSubtitleLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatText":
            suggest = "format_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVisualSubtitleLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVisualSubtitleLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVisualSubtitleLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_text: Optional['outputs.DashboardLongFormatText'] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardVisualSubtitleLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_text=format_text,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_text: Optional['outputs.DashboardLongFormatText'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_text is not None:
            _setter("format_text", format_text)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="formatText")
    def format_text(self) -> Optional['outputs.DashboardLongFormatText']:
        return pulumi.get(self, "format_text")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardVisualTitleLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatText":
            suggest = "format_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVisualTitleLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVisualTitleLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVisualTitleLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_text: Optional['outputs.DashboardShortFormatText'] = None,
                 visibility: Optional['DashboardVisibility'] = None):
        DashboardVisualTitleLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_text=format_text,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_text: Optional['outputs.DashboardShortFormatText'] = None,
             visibility: Optional['DashboardVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_text is not None:
            _setter("format_text", format_text)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="formatText")
    def format_text(self) -> Optional['outputs.DashboardShortFormatText']:
        return pulumi.get(self, "format_text")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['DashboardVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardWaterfallChartAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 breakdowns: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 categories: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 values: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardWaterfallChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            breakdowns=breakdowns,
            categories=categories,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             breakdowns: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             categories: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             values: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if breakdowns is not None:
            _setter("breakdowns", breakdowns)
        if categories is not None:
            _setter("categories", categories)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def breakdowns(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "breakdowns")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardWaterfallChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryAxisDisplayOptions":
            suggest = "category_axis_display_options"
        elif key == "categoryAxisLabelOptions":
            suggest = "category_axis_label_options"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "waterfallChartOptions":
            suggest = "waterfall_chart_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWaterfallChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWaterfallChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWaterfallChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 category_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardWaterfallChartFieldWells'] = None,
                 legend: Optional['outputs.DashboardLegendOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.DashboardWaterfallChartSortConfiguration'] = None,
                 visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
                 waterfall_chart_options: Optional['outputs.DashboardWaterfallChartOptions'] = None):
        DashboardWaterfallChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_axis_display_options=category_axis_display_options,
            category_axis_label_options=category_axis_label_options,
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            sort_configuration=sort_configuration,
            visual_palette=visual_palette,
            waterfall_chart_options=waterfall_chart_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             category_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             data_labels: Optional['outputs.DashboardDataLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardWaterfallChartFieldWells'] = None,
             legend: Optional['outputs.DashboardLegendOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.DashboardAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.DashboardWaterfallChartSortConfiguration'] = None,
             visual_palette: Optional['outputs.DashboardVisualPalette'] = None,
             waterfall_chart_options: Optional['outputs.DashboardWaterfallChartOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_axis_display_options is not None:
            _setter("category_axis_display_options", category_axis_display_options)
        if category_axis_label_options is not None:
            _setter("category_axis_label_options", category_axis_label_options)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if waterfall_chart_options is not None:
            _setter("waterfall_chart_options", waterfall_chart_options)

    @property
    @pulumi.getter(name="categoryAxisDisplayOptions")
    def category_axis_display_options(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "category_axis_display_options")

    @property
    @pulumi.getter(name="categoryAxisLabelOptions")
    def category_axis_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "category_axis_label_options")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.DashboardDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardWaterfallChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.DashboardAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardWaterfallChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.DashboardVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="waterfallChartOptions")
    def waterfall_chart_options(self) -> Optional['outputs.DashboardWaterfallChartOptions']:
        return pulumi.get(self, "waterfall_chart_options")


@pulumi.output_type
class DashboardWaterfallChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waterfallChartAggregatedFieldWells":
            suggest = "waterfall_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWaterfallChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWaterfallChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWaterfallChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 waterfall_chart_aggregated_field_wells: Optional['outputs.DashboardWaterfallChartAggregatedFieldWells'] = None):
        DashboardWaterfallChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            waterfall_chart_aggregated_field_wells=waterfall_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             waterfall_chart_aggregated_field_wells: Optional['outputs.DashboardWaterfallChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if waterfall_chart_aggregated_field_wells is not None:
            _setter("waterfall_chart_aggregated_field_wells", waterfall_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="waterfallChartAggregatedFieldWells")
    def waterfall_chart_aggregated_field_wells(self) -> Optional['outputs.DashboardWaterfallChartAggregatedFieldWells']:
        return pulumi.get(self, "waterfall_chart_aggregated_field_wells")


@pulumi.output_type
class DashboardWaterfallChartOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalBarLabel":
            suggest = "total_bar_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWaterfallChartOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWaterfallChartOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWaterfallChartOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_bar_label: Optional[str] = None):
        DashboardWaterfallChartOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            total_bar_label=total_bar_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             total_bar_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if total_bar_label is not None:
            _setter("total_bar_label", total_bar_label)

    @property
    @pulumi.getter(name="totalBarLabel")
    def total_bar_label(self) -> Optional[str]:
        return pulumi.get(self, "total_bar_label")


@pulumi.output_type
class DashboardWaterfallChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "breakdownItemsLimit":
            suggest = "breakdown_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWaterfallChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWaterfallChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWaterfallChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 breakdown_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardWaterfallChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            breakdown_items_limit=breakdown_items_limit,
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             breakdown_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if breakdown_items_limit is not None:
            _setter("breakdown_items_limit", breakdown_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="breakdownItemsLimit")
    def breakdown_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "breakdown_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class DashboardWaterfallVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWaterfallVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWaterfallVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWaterfallVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardWaterfallChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardWaterfallVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardWaterfallChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardWaterfallChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardWhatIfPointScenario(dict):
    def __init__(__self__, *,
                 date: str,
                 value: float):
        DashboardWhatIfPointScenario._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date=date,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date: str,
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("date", date)
        _setter("value", value)

    @property
    @pulumi.getter
    def date(self) -> str:
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardWhatIfRangeScenario(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWhatIfRangeScenario. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWhatIfRangeScenario.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWhatIfRangeScenario.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str,
                 value: float):
        DashboardWhatIfRangeScenario._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_date=end_date,
            start_date=start_date,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_date: str,
             start_date: str,
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_date", end_date)
        _setter("start_date", start_date)
        _setter("value", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardWordCloudAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWordCloudAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWordCloudAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWordCloudAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_by: Optional[Sequence['outputs.DashboardDimensionField']] = None,
                 size: Optional[Sequence['outputs.DashboardMeasureField']] = None):
        DashboardWordCloudAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_by=group_by,
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_by: Optional[Sequence['outputs.DashboardDimensionField']] = None,
             size: Optional[Sequence['outputs.DashboardMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_by is not None:
            _setter("group_by", group_by)
        if size is not None:
            _setter("size", size)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[Sequence['outputs.DashboardDimensionField']]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def size(self) -> Optional[Sequence['outputs.DashboardMeasureField']]:
        return pulumi.get(self, "size")


@pulumi.output_type
class DashboardWordCloudChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "wordCloudOptions":
            suggest = "word_cloud_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWordCloudChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWordCloudChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWordCloudChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.DashboardWordCloudFieldWells'] = None,
                 sort_configuration: Optional['outputs.DashboardWordCloudSortConfiguration'] = None,
                 word_cloud_options: Optional['outputs.DashboardWordCloudOptions'] = None):
        DashboardWordCloudChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_options=category_label_options,
            field_wells=field_wells,
            sort_configuration=sort_configuration,
            word_cloud_options=word_cloud_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_options: Optional['outputs.DashboardChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.DashboardWordCloudFieldWells'] = None,
             sort_configuration: Optional['outputs.DashboardWordCloudSortConfiguration'] = None,
             word_cloud_options: Optional['outputs.DashboardWordCloudOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if word_cloud_options is not None:
            _setter("word_cloud_options", word_cloud_options)

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.DashboardChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.DashboardWordCloudFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.DashboardWordCloudSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="wordCloudOptions")
    def word_cloud_options(self) -> Optional['outputs.DashboardWordCloudOptions']:
        return pulumi.get(self, "word_cloud_options")


@pulumi.output_type
class DashboardWordCloudFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wordCloudAggregatedFieldWells":
            suggest = "word_cloud_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWordCloudFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWordCloudFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWordCloudFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 word_cloud_aggregated_field_wells: Optional['outputs.DashboardWordCloudAggregatedFieldWells'] = None):
        DashboardWordCloudFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            word_cloud_aggregated_field_wells=word_cloud_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             word_cloud_aggregated_field_wells: Optional['outputs.DashboardWordCloudAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if word_cloud_aggregated_field_wells is not None:
            _setter("word_cloud_aggregated_field_wells", word_cloud_aggregated_field_wells)

    @property
    @pulumi.getter(name="wordCloudAggregatedFieldWells")
    def word_cloud_aggregated_field_wells(self) -> Optional['outputs.DashboardWordCloudAggregatedFieldWells']:
        return pulumi.get(self, "word_cloud_aggregated_field_wells")


@pulumi.output_type
class DashboardWordCloudOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudLayout":
            suggest = "cloud_layout"
        elif key == "maximumStringLength":
            suggest = "maximum_string_length"
        elif key == "wordCasing":
            suggest = "word_casing"
        elif key == "wordOrientation":
            suggest = "word_orientation"
        elif key == "wordPadding":
            suggest = "word_padding"
        elif key == "wordScaling":
            suggest = "word_scaling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWordCloudOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWordCloudOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWordCloudOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_layout: Optional['DashboardWordCloudCloudLayout'] = None,
                 maximum_string_length: Optional[float] = None,
                 word_casing: Optional['DashboardWordCloudWordCasing'] = None,
                 word_orientation: Optional['DashboardWordCloudWordOrientation'] = None,
                 word_padding: Optional['DashboardWordCloudWordPadding'] = None,
                 word_scaling: Optional['DashboardWordCloudWordScaling'] = None):
        DashboardWordCloudOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_layout=cloud_layout,
            maximum_string_length=maximum_string_length,
            word_casing=word_casing,
            word_orientation=word_orientation,
            word_padding=word_padding,
            word_scaling=word_scaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_layout: Optional['DashboardWordCloudCloudLayout'] = None,
             maximum_string_length: Optional[float] = None,
             word_casing: Optional['DashboardWordCloudWordCasing'] = None,
             word_orientation: Optional['DashboardWordCloudWordOrientation'] = None,
             word_padding: Optional['DashboardWordCloudWordPadding'] = None,
             word_scaling: Optional['DashboardWordCloudWordScaling'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cloud_layout is not None:
            _setter("cloud_layout", cloud_layout)
        if maximum_string_length is not None:
            _setter("maximum_string_length", maximum_string_length)
        if word_casing is not None:
            _setter("word_casing", word_casing)
        if word_orientation is not None:
            _setter("word_orientation", word_orientation)
        if word_padding is not None:
            _setter("word_padding", word_padding)
        if word_scaling is not None:
            _setter("word_scaling", word_scaling)

    @property
    @pulumi.getter(name="cloudLayout")
    def cloud_layout(self) -> Optional['DashboardWordCloudCloudLayout']:
        return pulumi.get(self, "cloud_layout")

    @property
    @pulumi.getter(name="maximumStringLength")
    def maximum_string_length(self) -> Optional[float]:
        return pulumi.get(self, "maximum_string_length")

    @property
    @pulumi.getter(name="wordCasing")
    def word_casing(self) -> Optional['DashboardWordCloudWordCasing']:
        return pulumi.get(self, "word_casing")

    @property
    @pulumi.getter(name="wordOrientation")
    def word_orientation(self) -> Optional['DashboardWordCloudWordOrientation']:
        return pulumi.get(self, "word_orientation")

    @property
    @pulumi.getter(name="wordPadding")
    def word_padding(self) -> Optional['DashboardWordCloudWordPadding']:
        return pulumi.get(self, "word_padding")

    @property
    @pulumi.getter(name="wordScaling")
    def word_scaling(self) -> Optional['DashboardWordCloudWordScaling']:
        return pulumi.get(self, "word_scaling")


@pulumi.output_type
class DashboardWordCloudSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWordCloudSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWordCloudSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWordCloudSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None):
        DashboardWordCloudSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.DashboardItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.DashboardFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.DashboardItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.DashboardFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class DashboardWordCloudVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWordCloudVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWordCloudVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWordCloudVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.DashboardWordCloudChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
                 subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None):
        DashboardWordCloudVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.DashboardVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.DashboardWordCloudChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.DashboardColumnHierarchy']] = None,
             subtitle: Optional['outputs.DashboardVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.DashboardVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.DashboardVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.DashboardWordCloudChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.DashboardColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.DashboardVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.DashboardVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class DataSetColumnGroup(dict):
    """
    <p>Groupings of columns that work together in certain Amazon QuickSight features. This is
                a variant type structure. For this structure to be valid, only one of the attributes can
                be non-null.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoSpatialColumnGroup":
            suggest = "geo_spatial_column_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetColumnGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetColumnGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetColumnGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_spatial_column_group: Optional['outputs.DataSetGeoSpatialColumnGroup'] = None):
        """
        <p>Groupings of columns that work together in certain Amazon QuickSight features. This is
                    a variant type structure. For this structure to be valid, only one of the attributes can
                    be non-null.</p>
        """
        DataSetColumnGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            geo_spatial_column_group=geo_spatial_column_group,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             geo_spatial_column_group: Optional['outputs.DataSetGeoSpatialColumnGroup'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if geo_spatial_column_group is not None:
            _setter("geo_spatial_column_group", geo_spatial_column_group)

    @property
    @pulumi.getter(name="geoSpatialColumnGroup")
    def geo_spatial_column_group(self) -> Optional['outputs.DataSetGeoSpatialColumnGroup']:
        return pulumi.get(self, "geo_spatial_column_group")


@pulumi.output_type
class DataSetColumnLevelPermissionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetColumnLevelPermissionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetColumnLevelPermissionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetColumnLevelPermissionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Optional[Sequence[str]] = None,
                 principals: Optional[Sequence[str]] = None):
        DataSetColumnLevelPermissionRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_names=column_names,
            principals=principals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_names: Optional[Sequence[str]] = None,
             principals: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_names is not None:
            _setter("column_names", column_names)
        if principals is not None:
            _setter("principals", principals)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "column_names")

    @property
    @pulumi.getter
    def principals(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "principals")


@pulumi.output_type
class DataSetDatasetParameter(dict):
    """
    <p>A parameter created in the dataset that could be of any one data type such as string, integer, decimal or datetime.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeDatasetParameter":
            suggest = "date_time_dataset_parameter"
        elif key == "decimalDatasetParameter":
            suggest = "decimal_dataset_parameter"
        elif key == "integerDatasetParameter":
            suggest = "integer_dataset_parameter"
        elif key == "stringDatasetParameter":
            suggest = "string_dataset_parameter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetDatasetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetDatasetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetDatasetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_dataset_parameter: Optional['outputs.DataSetDateTimeDatasetParameter'] = None,
                 decimal_dataset_parameter: Optional['outputs.DataSetDecimalDatasetParameter'] = None,
                 integer_dataset_parameter: Optional['outputs.DataSetIntegerDatasetParameter'] = None,
                 string_dataset_parameter: Optional['outputs.DataSetStringDatasetParameter'] = None):
        """
        <p>A parameter created in the dataset that could be of any one data type such as string, integer, decimal or datetime.</p>
        """
        DataSetDatasetParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_dataset_parameter=date_time_dataset_parameter,
            decimal_dataset_parameter=decimal_dataset_parameter,
            integer_dataset_parameter=integer_dataset_parameter,
            string_dataset_parameter=string_dataset_parameter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_dataset_parameter: Optional['outputs.DataSetDateTimeDatasetParameter'] = None,
             decimal_dataset_parameter: Optional['outputs.DataSetDecimalDatasetParameter'] = None,
             integer_dataset_parameter: Optional['outputs.DataSetIntegerDatasetParameter'] = None,
             string_dataset_parameter: Optional['outputs.DataSetStringDatasetParameter'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_dataset_parameter is not None:
            _setter("date_time_dataset_parameter", date_time_dataset_parameter)
        if decimal_dataset_parameter is not None:
            _setter("decimal_dataset_parameter", decimal_dataset_parameter)
        if integer_dataset_parameter is not None:
            _setter("integer_dataset_parameter", integer_dataset_parameter)
        if string_dataset_parameter is not None:
            _setter("string_dataset_parameter", string_dataset_parameter)

    @property
    @pulumi.getter(name="dateTimeDatasetParameter")
    def date_time_dataset_parameter(self) -> Optional['outputs.DataSetDateTimeDatasetParameter']:
        return pulumi.get(self, "date_time_dataset_parameter")

    @property
    @pulumi.getter(name="decimalDatasetParameter")
    def decimal_dataset_parameter(self) -> Optional['outputs.DataSetDecimalDatasetParameter']:
        return pulumi.get(self, "decimal_dataset_parameter")

    @property
    @pulumi.getter(name="integerDatasetParameter")
    def integer_dataset_parameter(self) -> Optional['outputs.DataSetIntegerDatasetParameter']:
        return pulumi.get(self, "integer_dataset_parameter")

    @property
    @pulumi.getter(name="stringDatasetParameter")
    def string_dataset_parameter(self) -> Optional['outputs.DataSetStringDatasetParameter']:
        return pulumi.get(self, "string_dataset_parameter")


@pulumi.output_type
class DataSetDateTimeDatasetParameter(dict):
    """
    <p>A parameter created in the dataset of date time data type.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"
        elif key == "defaultValues":
            suggest = "default_values"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetDateTimeDatasetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetDateTimeDatasetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetDateTimeDatasetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 value_type: 'DataSetDatasetParameterValueType',
                 default_values: Optional['outputs.DataSetDateTimeDatasetParameterDefaultValues'] = None,
                 time_granularity: Optional['DataSetTimeGranularity'] = None):
        """
        <p>A parameter created in the dataset of date time data type.</p>
        """
        DataSetDateTimeDatasetParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            value_type=value_type,
            default_values=default_values,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: str,
             value_type: 'DataSetDatasetParameterValueType',
             default_values: Optional['outputs.DataSetDateTimeDatasetParameterDefaultValues'] = None,
             time_granularity: Optional['DataSetTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("name", name)
        _setter("value_type", value_type)
        if default_values is not None:
            _setter("default_values", default_values)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> 'DataSetDatasetParameterValueType':
        return pulumi.get(self, "value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.DataSetDateTimeDatasetParameterDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['DataSetTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class DataSetDateTimeDatasetParameterDefaultValues(dict):
    """
    <p>List of default values defined for a given string date time parameter type. Currently only static values are supported.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetDateTimeDatasetParameterDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetDateTimeDatasetParameterDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetDateTimeDatasetParameterDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 static_values: Optional[Sequence[str]] = None):
        """
        <p>List of default values defined for a given string date time parameter type. Currently only static values are supported.</p>
        :param Sequence[str] static_values: <p>List of static default values defined for a given string date time parameter type.</p>
        """
        DataSetDateTimeDatasetParameterDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             static_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[str]]:
        """
        <p>List of static default values defined for a given string date time parameter type.</p>
        """
        return pulumi.get(self, "static_values")


@pulumi.output_type
class DataSetDecimalDatasetParameter(dict):
    """
    <p>A parameter created in the dataset of decimal data type.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"
        elif key == "defaultValues":
            suggest = "default_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetDecimalDatasetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetDecimalDatasetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetDecimalDatasetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 value_type: 'DataSetDatasetParameterValueType',
                 default_values: Optional['outputs.DataSetDecimalDatasetParameterDefaultValues'] = None):
        """
        <p>A parameter created in the dataset of decimal data type.</p>
        """
        DataSetDecimalDatasetParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            value_type=value_type,
            default_values=default_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: str,
             value_type: 'DataSetDatasetParameterValueType',
             default_values: Optional['outputs.DataSetDecimalDatasetParameterDefaultValues'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("name", name)
        _setter("value_type", value_type)
        if default_values is not None:
            _setter("default_values", default_values)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> 'DataSetDatasetParameterValueType':
        return pulumi.get(self, "value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.DataSetDecimalDatasetParameterDefaultValues']:
        return pulumi.get(self, "default_values")


@pulumi.output_type
class DataSetDecimalDatasetParameterDefaultValues(dict):
    """
    <p>List of default values defined for a given decimal dataset parameter type. Currently only static values are supported.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetDecimalDatasetParameterDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetDecimalDatasetParameterDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetDecimalDatasetParameterDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 static_values: Optional[Sequence[float]] = None):
        """
        <p>List of default values defined for a given decimal dataset parameter type. Currently only static values are supported.</p>
        :param Sequence[float] static_values: <p>List of static default values defined for a given decimal dataset parameter type.</p>
        """
        DataSetDecimalDatasetParameterDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             static_values: Optional[Sequence[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[float]]:
        """
        <p>List of static default values defined for a given decimal dataset parameter type.</p>
        """
        return pulumi.get(self, "static_values")


@pulumi.output_type
class DataSetFieldFolderMap(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class DataSetGeoSpatialColumnGroup(dict):
    """
    <p>Geospatial column group that denotes a hierarchy.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetGeoSpatialColumnGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetGeoSpatialColumnGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetGeoSpatialColumnGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence[str],
                 name: str,
                 country_code: Optional['DataSetGeoSpatialCountryCode'] = None):
        """
        <p>Geospatial column group that denotes a hierarchy.</p>
        :param Sequence[str] columns: <p>Columns in this hierarchy.</p>
        :param str name: <p>A display name for the hierarchy.</p>
        """
        DataSetGeoSpatialColumnGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            name=name,
            country_code=country_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Sequence[str],
             name: str,
             country_code: Optional['DataSetGeoSpatialCountryCode'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("columns", columns)
        _setter("name", name)
        if country_code is not None:
            _setter("country_code", country_code)

    @property
    @pulumi.getter
    def columns(self) -> Sequence[str]:
        """
        <p>Columns in this hierarchy.</p>
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        <p>A display name for the hierarchy.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional['DataSetGeoSpatialCountryCode']:
        return pulumi.get(self, "country_code")


@pulumi.output_type
class DataSetIncrementalRefresh(dict):
    """
    <p>Incremental Refresh</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookbackWindow":
            suggest = "lookback_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetIncrementalRefresh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetIncrementalRefresh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetIncrementalRefresh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookback_window: Optional['outputs.DataSetLookbackWindow'] = None):
        """
        <p>Incremental Refresh</p>
        """
        DataSetIncrementalRefresh._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lookback_window=lookback_window,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lookback_window: Optional['outputs.DataSetLookbackWindow'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if lookback_window is not None:
            _setter("lookback_window", lookback_window)

    @property
    @pulumi.getter(name="lookbackWindow")
    def lookback_window(self) -> Optional['outputs.DataSetLookbackWindow']:
        return pulumi.get(self, "lookback_window")


@pulumi.output_type
class DataSetIngestionWaitPolicy(dict):
    """
    <p>Wait policy to use when creating/updating dataset. Default is to wait for SPICE ingestion to finish with timeout of 36 hours.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ingestionWaitTimeInHours":
            suggest = "ingestion_wait_time_in_hours"
        elif key == "waitForSpiceIngestion":
            suggest = "wait_for_spice_ingestion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetIngestionWaitPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetIngestionWaitPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetIngestionWaitPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ingestion_wait_time_in_hours: Optional[float] = None,
                 wait_for_spice_ingestion: Optional[bool] = None):
        """
        <p>Wait policy to use when creating/updating dataset. Default is to wait for SPICE ingestion to finish with timeout of 36 hours.</p>
        :param float ingestion_wait_time_in_hours: <p>The maximum time (in hours) to wait for Ingestion to complete. Default timeout is 36 hours.
                Applicable only when DataSetImportMode mode is set to SPICE and WaitForSpiceIngestion is set to true.</p>
        :param bool wait_for_spice_ingestion: <p>Wait for SPICE ingestion to finish to mark dataset creation/update successful. Default (true).
                 Applicable only when DataSetImportMode mode is set to SPICE.</p>
        """
        DataSetIngestionWaitPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ingestion_wait_time_in_hours=ingestion_wait_time_in_hours,
            wait_for_spice_ingestion=wait_for_spice_ingestion,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ingestion_wait_time_in_hours: Optional[float] = None,
             wait_for_spice_ingestion: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ingestion_wait_time_in_hours is not None:
            _setter("ingestion_wait_time_in_hours", ingestion_wait_time_in_hours)
        if wait_for_spice_ingestion is not None:
            _setter("wait_for_spice_ingestion", wait_for_spice_ingestion)

    @property
    @pulumi.getter(name="ingestionWaitTimeInHours")
    def ingestion_wait_time_in_hours(self) -> Optional[float]:
        """
        <p>The maximum time (in hours) to wait for Ingestion to complete. Default timeout is 36 hours.
         Applicable only when DataSetImportMode mode is set to SPICE and WaitForSpiceIngestion is set to true.</p>
        """
        return pulumi.get(self, "ingestion_wait_time_in_hours")

    @property
    @pulumi.getter(name="waitForSpiceIngestion")
    def wait_for_spice_ingestion(self) -> Optional[bool]:
        """
        <p>Wait for SPICE ingestion to finish to mark dataset creation/update successful. Default (true).
          Applicable only when DataSetImportMode mode is set to SPICE.</p>
        """
        return pulumi.get(self, "wait_for_spice_ingestion")


@pulumi.output_type
class DataSetIntegerDatasetParameter(dict):
    """
    <p>A parameter created in the dataset of integer data type.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"
        elif key == "defaultValues":
            suggest = "default_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetIntegerDatasetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetIntegerDatasetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetIntegerDatasetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 value_type: 'DataSetDatasetParameterValueType',
                 default_values: Optional['outputs.DataSetIntegerDatasetParameterDefaultValues'] = None):
        """
        <p>A parameter created in the dataset of integer data type.</p>
        """
        DataSetIntegerDatasetParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            value_type=value_type,
            default_values=default_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: str,
             value_type: 'DataSetDatasetParameterValueType',
             default_values: Optional['outputs.DataSetIntegerDatasetParameterDefaultValues'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("name", name)
        _setter("value_type", value_type)
        if default_values is not None:
            _setter("default_values", default_values)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> 'DataSetDatasetParameterValueType':
        return pulumi.get(self, "value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.DataSetIntegerDatasetParameterDefaultValues']:
        return pulumi.get(self, "default_values")


@pulumi.output_type
class DataSetIntegerDatasetParameterDefaultValues(dict):
    """
    <p>List of default values defined for a given integer dataset parameter type. Currently only static values are supported.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetIntegerDatasetParameterDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetIntegerDatasetParameterDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetIntegerDatasetParameterDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 static_values: Optional[Sequence[float]] = None):
        """
        <p>List of default values defined for a given integer dataset parameter type. Currently only static values are supported.</p>
        :param Sequence[float] static_values: <p>List of static default values defined for a given integer dataset parameter type.</p>
        """
        DataSetIntegerDatasetParameterDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             static_values: Optional[Sequence[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[float]]:
        """
        <p>List of static default values defined for a given integer dataset parameter type.</p>
        """
        return pulumi.get(self, "static_values")


@pulumi.output_type
class DataSetLogicalTableMap(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class DataSetLookbackWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "sizeUnit":
            suggest = "size_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLookbackWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLookbackWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLookbackWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: Optional[str] = None,
                 size: Optional[float] = None,
                 size_unit: Optional['DataSetSizeUnit'] = None):
        """
        :param str column_name: <p>Column Name</p>
        :param float size: <p>Size</p>
        """
        DataSetLookbackWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            size=size,
            size_unit=size_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             size: Optional[float] = None,
             size_unit: Optional['DataSetSizeUnit'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_name is not None:
            _setter("column_name", column_name)
        if size is not None:
            _setter("size", size)
        if size_unit is not None:
            _setter("size_unit", size_unit)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[str]:
        """
        <p>Column Name</p>
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def size(self) -> Optional[float]:
        """
        <p>Size</p>
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeUnit")
    def size_unit(self) -> Optional['DataSetSizeUnit']:
        return pulumi.get(self, "size_unit")


@pulumi.output_type
class DataSetOutputColumn(dict):
    """
    <p>Output column.</p>
    """
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional['DataSetColumnDataType'] = None):
        """
        <p>Output column.</p>
        :param str description: <p>A description for a column.</p>
        :param str name: <p>A display name for the dataset.</p>
        """
        DataSetOutputColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             name: Optional[str] = None,
             type: Optional['DataSetColumnDataType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if description is not None:
            _setter("description", description)
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>A description for a column.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>A display name for the dataset.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional['DataSetColumnDataType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class DataSetPhysicalTableMap(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class DataSetRefreshConfiguration(dict):
    """
    <p> Refresh Configuration.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incrementalRefresh":
            suggest = "incremental_refresh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRefreshConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRefreshConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRefreshConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incremental_refresh: Optional['outputs.DataSetIncrementalRefresh'] = None):
        """
        <p> Refresh Configuration.</p>
        """
        DataSetRefreshConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            incremental_refresh=incremental_refresh,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             incremental_refresh: Optional['outputs.DataSetIncrementalRefresh'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if incremental_refresh is not None:
            _setter("incremental_refresh", incremental_refresh)

    @property
    @pulumi.getter(name="incrementalRefresh")
    def incremental_refresh(self) -> Optional['outputs.DataSetIncrementalRefresh']:
        return pulumi.get(self, "incremental_refresh")


@pulumi.output_type
class DataSetRefreshProperties(dict):
    """
    <p>The dataset refresh properties for the dataset.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refreshConfiguration":
            suggest = "refresh_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRefreshProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRefreshProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRefreshProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 refresh_configuration: Optional['outputs.DataSetRefreshConfiguration'] = None):
        """
        <p>The dataset refresh properties for the dataset.</p>
        """
        DataSetRefreshProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            refresh_configuration=refresh_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             refresh_configuration: Optional['outputs.DataSetRefreshConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if refresh_configuration is not None:
            _setter("refresh_configuration", refresh_configuration)

    @property
    @pulumi.getter(name="refreshConfiguration")
    def refresh_configuration(self) -> Optional['outputs.DataSetRefreshConfiguration']:
        return pulumi.get(self, "refresh_configuration")


@pulumi.output_type
class DataSetResourcePermission(dict):
    """
    <p>Permission for the resource.</p>
    """
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str):
        """
        <p>Permission for the resource.</p>
        :param Sequence[str] actions: <p>The IAM action to grant or revoke permissions on.</p>
        :param str principal: <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
                           following:</p>
                       <ul>
                           <li>
                               <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
                           </li>
                           <li>
                               <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
                           </li>
                           <li>
                               <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
                                   ARN. Use this option only to share resources (templates) across AWS accounts.
                                   (This is less common.) </p>
                           </li>
                        </ul>
        """
        DataSetResourcePermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Sequence[str],
             principal: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        _setter("principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        <p>The IAM action to grant or revoke permissions on.</p>
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
                    following:</p>
                <ul>
                    <li>
                        <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
                    </li>
                    <li>
                        <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
                    </li>
                    <li>
                        <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
                            ARN. Use this option only to share resources (templates) across AWS accounts.
                            (This is less common.) </p>
                    </li>
                 </ul>
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class DataSetRowLevelPermissionDataSet(dict):
    """
    <p>The row-level security configuration for the dataset.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionPolicy":
            suggest = "permission_policy"
        elif key == "formatVersion":
            suggest = "format_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRowLevelPermissionDataSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRowLevelPermissionDataSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRowLevelPermissionDataSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 permission_policy: 'DataSetRowLevelPermissionPolicy',
                 format_version: Optional['DataSetRowLevelPermissionFormatVersion'] = None,
                 namespace: Optional[str] = None,
                 status: Optional['DataSetStatus'] = None):
        """
        <p>The row-level security configuration for the dataset.</p>
        :param str arn: <p>The Amazon Resource Name (ARN) of the permission dataset.</p>
        :param str namespace: <p>The namespace associated with the row-level permissions dataset.</p>
        """
        DataSetRowLevelPermissionDataSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            permission_policy=permission_policy,
            format_version=format_version,
            namespace=namespace,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: str,
             permission_policy: 'DataSetRowLevelPermissionPolicy',
             format_version: Optional['DataSetRowLevelPermissionFormatVersion'] = None,
             namespace: Optional[str] = None,
             status: Optional['DataSetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("arn", arn)
        _setter("permission_policy", permission_policy)
        if format_version is not None:
            _setter("format_version", format_version)
        if namespace is not None:
            _setter("namespace", namespace)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        <p>The Amazon Resource Name (ARN) of the permission dataset.</p>
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="permissionPolicy")
    def permission_policy(self) -> 'DataSetRowLevelPermissionPolicy':
        return pulumi.get(self, "permission_policy")

    @property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional['DataSetRowLevelPermissionFormatVersion']:
        return pulumi.get(self, "format_version")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        <p>The namespace associated with the row-level permissions dataset.</p>
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def status(self) -> Optional['DataSetStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class DataSetRowLevelPermissionTagConfiguration(dict):
    """
    <p>The configuration of tags on a dataset to set row-level security.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagRules":
            suggest = "tag_rules"
        elif key == "tagRuleConfigurations":
            suggest = "tag_rule_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRowLevelPermissionTagConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRowLevelPermissionTagConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRowLevelPermissionTagConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_rules: Sequence['outputs.DataSetRowLevelPermissionTagRule'],
                 status: Optional['DataSetStatus'] = None,
                 tag_rule_configurations: Optional[Sequence[Sequence[str]]] = None):
        """
        <p>The configuration of tags on a dataset to set row-level security.</p>
        :param Sequence['DataSetRowLevelPermissionTagRule'] tag_rules: <p>A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.</p>
        :param Sequence[Sequence[str]] tag_rule_configurations: <p>A list of tag configuration rules to apply to a dataset. All tag configurations have the OR condition. Tags within each tile will be joined (AND). At least one rule in this structure must have all tag values assigned to it to apply Row-level security (RLS) to the dataset.</p>
        """
        DataSetRowLevelPermissionTagConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tag_rules=tag_rules,
            status=status,
            tag_rule_configurations=tag_rule_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tag_rules: Sequence['outputs.DataSetRowLevelPermissionTagRule'],
             status: Optional['DataSetStatus'] = None,
             tag_rule_configurations: Optional[Sequence[Sequence[str]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("tag_rules", tag_rules)
        if status is not None:
            _setter("status", status)
        if tag_rule_configurations is not None:
            _setter("tag_rule_configurations", tag_rule_configurations)

    @property
    @pulumi.getter(name="tagRules")
    def tag_rules(self) -> Sequence['outputs.DataSetRowLevelPermissionTagRule']:
        """
        <p>A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.</p>
        """
        return pulumi.get(self, "tag_rules")

    @property
    @pulumi.getter
    def status(self) -> Optional['DataSetStatus']:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tagRuleConfigurations")
    def tag_rule_configurations(self) -> Optional[Sequence[Sequence[str]]]:
        """
        <p>A list of tag configuration rules to apply to a dataset. All tag configurations have the OR condition. Tags within each tile will be joined (AND). At least one rule in this structure must have all tag values assigned to it to apply Row-level security (RLS) to the dataset.</p>
        """
        return pulumi.get(self, "tag_rule_configurations")


@pulumi.output_type
class DataSetRowLevelPermissionTagRule(dict):
    """
    <p>Permission for the resource.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "tagKey":
            suggest = "tag_key"
        elif key == "matchAllValue":
            suggest = "match_all_value"
        elif key == "tagMultiValueDelimiter":
            suggest = "tag_multi_value_delimiter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRowLevelPermissionTagRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRowLevelPermissionTagRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRowLevelPermissionTagRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 tag_key: str,
                 match_all_value: Optional[str] = None,
                 tag_multi_value_delimiter: Optional[str] = None):
        """
        <p>Permission for the resource.</p>
        :param str column_name: <p>The column name that a tag key is assigned to.</p>
        :param str tag_key: <p>The unique key for a tag.</p>
        :param str match_all_value: <p>A string that you want to use to filter by all the values in a column in the dataset and don’t want to list the values one by one. For example, you can use an asterisk as your match all value.</p>
        :param str tag_multi_value_delimiter: <p>A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.</p>
        """
        DataSetRowLevelPermissionTagRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            tag_key=tag_key,
            match_all_value=match_all_value,
            tag_multi_value_delimiter=tag_multi_value_delimiter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: str,
             tag_key: str,
             match_all_value: Optional[str] = None,
             tag_multi_value_delimiter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column_name", column_name)
        _setter("tag_key", tag_key)
        if match_all_value is not None:
            _setter("match_all_value", match_all_value)
        if tag_multi_value_delimiter is not None:
            _setter("tag_multi_value_delimiter", tag_multi_value_delimiter)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        <p>The column name that a tag key is assigned to.</p>
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        """
        <p>The unique key for a tag.</p>
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter(name="matchAllValue")
    def match_all_value(self) -> Optional[str]:
        """
        <p>A string that you want to use to filter by all the values in a column in the dataset and don’t want to list the values one by one. For example, you can use an asterisk as your match all value.</p>
        """
        return pulumi.get(self, "match_all_value")

    @property
    @pulumi.getter(name="tagMultiValueDelimiter")
    def tag_multi_value_delimiter(self) -> Optional[str]:
        """
        <p>A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.</p>
        """
        return pulumi.get(self, "tag_multi_value_delimiter")


@pulumi.output_type
class DataSetStringDatasetParameter(dict):
    """
    <p>A parameter created in the dataset of string data type.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"
        elif key == "defaultValues":
            suggest = "default_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetStringDatasetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetStringDatasetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetStringDatasetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 value_type: 'DataSetDatasetParameterValueType',
                 default_values: Optional['outputs.DataSetStringDatasetParameterDefaultValues'] = None):
        """
        <p>A parameter created in the dataset of string data type.</p>
        """
        DataSetStringDatasetParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            value_type=value_type,
            default_values=default_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: str,
             value_type: 'DataSetDatasetParameterValueType',
             default_values: Optional['outputs.DataSetStringDatasetParameterDefaultValues'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("name", name)
        _setter("value_type", value_type)
        if default_values is not None:
            _setter("default_values", default_values)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> 'DataSetDatasetParameterValueType':
        return pulumi.get(self, "value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.DataSetStringDatasetParameterDefaultValues']:
        return pulumi.get(self, "default_values")


@pulumi.output_type
class DataSetStringDatasetParameterDefaultValues(dict):
    """
    <p>List of default values defined for a given string dataset parameter type. Currently only static values are supported.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetStringDatasetParameterDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetStringDatasetParameterDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetStringDatasetParameterDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 static_values: Optional[Sequence[str]] = None):
        """
        <p>List of default values defined for a given string dataset parameter type. Currently only static values are supported.</p>
        :param Sequence[str] static_values: <p>List of static default values defined for a given string dataset parameter type.</p>
        """
        DataSetStringDatasetParameterDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             static_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[str]]:
        """
        <p>List of static default values defined for a given string dataset parameter type.</p>
        """
        return pulumi.get(self, "static_values")


@pulumi.output_type
class DataSetTag(dict):
    """
    <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
                resource.</p>
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
                    resource.</p>
        :param str key: <p>Tag key.</p>
        :param str value: <p>Tag value.</p>
        """
        DataSetTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        <p>Tag key.</p>
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        <p>Tag value.</p>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DataSetUsageConfiguration(dict):
    """
    <p>The dataset usage configuration for the dataset.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableUseAsDirectQuerySource":
            suggest = "disable_use_as_direct_query_source"
        elif key == "disableUseAsImportedSource":
            suggest = "disable_use_as_imported_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetUsageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetUsageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetUsageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_use_as_direct_query_source: Optional[bool] = None,
                 disable_use_as_imported_source: Optional[bool] = None):
        """
        <p>The dataset usage configuration for the dataset.</p>
        """
        DataSetUsageConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_use_as_direct_query_source=disable_use_as_direct_query_source,
            disable_use_as_imported_source=disable_use_as_imported_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_use_as_direct_query_source: Optional[bool] = None,
             disable_use_as_imported_source: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if disable_use_as_direct_query_source is not None:
            _setter("disable_use_as_direct_query_source", disable_use_as_direct_query_source)
        if disable_use_as_imported_source is not None:
            _setter("disable_use_as_imported_source", disable_use_as_imported_source)

    @property
    @pulumi.getter(name="disableUseAsDirectQuerySource")
    def disable_use_as_direct_query_source(self) -> Optional[bool]:
        return pulumi.get(self, "disable_use_as_direct_query_source")

    @property
    @pulumi.getter(name="disableUseAsImportedSource")
    def disable_use_as_imported_source(self) -> Optional[bool]:
        return pulumi.get(self, "disable_use_as_imported_source")


@pulumi.output_type
class DataSourceAmazonElasticsearchParameters(dict):
    """
    <p>Amazon Elasticsearch Service parameters.</p>
    """
    def __init__(__self__, *,
                 domain: str):
        """
        <p>Amazon Elasticsearch Service parameters.</p>
        :param str domain: <p>The Amazon Elasticsearch Service domain.</p>
        """
        DataSourceAmazonElasticsearchParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        <p>The Amazon Elasticsearch Service domain.</p>
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class DataSourceAmazonOpenSearchParameters(dict):
    """
    <p>Amazon OpenSearch Service parameters.</p>
    """
    def __init__(__self__, *,
                 domain: str):
        """
        <p>Amazon OpenSearch Service parameters.</p>
        :param str domain: <p>The Amazon OpenSearch Service domain.</p>
        """
        DataSourceAmazonOpenSearchParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        <p>The Amazon OpenSearch Service domain.</p>
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class DataSourceAthenaParameters(dict):
    """
    <p>Amazon Athena parameters.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "workGroup":
            suggest = "work_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceAthenaParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceAthenaParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceAthenaParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: Optional[str] = None,
                 work_group: Optional[str] = None):
        """
        <p>Amazon Athena parameters.</p>
        :param str role_arn: <p>Use the <code>RoleArn</code> structure to override an account-wide role for a specific Athena data source. For example, say an account administrator has turned off all Athena access with an account-wide role. The administrator can then use <code>RoleArn</code> to bypass the account-wide role and allow Athena access for the single Athena data source that is specified in the structure, even if the account-wide role forbidding Athena access is still active.</p>
        :param str work_group: <p>The workgroup that Amazon Athena uses.</p>
        """
        DataSourceAthenaParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            work_group=work_group,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[str] = None,
             work_group: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if role_arn is not None:
            _setter("role_arn", role_arn)
        if work_group is not None:
            _setter("work_group", work_group)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        <p>Use the <code>RoleArn</code> structure to override an account-wide role for a specific Athena data source. For example, say an account administrator has turned off all Athena access with an account-wide role. The administrator can then use <code>RoleArn</code> to bypass the account-wide role and allow Athena access for the single Athena data source that is specified in the structure, even if the account-wide role forbidding Athena access is still active.</p>
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="workGroup")
    def work_group(self) -> Optional[str]:
        """
        <p>The workgroup that Amazon Athena uses.</p>
        """
        return pulumi.get(self, "work_group")


@pulumi.output_type
class DataSourceAuroraParameters(dict):
    """
    <p>Amazon Aurora parameters.</p>
    """
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: float):
        """
        <p>Amazon Aurora parameters.</p>
        :param str database: <p>Database.</p>
        :param str host: <p>Host.</p>
        :param float port: <p>Port.</p>
        """
        DataSourceAuroraParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: str,
             host: str,
             port: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        <p>Database.</p>
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        <p>Host.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        <p>Port.</p>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceAuroraPostgreSqlParameters(dict):
    """
    <p>Amazon Aurora with PostgreSQL compatibility parameters.</p>
    """
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: float):
        """
        <p>Amazon Aurora with PostgreSQL compatibility parameters.</p>
        :param str database: <p>Database.</p>
        :param str host: <p>Host.</p>
        :param float port: <p>Port.</p>
        """
        DataSourceAuroraPostgreSqlParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: str,
             host: str,
             port: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        <p>Database.</p>
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        <p>Host.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        <p>Port.</p>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceCredentialPair(dict):
    """
    <p>The combination of user name and password that are used as credentials.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alternateDataSourceParameters":
            suggest = "alternate_data_source_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceCredentialPair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceCredentialPair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceCredentialPair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: str,
                 username: str,
                 alternate_data_source_parameters: Optional[Sequence['outputs.DataSourceParameters']] = None):
        """
        <p>The combination of user name and password that are used as credentials.</p>
        :param str password: <p>Password.</p>
        :param str username: <p>User name.</p>
        :param Sequence['DataSourceParameters'] alternate_data_source_parameters: <p>A set of alternate data source parameters that you want to share for these
                           credentials. The credentials are applied in tandem with the data source parameters when
                           you copy a data source by using a create or update request. The API operation compares
                           the <code>DataSourceParameters</code> structure that's in the request with the
                           structures in the <code>AlternateDataSourceParameters</code> allow list. If the
                           structures are an exact match, the request is allowed to use the new data source with
                           the existing credentials. If the <code>AlternateDataSourceParameters</code> list is
                           null, the <code>DataSourceParameters</code> originally used with these
                               <code>Credentials</code> is automatically allowed.</p>
        """
        DataSourceCredentialPair._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
            alternate_data_source_parameters=alternate_data_source_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: str,
             username: str,
             alternate_data_source_parameters: Optional[Sequence['outputs.DataSourceParameters']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("password", password)
        _setter("username", username)
        if alternate_data_source_parameters is not None:
            _setter("alternate_data_source_parameters", alternate_data_source_parameters)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        <p>Password.</p>
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        <p>User name.</p>
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="alternateDataSourceParameters")
    def alternate_data_source_parameters(self) -> Optional[Sequence['outputs.DataSourceParameters']]:
        """
        <p>A set of alternate data source parameters that you want to share for these
                    credentials. The credentials are applied in tandem with the data source parameters when
                    you copy a data source by using a create or update request. The API operation compares
                    the <code>DataSourceParameters</code> structure that's in the request with the
                    structures in the <code>AlternateDataSourceParameters</code> allow list. If the
                    structures are an exact match, the request is allowed to use the new data source with
                    the existing credentials. If the <code>AlternateDataSourceParameters</code> list is
                    null, the <code>DataSourceParameters</code> originally used with these
                        <code>Credentials</code> is automatically allowed.</p>
        """
        return pulumi.get(self, "alternate_data_source_parameters")


@pulumi.output_type
class DataSourceCredentials(dict):
    """
    <p>Data source credentials. This is a variant type structure. For this structure to be
                valid, only one of the attributes can be non-null.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copySourceArn":
            suggest = "copy_source_arn"
        elif key == "credentialPair":
            suggest = "credential_pair"
        elif key == "secretArn":
            suggest = "secret_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_source_arn: Optional[str] = None,
                 credential_pair: Optional['outputs.DataSourceCredentialPair'] = None,
                 secret_arn: Optional[str] = None):
        """
        <p>Data source credentials. This is a variant type structure. For this structure to be
                    valid, only one of the attributes can be non-null.</p>
        :param str copy_source_arn: <p>The Amazon Resource Name (ARN) of a data source that has the credential pair that you
                           want to use. When <code>CopySourceArn</code> is not null, the credential pair from the
                           data source in the ARN is used as the credentials for the
                           <code>DataSourceCredentials</code> structure.</p>
        :param str secret_arn: <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
        """
        DataSourceCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            copy_source_arn=copy_source_arn,
            credential_pair=credential_pair,
            secret_arn=secret_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             copy_source_arn: Optional[str] = None,
             credential_pair: Optional['outputs.DataSourceCredentialPair'] = None,
             secret_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if copy_source_arn is not None:
            _setter("copy_source_arn", copy_source_arn)
        if credential_pair is not None:
            _setter("credential_pair", credential_pair)
        if secret_arn is not None:
            _setter("secret_arn", secret_arn)

    @property
    @pulumi.getter(name="copySourceArn")
    def copy_source_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of a data source that has the credential pair that you
                    want to use. When <code>CopySourceArn</code> is not null, the credential pair from the
                    data source in the ARN is used as the credentials for the
                    <code>DataSourceCredentials</code> structure.</p>
        """
        return pulumi.get(self, "copy_source_arn")

    @property
    @pulumi.getter(name="credentialPair")
    def credential_pair(self) -> Optional['outputs.DataSourceCredentialPair']:
        return pulumi.get(self, "credential_pair")

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
        """
        return pulumi.get(self, "secret_arn")


@pulumi.output_type
class DataSourceDatabricksParameters(dict):
    """
    <p>Databricks parameters.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sqlEndpointPath":
            suggest = "sql_endpoint_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceDatabricksParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceDatabricksParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceDatabricksParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 port: float,
                 sql_endpoint_path: str):
        """
        <p>Databricks parameters.</p>
        :param str host: <p>Host.</p>
        :param float port: <p>Port.</p>
        :param str sql_endpoint_path: <p>The HTTP Path of the Databricks data source.</p>
        """
        DataSourceDatabricksParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            port=port,
            sql_endpoint_path=sql_endpoint_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: str,
             port: float,
             sql_endpoint_path: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("host", host)
        _setter("port", port)
        _setter("sql_endpoint_path", sql_endpoint_path)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        <p>Host.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        <p>Port.</p>
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sqlEndpointPath")
    def sql_endpoint_path(self) -> str:
        """
        <p>The HTTP Path of the Databricks data source.</p>
        """
        return pulumi.get(self, "sql_endpoint_path")


@pulumi.output_type
class DataSourceErrorInfo(dict):
    """
    <p>Error information for the data source creation or update.</p>
    """
    def __init__(__self__, *,
                 message: Optional[str] = None,
                 type: Optional['DataSourceErrorInfoType'] = None):
        """
        <p>Error information for the data source creation or update.</p>
        :param str message: <p>Error message.</p>
        """
        DataSourceErrorInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: Optional[str] = None,
             type: Optional['DataSourceErrorInfoType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if message is not None:
            _setter("message", message)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        <p>Error message.</p>
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def type(self) -> Optional['DataSourceErrorInfoType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class DataSourceManifestFileLocation(dict):
    """
    <p>Amazon S3 manifest file location.</p>
    """
    def __init__(__self__, *,
                 bucket: str,
                 key: str):
        """
        <p>Amazon S3 manifest file location.</p>
        :param str bucket: <p>Amazon S3 bucket.</p>
        :param str key: <p>Amazon S3 key that identifies an object.</p>
        """
        DataSourceManifestFileLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: str,
             key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bucket", bucket)
        _setter("key", key)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        <p>Amazon S3 bucket.</p>
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        <p>Amazon S3 key that identifies an object.</p>
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class DataSourceMariaDbParameters(dict):
    """
    <p>MariaDB parameters.</p>
    """
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: float):
        """
        <p>MariaDB parameters.</p>
        :param str database: <p>Database.</p>
        :param str host: <p>Host.</p>
        :param float port: <p>Port.</p>
        """
        DataSourceMariaDbParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: str,
             host: str,
             port: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        <p>Database.</p>
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        <p>Host.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        <p>Port.</p>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceMySqlParameters(dict):
    """
    <p>MySQL parameters.</p>
    """
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: float):
        """
        <p>MySQL parameters.</p>
        :param str database: <p>Database.</p>
        :param str host: <p>Host.</p>
        :param float port: <p>Port.</p>
        """
        DataSourceMySqlParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: str,
             host: str,
             port: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        <p>Database.</p>
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        <p>Host.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        <p>Port.</p>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceOracleParameters(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: float):
        DataSourceOracleParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: str,
             host: str,
             port: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParameters(dict):
    """
    <p>The parameters that Amazon QuickSight uses to connect to your underlying data source.
                This is a variant type structure. For this structure to be valid, only one of the
                attributes can be non-null.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonElasticsearchParameters":
            suggest = "amazon_elasticsearch_parameters"
        elif key == "amazonOpenSearchParameters":
            suggest = "amazon_open_search_parameters"
        elif key == "athenaParameters":
            suggest = "athena_parameters"
        elif key == "auroraParameters":
            suggest = "aurora_parameters"
        elif key == "auroraPostgreSqlParameters":
            suggest = "aurora_postgre_sql_parameters"
        elif key == "databricksParameters":
            suggest = "databricks_parameters"
        elif key == "mariaDbParameters":
            suggest = "maria_db_parameters"
        elif key == "mySqlParameters":
            suggest = "my_sql_parameters"
        elif key == "oracleParameters":
            suggest = "oracle_parameters"
        elif key == "postgreSqlParameters":
            suggest = "postgre_sql_parameters"
        elif key == "prestoParameters":
            suggest = "presto_parameters"
        elif key == "rdsParameters":
            suggest = "rds_parameters"
        elif key == "redshiftParameters":
            suggest = "redshift_parameters"
        elif key == "s3Parameters":
            suggest = "s3_parameters"
        elif key == "snowflakeParameters":
            suggest = "snowflake_parameters"
        elif key == "sparkParameters":
            suggest = "spark_parameters"
        elif key == "sqlServerParameters":
            suggest = "sql_server_parameters"
        elif key == "teradataParameters":
            suggest = "teradata_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_elasticsearch_parameters: Optional['outputs.DataSourceAmazonElasticsearchParameters'] = None,
                 amazon_open_search_parameters: Optional['outputs.DataSourceAmazonOpenSearchParameters'] = None,
                 athena_parameters: Optional['outputs.DataSourceAthenaParameters'] = None,
                 aurora_parameters: Optional['outputs.DataSourceAuroraParameters'] = None,
                 aurora_postgre_sql_parameters: Optional['outputs.DataSourceAuroraPostgreSqlParameters'] = None,
                 databricks_parameters: Optional['outputs.DataSourceDatabricksParameters'] = None,
                 maria_db_parameters: Optional['outputs.DataSourceMariaDbParameters'] = None,
                 my_sql_parameters: Optional['outputs.DataSourceMySqlParameters'] = None,
                 oracle_parameters: Optional['outputs.DataSourceOracleParameters'] = None,
                 postgre_sql_parameters: Optional['outputs.DataSourcePostgreSqlParameters'] = None,
                 presto_parameters: Optional['outputs.DataSourcePrestoParameters'] = None,
                 rds_parameters: Optional['outputs.DataSourceRdsParameters'] = None,
                 redshift_parameters: Optional['outputs.DataSourceRedshiftParameters'] = None,
                 s3_parameters: Optional['outputs.DataSourceS3Parameters'] = None,
                 snowflake_parameters: Optional['outputs.DataSourceSnowflakeParameters'] = None,
                 spark_parameters: Optional['outputs.DataSourceSparkParameters'] = None,
                 sql_server_parameters: Optional['outputs.DataSourceSqlServerParameters'] = None,
                 teradata_parameters: Optional['outputs.DataSourceTeradataParameters'] = None):
        """
        <p>The parameters that Amazon QuickSight uses to connect to your underlying data source.
                    This is a variant type structure. For this structure to be valid, only one of the
                    attributes can be non-null.</p>
        """
        DataSourceParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amazon_elasticsearch_parameters=amazon_elasticsearch_parameters,
            amazon_open_search_parameters=amazon_open_search_parameters,
            athena_parameters=athena_parameters,
            aurora_parameters=aurora_parameters,
            aurora_postgre_sql_parameters=aurora_postgre_sql_parameters,
            databricks_parameters=databricks_parameters,
            maria_db_parameters=maria_db_parameters,
            my_sql_parameters=my_sql_parameters,
            oracle_parameters=oracle_parameters,
            postgre_sql_parameters=postgre_sql_parameters,
            presto_parameters=presto_parameters,
            rds_parameters=rds_parameters,
            redshift_parameters=redshift_parameters,
            s3_parameters=s3_parameters,
            snowflake_parameters=snowflake_parameters,
            spark_parameters=spark_parameters,
            sql_server_parameters=sql_server_parameters,
            teradata_parameters=teradata_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amazon_elasticsearch_parameters: Optional['outputs.DataSourceAmazonElasticsearchParameters'] = None,
             amazon_open_search_parameters: Optional['outputs.DataSourceAmazonOpenSearchParameters'] = None,
             athena_parameters: Optional['outputs.DataSourceAthenaParameters'] = None,
             aurora_parameters: Optional['outputs.DataSourceAuroraParameters'] = None,
             aurora_postgre_sql_parameters: Optional['outputs.DataSourceAuroraPostgreSqlParameters'] = None,
             databricks_parameters: Optional['outputs.DataSourceDatabricksParameters'] = None,
             maria_db_parameters: Optional['outputs.DataSourceMariaDbParameters'] = None,
             my_sql_parameters: Optional['outputs.DataSourceMySqlParameters'] = None,
             oracle_parameters: Optional['outputs.DataSourceOracleParameters'] = None,
             postgre_sql_parameters: Optional['outputs.DataSourcePostgreSqlParameters'] = None,
             presto_parameters: Optional['outputs.DataSourcePrestoParameters'] = None,
             rds_parameters: Optional['outputs.DataSourceRdsParameters'] = None,
             redshift_parameters: Optional['outputs.DataSourceRedshiftParameters'] = None,
             s3_parameters: Optional['outputs.DataSourceS3Parameters'] = None,
             snowflake_parameters: Optional['outputs.DataSourceSnowflakeParameters'] = None,
             spark_parameters: Optional['outputs.DataSourceSparkParameters'] = None,
             sql_server_parameters: Optional['outputs.DataSourceSqlServerParameters'] = None,
             teradata_parameters: Optional['outputs.DataSourceTeradataParameters'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if amazon_elasticsearch_parameters is not None:
            _setter("amazon_elasticsearch_parameters", amazon_elasticsearch_parameters)
        if amazon_open_search_parameters is not None:
            _setter("amazon_open_search_parameters", amazon_open_search_parameters)
        if athena_parameters is not None:
            _setter("athena_parameters", athena_parameters)
        if aurora_parameters is not None:
            _setter("aurora_parameters", aurora_parameters)
        if aurora_postgre_sql_parameters is not None:
            _setter("aurora_postgre_sql_parameters", aurora_postgre_sql_parameters)
        if databricks_parameters is not None:
            _setter("databricks_parameters", databricks_parameters)
        if maria_db_parameters is not None:
            _setter("maria_db_parameters", maria_db_parameters)
        if my_sql_parameters is not None:
            _setter("my_sql_parameters", my_sql_parameters)
        if oracle_parameters is not None:
            _setter("oracle_parameters", oracle_parameters)
        if postgre_sql_parameters is not None:
            _setter("postgre_sql_parameters", postgre_sql_parameters)
        if presto_parameters is not None:
            _setter("presto_parameters", presto_parameters)
        if rds_parameters is not None:
            _setter("rds_parameters", rds_parameters)
        if redshift_parameters is not None:
            _setter("redshift_parameters", redshift_parameters)
        if s3_parameters is not None:
            _setter("s3_parameters", s3_parameters)
        if snowflake_parameters is not None:
            _setter("snowflake_parameters", snowflake_parameters)
        if spark_parameters is not None:
            _setter("spark_parameters", spark_parameters)
        if sql_server_parameters is not None:
            _setter("sql_server_parameters", sql_server_parameters)
        if teradata_parameters is not None:
            _setter("teradata_parameters", teradata_parameters)

    @property
    @pulumi.getter(name="amazonElasticsearchParameters")
    def amazon_elasticsearch_parameters(self) -> Optional['outputs.DataSourceAmazonElasticsearchParameters']:
        return pulumi.get(self, "amazon_elasticsearch_parameters")

    @property
    @pulumi.getter(name="amazonOpenSearchParameters")
    def amazon_open_search_parameters(self) -> Optional['outputs.DataSourceAmazonOpenSearchParameters']:
        return pulumi.get(self, "amazon_open_search_parameters")

    @property
    @pulumi.getter(name="athenaParameters")
    def athena_parameters(self) -> Optional['outputs.DataSourceAthenaParameters']:
        return pulumi.get(self, "athena_parameters")

    @property
    @pulumi.getter(name="auroraParameters")
    def aurora_parameters(self) -> Optional['outputs.DataSourceAuroraParameters']:
        return pulumi.get(self, "aurora_parameters")

    @property
    @pulumi.getter(name="auroraPostgreSqlParameters")
    def aurora_postgre_sql_parameters(self) -> Optional['outputs.DataSourceAuroraPostgreSqlParameters']:
        return pulumi.get(self, "aurora_postgre_sql_parameters")

    @property
    @pulumi.getter(name="databricksParameters")
    def databricks_parameters(self) -> Optional['outputs.DataSourceDatabricksParameters']:
        return pulumi.get(self, "databricks_parameters")

    @property
    @pulumi.getter(name="mariaDbParameters")
    def maria_db_parameters(self) -> Optional['outputs.DataSourceMariaDbParameters']:
        return pulumi.get(self, "maria_db_parameters")

    @property
    @pulumi.getter(name="mySqlParameters")
    def my_sql_parameters(self) -> Optional['outputs.DataSourceMySqlParameters']:
        return pulumi.get(self, "my_sql_parameters")

    @property
    @pulumi.getter(name="oracleParameters")
    def oracle_parameters(self) -> Optional['outputs.DataSourceOracleParameters']:
        return pulumi.get(self, "oracle_parameters")

    @property
    @pulumi.getter(name="postgreSqlParameters")
    def postgre_sql_parameters(self) -> Optional['outputs.DataSourcePostgreSqlParameters']:
        return pulumi.get(self, "postgre_sql_parameters")

    @property
    @pulumi.getter(name="prestoParameters")
    def presto_parameters(self) -> Optional['outputs.DataSourcePrestoParameters']:
        return pulumi.get(self, "presto_parameters")

    @property
    @pulumi.getter(name="rdsParameters")
    def rds_parameters(self) -> Optional['outputs.DataSourceRdsParameters']:
        return pulumi.get(self, "rds_parameters")

    @property
    @pulumi.getter(name="redshiftParameters")
    def redshift_parameters(self) -> Optional['outputs.DataSourceRedshiftParameters']:
        return pulumi.get(self, "redshift_parameters")

    @property
    @pulumi.getter(name="s3Parameters")
    def s3_parameters(self) -> Optional['outputs.DataSourceS3Parameters']:
        return pulumi.get(self, "s3_parameters")

    @property
    @pulumi.getter(name="snowflakeParameters")
    def snowflake_parameters(self) -> Optional['outputs.DataSourceSnowflakeParameters']:
        return pulumi.get(self, "snowflake_parameters")

    @property
    @pulumi.getter(name="sparkParameters")
    def spark_parameters(self) -> Optional['outputs.DataSourceSparkParameters']:
        return pulumi.get(self, "spark_parameters")

    @property
    @pulumi.getter(name="sqlServerParameters")
    def sql_server_parameters(self) -> Optional['outputs.DataSourceSqlServerParameters']:
        return pulumi.get(self, "sql_server_parameters")

    @property
    @pulumi.getter(name="teradataParameters")
    def teradata_parameters(self) -> Optional['outputs.DataSourceTeradataParameters']:
        return pulumi.get(self, "teradata_parameters")


@pulumi.output_type
class DataSourcePostgreSqlParameters(dict):
    """
    <p>PostgreSQL parameters.</p>
    """
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: float):
        """
        <p>PostgreSQL parameters.</p>
        :param str database: <p>Database.</p>
        :param str host: <p>Host.</p>
        :param float port: <p>Port.</p>
        """
        DataSourcePostgreSqlParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: str,
             host: str,
             port: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        <p>Database.</p>
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        <p>Host.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        <p>Port.</p>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourcePrestoParameters(dict):
    """
    <p>Presto parameters.</p>
    """
    def __init__(__self__, *,
                 catalog: str,
                 host: str,
                 port: float):
        """
        <p>Presto parameters.</p>
        :param str catalog: <p>Catalog.</p>
        :param str host: <p>Host.</p>
        :param float port: <p>Port.</p>
        """
        DataSourcePrestoParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog=catalog,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog: str,
             host: str,
             port: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("catalog", catalog)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        """
        <p>Catalog.</p>
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        <p>Host.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        <p>Port.</p>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceRdsParameters(dict):
    """
    <p>Amazon RDS parameters.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceRdsParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceRdsParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceRdsParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 instance_id: str):
        """
        <p>Amazon RDS parameters.</p>
        :param str database: <p>Database.</p>
        :param str instance_id: <p>Instance ID.</p>
        """
        DataSourceRdsParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            instance_id=instance_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: str,
             instance_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        _setter("instance_id", instance_id)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        <p>Database.</p>
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        <p>Instance ID.</p>
        """
        return pulumi.get(self, "instance_id")


@pulumi.output_type
class DataSourceRedshiftParameters(dict):
    """
    <p>Amazon Redshift parameters. The <code>ClusterId</code> field can be blank if
                <code>Host</code> and <code>Port</code> are both set. The <code>Host</code> and
                <code>Port</code> fields can be blank if the <code>ClusterId</code> field is set.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceRedshiftParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceRedshiftParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceRedshiftParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 cluster_id: Optional[str] = None,
                 host: Optional[str] = None,
                 port: Optional[float] = None):
        """
        <p>Amazon Redshift parameters. The <code>ClusterId</code> field can be blank if
                    <code>Host</code> and <code>Port</code> are both set. The <code>Host</code> and
                    <code>Port</code> fields can be blank if the <code>ClusterId</code> field is set.</p>
        :param str database: <p>Database.</p>
        :param str cluster_id: <p>Cluster ID. This field can be blank if the <code>Host</code> and <code>Port</code> are
                           provided.</p>
        :param str host: <p>Host. This field can be blank if <code>ClusterId</code> is provided.</p>
        :param float port: <p>Port. This field can be blank if the <code>ClusterId</code> is provided.</p>
        """
        DataSourceRedshiftParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            cluster_id=cluster_id,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: str,
             cluster_id: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if host is not None:
            _setter("host", host)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        <p>Database.</p>
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        """
        <p>Cluster ID. This field can be blank if the <code>Host</code> and <code>Port</code> are
                    provided.</p>
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        <p>Host. This field can be blank if <code>ClusterId</code> is provided.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[float]:
        """
        <p>Port. This field can be blank if the <code>ClusterId</code> is provided.</p>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceResourcePermission(dict):
    """
    <p>Permission for the resource.</p>
    """
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str):
        """
        <p>Permission for the resource.</p>
        :param Sequence[str] actions: <p>The IAM action to grant or revoke permissions on.</p>
        :param str principal: <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
                           following:</p>
                       <ul>
                           <li>
                               <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
                           </li>
                           <li>
                               <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
                           </li>
                           <li>
                               <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
                                   ARN. Use this option only to share resources (templates) across AWS accounts.
                                   (This is less common.) </p>
                           </li>
                        </ul>
        """
        DataSourceResourcePermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Sequence[str],
             principal: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        _setter("principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        <p>The IAM action to grant or revoke permissions on.</p>
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
                    following:</p>
                <ul>
                    <li>
                        <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
                    </li>
                    <li>
                        <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
                    </li>
                    <li>
                        <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
                            ARN. Use this option only to share resources (templates) across AWS accounts.
                            (This is less common.) </p>
                    </li>
                 </ul>
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class DataSourceS3Parameters(dict):
    """
    <p>S3 parameters.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manifestFileLocation":
            suggest = "manifest_file_location"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceS3Parameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceS3Parameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceS3Parameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 manifest_file_location: 'outputs.DataSourceManifestFileLocation',
                 role_arn: Optional[str] = None):
        """
        <p>S3 parameters.</p>
        :param str role_arn: <p>Use the <code>RoleArn</code> structure to override an account-wide role for a specific S3 data source. For example, say an account administrator has turned off all S3 access with an account-wide role. The administrator can then use <code>RoleArn</code> to bypass the account-wide role and allow S3 access for the single S3 data source that is specified in the structure, even if the account-wide role forbidding S3 access is still active.</p>
        """
        DataSourceS3Parameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            manifest_file_location=manifest_file_location,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             manifest_file_location: 'outputs.DataSourceManifestFileLocation',
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("manifest_file_location", manifest_file_location)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="manifestFileLocation")
    def manifest_file_location(self) -> 'outputs.DataSourceManifestFileLocation':
        return pulumi.get(self, "manifest_file_location")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        <p>Use the <code>RoleArn</code> structure to override an account-wide role for a specific S3 data source. For example, say an account administrator has turned off all S3 access with an account-wide role. The administrator can then use <code>RoleArn</code> to bypass the account-wide role and allow S3 access for the single S3 data source that is specified in the structure, even if the account-wide role forbidding S3 access is still active.</p>
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class DataSourceSnowflakeParameters(dict):
    """
    <p>Snowflake parameters.</p>
    """
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 warehouse: str):
        """
        <p>Snowflake parameters.</p>
        :param str database: <p>Database.</p>
        :param str host: <p>Host.</p>
        :param str warehouse: <p>Warehouse.</p>
        """
        DataSourceSnowflakeParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            warehouse=warehouse,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: str,
             host: str,
             warehouse: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        _setter("host", host)
        _setter("warehouse", warehouse)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        <p>Database.</p>
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        <p>Host.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def warehouse(self) -> str:
        """
        <p>Warehouse.</p>
        """
        return pulumi.get(self, "warehouse")


@pulumi.output_type
class DataSourceSparkParameters(dict):
    """
    <p>Spark parameters.</p>
    """
    def __init__(__self__, *,
                 host: str,
                 port: float):
        """
        <p>Spark parameters.</p>
        :param str host: <p>Host.</p>
        :param float port: <p>Port.</p>
        """
        DataSourceSparkParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: str,
             port: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        <p>Host.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        <p>Port.</p>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceSqlServerParameters(dict):
    """
    <p>SQL Server parameters.</p>
    """
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: float):
        """
        <p>SQL Server parameters.</p>
        :param str database: <p>Database.</p>
        :param str host: <p>Host.</p>
        :param float port: <p>Port.</p>
        """
        DataSourceSqlServerParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: str,
             host: str,
             port: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        <p>Database.</p>
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        <p>Host.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        <p>Port.</p>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceSslProperties(dict):
    """
    <p>Secure Socket Layer (SSL) properties that apply when QuickSight connects to your
                underlying data source.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableSsl":
            suggest = "disable_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceSslProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceSslProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceSslProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_ssl: Optional[bool] = None):
        """
        <p>Secure Socket Layer (SSL) properties that apply when QuickSight connects to your
                    underlying data source.</p>
        :param bool disable_ssl: <p>A Boolean option to control whether SSL should be disabled.</p>
        """
        DataSourceSslProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_ssl=disable_ssl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_ssl: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if disable_ssl is not None:
            _setter("disable_ssl", disable_ssl)

    @property
    @pulumi.getter(name="disableSsl")
    def disable_ssl(self) -> Optional[bool]:
        """
        <p>A Boolean option to control whether SSL should be disabled.</p>
        """
        return pulumi.get(self, "disable_ssl")


@pulumi.output_type
class DataSourceTag(dict):
    """
    <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
                resource.</p>
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
                    resource.</p>
        :param str key: <p>Tag key.</p>
        :param str value: <p>Tag value.</p>
        """
        DataSourceTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        <p>Tag key.</p>
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        <p>Tag value.</p>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DataSourceTeradataParameters(dict):
    """
    <p>Teradata parameters.</p>
    """
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: float):
        """
        <p>Teradata parameters.</p>
        :param str database: <p>Database.</p>
        :param str host: <p>Host.</p>
        :param float port: <p>Port.</p>
        """
        DataSourceTeradataParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: str,
             host: str,
             port: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        <p>Database.</p>
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        <p>Host.</p>
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        <p>Port.</p>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceVpcConnectionProperties(dict):
    """
    <p>VPC connection properties.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcConnectionArn":
            suggest = "vpc_connection_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceVpcConnectionProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceVpcConnectionProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceVpcConnectionProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_connection_arn: str):
        """
        <p>VPC connection properties.</p>
        :param str vpc_connection_arn: <p>The Amazon Resource Name (ARN) for the VPC connection.</p>
        """
        DataSourceVpcConnectionProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            vpc_connection_arn=vpc_connection_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             vpc_connection_arn: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("vpc_connection_arn", vpc_connection_arn)

    @property
    @pulumi.getter(name="vpcConnectionArn")
    def vpc_connection_arn(self) -> str:
        """
        <p>The Amazon Resource Name (ARN) for the VPC connection.</p>
        """
        return pulumi.get(self, "vpc_connection_arn")


@pulumi.output_type
class RefreshScheduleMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refreshType":
            suggest = "refresh_type"
        elif key == "scheduleFrequency":
            suggest = "schedule_frequency"
        elif key == "scheduleId":
            suggest = "schedule_id"
        elif key == "startAfterDateTime":
            suggest = "start_after_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RefreshScheduleMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RefreshScheduleMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RefreshScheduleMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 refresh_type: Optional['RefreshScheduleMapRefreshType'] = None,
                 schedule_frequency: Optional['outputs.RefreshScheduleMapScheduleFrequencyProperties'] = None,
                 schedule_id: Optional[str] = None,
                 start_after_date_time: Optional[str] = None):
        """
        :param 'RefreshScheduleMapScheduleFrequencyProperties' schedule_frequency: <p>Information about the schedule frequency.</p>
        :param str schedule_id: <p>An unique identifier for the refresh schedule.</p>
        :param str start_after_date_time: <p>The date time after which refresh is to be scheduled</p>
        """
        RefreshScheduleMap._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            refresh_type=refresh_type,
            schedule_frequency=schedule_frequency,
            schedule_id=schedule_id,
            start_after_date_time=start_after_date_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             refresh_type: Optional['RefreshScheduleMapRefreshType'] = None,
             schedule_frequency: Optional['outputs.RefreshScheduleMapScheduleFrequencyProperties'] = None,
             schedule_id: Optional[str] = None,
             start_after_date_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if refresh_type is not None:
            _setter("refresh_type", refresh_type)
        if schedule_frequency is not None:
            _setter("schedule_frequency", schedule_frequency)
        if schedule_id is not None:
            _setter("schedule_id", schedule_id)
        if start_after_date_time is not None:
            _setter("start_after_date_time", start_after_date_time)

    @property
    @pulumi.getter(name="refreshType")
    def refresh_type(self) -> Optional['RefreshScheduleMapRefreshType']:
        return pulumi.get(self, "refresh_type")

    @property
    @pulumi.getter(name="scheduleFrequency")
    def schedule_frequency(self) -> Optional['outputs.RefreshScheduleMapScheduleFrequencyProperties']:
        """
        <p>Information about the schedule frequency.</p>
        """
        return pulumi.get(self, "schedule_frequency")

    @property
    @pulumi.getter(name="scheduleId")
    def schedule_id(self) -> Optional[str]:
        """
        <p>An unique identifier for the refresh schedule.</p>
        """
        return pulumi.get(self, "schedule_id")

    @property
    @pulumi.getter(name="startAfterDateTime")
    def start_after_date_time(self) -> Optional[str]:
        """
        <p>The date time after which refresh is to be scheduled</p>
        """
        return pulumi.get(self, "start_after_date_time")


@pulumi.output_type
class RefreshScheduleMapScheduleFrequencyProperties(dict):
    """
    <p>Information about the schedule frequency.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refreshOnDay":
            suggest = "refresh_on_day"
        elif key == "timeOfTheDay":
            suggest = "time_of_the_day"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RefreshScheduleMapScheduleFrequencyProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RefreshScheduleMapScheduleFrequencyProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RefreshScheduleMapScheduleFrequencyProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: Optional['RefreshScheduleMapScheduleFrequencyPropertiesInterval'] = None,
                 refresh_on_day: Optional['outputs.RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayProperties'] = None,
                 time_of_the_day: Optional[str] = None,
                 time_zone: Optional[str] = None):
        """
        <p>Information about the schedule frequency.</p>
        :param 'RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayProperties' refresh_on_day: <p>The day scheduled for refresh.</p>
        :param str time_of_the_day: <p>The time of the day for scheduled refresh.</p>
        :param str time_zone: <p>The timezone for scheduled refresh.</p>
        """
        RefreshScheduleMapScheduleFrequencyProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interval=interval,
            refresh_on_day=refresh_on_day,
            time_of_the_day=time_of_the_day,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interval: Optional['RefreshScheduleMapScheduleFrequencyPropertiesInterval'] = None,
             refresh_on_day: Optional['outputs.RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayProperties'] = None,
             time_of_the_day: Optional[str] = None,
             time_zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if interval is not None:
            _setter("interval", interval)
        if refresh_on_day is not None:
            _setter("refresh_on_day", refresh_on_day)
        if time_of_the_day is not None:
            _setter("time_of_the_day", time_of_the_day)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def interval(self) -> Optional['RefreshScheduleMapScheduleFrequencyPropertiesInterval']:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="refreshOnDay")
    def refresh_on_day(self) -> Optional['outputs.RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayProperties']:
        """
        <p>The day scheduled for refresh.</p>
        """
        return pulumi.get(self, "refresh_on_day")

    @property
    @pulumi.getter(name="timeOfTheDay")
    def time_of_the_day(self) -> Optional[str]:
        """
        <p>The time of the day for scheduled refresh.</p>
        """
        return pulumi.get(self, "time_of_the_day")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        <p>The timezone for scheduled refresh.</p>
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayProperties(dict):
    """
    <p>The day scheduled for refresh.</p>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "dayOfWeek":
            suggest = "day_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_month: Optional[str] = None,
                 day_of_week: Optional['RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayPropertiesDayOfWeek'] = None):
        """
        <p>The day scheduled for refresh.</p>
        :param str day_of_month: <p>The Day Of Month for scheduled refresh.</p>
        """
        RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_of_month=day_of_month,
            day_of_week=day_of_week,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_of_month: Optional[str] = None,
             day_of_week: Optional['RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayPropertiesDayOfWeek'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if day_of_month is not None:
            _setter("day_of_month", day_of_month)
        if day_of_week is not None:
            _setter("day_of_week", day_of_week)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[str]:
        """
        <p>The Day Of Month for scheduled refresh.</p>
        """
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional['RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayPropertiesDayOfWeek']:
        return pulumi.get(self, "day_of_week")


@pulumi.output_type
class TemplateAggregationFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeAggregationFunction":
            suggest = "attribute_aggregation_function"
        elif key == "categoricalAggregationFunction":
            suggest = "categorical_aggregation_function"
        elif key == "dateAggregationFunction":
            suggest = "date_aggregation_function"
        elif key == "numericalAggregationFunction":
            suggest = "numerical_aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAggregationFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAggregationFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAggregationFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_aggregation_function: Optional['outputs.TemplateAttributeAggregationFunction'] = None,
                 categorical_aggregation_function: Optional['TemplateCategoricalAggregationFunction'] = None,
                 date_aggregation_function: Optional['TemplateDateAggregationFunction'] = None,
                 numerical_aggregation_function: Optional['outputs.TemplateNumericalAggregationFunction'] = None):
        TemplateAggregationFunction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_aggregation_function=attribute_aggregation_function,
            categorical_aggregation_function=categorical_aggregation_function,
            date_aggregation_function=date_aggregation_function,
            numerical_aggregation_function=numerical_aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_aggregation_function: Optional['outputs.TemplateAttributeAggregationFunction'] = None,
             categorical_aggregation_function: Optional['TemplateCategoricalAggregationFunction'] = None,
             date_aggregation_function: Optional['TemplateDateAggregationFunction'] = None,
             numerical_aggregation_function: Optional['outputs.TemplateNumericalAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attribute_aggregation_function is not None:
            _setter("attribute_aggregation_function", attribute_aggregation_function)
        if categorical_aggregation_function is not None:
            _setter("categorical_aggregation_function", categorical_aggregation_function)
        if date_aggregation_function is not None:
            _setter("date_aggregation_function", date_aggregation_function)
        if numerical_aggregation_function is not None:
            _setter("numerical_aggregation_function", numerical_aggregation_function)

    @property
    @pulumi.getter(name="attributeAggregationFunction")
    def attribute_aggregation_function(self) -> Optional['outputs.TemplateAttributeAggregationFunction']:
        return pulumi.get(self, "attribute_aggregation_function")

    @property
    @pulumi.getter(name="categoricalAggregationFunction")
    def categorical_aggregation_function(self) -> Optional['TemplateCategoricalAggregationFunction']:
        return pulumi.get(self, "categorical_aggregation_function")

    @property
    @pulumi.getter(name="dateAggregationFunction")
    def date_aggregation_function(self) -> Optional['TemplateDateAggregationFunction']:
        return pulumi.get(self, "date_aggregation_function")

    @property
    @pulumi.getter(name="numericalAggregationFunction")
    def numerical_aggregation_function(self) -> Optional['outputs.TemplateNumericalAggregationFunction']:
        return pulumi.get(self, "numerical_aggregation_function")


@pulumi.output_type
class TemplateAggregationSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortDirection":
            suggest = "sort_direction"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAggregationSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAggregationSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAggregationSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 sort_direction: 'TemplateSortDirection',
                 aggregation_function: Optional['outputs.TemplateAggregationFunction'] = None):
        TemplateAggregationSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            sort_direction=sort_direction,
            aggregation_function=aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             sort_direction: 'TemplateSortDirection',
             aggregation_function: Optional['outputs.TemplateAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("sort_direction", sort_direction)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="sortDirection")
    def sort_direction(self) -> 'TemplateSortDirection':
        return pulumi.get(self, "sort_direction")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.TemplateAggregationFunction']:
        return pulumi.get(self, "aggregation_function")


@pulumi.output_type
class TemplateAllSheetsFilterScopeConfiguration(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class TemplateAnalysisDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultNewSheetConfiguration":
            suggest = "default_new_sheet_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAnalysisDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAnalysisDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAnalysisDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_new_sheet_configuration: 'outputs.TemplateDefaultNewSheetConfiguration'):
        TemplateAnalysisDefaults._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_new_sheet_configuration=default_new_sheet_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_new_sheet_configuration: 'outputs.TemplateDefaultNewSheetConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_new_sheet_configuration", default_new_sheet_configuration)

    @property
    @pulumi.getter(name="defaultNewSheetConfiguration")
    def default_new_sheet_configuration(self) -> 'outputs.TemplateDefaultNewSheetConfiguration':
        return pulumi.get(self, "default_new_sheet_configuration")


@pulumi.output_type
class TemplateAnchorDateConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anchorOption":
            suggest = "anchor_option"
        elif key == "parameterName":
            suggest = "parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAnchorDateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAnchorDateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAnchorDateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anchor_option: Optional['TemplateAnchorOption'] = None,
                 parameter_name: Optional[str] = None):
        TemplateAnchorDateConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            anchor_option=anchor_option,
            parameter_name=parameter_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             anchor_option: Optional['TemplateAnchorOption'] = None,
             parameter_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if anchor_option is not None:
            _setter("anchor_option", anchor_option)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)

    @property
    @pulumi.getter(name="anchorOption")
    def anchor_option(self) -> Optional['TemplateAnchorOption']:
        return pulumi.get(self, "anchor_option")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")


@pulumi.output_type
class TemplateArcAxisConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reserveRange":
            suggest = "reserve_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateArcAxisConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateArcAxisConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateArcAxisConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range: Optional['outputs.TemplateArcAxisDisplayRange'] = None,
                 reserve_range: Optional[float] = None):
        TemplateArcAxisConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            range=range,
            reserve_range=reserve_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             range: Optional['outputs.TemplateArcAxisDisplayRange'] = None,
             reserve_range: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if range is not None:
            _setter("range", range)
        if reserve_range is not None:
            _setter("reserve_range", reserve_range)

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.TemplateArcAxisDisplayRange']:
        return pulumi.get(self, "range")

    @property
    @pulumi.getter(name="reserveRange")
    def reserve_range(self) -> Optional[float]:
        return pulumi.get(self, "reserve_range")


@pulumi.output_type
class TemplateArcAxisDisplayRange(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        TemplateArcAxisDisplayRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class TemplateArcConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcAngle":
            suggest = "arc_angle"
        elif key == "arcThickness":
            suggest = "arc_thickness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateArcConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateArcConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateArcConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc_angle: Optional[float] = None,
                 arc_thickness: Optional['TemplateArcThicknessOptions'] = None):
        TemplateArcConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc_angle=arc_angle,
            arc_thickness=arc_thickness,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc_angle: Optional[float] = None,
             arc_thickness: Optional['TemplateArcThicknessOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc_angle is not None:
            _setter("arc_angle", arc_angle)
        if arc_thickness is not None:
            _setter("arc_thickness", arc_thickness)

    @property
    @pulumi.getter(name="arcAngle")
    def arc_angle(self) -> Optional[float]:
        return pulumi.get(self, "arc_angle")

    @property
    @pulumi.getter(name="arcThickness")
    def arc_thickness(self) -> Optional['TemplateArcThicknessOptions']:
        return pulumi.get(self, "arc_thickness")


@pulumi.output_type
class TemplateArcOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcThickness":
            suggest = "arc_thickness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateArcOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateArcOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateArcOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc_thickness: Optional['TemplateArcThickness'] = None):
        TemplateArcOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc_thickness=arc_thickness,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc_thickness: Optional['TemplateArcThickness'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc_thickness is not None:
            _setter("arc_thickness", arc_thickness)

    @property
    @pulumi.getter(name="arcThickness")
    def arc_thickness(self) -> Optional['TemplateArcThickness']:
        return pulumi.get(self, "arc_thickness")


@pulumi.output_type
class TemplateAttributeAggregationFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simpleAttributeAggregation":
            suggest = "simple_attribute_aggregation"
        elif key == "valueForMultipleValues":
            suggest = "value_for_multiple_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAttributeAggregationFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAttributeAggregationFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAttributeAggregationFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 simple_attribute_aggregation: Optional['TemplateSimpleAttributeAggregationFunction'] = None,
                 value_for_multiple_values: Optional[str] = None):
        TemplateAttributeAggregationFunction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            simple_attribute_aggregation=simple_attribute_aggregation,
            value_for_multiple_values=value_for_multiple_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             simple_attribute_aggregation: Optional['TemplateSimpleAttributeAggregationFunction'] = None,
             value_for_multiple_values: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if simple_attribute_aggregation is not None:
            _setter("simple_attribute_aggregation", simple_attribute_aggregation)
        if value_for_multiple_values is not None:
            _setter("value_for_multiple_values", value_for_multiple_values)

    @property
    @pulumi.getter(name="simpleAttributeAggregation")
    def simple_attribute_aggregation(self) -> Optional['TemplateSimpleAttributeAggregationFunction']:
        return pulumi.get(self, "simple_attribute_aggregation")

    @property
    @pulumi.getter(name="valueForMultipleValues")
    def value_for_multiple_values(self) -> Optional[str]:
        return pulumi.get(self, "value_for_multiple_values")


@pulumi.output_type
class TemplateAxisDataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateAxisOptions":
            suggest = "date_axis_options"
        elif key == "numericAxisOptions":
            suggest = "numeric_axis_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAxisDataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAxisDataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAxisDataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_axis_options: Optional['outputs.TemplateDateAxisOptions'] = None,
                 numeric_axis_options: Optional['outputs.TemplateNumericAxisOptions'] = None):
        TemplateAxisDataOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_axis_options=date_axis_options,
            numeric_axis_options=numeric_axis_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_axis_options: Optional['outputs.TemplateDateAxisOptions'] = None,
             numeric_axis_options: Optional['outputs.TemplateNumericAxisOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_axis_options is not None:
            _setter("date_axis_options", date_axis_options)
        if numeric_axis_options is not None:
            _setter("numeric_axis_options", numeric_axis_options)

    @property
    @pulumi.getter(name="dateAxisOptions")
    def date_axis_options(self) -> Optional['outputs.TemplateDateAxisOptions']:
        return pulumi.get(self, "date_axis_options")

    @property
    @pulumi.getter(name="numericAxisOptions")
    def numeric_axis_options(self) -> Optional['outputs.TemplateNumericAxisOptions']:
        return pulumi.get(self, "numeric_axis_options")


@pulumi.output_type
class TemplateAxisDisplayDataDrivenRange(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class TemplateAxisDisplayMinMaxRange(dict):
    def __init__(__self__, *,
                 maximum: Optional[float] = None,
                 minimum: Optional[float] = None):
        TemplateAxisDisplayMinMaxRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum=maximum,
            minimum=minimum,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum: Optional[float] = None,
             minimum: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if maximum is not None:
            _setter("maximum", maximum)
        if minimum is not None:
            _setter("minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[float]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[float]:
        return pulumi.get(self, "minimum")


@pulumi.output_type
class TemplateAxisDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisLineVisibility":
            suggest = "axis_line_visibility"
        elif key == "axisOffset":
            suggest = "axis_offset"
        elif key == "dataOptions":
            suggest = "data_options"
        elif key == "gridLineVisibility":
            suggest = "grid_line_visibility"
        elif key == "scrollbarOptions":
            suggest = "scrollbar_options"
        elif key == "tickLabelOptions":
            suggest = "tick_label_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAxisDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAxisDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAxisDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_line_visibility: Optional['TemplateVisibility'] = None,
                 axis_offset: Optional[str] = None,
                 data_options: Optional['outputs.TemplateAxisDataOptions'] = None,
                 grid_line_visibility: Optional['TemplateVisibility'] = None,
                 scrollbar_options: Optional['outputs.TemplateScrollBarOptions'] = None,
                 tick_label_options: Optional['outputs.TemplateAxisTickLabelOptions'] = None):
        """
        :param str axis_offset: String based length that is composed of value and unit in px
        """
        TemplateAxisDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_line_visibility=axis_line_visibility,
            axis_offset=axis_offset,
            data_options=data_options,
            grid_line_visibility=grid_line_visibility,
            scrollbar_options=scrollbar_options,
            tick_label_options=tick_label_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_line_visibility: Optional['TemplateVisibility'] = None,
             axis_offset: Optional[str] = None,
             data_options: Optional['outputs.TemplateAxisDataOptions'] = None,
             grid_line_visibility: Optional['TemplateVisibility'] = None,
             scrollbar_options: Optional['outputs.TemplateScrollBarOptions'] = None,
             tick_label_options: Optional['outputs.TemplateAxisTickLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_line_visibility is not None:
            _setter("axis_line_visibility", axis_line_visibility)
        if axis_offset is not None:
            _setter("axis_offset", axis_offset)
        if data_options is not None:
            _setter("data_options", data_options)
        if grid_line_visibility is not None:
            _setter("grid_line_visibility", grid_line_visibility)
        if scrollbar_options is not None:
            _setter("scrollbar_options", scrollbar_options)
        if tick_label_options is not None:
            _setter("tick_label_options", tick_label_options)

    @property
    @pulumi.getter(name="axisLineVisibility")
    def axis_line_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "axis_line_visibility")

    @property
    @pulumi.getter(name="axisOffset")
    def axis_offset(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "axis_offset")

    @property
    @pulumi.getter(name="dataOptions")
    def data_options(self) -> Optional['outputs.TemplateAxisDataOptions']:
        return pulumi.get(self, "data_options")

    @property
    @pulumi.getter(name="gridLineVisibility")
    def grid_line_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "grid_line_visibility")

    @property
    @pulumi.getter(name="scrollbarOptions")
    def scrollbar_options(self) -> Optional['outputs.TemplateScrollBarOptions']:
        return pulumi.get(self, "scrollbar_options")

    @property
    @pulumi.getter(name="tickLabelOptions")
    def tick_label_options(self) -> Optional['outputs.TemplateAxisTickLabelOptions']:
        return pulumi.get(self, "tick_label_options")


@pulumi.output_type
class TemplateAxisDisplayRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDriven":
            suggest = "data_driven"
        elif key == "minMax":
            suggest = "min_max"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAxisDisplayRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAxisDisplayRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAxisDisplayRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_driven: Optional['outputs.TemplateAxisDisplayDataDrivenRange'] = None,
                 min_max: Optional['outputs.TemplateAxisDisplayMinMaxRange'] = None):
        TemplateAxisDisplayRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_driven=data_driven,
            min_max=min_max,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_driven: Optional['outputs.TemplateAxisDisplayDataDrivenRange'] = None,
             min_max: Optional['outputs.TemplateAxisDisplayMinMaxRange'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_driven is not None:
            _setter("data_driven", data_driven)
        if min_max is not None:
            _setter("min_max", min_max)

    @property
    @pulumi.getter(name="dataDriven")
    def data_driven(self) -> Optional['outputs.TemplateAxisDisplayDataDrivenRange']:
        return pulumi.get(self, "data_driven")

    @property
    @pulumi.getter(name="minMax")
    def min_max(self) -> Optional['outputs.TemplateAxisDisplayMinMaxRange']:
        return pulumi.get(self, "min_max")


@pulumi.output_type
class TemplateAxisLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyTo":
            suggest = "apply_to"
        elif key == "customLabel":
            suggest = "custom_label"
        elif key == "fontConfiguration":
            suggest = "font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAxisLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAxisLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAxisLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_to: Optional['outputs.TemplateAxisLabelReferenceOptions'] = None,
                 custom_label: Optional[str] = None,
                 font_configuration: Optional['outputs.TemplateFontConfiguration'] = None):
        TemplateAxisLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apply_to=apply_to,
            custom_label=custom_label,
            font_configuration=font_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apply_to: Optional['outputs.TemplateAxisLabelReferenceOptions'] = None,
             custom_label: Optional[str] = None,
             font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apply_to is not None:
            _setter("apply_to", apply_to)
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)

    @property
    @pulumi.getter(name="applyTo")
    def apply_to(self) -> Optional['outputs.TemplateAxisLabelReferenceOptions']:
        return pulumi.get(self, "apply_to")

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.TemplateFontConfiguration']:
        return pulumi.get(self, "font_configuration")


@pulumi.output_type
class TemplateAxisLabelReferenceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAxisLabelReferenceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAxisLabelReferenceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAxisLabelReferenceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 field_id: str):
        TemplateAxisLabelReferenceOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class TemplateAxisLinearScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stepCount":
            suggest = "step_count"
        elif key == "stepSize":
            suggest = "step_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAxisLinearScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAxisLinearScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAxisLinearScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 step_count: Optional[float] = None,
                 step_size: Optional[float] = None):
        TemplateAxisLinearScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            step_count=step_count,
            step_size=step_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             step_count: Optional[float] = None,
             step_size: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if step_count is not None:
            _setter("step_count", step_count)
        if step_size is not None:
            _setter("step_size", step_size)

    @property
    @pulumi.getter(name="stepCount")
    def step_count(self) -> Optional[float]:
        return pulumi.get(self, "step_count")

    @property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> Optional[float]:
        return pulumi.get(self, "step_size")


@pulumi.output_type
class TemplateAxisLogarithmicScale(dict):
    def __init__(__self__, *,
                 base: Optional[float] = None):
        TemplateAxisLogarithmicScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base=base,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if base is not None:
            _setter("base", base)

    @property
    @pulumi.getter
    def base(self) -> Optional[float]:
        return pulumi.get(self, "base")


@pulumi.output_type
class TemplateAxisScale(dict):
    def __init__(__self__, *,
                 linear: Optional['outputs.TemplateAxisLinearScale'] = None,
                 logarithmic: Optional['outputs.TemplateAxisLogarithmicScale'] = None):
        TemplateAxisScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            linear=linear,
            logarithmic=logarithmic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             linear: Optional['outputs.TemplateAxisLinearScale'] = None,
             logarithmic: Optional['outputs.TemplateAxisLogarithmicScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if linear is not None:
            _setter("linear", linear)
        if logarithmic is not None:
            _setter("logarithmic", logarithmic)

    @property
    @pulumi.getter
    def linear(self) -> Optional['outputs.TemplateAxisLinearScale']:
        return pulumi.get(self, "linear")

    @property
    @pulumi.getter
    def logarithmic(self) -> Optional['outputs.TemplateAxisLogarithmicScale']:
        return pulumi.get(self, "logarithmic")


@pulumi.output_type
class TemplateAxisTickLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelOptions":
            suggest = "label_options"
        elif key == "rotationAngle":
            suggest = "rotation_angle"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateAxisTickLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateAxisTickLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateAxisTickLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_options: Optional['outputs.TemplateLabelOptions'] = None,
                 rotation_angle: Optional[float] = None):
        TemplateAxisTickLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_options=label_options,
            rotation_angle=rotation_angle,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_options: Optional['outputs.TemplateLabelOptions'] = None,
             rotation_angle: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if label_options is not None:
            _setter("label_options", label_options)
        if rotation_angle is not None:
            _setter("rotation_angle", rotation_angle)

    @property
    @pulumi.getter(name="labelOptions")
    def label_options(self) -> Optional['outputs.TemplateLabelOptions']:
        return pulumi.get(self, "label_options")

    @property
    @pulumi.getter(name="rotationAngle")
    def rotation_angle(self) -> Optional[float]:
        return pulumi.get(self, "rotation_angle")


@pulumi.output_type
class TemplateBarChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "smallMultiples":
            suggest = "small_multiples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBarChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBarChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBarChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 colors: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 small_multiples: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateBarChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            colors=colors,
            small_multiples=small_multiples,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             colors: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             small_multiples: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if colors is not None:
            _setter("colors", colors)
        if small_multiples is not None:
            _setter("small_multiples", small_multiples)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="smallMultiples")
    def small_multiples(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "small_multiples")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateBarChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barsArrangement":
            suggest = "bars_arrangement"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "contributionAnalysisDefaults":
            suggest = "contribution_analysis_defaults"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "smallMultiplesOptions":
            suggest = "small_multiples_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "valueAxis":
            suggest = "value_axis"
        elif key == "valueLabelOptions":
            suggest = "value_label_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBarChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBarChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBarChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bars_arrangement: Optional['TemplateBarsArrangement'] = None,
                 category_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 color_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 contribution_analysis_defaults: Optional[Sequence['outputs.TemplateContributionAnalysisDefault']] = None,
                 data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateBarChartFieldWells'] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 orientation: Optional['TemplateBarChartOrientation'] = None,
                 reference_lines: Optional[Sequence['outputs.TemplateReferenceLine']] = None,
                 small_multiples_options: Optional['outputs.TemplateSmallMultiplesOptions'] = None,
                 sort_configuration: Optional['outputs.TemplateBarChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
                 value_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 value_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None):
        TemplateBarChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bars_arrangement=bars_arrangement,
            category_axis=category_axis,
            category_label_options=category_label_options,
            color_label_options=color_label_options,
            contribution_analysis_defaults=contribution_analysis_defaults,
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            orientation=orientation,
            reference_lines=reference_lines,
            small_multiples_options=small_multiples_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            value_axis=value_axis,
            value_label_options=value_label_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bars_arrangement: Optional['TemplateBarsArrangement'] = None,
             category_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             color_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             contribution_analysis_defaults: Optional[Sequence['outputs.TemplateContributionAnalysisDefault']] = None,
             data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateBarChartFieldWells'] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             orientation: Optional['TemplateBarChartOrientation'] = None,
             reference_lines: Optional[Sequence['outputs.TemplateReferenceLine']] = None,
             small_multiples_options: Optional['outputs.TemplateSmallMultiplesOptions'] = None,
             sort_configuration: Optional['outputs.TemplateBarChartSortConfiguration'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             value_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             value_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bars_arrangement is not None:
            _setter("bars_arrangement", bars_arrangement)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if contribution_analysis_defaults is not None:
            _setter("contribution_analysis_defaults", contribution_analysis_defaults)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if orientation is not None:
            _setter("orientation", orientation)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if small_multiples_options is not None:
            _setter("small_multiples_options", small_multiples_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if value_axis is not None:
            _setter("value_axis", value_axis)
        if value_label_options is not None:
            _setter("value_label_options", value_label_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="barsArrangement")
    def bars_arrangement(self) -> Optional['TemplateBarsArrangement']:
        return pulumi.get(self, "bars_arrangement")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="contributionAnalysisDefaults")
    def contribution_analysis_defaults(self) -> Optional[Sequence['outputs.TemplateContributionAnalysisDefault']]:
        return pulumi.get(self, "contribution_analysis_defaults")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateBarChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter
    def orientation(self) -> Optional['TemplateBarChartOrientation']:
        return pulumi.get(self, "orientation")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.TemplateReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="smallMultiplesOptions")
    def small_multiples_options(self) -> Optional['outputs.TemplateSmallMultiplesOptions']:
        return pulumi.get(self, "small_multiples_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateBarChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="valueAxis")
    def value_axis(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "value_axis")

    @property
    @pulumi.getter(name="valueLabelOptions")
    def value_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "value_label_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class TemplateBarChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barChartAggregatedFieldWells":
            suggest = "bar_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBarChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBarChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBarChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_chart_aggregated_field_wells: Optional['outputs.TemplateBarChartAggregatedFieldWells'] = None):
        TemplateBarChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_chart_aggregated_field_wells=bar_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_chart_aggregated_field_wells: Optional['outputs.TemplateBarChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_chart_aggregated_field_wells is not None:
            _setter("bar_chart_aggregated_field_wells", bar_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="barChartAggregatedFieldWells")
    def bar_chart_aggregated_field_wells(self) -> Optional['outputs.TemplateBarChartAggregatedFieldWells']:
        return pulumi.get(self, "bar_chart_aggregated_field_wells")


@pulumi.output_type
class TemplateBarChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimit":
            suggest = "color_items_limit"
        elif key == "colorSort":
            suggest = "color_sort"
        elif key == "smallMultiplesLimitConfiguration":
            suggest = "small_multiples_limit_configuration"
        elif key == "smallMultiplesSort":
            suggest = "small_multiples_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBarChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBarChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBarChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
                 color_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 color_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
                 small_multiples_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 small_multiples_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateBarChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            color_items_limit=color_items_limit,
            color_sort=color_sort,
            small_multiples_limit_configuration=small_multiples_limit_configuration,
            small_multiples_sort=small_multiples_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             color_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             color_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             small_multiples_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             small_multiples_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit is not None:
            _setter("color_items_limit", color_items_limit)
        if color_sort is not None:
            _setter("color_sort", color_sort)
        if small_multiples_limit_configuration is not None:
            _setter("small_multiples_limit_configuration", small_multiples_limit_configuration)
        if small_multiples_sort is not None:
            _setter("small_multiples_sort", small_multiples_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimit")
    def color_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit")

    @property
    @pulumi.getter(name="colorSort")
    def color_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "color_sort")

    @property
    @pulumi.getter(name="smallMultiplesLimitConfiguration")
    def small_multiples_limit_configuration(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "small_multiples_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesSort")
    def small_multiples_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "small_multiples_sort")


@pulumi.output_type
class TemplateBarChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBarChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBarChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBarChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateBarChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateBarChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateBarChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateBarChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateBinCountOptions(dict):
    def __init__(__self__, *,
                 value: Optional[float] = None):
        TemplateBinCountOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateBinWidthOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binCountLimit":
            suggest = "bin_count_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBinWidthOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBinWidthOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBinWidthOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bin_count_limit: Optional[float] = None,
                 value: Optional[float] = None):
        TemplateBinWidthOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bin_count_limit=bin_count_limit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bin_count_limit: Optional[float] = None,
             value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bin_count_limit is not None:
            _setter("bin_count_limit", bin_count_limit)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="binCountLimit")
    def bin_count_limit(self) -> Optional[float]:
        return pulumi.get(self, "bin_count_limit")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateBodySectionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionId":
            suggest = "section_id"
        elif key == "pageBreakConfiguration":
            suggest = "page_break_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBodySectionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBodySectionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBodySectionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: 'outputs.TemplateBodySectionContent',
                 section_id: str,
                 page_break_configuration: Optional['outputs.TemplateSectionPageBreakConfiguration'] = None,
                 style: Optional['outputs.TemplateSectionStyle'] = None):
        TemplateBodySectionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            section_id=section_id,
            page_break_configuration=page_break_configuration,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: 'outputs.TemplateBodySectionContent',
             section_id: str,
             page_break_configuration: Optional['outputs.TemplateSectionPageBreakConfiguration'] = None,
             style: Optional['outputs.TemplateSectionStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        _setter("section_id", section_id)
        if page_break_configuration is not None:
            _setter("page_break_configuration", page_break_configuration)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter
    def content(self) -> 'outputs.TemplateBodySectionContent':
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="sectionId")
    def section_id(self) -> str:
        return pulumi.get(self, "section_id")

    @property
    @pulumi.getter(name="pageBreakConfiguration")
    def page_break_configuration(self) -> Optional['outputs.TemplateSectionPageBreakConfiguration']:
        return pulumi.get(self, "page_break_configuration")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.TemplateSectionStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class TemplateBodySectionContent(dict):
    def __init__(__self__, *,
                 layout: Optional['outputs.TemplateSectionLayoutConfiguration'] = None):
        TemplateBodySectionContent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            layout=layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             layout: Optional['outputs.TemplateSectionLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if layout is not None:
            _setter("layout", layout)

    @property
    @pulumi.getter
    def layout(self) -> Optional['outputs.TemplateSectionLayoutConfiguration']:
        return pulumi.get(self, "layout")


@pulumi.output_type
class TemplateBoxPlotAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBoxPlotAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBoxPlotAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBoxPlotAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_by: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateBoxPlotAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_by=group_by,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_by: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_by is not None:
            _setter("group_by", group_by)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateBoxPlotChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boxPlotOptions":
            suggest = "box_plot_options"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBoxPlotChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBoxPlotChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBoxPlotChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 box_plot_options: Optional['outputs.TemplateBoxPlotOptions'] = None,
                 category_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateBoxPlotFieldWells'] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 reference_lines: Optional[Sequence['outputs.TemplateReferenceLine']] = None,
                 sort_configuration: Optional['outputs.TemplateBoxPlotSortConfiguration'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None):
        TemplateBoxPlotChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            box_plot_options=box_plot_options,
            category_axis=category_axis,
            category_label_options=category_label_options,
            field_wells=field_wells,
            legend=legend,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            reference_lines=reference_lines,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             box_plot_options: Optional['outputs.TemplateBoxPlotOptions'] = None,
             category_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateBoxPlotFieldWells'] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             reference_lines: Optional[Sequence['outputs.TemplateReferenceLine']] = None,
             sort_configuration: Optional['outputs.TemplateBoxPlotSortConfiguration'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if box_plot_options is not None:
            _setter("box_plot_options", box_plot_options)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="boxPlotOptions")
    def box_plot_options(self) -> Optional['outputs.TemplateBoxPlotOptions']:
        return pulumi.get(self, "box_plot_options")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateBoxPlotFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.TemplateReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateBoxPlotSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class TemplateBoxPlotFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boxPlotAggregatedFieldWells":
            suggest = "box_plot_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBoxPlotFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBoxPlotFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBoxPlotFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 box_plot_aggregated_field_wells: Optional['outputs.TemplateBoxPlotAggregatedFieldWells'] = None):
        TemplateBoxPlotFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            box_plot_aggregated_field_wells=box_plot_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             box_plot_aggregated_field_wells: Optional['outputs.TemplateBoxPlotAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if box_plot_aggregated_field_wells is not None:
            _setter("box_plot_aggregated_field_wells", box_plot_aggregated_field_wells)

    @property
    @pulumi.getter(name="boxPlotAggregatedFieldWells")
    def box_plot_aggregated_field_wells(self) -> Optional['outputs.TemplateBoxPlotAggregatedFieldWells']:
        return pulumi.get(self, "box_plot_aggregated_field_wells")


@pulumi.output_type
class TemplateBoxPlotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allDataPointsVisibility":
            suggest = "all_data_points_visibility"
        elif key == "outlierVisibility":
            suggest = "outlier_visibility"
        elif key == "styleOptions":
            suggest = "style_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBoxPlotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBoxPlotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBoxPlotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_data_points_visibility: Optional['TemplateVisibility'] = None,
                 outlier_visibility: Optional['TemplateVisibility'] = None,
                 style_options: Optional['outputs.TemplateBoxPlotStyleOptions'] = None):
        TemplateBoxPlotOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_data_points_visibility=all_data_points_visibility,
            outlier_visibility=outlier_visibility,
            style_options=style_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_data_points_visibility: Optional['TemplateVisibility'] = None,
             outlier_visibility: Optional['TemplateVisibility'] = None,
             style_options: Optional['outputs.TemplateBoxPlotStyleOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_data_points_visibility is not None:
            _setter("all_data_points_visibility", all_data_points_visibility)
        if outlier_visibility is not None:
            _setter("outlier_visibility", outlier_visibility)
        if style_options is not None:
            _setter("style_options", style_options)

    @property
    @pulumi.getter(name="allDataPointsVisibility")
    def all_data_points_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "all_data_points_visibility")

    @property
    @pulumi.getter(name="outlierVisibility")
    def outlier_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "outlier_visibility")

    @property
    @pulumi.getter(name="styleOptions")
    def style_options(self) -> Optional['outputs.TemplateBoxPlotStyleOptions']:
        return pulumi.get(self, "style_options")


@pulumi.output_type
class TemplateBoxPlotSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categorySort":
            suggest = "category_sort"
        elif key == "paginationConfiguration":
            suggest = "pagination_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBoxPlotSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBoxPlotSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBoxPlotSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
                 pagination_configuration: Optional['outputs.TemplatePaginationConfiguration'] = None):
        TemplateBoxPlotSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_sort=category_sort,
            pagination_configuration=pagination_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             pagination_configuration: Optional['outputs.TemplatePaginationConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if pagination_configuration is not None:
            _setter("pagination_configuration", pagination_configuration)

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="paginationConfiguration")
    def pagination_configuration(self) -> Optional['outputs.TemplatePaginationConfiguration']:
        return pulumi.get(self, "pagination_configuration")


@pulumi.output_type
class TemplateBoxPlotStyleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillStyle":
            suggest = "fill_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBoxPlotStyleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBoxPlotStyleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBoxPlotStyleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fill_style: Optional['TemplateBoxPlotFillStyle'] = None):
        TemplateBoxPlotStyleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fill_style=fill_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fill_style: Optional['TemplateBoxPlotFillStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if fill_style is not None:
            _setter("fill_style", fill_style)

    @property
    @pulumi.getter(name="fillStyle")
    def fill_style(self) -> Optional['TemplateBoxPlotFillStyle']:
        return pulumi.get(self, "fill_style")


@pulumi.output_type
class TemplateBoxPlotVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateBoxPlotVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateBoxPlotVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateBoxPlotVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateBoxPlotChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateBoxPlotVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateBoxPlotChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateBoxPlotChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateCalculatedField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCalculatedField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCalculatedField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCalculatedField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 expression: str,
                 name: str):
        TemplateCalculatedField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            expression=expression,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             expression: str,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("expression", expression)
        _setter("name", name)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class TemplateCalculatedMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCalculatedMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCalculatedMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCalculatedMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 field_id: str):
        TemplateCalculatedMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        _setter("field_id", field_id)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class TemplateCascadingControlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceControls":
            suggest = "source_controls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCascadingControlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCascadingControlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCascadingControlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_controls: Optional[Sequence['outputs.TemplateCascadingControlSource']] = None):
        TemplateCascadingControlConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_controls=source_controls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_controls: Optional[Sequence['outputs.TemplateCascadingControlSource']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if source_controls is not None:
            _setter("source_controls", source_controls)

    @property
    @pulumi.getter(name="sourceControls")
    def source_controls(self) -> Optional[Sequence['outputs.TemplateCascadingControlSource']]:
        return pulumi.get(self, "source_controls")


@pulumi.output_type
class TemplateCascadingControlSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnToMatch":
            suggest = "column_to_match"
        elif key == "sourceSheetControlId":
            suggest = "source_sheet_control_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCascadingControlSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCascadingControlSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCascadingControlSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_to_match: Optional['outputs.TemplateColumnIdentifier'] = None,
                 source_sheet_control_id: Optional[str] = None):
        TemplateCascadingControlSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_to_match=column_to_match,
            source_sheet_control_id=source_sheet_control_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_to_match: Optional['outputs.TemplateColumnIdentifier'] = None,
             source_sheet_control_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_to_match is not None:
            _setter("column_to_match", column_to_match)
        if source_sheet_control_id is not None:
            _setter("source_sheet_control_id", source_sheet_control_id)

    @property
    @pulumi.getter(name="columnToMatch")
    def column_to_match(self) -> Optional['outputs.TemplateColumnIdentifier']:
        return pulumi.get(self, "column_to_match")

    @property
    @pulumi.getter(name="sourceSheetControlId")
    def source_sheet_control_id(self) -> Optional[str]:
        return pulumi.get(self, "source_sheet_control_id")


@pulumi.output_type
class TemplateCategoricalDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "hierarchyId":
            suggest = "hierarchy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCategoricalDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCategoricalDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCategoricalDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 field_id: str,
                 format_configuration: Optional['outputs.TemplateStringFormatConfiguration'] = None,
                 hierarchy_id: Optional[str] = None):
        TemplateCategoricalDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            format_configuration=format_configuration,
            hierarchy_id=hierarchy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             field_id: str,
             format_configuration: Optional['outputs.TemplateStringFormatConfiguration'] = None,
             hierarchy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if hierarchy_id is not None:
            _setter("hierarchy_id", hierarchy_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.TemplateStringFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> Optional[str]:
        return pulumi.get(self, "hierarchy_id")


@pulumi.output_type
class TemplateCategoricalMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCategoricalMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCategoricalMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCategoricalMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 field_id: str,
                 aggregation_function: Optional['TemplateCategoricalAggregationFunction'] = None,
                 format_configuration: Optional['outputs.TemplateStringFormatConfiguration'] = None):
        TemplateCategoricalMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            aggregation_function=aggregation_function,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             field_id: str,
             aggregation_function: Optional['TemplateCategoricalAggregationFunction'] = None,
             format_configuration: Optional['outputs.TemplateStringFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['TemplateCategoricalAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.TemplateStringFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class TemplateCategoryDrillDownFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryValues":
            suggest = "category_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCategoryDrillDownFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCategoryDrillDownFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCategoryDrillDownFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_values: Sequence[str],
                 column: 'outputs.TemplateColumnIdentifier'):
        TemplateCategoryDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_values=category_values,
            column=column,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_values: Sequence[str],
             column: 'outputs.TemplateColumnIdentifier',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("category_values", category_values)
        _setter("column", column)

    @property
    @pulumi.getter(name="categoryValues")
    def category_values(self) -> Sequence[str]:
        return pulumi.get(self, "category_values")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")


@pulumi.output_type
class TemplateCategoryFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCategoryFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCategoryFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCategoryFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 configuration: 'outputs.TemplateCategoryFilterConfiguration',
                 filter_id: str):
        TemplateCategoryFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            configuration=configuration,
            filter_id=filter_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             configuration: 'outputs.TemplateCategoryFilterConfiguration',
             filter_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("configuration", configuration)
        _setter("filter_id", filter_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.TemplateCategoryFilterConfiguration':
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")


@pulumi.output_type
class TemplateCategoryFilterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customFilterConfiguration":
            suggest = "custom_filter_configuration"
        elif key == "customFilterListConfiguration":
            suggest = "custom_filter_list_configuration"
        elif key == "filterListConfiguration":
            suggest = "filter_list_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCategoryFilterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCategoryFilterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCategoryFilterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_filter_configuration: Optional['outputs.TemplateCustomFilterConfiguration'] = None,
                 custom_filter_list_configuration: Optional['outputs.TemplateCustomFilterListConfiguration'] = None,
                 filter_list_configuration: Optional['outputs.TemplateFilterListConfiguration'] = None):
        TemplateCategoryFilterConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_filter_configuration=custom_filter_configuration,
            custom_filter_list_configuration=custom_filter_list_configuration,
            filter_list_configuration=filter_list_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_filter_configuration: Optional['outputs.TemplateCustomFilterConfiguration'] = None,
             custom_filter_list_configuration: Optional['outputs.TemplateCustomFilterListConfiguration'] = None,
             filter_list_configuration: Optional['outputs.TemplateFilterListConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_filter_configuration is not None:
            _setter("custom_filter_configuration", custom_filter_configuration)
        if custom_filter_list_configuration is not None:
            _setter("custom_filter_list_configuration", custom_filter_list_configuration)
        if filter_list_configuration is not None:
            _setter("filter_list_configuration", filter_list_configuration)

    @property
    @pulumi.getter(name="customFilterConfiguration")
    def custom_filter_configuration(self) -> Optional['outputs.TemplateCustomFilterConfiguration']:
        return pulumi.get(self, "custom_filter_configuration")

    @property
    @pulumi.getter(name="customFilterListConfiguration")
    def custom_filter_list_configuration(self) -> Optional['outputs.TemplateCustomFilterListConfiguration']:
        return pulumi.get(self, "custom_filter_list_configuration")

    @property
    @pulumi.getter(name="filterListConfiguration")
    def filter_list_configuration(self) -> Optional['outputs.TemplateFilterListConfiguration']:
        return pulumi.get(self, "filter_list_configuration")


@pulumi.output_type
class TemplateChartAxisLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisLabelOptions":
            suggest = "axis_label_options"
        elif key == "sortIconVisibility":
            suggest = "sort_icon_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateChartAxisLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateChartAxisLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateChartAxisLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_label_options: Optional[Sequence['outputs.TemplateAxisLabelOptions']] = None,
                 sort_icon_visibility: Optional['TemplateVisibility'] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateChartAxisLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_label_options=axis_label_options,
            sort_icon_visibility=sort_icon_visibility,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_label_options: Optional[Sequence['outputs.TemplateAxisLabelOptions']] = None,
             sort_icon_visibility: Optional['TemplateVisibility'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_label_options is not None:
            _setter("axis_label_options", axis_label_options)
        if sort_icon_visibility is not None:
            _setter("sort_icon_visibility", sort_icon_visibility)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="axisLabelOptions")
    def axis_label_options(self) -> Optional[Sequence['outputs.TemplateAxisLabelOptions']]:
        return pulumi.get(self, "axis_label_options")

    @property
    @pulumi.getter(name="sortIconVisibility")
    def sort_icon_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "sort_icon_visibility")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateClusterMarker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simpleClusterMarker":
            suggest = "simple_cluster_marker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateClusterMarker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateClusterMarker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateClusterMarker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 simple_cluster_marker: Optional['outputs.TemplateSimpleClusterMarker'] = None):
        TemplateClusterMarker._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            simple_cluster_marker=simple_cluster_marker,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             simple_cluster_marker: Optional['outputs.TemplateSimpleClusterMarker'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if simple_cluster_marker is not None:
            _setter("simple_cluster_marker", simple_cluster_marker)

    @property
    @pulumi.getter(name="simpleClusterMarker")
    def simple_cluster_marker(self) -> Optional['outputs.TemplateSimpleClusterMarker']:
        return pulumi.get(self, "simple_cluster_marker")


@pulumi.output_type
class TemplateClusterMarkerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterMarker":
            suggest = "cluster_marker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateClusterMarkerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateClusterMarkerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateClusterMarkerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_marker: Optional['outputs.TemplateClusterMarker'] = None):
        TemplateClusterMarkerConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_marker=cluster_marker,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_marker: Optional['outputs.TemplateClusterMarker'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cluster_marker is not None:
            _setter("cluster_marker", cluster_marker)

    @property
    @pulumi.getter(name="clusterMarker")
    def cluster_marker(self) -> Optional['outputs.TemplateClusterMarker']:
        return pulumi.get(self, "cluster_marker")


@pulumi.output_type
class TemplateColorScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorFillType":
            suggest = "color_fill_type"
        elif key == "nullValueColor":
            suggest = "null_value_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateColorScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateColorScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateColorScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_fill_type: 'TemplateColorFillType',
                 colors: Sequence['outputs.TemplateDataColor'],
                 null_value_color: Optional['outputs.TemplateDataColor'] = None):
        TemplateColorScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_fill_type=color_fill_type,
            colors=colors,
            null_value_color=null_value_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_fill_type: 'TemplateColorFillType',
             colors: Sequence['outputs.TemplateDataColor'],
             null_value_color: Optional['outputs.TemplateDataColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color_fill_type", color_fill_type)
        _setter("colors", colors)
        if null_value_color is not None:
            _setter("null_value_color", null_value_color)

    @property
    @pulumi.getter(name="colorFillType")
    def color_fill_type(self) -> 'TemplateColorFillType':
        return pulumi.get(self, "color_fill_type")

    @property
    @pulumi.getter
    def colors(self) -> Sequence['outputs.TemplateDataColor']:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="nullValueColor")
    def null_value_color(self) -> Optional['outputs.TemplateDataColor']:
        return pulumi.get(self, "null_value_color")


@pulumi.output_type
class TemplateColorsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customColors":
            suggest = "custom_colors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateColorsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateColorsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateColorsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_colors: Optional[Sequence['outputs.TemplateCustomColor']] = None):
        TemplateColorsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_colors=custom_colors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_colors: Optional[Sequence['outputs.TemplateCustomColor']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_colors is not None:
            _setter("custom_colors", custom_colors)

    @property
    @pulumi.getter(name="customColors")
    def custom_colors(self) -> Optional[Sequence['outputs.TemplateCustomColor']]:
        return pulumi.get(self, "custom_colors")


@pulumi.output_type
class TemplateColumnConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorsConfiguration":
            suggest = "colors_configuration"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateColumnConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateColumnConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateColumnConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 colors_configuration: Optional['outputs.TemplateColorsConfiguration'] = None,
                 format_configuration: Optional['outputs.TemplateFormatConfiguration'] = None,
                 role: Optional['TemplateColumnRole'] = None):
        TemplateColumnConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            colors_configuration=colors_configuration,
            format_configuration=format_configuration,
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             colors_configuration: Optional['outputs.TemplateColorsConfiguration'] = None,
             format_configuration: Optional['outputs.TemplateFormatConfiguration'] = None,
             role: Optional['TemplateColumnRole'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        if colors_configuration is not None:
            _setter("colors_configuration", colors_configuration)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if role is not None:
            _setter("role", role)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="colorsConfiguration")
    def colors_configuration(self) -> Optional['outputs.TemplateColorsConfiguration']:
        return pulumi.get(self, "colors_configuration")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.TemplateFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter
    def role(self) -> Optional['TemplateColumnRole']:
        return pulumi.get(self, "role")


@pulumi.output_type
class TemplateColumnGroupColumnSchema(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        TemplateColumnGroupColumnSchema._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class TemplateColumnGroupSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnGroupColumnSchemaList":
            suggest = "column_group_column_schema_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateColumnGroupSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateColumnGroupSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateColumnGroupSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_group_column_schema_list: Optional[Sequence['outputs.TemplateColumnGroupColumnSchema']] = None,
                 name: Optional[str] = None):
        TemplateColumnGroupSchema._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_group_column_schema_list=column_group_column_schema_list,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_group_column_schema_list: Optional[Sequence['outputs.TemplateColumnGroupColumnSchema']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_group_column_schema_list is not None:
            _setter("column_group_column_schema_list", column_group_column_schema_list)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="columnGroupColumnSchemaList")
    def column_group_column_schema_list(self) -> Optional[Sequence['outputs.TemplateColumnGroupColumnSchema']]:
        return pulumi.get(self, "column_group_column_schema_list")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class TemplateColumnHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeHierarchy":
            suggest = "date_time_hierarchy"
        elif key == "explicitHierarchy":
            suggest = "explicit_hierarchy"
        elif key == "predefinedHierarchy":
            suggest = "predefined_hierarchy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateColumnHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateColumnHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateColumnHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_hierarchy: Optional['outputs.TemplateDateTimeHierarchy'] = None,
                 explicit_hierarchy: Optional['outputs.TemplateExplicitHierarchy'] = None,
                 predefined_hierarchy: Optional['outputs.TemplatePredefinedHierarchy'] = None):
        TemplateColumnHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_hierarchy=date_time_hierarchy,
            explicit_hierarchy=explicit_hierarchy,
            predefined_hierarchy=predefined_hierarchy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_hierarchy: Optional['outputs.TemplateDateTimeHierarchy'] = None,
             explicit_hierarchy: Optional['outputs.TemplateExplicitHierarchy'] = None,
             predefined_hierarchy: Optional['outputs.TemplatePredefinedHierarchy'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_hierarchy is not None:
            _setter("date_time_hierarchy", date_time_hierarchy)
        if explicit_hierarchy is not None:
            _setter("explicit_hierarchy", explicit_hierarchy)
        if predefined_hierarchy is not None:
            _setter("predefined_hierarchy", predefined_hierarchy)

    @property
    @pulumi.getter(name="dateTimeHierarchy")
    def date_time_hierarchy(self) -> Optional['outputs.TemplateDateTimeHierarchy']:
        return pulumi.get(self, "date_time_hierarchy")

    @property
    @pulumi.getter(name="explicitHierarchy")
    def explicit_hierarchy(self) -> Optional['outputs.TemplateExplicitHierarchy']:
        return pulumi.get(self, "explicit_hierarchy")

    @property
    @pulumi.getter(name="predefinedHierarchy")
    def predefined_hierarchy(self) -> Optional['outputs.TemplatePredefinedHierarchy']:
        return pulumi.get(self, "predefined_hierarchy")


@pulumi.output_type
class TemplateColumnIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "dataSetIdentifier":
            suggest = "data_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateColumnIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateColumnIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateColumnIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 data_set_identifier: str):
        TemplateColumnIdentifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            data_set_identifier=data_set_identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: str,
             data_set_identifier: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column_name", column_name)
        _setter("data_set_identifier", data_set_identifier)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")


@pulumi.output_type
class TemplateColumnSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "geographicRole":
            suggest = "geographic_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateColumnSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateColumnSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateColumnSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: Optional[str] = None,
                 geographic_role: Optional[str] = None,
                 name: Optional[str] = None):
        TemplateColumnSchema._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            geographic_role=geographic_role,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional[str] = None,
             geographic_role: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_type is not None:
            _setter("data_type", data_type)
        if geographic_role is not None:
            _setter("geographic_role", geographic_role)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="geographicRole")
    def geographic_role(self) -> Optional[str]:
        return pulumi.get(self, "geographic_role")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class TemplateColumnSort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortBy":
            suggest = "sort_by"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateColumnSort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateColumnSort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateColumnSort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: 'TemplateSortDirection',
                 sort_by: 'outputs.TemplateColumnIdentifier',
                 aggregation_function: Optional['outputs.TemplateAggregationFunction'] = None):
        TemplateColumnSort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            sort_by=sort_by,
            aggregation_function=aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: 'TemplateSortDirection',
             sort_by: 'outputs.TemplateColumnIdentifier',
             aggregation_function: Optional['outputs.TemplateAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("direction", direction)
        _setter("sort_by", sort_by)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)

    @property
    @pulumi.getter
    def direction(self) -> 'TemplateSortDirection':
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="sortBy")
    def sort_by(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "sort_by")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.TemplateAggregationFunction']:
        return pulumi.get(self, "aggregation_function")


@pulumi.output_type
class TemplateColumnTooltipItem(dict):
    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 aggregation: Optional['outputs.TemplateAggregationFunction'] = None,
                 label: Optional[str] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateColumnTooltipItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            aggregation=aggregation,
            label=label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             aggregation: Optional['outputs.TemplateAggregationFunction'] = None,
             label: Optional[str] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if label is not None:
            _setter("label", label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional['outputs.TemplateAggregationFunction']:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateComboChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barValues":
            suggest = "bar_values"
        elif key == "lineValues":
            suggest = "line_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateComboChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateComboChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateComboChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
                 category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 colors: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 line_values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateComboChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_values=bar_values,
            category=category,
            colors=colors,
            line_values=line_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             colors: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             line_values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_values is not None:
            _setter("bar_values", bar_values)
        if category is not None:
            _setter("category", category)
        if colors is not None:
            _setter("colors", colors)
        if line_values is not None:
            _setter("line_values", line_values)

    @property
    @pulumi.getter(name="barValues")
    def bar_values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "bar_values")

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="lineValues")
    def line_values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "line_values")


@pulumi.output_type
class TemplateComboChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barDataLabels":
            suggest = "bar_data_labels"
        elif key == "barsArrangement":
            suggest = "bars_arrangement"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "lineDataLabels":
            suggest = "line_data_labels"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "secondaryYAxisDisplayOptions":
            suggest = "secondary_y_axis_display_options"
        elif key == "secondaryYAxisLabelOptions":
            suggest = "secondary_y_axis_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateComboChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateComboChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateComboChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 bars_arrangement: Optional['TemplateBarsArrangement'] = None,
                 category_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 color_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateComboChartFieldWells'] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 line_data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 reference_lines: Optional[Sequence['outputs.TemplateReferenceLine']] = None,
                 secondary_y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 secondary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.TemplateComboChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None):
        TemplateComboChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_data_labels=bar_data_labels,
            bars_arrangement=bars_arrangement,
            category_axis=category_axis,
            category_label_options=category_label_options,
            color_label_options=color_label_options,
            field_wells=field_wells,
            legend=legend,
            line_data_labels=line_data_labels,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            reference_lines=reference_lines,
            secondary_y_axis_display_options=secondary_y_axis_display_options,
            secondary_y_axis_label_options=secondary_y_axis_label_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             bars_arrangement: Optional['TemplateBarsArrangement'] = None,
             category_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             color_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateComboChartFieldWells'] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             line_data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             reference_lines: Optional[Sequence['outputs.TemplateReferenceLine']] = None,
             secondary_y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             secondary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.TemplateComboChartSortConfiguration'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_data_labels is not None:
            _setter("bar_data_labels", bar_data_labels)
        if bars_arrangement is not None:
            _setter("bars_arrangement", bars_arrangement)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if line_data_labels is not None:
            _setter("line_data_labels", line_data_labels)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if secondary_y_axis_display_options is not None:
            _setter("secondary_y_axis_display_options", secondary_y_axis_display_options)
        if secondary_y_axis_label_options is not None:
            _setter("secondary_y_axis_label_options", secondary_y_axis_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="barDataLabels")
    def bar_data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "bar_data_labels")

    @property
    @pulumi.getter(name="barsArrangement")
    def bars_arrangement(self) -> Optional['TemplateBarsArrangement']:
        return pulumi.get(self, "bars_arrangement")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateComboChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="lineDataLabels")
    def line_data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "line_data_labels")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.TemplateReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="secondaryYAxisDisplayOptions")
    def secondary_y_axis_display_options(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "secondary_y_axis_display_options")

    @property
    @pulumi.getter(name="secondaryYAxisLabelOptions")
    def secondary_y_axis_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "secondary_y_axis_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateComboChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class TemplateComboChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comboChartAggregatedFieldWells":
            suggest = "combo_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateComboChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateComboChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateComboChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 combo_chart_aggregated_field_wells: Optional['outputs.TemplateComboChartAggregatedFieldWells'] = None):
        TemplateComboChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            combo_chart_aggregated_field_wells=combo_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             combo_chart_aggregated_field_wells: Optional['outputs.TemplateComboChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if combo_chart_aggregated_field_wells is not None:
            _setter("combo_chart_aggregated_field_wells", combo_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="comboChartAggregatedFieldWells")
    def combo_chart_aggregated_field_wells(self) -> Optional['outputs.TemplateComboChartAggregatedFieldWells']:
        return pulumi.get(self, "combo_chart_aggregated_field_wells")


@pulumi.output_type
class TemplateComboChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimit":
            suggest = "color_items_limit"
        elif key == "colorSort":
            suggest = "color_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateComboChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateComboChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateComboChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
                 color_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 color_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateComboChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            color_items_limit=color_items_limit,
            color_sort=color_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             color_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             color_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit is not None:
            _setter("color_items_limit", color_items_limit)
        if color_sort is not None:
            _setter("color_sort", color_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimit")
    def color_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit")

    @property
    @pulumi.getter(name="colorSort")
    def color_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "color_sort")


@pulumi.output_type
class TemplateComboChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateComboChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateComboChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateComboChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateComboChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateComboChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateComboChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateComboChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateComparisonConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonFormat":
            suggest = "comparison_format"
        elif key == "comparisonMethod":
            suggest = "comparison_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateComparisonConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateComparisonConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateComparisonConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_format: Optional['outputs.TemplateComparisonFormatConfiguration'] = None,
                 comparison_method: Optional['TemplateComparisonMethod'] = None):
        TemplateComparisonConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_format=comparison_format,
            comparison_method=comparison_method,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_format: Optional['outputs.TemplateComparisonFormatConfiguration'] = None,
             comparison_method: Optional['TemplateComparisonMethod'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if comparison_format is not None:
            _setter("comparison_format", comparison_format)
        if comparison_method is not None:
            _setter("comparison_method", comparison_method)

    @property
    @pulumi.getter(name="comparisonFormat")
    def comparison_format(self) -> Optional['outputs.TemplateComparisonFormatConfiguration']:
        return pulumi.get(self, "comparison_format")

    @property
    @pulumi.getter(name="comparisonMethod")
    def comparison_method(self) -> Optional['TemplateComparisonMethod']:
        return pulumi.get(self, "comparison_method")


@pulumi.output_type
class TemplateComparisonFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberDisplayFormatConfiguration":
            suggest = "number_display_format_configuration"
        elif key == "percentageDisplayFormatConfiguration":
            suggest = "percentage_display_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateComparisonFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateComparisonFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateComparisonFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_display_format_configuration: Optional['outputs.TemplateNumberDisplayFormatConfiguration'] = None,
                 percentage_display_format_configuration: Optional['outputs.TemplatePercentageDisplayFormatConfiguration'] = None):
        TemplateComparisonFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            number_display_format_configuration=number_display_format_configuration,
            percentage_display_format_configuration=percentage_display_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             number_display_format_configuration: Optional['outputs.TemplateNumberDisplayFormatConfiguration'] = None,
             percentage_display_format_configuration: Optional['outputs.TemplatePercentageDisplayFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if number_display_format_configuration is not None:
            _setter("number_display_format_configuration", number_display_format_configuration)
        if percentage_display_format_configuration is not None:
            _setter("percentage_display_format_configuration", percentage_display_format_configuration)

    @property
    @pulumi.getter(name="numberDisplayFormatConfiguration")
    def number_display_format_configuration(self) -> Optional['outputs.TemplateNumberDisplayFormatConfiguration']:
        return pulumi.get(self, "number_display_format_configuration")

    @property
    @pulumi.getter(name="percentageDisplayFormatConfiguration")
    def percentage_display_format_configuration(self) -> Optional['outputs.TemplatePercentageDisplayFormatConfiguration']:
        return pulumi.get(self, "percentage_display_format_configuration")


@pulumi.output_type
class TemplateComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "growthRate":
            suggest = "growth_rate"
        elif key == "maximumMinimum":
            suggest = "maximum_minimum"
        elif key == "metricComparison":
            suggest = "metric_comparison"
        elif key == "periodOverPeriod":
            suggest = "period_over_period"
        elif key == "periodToDate":
            suggest = "period_to_date"
        elif key == "topBottomMovers":
            suggest = "top_bottom_movers"
        elif key == "topBottomRanked":
            suggest = "top_bottom_ranked"
        elif key == "totalAggregation":
            suggest = "total_aggregation"
        elif key == "uniqueValues":
            suggest = "unique_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forecast: Optional['outputs.TemplateForecastComputation'] = None,
                 growth_rate: Optional['outputs.TemplateGrowthRateComputation'] = None,
                 maximum_minimum: Optional['outputs.TemplateMaximumMinimumComputation'] = None,
                 metric_comparison: Optional['outputs.TemplateMetricComparisonComputation'] = None,
                 period_over_period: Optional['outputs.TemplatePeriodOverPeriodComputation'] = None,
                 period_to_date: Optional['outputs.TemplatePeriodToDateComputation'] = None,
                 top_bottom_movers: Optional['outputs.TemplateTopBottomMoversComputation'] = None,
                 top_bottom_ranked: Optional['outputs.TemplateTopBottomRankedComputation'] = None,
                 total_aggregation: Optional['outputs.TemplateTotalAggregationComputation'] = None,
                 unique_values: Optional['outputs.TemplateUniqueValuesComputation'] = None):
        TemplateComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forecast=forecast,
            growth_rate=growth_rate,
            maximum_minimum=maximum_minimum,
            metric_comparison=metric_comparison,
            period_over_period=period_over_period,
            period_to_date=period_to_date,
            top_bottom_movers=top_bottom_movers,
            top_bottom_ranked=top_bottom_ranked,
            total_aggregation=total_aggregation,
            unique_values=unique_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forecast: Optional['outputs.TemplateForecastComputation'] = None,
             growth_rate: Optional['outputs.TemplateGrowthRateComputation'] = None,
             maximum_minimum: Optional['outputs.TemplateMaximumMinimumComputation'] = None,
             metric_comparison: Optional['outputs.TemplateMetricComparisonComputation'] = None,
             period_over_period: Optional['outputs.TemplatePeriodOverPeriodComputation'] = None,
             period_to_date: Optional['outputs.TemplatePeriodToDateComputation'] = None,
             top_bottom_movers: Optional['outputs.TemplateTopBottomMoversComputation'] = None,
             top_bottom_ranked: Optional['outputs.TemplateTopBottomRankedComputation'] = None,
             total_aggregation: Optional['outputs.TemplateTotalAggregationComputation'] = None,
             unique_values: Optional['outputs.TemplateUniqueValuesComputation'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if forecast is not None:
            _setter("forecast", forecast)
        if growth_rate is not None:
            _setter("growth_rate", growth_rate)
        if maximum_minimum is not None:
            _setter("maximum_minimum", maximum_minimum)
        if metric_comparison is not None:
            _setter("metric_comparison", metric_comparison)
        if period_over_period is not None:
            _setter("period_over_period", period_over_period)
        if period_to_date is not None:
            _setter("period_to_date", period_to_date)
        if top_bottom_movers is not None:
            _setter("top_bottom_movers", top_bottom_movers)
        if top_bottom_ranked is not None:
            _setter("top_bottom_ranked", top_bottom_ranked)
        if total_aggregation is not None:
            _setter("total_aggregation", total_aggregation)
        if unique_values is not None:
            _setter("unique_values", unique_values)

    @property
    @pulumi.getter
    def forecast(self) -> Optional['outputs.TemplateForecastComputation']:
        return pulumi.get(self, "forecast")

    @property
    @pulumi.getter(name="growthRate")
    def growth_rate(self) -> Optional['outputs.TemplateGrowthRateComputation']:
        return pulumi.get(self, "growth_rate")

    @property
    @pulumi.getter(name="maximumMinimum")
    def maximum_minimum(self) -> Optional['outputs.TemplateMaximumMinimumComputation']:
        return pulumi.get(self, "maximum_minimum")

    @property
    @pulumi.getter(name="metricComparison")
    def metric_comparison(self) -> Optional['outputs.TemplateMetricComparisonComputation']:
        return pulumi.get(self, "metric_comparison")

    @property
    @pulumi.getter(name="periodOverPeriod")
    def period_over_period(self) -> Optional['outputs.TemplatePeriodOverPeriodComputation']:
        return pulumi.get(self, "period_over_period")

    @property
    @pulumi.getter(name="periodToDate")
    def period_to_date(self) -> Optional['outputs.TemplatePeriodToDateComputation']:
        return pulumi.get(self, "period_to_date")

    @property
    @pulumi.getter(name="topBottomMovers")
    def top_bottom_movers(self) -> Optional['outputs.TemplateTopBottomMoversComputation']:
        return pulumi.get(self, "top_bottom_movers")

    @property
    @pulumi.getter(name="topBottomRanked")
    def top_bottom_ranked(self) -> Optional['outputs.TemplateTopBottomRankedComputation']:
        return pulumi.get(self, "top_bottom_ranked")

    @property
    @pulumi.getter(name="totalAggregation")
    def total_aggregation(self) -> Optional['outputs.TemplateTotalAggregationComputation']:
        return pulumi.get(self, "total_aggregation")

    @property
    @pulumi.getter(name="uniqueValues")
    def unique_values(self) -> Optional['outputs.TemplateUniqueValuesComputation']:
        return pulumi.get(self, "unique_values")


@pulumi.output_type
class TemplateConditionalFormattingColor(dict):
    def __init__(__self__, *,
                 gradient: Optional['outputs.TemplateConditionalFormattingGradientColor'] = None,
                 solid: Optional['outputs.TemplateConditionalFormattingSolidColor'] = None):
        TemplateConditionalFormattingColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gradient=gradient,
            solid=solid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gradient: Optional['outputs.TemplateConditionalFormattingGradientColor'] = None,
             solid: Optional['outputs.TemplateConditionalFormattingSolidColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if gradient is not None:
            _setter("gradient", gradient)
        if solid is not None:
            _setter("solid", solid)

    @property
    @pulumi.getter
    def gradient(self) -> Optional['outputs.TemplateConditionalFormattingGradientColor']:
        return pulumi.get(self, "gradient")

    @property
    @pulumi.getter
    def solid(self) -> Optional['outputs.TemplateConditionalFormattingSolidColor']:
        return pulumi.get(self, "solid")


@pulumi.output_type
class TemplateConditionalFormattingCustomIconCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iconOptions":
            suggest = "icon_options"
        elif key == "displayConfiguration":
            suggest = "display_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateConditionalFormattingCustomIconCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateConditionalFormattingCustomIconCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateConditionalFormattingCustomIconCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 icon_options: 'outputs.TemplateConditionalFormattingCustomIconOptions',
                 color: Optional[str] = None,
                 display_configuration: Optional['outputs.TemplateConditionalFormattingIconDisplayConfiguration'] = None):
        TemplateConditionalFormattingCustomIconCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            icon_options=icon_options,
            color=color,
            display_configuration=display_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             icon_options: 'outputs.TemplateConditionalFormattingCustomIconOptions',
             color: Optional[str] = None,
             display_configuration: Optional['outputs.TemplateConditionalFormattingIconDisplayConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        _setter("icon_options", icon_options)
        if color is not None:
            _setter("color", color)
        if display_configuration is not None:
            _setter("display_configuration", display_configuration)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="iconOptions")
    def icon_options(self) -> 'outputs.TemplateConditionalFormattingCustomIconOptions':
        return pulumi.get(self, "icon_options")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="displayConfiguration")
    def display_configuration(self) -> Optional['outputs.TemplateConditionalFormattingIconDisplayConfiguration']:
        return pulumi.get(self, "display_configuration")


@pulumi.output_type
class TemplateConditionalFormattingCustomIconOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unicodeIcon":
            suggest = "unicode_icon"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateConditionalFormattingCustomIconOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateConditionalFormattingCustomIconOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateConditionalFormattingCustomIconOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['TemplateIcon'] = None,
                 unicode_icon: Optional[str] = None):
        TemplateConditionalFormattingCustomIconOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            unicode_icon=unicode_icon,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['TemplateIcon'] = None,
             unicode_icon: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if unicode_icon is not None:
            _setter("unicode_icon", unicode_icon)

    @property
    @pulumi.getter
    def icon(self) -> Optional['TemplateIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="unicodeIcon")
    def unicode_icon(self) -> Optional[str]:
        return pulumi.get(self, "unicode_icon")


@pulumi.output_type
class TemplateConditionalFormattingGradientColor(dict):
    def __init__(__self__, *,
                 color: 'outputs.TemplateGradientColor',
                 expression: str):
        TemplateConditionalFormattingGradientColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: 'outputs.TemplateGradientColor',
             expression: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)
        _setter("expression", expression)

    @property
    @pulumi.getter
    def color(self) -> 'outputs.TemplateGradientColor':
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")


@pulumi.output_type
class TemplateConditionalFormattingIcon(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customCondition":
            suggest = "custom_condition"
        elif key == "iconSet":
            suggest = "icon_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateConditionalFormattingIcon. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateConditionalFormattingIcon.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateConditionalFormattingIcon.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_condition: Optional['outputs.TemplateConditionalFormattingCustomIconCondition'] = None,
                 icon_set: Optional['outputs.TemplateConditionalFormattingIconSet'] = None):
        TemplateConditionalFormattingIcon._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_condition=custom_condition,
            icon_set=icon_set,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_condition: Optional['outputs.TemplateConditionalFormattingCustomIconCondition'] = None,
             icon_set: Optional['outputs.TemplateConditionalFormattingIconSet'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_condition is not None:
            _setter("custom_condition", custom_condition)
        if icon_set is not None:
            _setter("icon_set", icon_set)

    @property
    @pulumi.getter(name="customCondition")
    def custom_condition(self) -> Optional['outputs.TemplateConditionalFormattingCustomIconCondition']:
        return pulumi.get(self, "custom_condition")

    @property
    @pulumi.getter(name="iconSet")
    def icon_set(self) -> Optional['outputs.TemplateConditionalFormattingIconSet']:
        return pulumi.get(self, "icon_set")


@pulumi.output_type
class TemplateConditionalFormattingIconDisplayConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iconDisplayOption":
            suggest = "icon_display_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateConditionalFormattingIconDisplayConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateConditionalFormattingIconDisplayConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateConditionalFormattingIconDisplayConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon_display_option: Optional['TemplateConditionalFormattingIconDisplayOption'] = None):
        TemplateConditionalFormattingIconDisplayConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon_display_option=icon_display_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon_display_option: Optional['TemplateConditionalFormattingIconDisplayOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon_display_option is not None:
            _setter("icon_display_option", icon_display_option)

    @property
    @pulumi.getter(name="iconDisplayOption")
    def icon_display_option(self) -> Optional['TemplateConditionalFormattingIconDisplayOption']:
        return pulumi.get(self, "icon_display_option")


@pulumi.output_type
class TemplateConditionalFormattingIconSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iconSetType":
            suggest = "icon_set_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateConditionalFormattingIconSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateConditionalFormattingIconSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateConditionalFormattingIconSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 icon_set_type: Optional['TemplateConditionalFormattingIconSetType'] = None):
        TemplateConditionalFormattingIconSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            icon_set_type=icon_set_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             icon_set_type: Optional['TemplateConditionalFormattingIconSetType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if icon_set_type is not None:
            _setter("icon_set_type", icon_set_type)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="iconSetType")
    def icon_set_type(self) -> Optional['TemplateConditionalFormattingIconSetType']:
        return pulumi.get(self, "icon_set_type")


@pulumi.output_type
class TemplateConditionalFormattingSolidColor(dict):
    def __init__(__self__, *,
                 expression: str,
                 color: Optional[str] = None):
        TemplateConditionalFormattingSolidColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            color=color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             color: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if color is not None:
            _setter("color", color)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")


@pulumi.output_type
class TemplateContributionAnalysisDefault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributorDimensions":
            suggest = "contributor_dimensions"
        elif key == "measureFieldId":
            suggest = "measure_field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateContributionAnalysisDefault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateContributionAnalysisDefault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateContributionAnalysisDefault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contributor_dimensions: Sequence['outputs.TemplateColumnIdentifier'],
                 measure_field_id: str):
        TemplateContributionAnalysisDefault._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contributor_dimensions=contributor_dimensions,
            measure_field_id=measure_field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contributor_dimensions: Sequence['outputs.TemplateColumnIdentifier'],
             measure_field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("contributor_dimensions", contributor_dimensions)
        _setter("measure_field_id", measure_field_id)

    @property
    @pulumi.getter(name="contributorDimensions")
    def contributor_dimensions(self) -> Sequence['outputs.TemplateColumnIdentifier']:
        return pulumi.get(self, "contributor_dimensions")

    @property
    @pulumi.getter(name="measureFieldId")
    def measure_field_id(self) -> str:
        return pulumi.get(self, "measure_field_id")


@pulumi.output_type
class TemplateCurrencyDisplayFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlacesConfiguration":
            suggest = "decimal_places_configuration"
        elif key == "negativeValueConfiguration":
            suggest = "negative_value_configuration"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numberScale":
            suggest = "number_scale"
        elif key == "separatorConfiguration":
            suggest = "separator_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCurrencyDisplayFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCurrencyDisplayFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCurrencyDisplayFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places_configuration: Optional['outputs.TemplateDecimalPlacesConfiguration'] = None,
                 negative_value_configuration: Optional['outputs.TemplateNegativeValueConfiguration'] = None,
                 null_value_format_configuration: Optional['outputs.TemplateNullValueFormatConfiguration'] = None,
                 number_scale: Optional['TemplateNumberScale'] = None,
                 prefix: Optional[str] = None,
                 separator_configuration: Optional['outputs.TemplateNumericSeparatorConfiguration'] = None,
                 suffix: Optional[str] = None,
                 symbol: Optional[str] = None):
        TemplateCurrencyDisplayFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places_configuration=decimal_places_configuration,
            negative_value_configuration=negative_value_configuration,
            null_value_format_configuration=null_value_format_configuration,
            number_scale=number_scale,
            prefix=prefix,
            separator_configuration=separator_configuration,
            suffix=suffix,
            symbol=symbol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places_configuration: Optional['outputs.TemplateDecimalPlacesConfiguration'] = None,
             negative_value_configuration: Optional['outputs.TemplateNegativeValueConfiguration'] = None,
             null_value_format_configuration: Optional['outputs.TemplateNullValueFormatConfiguration'] = None,
             number_scale: Optional['TemplateNumberScale'] = None,
             prefix: Optional[str] = None,
             separator_configuration: Optional['outputs.TemplateNumericSeparatorConfiguration'] = None,
             suffix: Optional[str] = None,
             symbol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_places_configuration is not None:
            _setter("decimal_places_configuration", decimal_places_configuration)
        if negative_value_configuration is not None:
            _setter("negative_value_configuration", negative_value_configuration)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if number_scale is not None:
            _setter("number_scale", number_scale)
        if prefix is not None:
            _setter("prefix", prefix)
        if separator_configuration is not None:
            _setter("separator_configuration", separator_configuration)
        if suffix is not None:
            _setter("suffix", suffix)
        if symbol is not None:
            _setter("symbol", symbol)

    @property
    @pulumi.getter(name="decimalPlacesConfiguration")
    def decimal_places_configuration(self) -> Optional['outputs.TemplateDecimalPlacesConfiguration']:
        return pulumi.get(self, "decimal_places_configuration")

    @property
    @pulumi.getter(name="negativeValueConfiguration")
    def negative_value_configuration(self) -> Optional['outputs.TemplateNegativeValueConfiguration']:
        return pulumi.get(self, "negative_value_configuration")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.TemplateNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numberScale")
    def number_scale(self) -> Optional['TemplateNumberScale']:
        return pulumi.get(self, "number_scale")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="separatorConfiguration")
    def separator_configuration(self) -> Optional['outputs.TemplateNumericSeparatorConfiguration']:
        return pulumi.get(self, "separator_configuration")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter
    def symbol(self) -> Optional[str]:
        return pulumi.get(self, "symbol")


@pulumi.output_type
class TemplateCustomActionFilterOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedFieldsConfiguration":
            suggest = "selected_fields_configuration"
        elif key == "targetVisualsConfiguration":
            suggest = "target_visuals_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCustomActionFilterOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCustomActionFilterOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCustomActionFilterOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_fields_configuration: 'outputs.TemplateFilterOperationSelectedFieldsConfiguration',
                 target_visuals_configuration: 'outputs.TemplateFilterOperationTargetVisualsConfiguration'):
        TemplateCustomActionFilterOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_fields_configuration=selected_fields_configuration,
            target_visuals_configuration=target_visuals_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_fields_configuration: 'outputs.TemplateFilterOperationSelectedFieldsConfiguration',
             target_visuals_configuration: 'outputs.TemplateFilterOperationTargetVisualsConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("selected_fields_configuration", selected_fields_configuration)
        _setter("target_visuals_configuration", target_visuals_configuration)

    @property
    @pulumi.getter(name="selectedFieldsConfiguration")
    def selected_fields_configuration(self) -> 'outputs.TemplateFilterOperationSelectedFieldsConfiguration':
        return pulumi.get(self, "selected_fields_configuration")

    @property
    @pulumi.getter(name="targetVisualsConfiguration")
    def target_visuals_configuration(self) -> 'outputs.TemplateFilterOperationTargetVisualsConfiguration':
        return pulumi.get(self, "target_visuals_configuration")


@pulumi.output_type
class TemplateCustomActionNavigationOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localNavigationConfiguration":
            suggest = "local_navigation_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCustomActionNavigationOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCustomActionNavigationOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCustomActionNavigationOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_navigation_configuration: Optional['outputs.TemplateLocalNavigationConfiguration'] = None):
        TemplateCustomActionNavigationOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_navigation_configuration=local_navigation_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_navigation_configuration: Optional['outputs.TemplateLocalNavigationConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if local_navigation_configuration is not None:
            _setter("local_navigation_configuration", local_navigation_configuration)

    @property
    @pulumi.getter(name="localNavigationConfiguration")
    def local_navigation_configuration(self) -> Optional['outputs.TemplateLocalNavigationConfiguration']:
        return pulumi.get(self, "local_navigation_configuration")


@pulumi.output_type
class TemplateCustomActionSetParametersOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueConfigurations":
            suggest = "parameter_value_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCustomActionSetParametersOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCustomActionSetParametersOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCustomActionSetParametersOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_value_configurations: Sequence['outputs.TemplateSetParameterValueConfiguration']):
        TemplateCustomActionSetParametersOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_value_configurations=parameter_value_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_value_configurations: Sequence['outputs.TemplateSetParameterValueConfiguration'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_value_configurations", parameter_value_configurations)

    @property
    @pulumi.getter(name="parameterValueConfigurations")
    def parameter_value_configurations(self) -> Sequence['outputs.TemplateSetParameterValueConfiguration']:
        return pulumi.get(self, "parameter_value_configurations")


@pulumi.output_type
class TemplateCustomActionUrlOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlTarget":
            suggest = "url_target"
        elif key == "urlTemplate":
            suggest = "url_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCustomActionUrlOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCustomActionUrlOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCustomActionUrlOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_target: 'TemplateUrlTargetConfiguration',
                 url_template: str):
        TemplateCustomActionUrlOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url_target=url_target,
            url_template=url_template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url_target: 'TemplateUrlTargetConfiguration',
             url_template: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url_target", url_target)
        _setter("url_template", url_template)

    @property
    @pulumi.getter(name="urlTarget")
    def url_target(self) -> 'TemplateUrlTargetConfiguration':
        return pulumi.get(self, "url_target")

    @property
    @pulumi.getter(name="urlTemplate")
    def url_template(self) -> str:
        return pulumi.get(self, "url_template")


@pulumi.output_type
class TemplateCustomColor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldValue":
            suggest = "field_value"
        elif key == "specialValue":
            suggest = "special_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCustomColor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCustomColor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCustomColor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: str,
                 field_value: Optional[str] = None,
                 special_value: Optional['TemplateSpecialValue'] = None):
        TemplateCustomColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            field_value=field_value,
            special_value=special_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: str,
             field_value: Optional[str] = None,
             special_value: Optional['TemplateSpecialValue'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)
        if field_value is not None:
            _setter("field_value", field_value)
        if special_value is not None:
            _setter("special_value", special_value)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[str]:
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter(name="specialValue")
    def special_value(self) -> Optional['TemplateSpecialValue']:
        return pulumi.get(self, "special_value")


@pulumi.output_type
class TemplateCustomContentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "contentUrl":
            suggest = "content_url"
        elif key == "imageScaling":
            suggest = "image_scaling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCustomContentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCustomContentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCustomContentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional['TemplateCustomContentType'] = None,
                 content_url: Optional[str] = None,
                 image_scaling: Optional['TemplateCustomContentImageScalingConfiguration'] = None):
        TemplateCustomContentConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_type=content_type,
            content_url=content_url,
            image_scaling=image_scaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_type: Optional['TemplateCustomContentType'] = None,
             content_url: Optional[str] = None,
             image_scaling: Optional['TemplateCustomContentImageScalingConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if content_type is not None:
            _setter("content_type", content_type)
        if content_url is not None:
            _setter("content_url", content_url)
        if image_scaling is not None:
            _setter("image_scaling", image_scaling)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional['TemplateCustomContentType']:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="contentUrl")
    def content_url(self) -> Optional[str]:
        return pulumi.get(self, "content_url")

    @property
    @pulumi.getter(name="imageScaling")
    def image_scaling(self) -> Optional['TemplateCustomContentImageScalingConfiguration']:
        return pulumi.get(self, "image_scaling")


@pulumi.output_type
class TemplateCustomContentVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCustomContentVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCustomContentVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCustomContentVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateCustomContentConfiguration'] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateCustomContentVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateCustomContentConfiguration'] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateCustomContentConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateCustomFilterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOperator":
            suggest = "match_operator"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "categoryValue":
            suggest = "category_value"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCustomFilterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCustomFilterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCustomFilterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_operator: 'TemplateCategoryFilterMatchOperator',
                 null_option: 'TemplateFilterNullOption',
                 category_value: Optional[str] = None,
                 parameter_name: Optional[str] = None,
                 select_all_options: Optional['TemplateCategoryFilterSelectAllOptions'] = None):
        TemplateCustomFilterConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_operator=match_operator,
            null_option=null_option,
            category_value=category_value,
            parameter_name=parameter_name,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_operator: 'TemplateCategoryFilterMatchOperator',
             null_option: 'TemplateFilterNullOption',
             category_value: Optional[str] = None,
             parameter_name: Optional[str] = None,
             select_all_options: Optional['TemplateCategoryFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("match_operator", match_operator)
        _setter("null_option", null_option)
        if category_value is not None:
            _setter("category_value", category_value)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'TemplateCategoryFilterMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'TemplateFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="categoryValue")
    def category_value(self) -> Optional[str]:
        return pulumi.get(self, "category_value")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['TemplateCategoryFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class TemplateCustomFilterListConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOperator":
            suggest = "match_operator"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "categoryValues":
            suggest = "category_values"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCustomFilterListConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCustomFilterListConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCustomFilterListConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_operator: 'TemplateCategoryFilterMatchOperator',
                 null_option: 'TemplateFilterNullOption',
                 category_values: Optional[Sequence[str]] = None,
                 select_all_options: Optional['TemplateCategoryFilterSelectAllOptions'] = None):
        TemplateCustomFilterListConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_operator=match_operator,
            null_option=null_option,
            category_values=category_values,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_operator: 'TemplateCategoryFilterMatchOperator',
             null_option: 'TemplateFilterNullOption',
             category_values: Optional[Sequence[str]] = None,
             select_all_options: Optional['TemplateCategoryFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("match_operator", match_operator)
        _setter("null_option", null_option)
        if category_values is not None:
            _setter("category_values", category_values)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'TemplateCategoryFilterMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'TemplateFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="categoryValues")
    def category_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "category_values")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['TemplateCategoryFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class TemplateCustomNarrativeOptions(dict):
    def __init__(__self__, *,
                 narrative: str):
        TemplateCustomNarrativeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            narrative=narrative,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             narrative: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("narrative", narrative)

    @property
    @pulumi.getter
    def narrative(self) -> str:
        return pulumi.get(self, "narrative")


@pulumi.output_type
class TemplateCustomParameterValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeValues":
            suggest = "date_time_values"
        elif key == "decimalValues":
            suggest = "decimal_values"
        elif key == "integerValues":
            suggest = "integer_values"
        elif key == "stringValues":
            suggest = "string_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCustomParameterValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCustomParameterValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCustomParameterValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_values: Optional[Sequence[str]] = None,
                 decimal_values: Optional[Sequence[float]] = None,
                 integer_values: Optional[Sequence[float]] = None,
                 string_values: Optional[Sequence[str]] = None):
        TemplateCustomParameterValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_values=date_time_values,
            decimal_values=decimal_values,
            integer_values=integer_values,
            string_values=string_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_values: Optional[Sequence[str]] = None,
             decimal_values: Optional[Sequence[float]] = None,
             integer_values: Optional[Sequence[float]] = None,
             string_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_values is not None:
            _setter("date_time_values", date_time_values)
        if decimal_values is not None:
            _setter("decimal_values", decimal_values)
        if integer_values is not None:
            _setter("integer_values", integer_values)
        if string_values is not None:
            _setter("string_values", string_values)

    @property
    @pulumi.getter(name="dateTimeValues")
    def date_time_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "date_time_values")

    @property
    @pulumi.getter(name="decimalValues")
    def decimal_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "decimal_values")

    @property
    @pulumi.getter(name="integerValues")
    def integer_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "integer_values")

    @property
    @pulumi.getter(name="stringValues")
    def string_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "string_values")


@pulumi.output_type
class TemplateCustomValuesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValues":
            suggest = "custom_values"
        elif key == "includeNullValue":
            suggest = "include_null_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateCustomValuesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateCustomValuesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateCustomValuesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_values: 'outputs.TemplateCustomParameterValues',
                 include_null_value: Optional[bool] = None):
        TemplateCustomValuesConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_values=custom_values,
            include_null_value=include_null_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_values: 'outputs.TemplateCustomParameterValues',
             include_null_value: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_values", custom_values)
        if include_null_value is not None:
            _setter("include_null_value", include_null_value)

    @property
    @pulumi.getter(name="customValues")
    def custom_values(self) -> 'outputs.TemplateCustomParameterValues':
        return pulumi.get(self, "custom_values")

    @property
    @pulumi.getter(name="includeNullValue")
    def include_null_value(self) -> Optional[bool]:
        return pulumi.get(self, "include_null_value")


@pulumi.output_type
class TemplateDataBarsOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "negativeColor":
            suggest = "negative_color"
        elif key == "positiveColor":
            suggest = "positive_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataBarsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataBarsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataBarsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 negative_color: Optional[str] = None,
                 positive_color: Optional[str] = None):
        TemplateDataBarsOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            negative_color=negative_color,
            positive_color=positive_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             negative_color: Optional[str] = None,
             positive_color: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if negative_color is not None:
            _setter("negative_color", negative_color)
        if positive_color is not None:
            _setter("positive_color", positive_color)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="negativeColor")
    def negative_color(self) -> Optional[str]:
        return pulumi.get(self, "negative_color")

    @property
    @pulumi.getter(name="positiveColor")
    def positive_color(self) -> Optional[str]:
        return pulumi.get(self, "positive_color")


@pulumi.output_type
class TemplateDataColor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataValue":
            suggest = "data_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataColor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataColor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataColor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: Optional[str] = None,
                 data_value: Optional[float] = None):
        TemplateDataColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            data_value=data_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             data_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if data_value is not None:
            _setter("data_value", data_value)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="dataValue")
    def data_value(self) -> Optional[float]:
        return pulumi.get(self, "data_value")


@pulumi.output_type
class TemplateDataFieldSeriesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "fieldId":
            suggest = "field_id"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataFieldSeriesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataFieldSeriesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataFieldSeriesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: 'TemplateAxisBinding',
                 field_id: str,
                 field_value: Optional[str] = None,
                 settings: Optional['outputs.TemplateLineChartSeriesSettings'] = None):
        TemplateDataFieldSeriesItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            field_id=field_id,
            field_value=field_value,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: 'TemplateAxisBinding',
             field_id: str,
             field_value: Optional[str] = None,
             settings: Optional['outputs.TemplateLineChartSeriesSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("axis_binding", axis_binding)
        _setter("field_id", field_id)
        if field_value is not None:
            _setter("field_value", field_value)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> 'TemplateAxisBinding':
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[str]:
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.TemplateLineChartSeriesSettings']:
        return pulumi.get(self, "settings")


@pulumi.output_type
class TemplateDataLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelVisibility":
            suggest = "category_label_visibility"
        elif key == "dataLabelTypes":
            suggest = "data_label_types"
        elif key == "labelColor":
            suggest = "label_color"
        elif key == "labelContent":
            suggest = "label_content"
        elif key == "labelFontConfiguration":
            suggest = "label_font_configuration"
        elif key == "measureLabelVisibility":
            suggest = "measure_label_visibility"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_visibility: Optional['TemplateVisibility'] = None,
                 data_label_types: Optional[Sequence['outputs.TemplateDataLabelType']] = None,
                 label_color: Optional[str] = None,
                 label_content: Optional['TemplateDataLabelContent'] = None,
                 label_font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
                 measure_label_visibility: Optional['TemplateVisibility'] = None,
                 overlap: Optional['TemplateDataLabelOverlap'] = None,
                 position: Optional['TemplateDataLabelPosition'] = None,
                 totals_visibility: Optional['TemplateVisibility'] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateDataLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_visibility=category_label_visibility,
            data_label_types=data_label_types,
            label_color=label_color,
            label_content=label_content,
            label_font_configuration=label_font_configuration,
            measure_label_visibility=measure_label_visibility,
            overlap=overlap,
            position=position,
            totals_visibility=totals_visibility,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_visibility: Optional['TemplateVisibility'] = None,
             data_label_types: Optional[Sequence['outputs.TemplateDataLabelType']] = None,
             label_color: Optional[str] = None,
             label_content: Optional['TemplateDataLabelContent'] = None,
             label_font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
             measure_label_visibility: Optional['TemplateVisibility'] = None,
             overlap: Optional['TemplateDataLabelOverlap'] = None,
             position: Optional['TemplateDataLabelPosition'] = None,
             totals_visibility: Optional['TemplateVisibility'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_visibility is not None:
            _setter("category_label_visibility", category_label_visibility)
        if data_label_types is not None:
            _setter("data_label_types", data_label_types)
        if label_color is not None:
            _setter("label_color", label_color)
        if label_content is not None:
            _setter("label_content", label_content)
        if label_font_configuration is not None:
            _setter("label_font_configuration", label_font_configuration)
        if measure_label_visibility is not None:
            _setter("measure_label_visibility", measure_label_visibility)
        if overlap is not None:
            _setter("overlap", overlap)
        if position is not None:
            _setter("position", position)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="categoryLabelVisibility")
    def category_label_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "category_label_visibility")

    @property
    @pulumi.getter(name="dataLabelTypes")
    def data_label_types(self) -> Optional[Sequence['outputs.TemplateDataLabelType']]:
        return pulumi.get(self, "data_label_types")

    @property
    @pulumi.getter(name="labelColor")
    def label_color(self) -> Optional[str]:
        return pulumi.get(self, "label_color")

    @property
    @pulumi.getter(name="labelContent")
    def label_content(self) -> Optional['TemplateDataLabelContent']:
        return pulumi.get(self, "label_content")

    @property
    @pulumi.getter(name="labelFontConfiguration")
    def label_font_configuration(self) -> Optional['outputs.TemplateFontConfiguration']:
        return pulumi.get(self, "label_font_configuration")

    @property
    @pulumi.getter(name="measureLabelVisibility")
    def measure_label_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "measure_label_visibility")

    @property
    @pulumi.getter
    def overlap(self) -> Optional['TemplateDataLabelOverlap']:
        return pulumi.get(self, "overlap")

    @property
    @pulumi.getter
    def position(self) -> Optional['TemplateDataLabelPosition']:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "totals_visibility")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateDataLabelType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPathLabelType":
            suggest = "data_path_label_type"
        elif key == "fieldLabelType":
            suggest = "field_label_type"
        elif key == "maximumLabelType":
            suggest = "maximum_label_type"
        elif key == "minimumLabelType":
            suggest = "minimum_label_type"
        elif key == "rangeEndsLabelType":
            suggest = "range_ends_label_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataLabelType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataLabelType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataLabelType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_path_label_type: Optional['outputs.TemplateDataPathLabelType'] = None,
                 field_label_type: Optional['outputs.TemplateFieldLabelType'] = None,
                 maximum_label_type: Optional['outputs.TemplateMaximumLabelType'] = None,
                 minimum_label_type: Optional['outputs.TemplateMinimumLabelType'] = None,
                 range_ends_label_type: Optional['outputs.TemplateRangeEndsLabelType'] = None):
        TemplateDataLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_path_label_type=data_path_label_type,
            field_label_type=field_label_type,
            maximum_label_type=maximum_label_type,
            minimum_label_type=minimum_label_type,
            range_ends_label_type=range_ends_label_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_path_label_type: Optional['outputs.TemplateDataPathLabelType'] = None,
             field_label_type: Optional['outputs.TemplateFieldLabelType'] = None,
             maximum_label_type: Optional['outputs.TemplateMaximumLabelType'] = None,
             minimum_label_type: Optional['outputs.TemplateMinimumLabelType'] = None,
             range_ends_label_type: Optional['outputs.TemplateRangeEndsLabelType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_path_label_type is not None:
            _setter("data_path_label_type", data_path_label_type)
        if field_label_type is not None:
            _setter("field_label_type", field_label_type)
        if maximum_label_type is not None:
            _setter("maximum_label_type", maximum_label_type)
        if minimum_label_type is not None:
            _setter("minimum_label_type", minimum_label_type)
        if range_ends_label_type is not None:
            _setter("range_ends_label_type", range_ends_label_type)

    @property
    @pulumi.getter(name="dataPathLabelType")
    def data_path_label_type(self) -> Optional['outputs.TemplateDataPathLabelType']:
        return pulumi.get(self, "data_path_label_type")

    @property
    @pulumi.getter(name="fieldLabelType")
    def field_label_type(self) -> Optional['outputs.TemplateFieldLabelType']:
        return pulumi.get(self, "field_label_type")

    @property
    @pulumi.getter(name="maximumLabelType")
    def maximum_label_type(self) -> Optional['outputs.TemplateMaximumLabelType']:
        return pulumi.get(self, "maximum_label_type")

    @property
    @pulumi.getter(name="minimumLabelType")
    def minimum_label_type(self) -> Optional['outputs.TemplateMinimumLabelType']:
        return pulumi.get(self, "minimum_label_type")

    @property
    @pulumi.getter(name="rangeEndsLabelType")
    def range_ends_label_type(self) -> Optional['outputs.TemplateRangeEndsLabelType']:
        return pulumi.get(self, "range_ends_label_type")


@pulumi.output_type
class TemplateDataPathColor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataPathColor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataPathColor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataPathColor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: str,
                 element: 'outputs.TemplateDataPathValue',
                 time_granularity: Optional['TemplateTimeGranularity'] = None):
        TemplateDataPathColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            element=element,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: str,
             element: 'outputs.TemplateDataPathValue',
             time_granularity: Optional['TemplateTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)
        _setter("element", element)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def element(self) -> 'outputs.TemplateDataPathValue':
        return pulumi.get(self, "element")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['TemplateTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class TemplateDataPathLabelType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataPathLabelType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataPathLabelType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataPathLabelType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: Optional[str] = None,
                 field_value: Optional[str] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateDataPathLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            field_value=field_value,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: Optional[str] = None,
             field_value: Optional[str] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_id is not None:
            _setter("field_id", field_id)
        if field_value is not None:
            _setter("field_value", field_value)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[str]:
        return pulumi.get(self, "field_value")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateDataPathSort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortPaths":
            suggest = "sort_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataPathSort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataPathSort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataPathSort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: 'TemplateSortDirection',
                 sort_paths: Sequence['outputs.TemplateDataPathValue']):
        TemplateDataPathSort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            sort_paths=sort_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: 'TemplateSortDirection',
             sort_paths: Sequence['outputs.TemplateDataPathValue'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("direction", direction)
        _setter("sort_paths", sort_paths)

    @property
    @pulumi.getter
    def direction(self) -> 'TemplateSortDirection':
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="sortPaths")
    def sort_paths(self) -> Sequence['outputs.TemplateDataPathValue']:
        return pulumi.get(self, "sort_paths")


@pulumi.output_type
class TemplateDataPathValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataPathValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataPathValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataPathValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 field_value: str):
        TemplateDataPathValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            field_value=field_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             field_value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        _setter("field_value", field_value)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> str:
        return pulumi.get(self, "field_value")


@pulumi.output_type
class TemplateDataSetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnGroupSchemaList":
            suggest = "column_group_schema_list"
        elif key == "dataSetSchema":
            suggest = "data_set_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataSetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataSetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataSetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_group_schema_list: Optional[Sequence['outputs.TemplateColumnGroupSchema']] = None,
                 data_set_schema: Optional['outputs.TemplateDataSetSchema'] = None,
                 placeholder: Optional[str] = None):
        TemplateDataSetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_group_schema_list=column_group_schema_list,
            data_set_schema=data_set_schema,
            placeholder=placeholder,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_group_schema_list: Optional[Sequence['outputs.TemplateColumnGroupSchema']] = None,
             data_set_schema: Optional['outputs.TemplateDataSetSchema'] = None,
             placeholder: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_group_schema_list is not None:
            _setter("column_group_schema_list", column_group_schema_list)
        if data_set_schema is not None:
            _setter("data_set_schema", data_set_schema)
        if placeholder is not None:
            _setter("placeholder", placeholder)

    @property
    @pulumi.getter(name="columnGroupSchemaList")
    def column_group_schema_list(self) -> Optional[Sequence['outputs.TemplateColumnGroupSchema']]:
        return pulumi.get(self, "column_group_schema_list")

    @property
    @pulumi.getter(name="dataSetSchema")
    def data_set_schema(self) -> Optional['outputs.TemplateDataSetSchema']:
        return pulumi.get(self, "data_set_schema")

    @property
    @pulumi.getter
    def placeholder(self) -> Optional[str]:
        return pulumi.get(self, "placeholder")


@pulumi.output_type
class TemplateDataSetReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetArn":
            suggest = "data_set_arn"
        elif key == "dataSetPlaceholder":
            suggest = "data_set_placeholder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataSetReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataSetReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataSetReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_arn: str,
                 data_set_placeholder: str):
        TemplateDataSetReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_arn=data_set_arn,
            data_set_placeholder=data_set_placeholder,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_arn: str,
             data_set_placeholder: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_arn", data_set_arn)
        _setter("data_set_placeholder", data_set_placeholder)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> str:
        return pulumi.get(self, "data_set_arn")

    @property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> str:
        return pulumi.get(self, "data_set_placeholder")


@pulumi.output_type
class TemplateDataSetSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnSchemaList":
            suggest = "column_schema_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDataSetSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDataSetSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDataSetSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_schema_list: Optional[Sequence['outputs.TemplateColumnSchema']] = None):
        TemplateDataSetSchema._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_schema_list=column_schema_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_schema_list: Optional[Sequence['outputs.TemplateColumnSchema']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_schema_list is not None:
            _setter("column_schema_list", column_schema_list)

    @property
    @pulumi.getter(name="columnSchemaList")
    def column_schema_list(self) -> Optional[Sequence['outputs.TemplateColumnSchema']]:
        return pulumi.get(self, "column_schema_list")


@pulumi.output_type
class TemplateDateAxisOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "missingDateVisibility":
            suggest = "missing_date_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDateAxisOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDateAxisOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDateAxisOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 missing_date_visibility: Optional['TemplateVisibility'] = None):
        TemplateDateAxisOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            missing_date_visibility=missing_date_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             missing_date_visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if missing_date_visibility is not None:
            _setter("missing_date_visibility", missing_date_visibility)

    @property
    @pulumi.getter(name="missingDateVisibility")
    def missing_date_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "missing_date_visibility")


@pulumi.output_type
class TemplateDateDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "dateGranularity":
            suggest = "date_granularity"
        elif key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "hierarchyId":
            suggest = "hierarchy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDateDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDateDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDateDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 field_id: str,
                 date_granularity: Optional['TemplateTimeGranularity'] = None,
                 format_configuration: Optional['outputs.TemplateDateTimeFormatConfiguration'] = None,
                 hierarchy_id: Optional[str] = None):
        TemplateDateDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            date_granularity=date_granularity,
            format_configuration=format_configuration,
            hierarchy_id=hierarchy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             field_id: str,
             date_granularity: Optional['TemplateTimeGranularity'] = None,
             format_configuration: Optional['outputs.TemplateDateTimeFormatConfiguration'] = None,
             hierarchy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if date_granularity is not None:
            _setter("date_granularity", date_granularity)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if hierarchy_id is not None:
            _setter("hierarchy_id", hierarchy_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="dateGranularity")
    def date_granularity(self) -> Optional['TemplateTimeGranularity']:
        return pulumi.get(self, "date_granularity")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.TemplateDateTimeFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> Optional[str]:
        return pulumi.get(self, "hierarchy_id")


@pulumi.output_type
class TemplateDateMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDateMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDateMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDateMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 field_id: str,
                 aggregation_function: Optional['TemplateDateAggregationFunction'] = None,
                 format_configuration: Optional['outputs.TemplateDateTimeFormatConfiguration'] = None):
        TemplateDateMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            aggregation_function=aggregation_function,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             field_id: str,
             aggregation_function: Optional['TemplateDateAggregationFunction'] = None,
             format_configuration: Optional['outputs.TemplateDateTimeFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['TemplateDateAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.TemplateDateTimeFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class TemplateDateTimeDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "rollingDate":
            suggest = "rolling_date"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDateTimeDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDateTimeDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDateTimeDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.TemplateDynamicDefaultValue'] = None,
                 rolling_date: Optional['outputs.TemplateRollingDateConfiguration'] = None,
                 static_values: Optional[Sequence[str]] = None):
        TemplateDateTimeDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            rolling_date=rolling_date,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.TemplateDynamicDefaultValue'] = None,
             rolling_date: Optional['outputs.TemplateRollingDateConfiguration'] = None,
             static_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if rolling_date is not None:
            _setter("rolling_date", rolling_date)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.TemplateDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="rollingDate")
    def rolling_date(self) -> Optional['outputs.TemplateRollingDateConfiguration']:
        return pulumi.get(self, "rolling_date")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class TemplateDateTimeFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormat":
            suggest = "date_time_format"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numericFormatConfiguration":
            suggest = "numeric_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDateTimeFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDateTimeFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDateTimeFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format: Optional[str] = None,
                 null_value_format_configuration: Optional['outputs.TemplateNullValueFormatConfiguration'] = None,
                 numeric_format_configuration: Optional['outputs.TemplateNumericFormatConfiguration'] = None):
        TemplateDateTimeFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format=date_time_format,
            null_value_format_configuration=null_value_format_configuration,
            numeric_format_configuration=numeric_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format: Optional[str] = None,
             null_value_format_configuration: Optional['outputs.TemplateNullValueFormatConfiguration'] = None,
             numeric_format_configuration: Optional['outputs.TemplateNumericFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format is not None:
            _setter("date_time_format", date_time_format)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if numeric_format_configuration is not None:
            _setter("numeric_format_configuration", numeric_format_configuration)

    @property
    @pulumi.getter(name="dateTimeFormat")
    def date_time_format(self) -> Optional[str]:
        return pulumi.get(self, "date_time_format")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.TemplateNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numericFormatConfiguration")
    def numeric_format_configuration(self) -> Optional['outputs.TemplateNumericFormatConfiguration']:
        return pulumi.get(self, "numeric_format_configuration")


@pulumi.output_type
class TemplateDateTimeHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hierarchyId":
            suggest = "hierarchy_id"
        elif key == "drillDownFilters":
            suggest = "drill_down_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDateTimeHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDateTimeHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDateTimeHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hierarchy_id: str,
                 drill_down_filters: Optional[Sequence['outputs.TemplateDrillDownFilter']] = None):
        TemplateDateTimeHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hierarchy_id=hierarchy_id,
            drill_down_filters=drill_down_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hierarchy_id: str,
             drill_down_filters: Optional[Sequence['outputs.TemplateDrillDownFilter']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hierarchy_id", hierarchy_id)
        if drill_down_filters is not None:
            _setter("drill_down_filters", drill_down_filters)

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> str:
        return pulumi.get(self, "hierarchy_id")

    @property
    @pulumi.getter(name="drillDownFilters")
    def drill_down_filters(self) -> Optional[Sequence['outputs.TemplateDrillDownFilter']]:
        return pulumi.get(self, "drill_down_filters")


@pulumi.output_type
class TemplateDateTimeParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "timeGranularity":
            suggest = "time_granularity"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDateTimeParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDateTimeParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDateTimeParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 default_values: Optional['outputs.TemplateDateTimeDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.TemplateMappedDataSetParameter']] = None,
                 time_granularity: Optional['TemplateTimeGranularity'] = None,
                 value_when_unset: Optional['outputs.TemplateDateTimeValueWhenUnsetConfiguration'] = None):
        TemplateDateTimeParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            time_granularity=time_granularity,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             default_values: Optional['outputs.TemplateDateTimeDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.TemplateMappedDataSetParameter']] = None,
             time_granularity: Optional['TemplateTimeGranularity'] = None,
             value_when_unset: Optional['outputs.TemplateDateTimeValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.TemplateDateTimeDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.TemplateMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['TemplateTimeGranularity']:
        return pulumi.get(self, "time_granularity")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.TemplateDateTimeValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class TemplateDateTimePickerControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormat":
            suggest = "date_time_format"
        elif key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDateTimePickerControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDateTimePickerControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDateTimePickerControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format: Optional[str] = None,
                 info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
                 title_options: Optional['outputs.TemplateLabelOptions'] = None):
        TemplateDateTimePickerControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format=date_time_format,
            info_icon_label_options=info_icon_label_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format: Optional[str] = None,
             info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
             title_options: Optional['outputs.TemplateLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format is not None:
            _setter("date_time_format", date_time_format)
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="dateTimeFormat")
    def date_time_format(self) -> Optional[str]:
        return pulumi.get(self, "date_time_format")

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.TemplateSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.TemplateLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class TemplateDateTimeValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDateTimeValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDateTimeValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDateTimeValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[str] = None,
                 value_when_unset_option: Optional['TemplateValueWhenUnsetOption'] = None):
        TemplateDateTimeValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[str] = None,
             value_when_unset_option: Optional['TemplateValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[str]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['TemplateValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class TemplateDecimalDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDecimalDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDecimalDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDecimalDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.TemplateDynamicDefaultValue'] = None,
                 static_values: Optional[Sequence[float]] = None):
        TemplateDecimalDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.TemplateDynamicDefaultValue'] = None,
             static_values: Optional[Sequence[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.TemplateDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class TemplateDecimalParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueType":
            suggest = "parameter_value_type"
        elif key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDecimalParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDecimalParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDecimalParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 parameter_value_type: 'TemplateParameterValueType',
                 default_values: Optional['outputs.TemplateDecimalDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.TemplateMappedDataSetParameter']] = None,
                 value_when_unset: Optional['outputs.TemplateDecimalValueWhenUnsetConfiguration'] = None):
        TemplateDecimalParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameter_value_type=parameter_value_type,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             parameter_value_type: 'TemplateParameterValueType',
             default_values: Optional['outputs.TemplateDecimalDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.TemplateMappedDataSetParameter']] = None,
             value_when_unset: Optional['outputs.TemplateDecimalValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("parameter_value_type", parameter_value_type)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterValueType")
    def parameter_value_type(self) -> 'TemplateParameterValueType':
        return pulumi.get(self, "parameter_value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.TemplateDecimalDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.TemplateMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.TemplateDecimalValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class TemplateDecimalPlacesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlaces":
            suggest = "decimal_places"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDecimalPlacesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDecimalPlacesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDecimalPlacesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places: float):
        TemplateDecimalPlacesConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places=decimal_places,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("decimal_places", decimal_places)

    @property
    @pulumi.getter(name="decimalPlaces")
    def decimal_places(self) -> float:
        return pulumi.get(self, "decimal_places")


@pulumi.output_type
class TemplateDecimalValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDecimalValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDecimalValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDecimalValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[float] = None,
                 value_when_unset_option: Optional['TemplateValueWhenUnsetOption'] = None):
        TemplateDecimalValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[float] = None,
             value_when_unset_option: Optional['TemplateValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[float]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['TemplateValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class TemplateDefaultFreeFormLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDefaultFreeFormLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDefaultFreeFormLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDefaultFreeFormLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canvas_size_options: 'outputs.TemplateFreeFormLayoutCanvasSizeOptions'):
        TemplateDefaultFreeFormLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canvas_size_options: 'outputs.TemplateFreeFormLayoutCanvasSizeOptions',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.TemplateFreeFormLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class TemplateDefaultGridLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDefaultGridLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDefaultGridLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDefaultGridLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canvas_size_options: 'outputs.TemplateGridLayoutCanvasSizeOptions'):
        TemplateDefaultGridLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canvas_size_options: 'outputs.TemplateGridLayoutCanvasSizeOptions',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.TemplateGridLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class TemplateDefaultInteractiveLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeForm":
            suggest = "free_form"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDefaultInteractiveLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDefaultInteractiveLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDefaultInteractiveLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_form: Optional['outputs.TemplateDefaultFreeFormLayoutConfiguration'] = None,
                 grid: Optional['outputs.TemplateDefaultGridLayoutConfiguration'] = None):
        TemplateDefaultInteractiveLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            free_form=free_form,
            grid=grid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             free_form: Optional['outputs.TemplateDefaultFreeFormLayoutConfiguration'] = None,
             grid: Optional['outputs.TemplateDefaultGridLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if free_form is not None:
            _setter("free_form", free_form)
        if grid is not None:
            _setter("grid", grid)

    @property
    @pulumi.getter(name="freeForm")
    def free_form(self) -> Optional['outputs.TemplateDefaultFreeFormLayoutConfiguration']:
        return pulumi.get(self, "free_form")

    @property
    @pulumi.getter
    def grid(self) -> Optional['outputs.TemplateDefaultGridLayoutConfiguration']:
        return pulumi.get(self, "grid")


@pulumi.output_type
class TemplateDefaultNewSheetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interactiveLayoutConfiguration":
            suggest = "interactive_layout_configuration"
        elif key == "paginatedLayoutConfiguration":
            suggest = "paginated_layout_configuration"
        elif key == "sheetContentType":
            suggest = "sheet_content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDefaultNewSheetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDefaultNewSheetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDefaultNewSheetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interactive_layout_configuration: Optional['outputs.TemplateDefaultInteractiveLayoutConfiguration'] = None,
                 paginated_layout_configuration: Optional['outputs.TemplateDefaultPaginatedLayoutConfiguration'] = None,
                 sheet_content_type: Optional['TemplateSheetContentType'] = None):
        TemplateDefaultNewSheetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interactive_layout_configuration=interactive_layout_configuration,
            paginated_layout_configuration=paginated_layout_configuration,
            sheet_content_type=sheet_content_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interactive_layout_configuration: Optional['outputs.TemplateDefaultInteractiveLayoutConfiguration'] = None,
             paginated_layout_configuration: Optional['outputs.TemplateDefaultPaginatedLayoutConfiguration'] = None,
             sheet_content_type: Optional['TemplateSheetContentType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if interactive_layout_configuration is not None:
            _setter("interactive_layout_configuration", interactive_layout_configuration)
        if paginated_layout_configuration is not None:
            _setter("paginated_layout_configuration", paginated_layout_configuration)
        if sheet_content_type is not None:
            _setter("sheet_content_type", sheet_content_type)

    @property
    @pulumi.getter(name="interactiveLayoutConfiguration")
    def interactive_layout_configuration(self) -> Optional['outputs.TemplateDefaultInteractiveLayoutConfiguration']:
        return pulumi.get(self, "interactive_layout_configuration")

    @property
    @pulumi.getter(name="paginatedLayoutConfiguration")
    def paginated_layout_configuration(self) -> Optional['outputs.TemplateDefaultPaginatedLayoutConfiguration']:
        return pulumi.get(self, "paginated_layout_configuration")

    @property
    @pulumi.getter(name="sheetContentType")
    def sheet_content_type(self) -> Optional['TemplateSheetContentType']:
        return pulumi.get(self, "sheet_content_type")


@pulumi.output_type
class TemplateDefaultPaginatedLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionBased":
            suggest = "section_based"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDefaultPaginatedLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDefaultPaginatedLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDefaultPaginatedLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 section_based: Optional['outputs.TemplateDefaultSectionBasedLayoutConfiguration'] = None):
        TemplateDefaultPaginatedLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            section_based=section_based,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             section_based: Optional['outputs.TemplateDefaultSectionBasedLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if section_based is not None:
            _setter("section_based", section_based)

    @property
    @pulumi.getter(name="sectionBased")
    def section_based(self) -> Optional['outputs.TemplateDefaultSectionBasedLayoutConfiguration']:
        return pulumi.get(self, "section_based")


@pulumi.output_type
class TemplateDefaultSectionBasedLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDefaultSectionBasedLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDefaultSectionBasedLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDefaultSectionBasedLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canvas_size_options: 'outputs.TemplateSectionBasedLayoutCanvasSizeOptions'):
        TemplateDefaultSectionBasedLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canvas_size_options: 'outputs.TemplateSectionBasedLayoutCanvasSizeOptions',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.TemplateSectionBasedLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class TemplateDestinationParameterValueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValuesConfiguration":
            suggest = "custom_values_configuration"
        elif key == "selectAllValueOptions":
            suggest = "select_all_value_options"
        elif key == "sourceColumn":
            suggest = "source_column"
        elif key == "sourceField":
            suggest = "source_field"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDestinationParameterValueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDestinationParameterValueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDestinationParameterValueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_values_configuration: Optional['outputs.TemplateCustomValuesConfiguration'] = None,
                 select_all_value_options: Optional['TemplateSelectAllValueOptions'] = None,
                 source_column: Optional['outputs.TemplateColumnIdentifier'] = None,
                 source_field: Optional[str] = None,
                 source_parameter_name: Optional[str] = None):
        TemplateDestinationParameterValueConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_values_configuration=custom_values_configuration,
            select_all_value_options=select_all_value_options,
            source_column=source_column,
            source_field=source_field,
            source_parameter_name=source_parameter_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_values_configuration: Optional['outputs.TemplateCustomValuesConfiguration'] = None,
             select_all_value_options: Optional['TemplateSelectAllValueOptions'] = None,
             source_column: Optional['outputs.TemplateColumnIdentifier'] = None,
             source_field: Optional[str] = None,
             source_parameter_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_values_configuration is not None:
            _setter("custom_values_configuration", custom_values_configuration)
        if select_all_value_options is not None:
            _setter("select_all_value_options", select_all_value_options)
        if source_column is not None:
            _setter("source_column", source_column)
        if source_field is not None:
            _setter("source_field", source_field)
        if source_parameter_name is not None:
            _setter("source_parameter_name", source_parameter_name)

    @property
    @pulumi.getter(name="customValuesConfiguration")
    def custom_values_configuration(self) -> Optional['outputs.TemplateCustomValuesConfiguration']:
        return pulumi.get(self, "custom_values_configuration")

    @property
    @pulumi.getter(name="selectAllValueOptions")
    def select_all_value_options(self) -> Optional['TemplateSelectAllValueOptions']:
        return pulumi.get(self, "select_all_value_options")

    @property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> Optional['outputs.TemplateColumnIdentifier']:
        return pulumi.get(self, "source_column")

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[str]:
        return pulumi.get(self, "source_field")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "source_parameter_name")


@pulumi.output_type
class TemplateDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoricalDimensionField":
            suggest = "categorical_dimension_field"
        elif key == "dateDimensionField":
            suggest = "date_dimension_field"
        elif key == "numericalDimensionField":
            suggest = "numerical_dimension_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categorical_dimension_field: Optional['outputs.TemplateCategoricalDimensionField'] = None,
                 date_dimension_field: Optional['outputs.TemplateDateDimensionField'] = None,
                 numerical_dimension_field: Optional['outputs.TemplateNumericalDimensionField'] = None):
        TemplateDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            categorical_dimension_field=categorical_dimension_field,
            date_dimension_field=date_dimension_field,
            numerical_dimension_field=numerical_dimension_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             categorical_dimension_field: Optional['outputs.TemplateCategoricalDimensionField'] = None,
             date_dimension_field: Optional['outputs.TemplateDateDimensionField'] = None,
             numerical_dimension_field: Optional['outputs.TemplateNumericalDimensionField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if categorical_dimension_field is not None:
            _setter("categorical_dimension_field", categorical_dimension_field)
        if date_dimension_field is not None:
            _setter("date_dimension_field", date_dimension_field)
        if numerical_dimension_field is not None:
            _setter("numerical_dimension_field", numerical_dimension_field)

    @property
    @pulumi.getter(name="categoricalDimensionField")
    def categorical_dimension_field(self) -> Optional['outputs.TemplateCategoricalDimensionField']:
        return pulumi.get(self, "categorical_dimension_field")

    @property
    @pulumi.getter(name="dateDimensionField")
    def date_dimension_field(self) -> Optional['outputs.TemplateDateDimensionField']:
        return pulumi.get(self, "date_dimension_field")

    @property
    @pulumi.getter(name="numericalDimensionField")
    def numerical_dimension_field(self) -> Optional['outputs.TemplateNumericalDimensionField']:
        return pulumi.get(self, "numerical_dimension_field")


@pulumi.output_type
class TemplateDonutCenterOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelVisibility":
            suggest = "label_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDonutCenterOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDonutCenterOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDonutCenterOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_visibility: Optional['TemplateVisibility'] = None):
        TemplateDonutCenterOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_visibility=label_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if label_visibility is not None:
            _setter("label_visibility", label_visibility)

    @property
    @pulumi.getter(name="labelVisibility")
    def label_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "label_visibility")


@pulumi.output_type
class TemplateDonutOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcOptions":
            suggest = "arc_options"
        elif key == "donutCenterOptions":
            suggest = "donut_center_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDonutOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDonutOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDonutOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc_options: Optional['outputs.TemplateArcOptions'] = None,
                 donut_center_options: Optional['outputs.TemplateDonutCenterOptions'] = None):
        TemplateDonutOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc_options=arc_options,
            donut_center_options=donut_center_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc_options: Optional['outputs.TemplateArcOptions'] = None,
             donut_center_options: Optional['outputs.TemplateDonutCenterOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc_options is not None:
            _setter("arc_options", arc_options)
        if donut_center_options is not None:
            _setter("donut_center_options", donut_center_options)

    @property
    @pulumi.getter(name="arcOptions")
    def arc_options(self) -> Optional['outputs.TemplateArcOptions']:
        return pulumi.get(self, "arc_options")

    @property
    @pulumi.getter(name="donutCenterOptions")
    def donut_center_options(self) -> Optional['outputs.TemplateDonutCenterOptions']:
        return pulumi.get(self, "donut_center_options")


@pulumi.output_type
class TemplateDrillDownFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryFilter":
            suggest = "category_filter"
        elif key == "numericEqualityFilter":
            suggest = "numeric_equality_filter"
        elif key == "timeRangeFilter":
            suggest = "time_range_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDrillDownFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDrillDownFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDrillDownFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_filter: Optional['outputs.TemplateCategoryDrillDownFilter'] = None,
                 numeric_equality_filter: Optional['outputs.TemplateNumericEqualityDrillDownFilter'] = None,
                 time_range_filter: Optional['outputs.TemplateTimeRangeDrillDownFilter'] = None):
        TemplateDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_filter=category_filter,
            numeric_equality_filter=numeric_equality_filter,
            time_range_filter=time_range_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_filter: Optional['outputs.TemplateCategoryDrillDownFilter'] = None,
             numeric_equality_filter: Optional['outputs.TemplateNumericEqualityDrillDownFilter'] = None,
             time_range_filter: Optional['outputs.TemplateTimeRangeDrillDownFilter'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_filter is not None:
            _setter("category_filter", category_filter)
        if numeric_equality_filter is not None:
            _setter("numeric_equality_filter", numeric_equality_filter)
        if time_range_filter is not None:
            _setter("time_range_filter", time_range_filter)

    @property
    @pulumi.getter(name="categoryFilter")
    def category_filter(self) -> Optional['outputs.TemplateCategoryDrillDownFilter']:
        return pulumi.get(self, "category_filter")

    @property
    @pulumi.getter(name="numericEqualityFilter")
    def numeric_equality_filter(self) -> Optional['outputs.TemplateNumericEqualityDrillDownFilter']:
        return pulumi.get(self, "numeric_equality_filter")

    @property
    @pulumi.getter(name="timeRangeFilter")
    def time_range_filter(self) -> Optional['outputs.TemplateTimeRangeDrillDownFilter']:
        return pulumi.get(self, "time_range_filter")


@pulumi.output_type
class TemplateDropDownControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "selectAllOptions":
            suggest = "select_all_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDropDownControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDropDownControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDropDownControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
                 select_all_options: Optional['outputs.TemplateListControlSelectAllOptions'] = None,
                 title_options: Optional['outputs.TemplateLabelOptions'] = None):
        TemplateDropDownControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            select_all_options=select_all_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
             select_all_options: Optional['outputs.TemplateListControlSelectAllOptions'] = None,
             title_options: Optional['outputs.TemplateLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.TemplateSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['outputs.TemplateListControlSelectAllOptions']:
        return pulumi.get(self, "select_all_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.TemplateLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class TemplateDynamicDefaultValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValueColumn":
            suggest = "default_value_column"
        elif key == "groupNameColumn":
            suggest = "group_name_column"
        elif key == "userNameColumn":
            suggest = "user_name_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateDynamicDefaultValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateDynamicDefaultValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateDynamicDefaultValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value_column: 'outputs.TemplateColumnIdentifier',
                 group_name_column: Optional['outputs.TemplateColumnIdentifier'] = None,
                 user_name_column: Optional['outputs.TemplateColumnIdentifier'] = None):
        TemplateDynamicDefaultValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_value_column=default_value_column,
            group_name_column=group_name_column,
            user_name_column=user_name_column,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_value_column: 'outputs.TemplateColumnIdentifier',
             group_name_column: Optional['outputs.TemplateColumnIdentifier'] = None,
             user_name_column: Optional['outputs.TemplateColumnIdentifier'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_value_column", default_value_column)
        if group_name_column is not None:
            _setter("group_name_column", group_name_column)
        if user_name_column is not None:
            _setter("user_name_column", user_name_column)

    @property
    @pulumi.getter(name="defaultValueColumn")
    def default_value_column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "default_value_column")

    @property
    @pulumi.getter(name="groupNameColumn")
    def group_name_column(self) -> Optional['outputs.TemplateColumnIdentifier']:
        return pulumi.get(self, "group_name_column")

    @property
    @pulumi.getter(name="userNameColumn")
    def user_name_column(self) -> Optional['outputs.TemplateColumnIdentifier']:
        return pulumi.get(self, "user_name_column")


@pulumi.output_type
class TemplateEmptyVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "visualId":
            suggest = "visual_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateEmptyVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateEmptyVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateEmptyVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None):
        TemplateEmptyVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            visual_id=visual_id,
            actions=actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")


@pulumi.output_type
class TemplateEntity(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None):
        TemplateEntity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class TemplateError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "violatedEntities":
            suggest = "violated_entities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: Optional[str] = None,
                 type: Optional['TemplateErrorType'] = None,
                 violated_entities: Optional[Sequence['outputs.TemplateEntity']] = None):
        TemplateError._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
            type=type,
            violated_entities=violated_entities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: Optional[str] = None,
             type: Optional['TemplateErrorType'] = None,
             violated_entities: Optional[Sequence['outputs.TemplateEntity']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if message is not None:
            _setter("message", message)
        if type is not None:
            _setter("type", type)
        if violated_entities is not None:
            _setter("violated_entities", violated_entities)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def type(self) -> Optional['TemplateErrorType']:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="violatedEntities")
    def violated_entities(self) -> Optional[Sequence['outputs.TemplateEntity']]:
        return pulumi.get(self, "violated_entities")


@pulumi.output_type
class TemplateExcludePeriodConfiguration(dict):
    def __init__(__self__, *,
                 amount: float,
                 granularity: 'TemplateTimeGranularity',
                 status: Optional['TemplateWidgetStatus'] = None):
        TemplateExcludePeriodConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amount=amount,
            granularity=granularity,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amount: float,
             granularity: 'TemplateTimeGranularity',
             status: Optional['TemplateWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("amount", amount)
        _setter("granularity", granularity)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def amount(self) -> float:
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def granularity(self) -> 'TemplateTimeGranularity':
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter
    def status(self) -> Optional['TemplateWidgetStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class TemplateExplicitHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hierarchyId":
            suggest = "hierarchy_id"
        elif key == "drillDownFilters":
            suggest = "drill_down_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateExplicitHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateExplicitHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateExplicitHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence['outputs.TemplateColumnIdentifier'],
                 hierarchy_id: str,
                 drill_down_filters: Optional[Sequence['outputs.TemplateDrillDownFilter']] = None):
        TemplateExplicitHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            hierarchy_id=hierarchy_id,
            drill_down_filters=drill_down_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Sequence['outputs.TemplateColumnIdentifier'],
             hierarchy_id: str,
             drill_down_filters: Optional[Sequence['outputs.TemplateDrillDownFilter']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("columns", columns)
        _setter("hierarchy_id", hierarchy_id)
        if drill_down_filters is not None:
            _setter("drill_down_filters", drill_down_filters)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.TemplateColumnIdentifier']:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> str:
        return pulumi.get(self, "hierarchy_id")

    @property
    @pulumi.getter(name="drillDownFilters")
    def drill_down_filters(self) -> Optional[Sequence['outputs.TemplateDrillDownFilter']]:
        return pulumi.get(self, "drill_down_filters")


@pulumi.output_type
class TemplateFieldBasedTooltip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationVisibility":
            suggest = "aggregation_visibility"
        elif key == "tooltipFields":
            suggest = "tooltip_fields"
        elif key == "tooltipTitleType":
            suggest = "tooltip_title_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFieldBasedTooltip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFieldBasedTooltip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFieldBasedTooltip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_visibility: Optional['TemplateVisibility'] = None,
                 tooltip_fields: Optional[Sequence['outputs.TemplateTooltipItem']] = None,
                 tooltip_title_type: Optional['TemplateTooltipTitleType'] = None):
        TemplateFieldBasedTooltip._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_visibility=aggregation_visibility,
            tooltip_fields=tooltip_fields,
            tooltip_title_type=tooltip_title_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_visibility: Optional['TemplateVisibility'] = None,
             tooltip_fields: Optional[Sequence['outputs.TemplateTooltipItem']] = None,
             tooltip_title_type: Optional['TemplateTooltipTitleType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregation_visibility is not None:
            _setter("aggregation_visibility", aggregation_visibility)
        if tooltip_fields is not None:
            _setter("tooltip_fields", tooltip_fields)
        if tooltip_title_type is not None:
            _setter("tooltip_title_type", tooltip_title_type)

    @property
    @pulumi.getter(name="aggregationVisibility")
    def aggregation_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "aggregation_visibility")

    @property
    @pulumi.getter(name="tooltipFields")
    def tooltip_fields(self) -> Optional[Sequence['outputs.TemplateTooltipItem']]:
        return pulumi.get(self, "tooltip_fields")

    @property
    @pulumi.getter(name="tooltipTitleType")
    def tooltip_title_type(self) -> Optional['TemplateTooltipTitleType']:
        return pulumi.get(self, "tooltip_title_type")


@pulumi.output_type
class TemplateFieldLabelType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFieldLabelType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFieldLabelType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFieldLabelType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: Optional[str] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateFieldLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: Optional[str] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_id is not None:
            _setter("field_id", field_id)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateFieldSeriesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFieldSeriesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFieldSeriesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFieldSeriesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: 'TemplateAxisBinding',
                 field_id: str,
                 settings: Optional['outputs.TemplateLineChartSeriesSettings'] = None):
        TemplateFieldSeriesItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            field_id=field_id,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: 'TemplateAxisBinding',
             field_id: str,
             settings: Optional['outputs.TemplateLineChartSeriesSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("axis_binding", axis_binding)
        _setter("field_id", field_id)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> 'TemplateAxisBinding':
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.TemplateLineChartSeriesSettings']:
        return pulumi.get(self, "settings")


@pulumi.output_type
class TemplateFieldSort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFieldSort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFieldSort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFieldSort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: 'TemplateSortDirection',
                 field_id: str):
        TemplateFieldSort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            direction=direction,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             direction: 'TemplateSortDirection',
             field_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("direction", direction)
        _setter("field_id", field_id)

    @property
    @pulumi.getter
    def direction(self) -> 'TemplateSortDirection':
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class TemplateFieldSortOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnSort":
            suggest = "column_sort"
        elif key == "fieldSort":
            suggest = "field_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFieldSortOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFieldSortOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFieldSortOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_sort: Optional['outputs.TemplateColumnSort'] = None,
                 field_sort: Optional['outputs.TemplateFieldSort'] = None):
        TemplateFieldSortOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_sort=column_sort,
            field_sort=field_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_sort: Optional['outputs.TemplateColumnSort'] = None,
             field_sort: Optional['outputs.TemplateFieldSort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_sort is not None:
            _setter("column_sort", column_sort)
        if field_sort is not None:
            _setter("field_sort", field_sort)

    @property
    @pulumi.getter(name="columnSort")
    def column_sort(self) -> Optional['outputs.TemplateColumnSort']:
        return pulumi.get(self, "column_sort")

    @property
    @pulumi.getter(name="fieldSort")
    def field_sort(self) -> Optional['outputs.TemplateFieldSort']:
        return pulumi.get(self, "field_sort")


@pulumi.output_type
class TemplateFieldTooltipItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFieldTooltipItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFieldTooltipItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFieldTooltipItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 label: Optional[str] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateFieldTooltipItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            label=label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             label: Optional[str] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if label is not None:
            _setter("label", label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateFilledMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 geospatial: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateFilledMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            geospatial=geospatial,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             geospatial: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if geospatial is not None:
            _setter("geospatial", geospatial)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def geospatial(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "geospatial")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateFilledMapConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilledMapConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilledMapConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilledMapConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Sequence['outputs.TemplateFilledMapConditionalFormattingOption']):
        TemplateFilledMapConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Sequence['outputs.TemplateFilledMapConditionalFormattingOption'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Sequence['outputs.TemplateFilledMapConditionalFormattingOption']:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class TemplateFilledMapConditionalFormattingOption(dict):
    def __init__(__self__, *,
                 shape: 'outputs.TemplateFilledMapShapeConditionalFormatting'):
        TemplateFilledMapConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            shape=shape,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             shape: 'outputs.TemplateFilledMapShapeConditionalFormatting',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("shape", shape)

    @property
    @pulumi.getter
    def shape(self) -> 'outputs.TemplateFilledMapShapeConditionalFormatting':
        return pulumi.get(self, "shape")


@pulumi.output_type
class TemplateFilledMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldWells":
            suggest = "field_wells"
        elif key == "mapStyleOptions":
            suggest = "map_style_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "windowOptions":
            suggest = "window_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilledMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilledMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilledMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_wells: Optional['outputs.TemplateFilledMapFieldWells'] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 map_style_options: Optional['outputs.TemplateGeospatialMapStyleOptions'] = None,
                 sort_configuration: Optional['outputs.TemplateFilledMapSortConfiguration'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
                 window_options: Optional['outputs.TemplateGeospatialWindowOptions'] = None):
        TemplateFilledMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_wells=field_wells,
            legend=legend,
            map_style_options=map_style_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            window_options=window_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_wells: Optional['outputs.TemplateFilledMapFieldWells'] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             map_style_options: Optional['outputs.TemplateGeospatialMapStyleOptions'] = None,
             sort_configuration: Optional['outputs.TemplateFilledMapSortConfiguration'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             window_options: Optional['outputs.TemplateGeospatialWindowOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if map_style_options is not None:
            _setter("map_style_options", map_style_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if window_options is not None:
            _setter("window_options", window_options)

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateFilledMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="mapStyleOptions")
    def map_style_options(self) -> Optional['outputs.TemplateGeospatialMapStyleOptions']:
        return pulumi.get(self, "map_style_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateFilledMapSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="windowOptions")
    def window_options(self) -> Optional['outputs.TemplateGeospatialWindowOptions']:
        return pulumi.get(self, "window_options")


@pulumi.output_type
class TemplateFilledMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filledMapAggregatedFieldWells":
            suggest = "filled_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilledMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilledMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilledMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filled_map_aggregated_field_wells: Optional['outputs.TemplateFilledMapAggregatedFieldWells'] = None):
        TemplateFilledMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filled_map_aggregated_field_wells=filled_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filled_map_aggregated_field_wells: Optional['outputs.TemplateFilledMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if filled_map_aggregated_field_wells is not None:
            _setter("filled_map_aggregated_field_wells", filled_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="filledMapAggregatedFieldWells")
    def filled_map_aggregated_field_wells(self) -> Optional['outputs.TemplateFilledMapAggregatedFieldWells']:
        return pulumi.get(self, "filled_map_aggregated_field_wells")


@pulumi.output_type
class TemplateFilledMapShapeConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilledMapShapeConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilledMapShapeConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilledMapShapeConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 format: Optional['outputs.TemplateShapeConditionalFormat'] = None):
        TemplateFilledMapShapeConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            format=format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             format: Optional['outputs.TemplateShapeConditionalFormat'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if format is not None:
            _setter("format", format)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def format(self) -> Optional['outputs.TemplateShapeConditionalFormat']:
        return pulumi.get(self, "format")


@pulumi.output_type
class TemplateFilledMapSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilledMapSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilledMapSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilledMapSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateFilledMapSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class TemplateFilledMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilledMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilledMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilledMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateFilledMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 conditional_formatting: Optional['outputs.TemplateFilledMapConditionalFormatting'] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateFilledMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateFilledMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             conditional_formatting: Optional['outputs.TemplateFilledMapConditionalFormatting'] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateFilledMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.TemplateFilledMapConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryFilter":
            suggest = "category_filter"
        elif key == "numericEqualityFilter":
            suggest = "numeric_equality_filter"
        elif key == "numericRangeFilter":
            suggest = "numeric_range_filter"
        elif key == "relativeDatesFilter":
            suggest = "relative_dates_filter"
        elif key == "timeEqualityFilter":
            suggest = "time_equality_filter"
        elif key == "timeRangeFilter":
            suggest = "time_range_filter"
        elif key == "topBottomFilter":
            suggest = "top_bottom_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_filter: Optional['outputs.TemplateCategoryFilter'] = None,
                 numeric_equality_filter: Optional['outputs.TemplateNumericEqualityFilter'] = None,
                 numeric_range_filter: Optional['outputs.TemplateNumericRangeFilter'] = None,
                 relative_dates_filter: Optional['outputs.TemplateRelativeDatesFilter'] = None,
                 time_equality_filter: Optional['outputs.TemplateTimeEqualityFilter'] = None,
                 time_range_filter: Optional['outputs.TemplateTimeRangeFilter'] = None,
                 top_bottom_filter: Optional['outputs.TemplateTopBottomFilter'] = None):
        TemplateFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_filter=category_filter,
            numeric_equality_filter=numeric_equality_filter,
            numeric_range_filter=numeric_range_filter,
            relative_dates_filter=relative_dates_filter,
            time_equality_filter=time_equality_filter,
            time_range_filter=time_range_filter,
            top_bottom_filter=top_bottom_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_filter: Optional['outputs.TemplateCategoryFilter'] = None,
             numeric_equality_filter: Optional['outputs.TemplateNumericEqualityFilter'] = None,
             numeric_range_filter: Optional['outputs.TemplateNumericRangeFilter'] = None,
             relative_dates_filter: Optional['outputs.TemplateRelativeDatesFilter'] = None,
             time_equality_filter: Optional['outputs.TemplateTimeEqualityFilter'] = None,
             time_range_filter: Optional['outputs.TemplateTimeRangeFilter'] = None,
             top_bottom_filter: Optional['outputs.TemplateTopBottomFilter'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_filter is not None:
            _setter("category_filter", category_filter)
        if numeric_equality_filter is not None:
            _setter("numeric_equality_filter", numeric_equality_filter)
        if numeric_range_filter is not None:
            _setter("numeric_range_filter", numeric_range_filter)
        if relative_dates_filter is not None:
            _setter("relative_dates_filter", relative_dates_filter)
        if time_equality_filter is not None:
            _setter("time_equality_filter", time_equality_filter)
        if time_range_filter is not None:
            _setter("time_range_filter", time_range_filter)
        if top_bottom_filter is not None:
            _setter("top_bottom_filter", top_bottom_filter)

    @property
    @pulumi.getter(name="categoryFilter")
    def category_filter(self) -> Optional['outputs.TemplateCategoryFilter']:
        return pulumi.get(self, "category_filter")

    @property
    @pulumi.getter(name="numericEqualityFilter")
    def numeric_equality_filter(self) -> Optional['outputs.TemplateNumericEqualityFilter']:
        return pulumi.get(self, "numeric_equality_filter")

    @property
    @pulumi.getter(name="numericRangeFilter")
    def numeric_range_filter(self) -> Optional['outputs.TemplateNumericRangeFilter']:
        return pulumi.get(self, "numeric_range_filter")

    @property
    @pulumi.getter(name="relativeDatesFilter")
    def relative_dates_filter(self) -> Optional['outputs.TemplateRelativeDatesFilter']:
        return pulumi.get(self, "relative_dates_filter")

    @property
    @pulumi.getter(name="timeEqualityFilter")
    def time_equality_filter(self) -> Optional['outputs.TemplateTimeEqualityFilter']:
        return pulumi.get(self, "time_equality_filter")

    @property
    @pulumi.getter(name="timeRangeFilter")
    def time_range_filter(self) -> Optional['outputs.TemplateTimeRangeFilter']:
        return pulumi.get(self, "time_range_filter")

    @property
    @pulumi.getter(name="topBottomFilter")
    def top_bottom_filter(self) -> Optional['outputs.TemplateTopBottomFilter']:
        return pulumi.get(self, "top_bottom_filter")


@pulumi.output_type
class TemplateFilterControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimePicker":
            suggest = "date_time_picker"
        elif key == "relativeDateTime":
            suggest = "relative_date_time"
        elif key == "textArea":
            suggest = "text_area"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_picker: Optional['outputs.TemplateFilterDateTimePickerControl'] = None,
                 dropdown: Optional['outputs.TemplateFilterDropDownControl'] = None,
                 list: Optional['outputs.TemplateFilterListControl'] = None,
                 relative_date_time: Optional['outputs.TemplateFilterRelativeDateTimeControl'] = None,
                 slider: Optional['outputs.TemplateFilterSliderControl'] = None,
                 text_area: Optional['outputs.TemplateFilterTextAreaControl'] = None,
                 text_field: Optional['outputs.TemplateFilterTextFieldControl'] = None):
        TemplateFilterControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_picker=date_time_picker,
            dropdown=dropdown,
            list=list,
            relative_date_time=relative_date_time,
            slider=slider,
            text_area=text_area,
            text_field=text_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_picker: Optional['outputs.TemplateFilterDateTimePickerControl'] = None,
             dropdown: Optional['outputs.TemplateFilterDropDownControl'] = None,
             list: Optional['outputs.TemplateFilterListControl'] = None,
             relative_date_time: Optional['outputs.TemplateFilterRelativeDateTimeControl'] = None,
             slider: Optional['outputs.TemplateFilterSliderControl'] = None,
             text_area: Optional['outputs.TemplateFilterTextAreaControl'] = None,
             text_field: Optional['outputs.TemplateFilterTextFieldControl'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_picker is not None:
            _setter("date_time_picker", date_time_picker)
        if dropdown is not None:
            _setter("dropdown", dropdown)
        if list is not None:
            _setter("list", list)
        if relative_date_time is not None:
            _setter("relative_date_time", relative_date_time)
        if slider is not None:
            _setter("slider", slider)
        if text_area is not None:
            _setter("text_area", text_area)
        if text_field is not None:
            _setter("text_field", text_field)

    @property
    @pulumi.getter(name="dateTimePicker")
    def date_time_picker(self) -> Optional['outputs.TemplateFilterDateTimePickerControl']:
        return pulumi.get(self, "date_time_picker")

    @property
    @pulumi.getter
    def dropdown(self) -> Optional['outputs.TemplateFilterDropDownControl']:
        return pulumi.get(self, "dropdown")

    @property
    @pulumi.getter
    def list(self) -> Optional['outputs.TemplateFilterListControl']:
        return pulumi.get(self, "list")

    @property
    @pulumi.getter(name="relativeDateTime")
    def relative_date_time(self) -> Optional['outputs.TemplateFilterRelativeDateTimeControl']:
        return pulumi.get(self, "relative_date_time")

    @property
    @pulumi.getter
    def slider(self) -> Optional['outputs.TemplateFilterSliderControl']:
        return pulumi.get(self, "slider")

    @property
    @pulumi.getter(name="textArea")
    def text_area(self) -> Optional['outputs.TemplateFilterTextAreaControl']:
        return pulumi.get(self, "text_area")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional['outputs.TemplateFilterTextFieldControl']:
        return pulumi.get(self, "text_field")


@pulumi.output_type
class TemplateFilterDateTimePickerControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterDateTimePickerControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterDateTimePickerControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterDateTimePickerControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 display_options: Optional['outputs.TemplateDateTimePickerControlDisplayOptions'] = None,
                 type: Optional['TemplateSheetControlDateTimePickerType'] = None):
        TemplateFilterDateTimePickerControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            display_options=display_options,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             display_options: Optional['outputs.TemplateDateTimePickerControlDisplayOptions'] = None,
             type: Optional['TemplateSheetControlDateTimePickerType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateDateTimePickerControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter
    def type(self) -> Optional['TemplateSheetControlDateTimePickerType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class TemplateFilterDropDownControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterDropDownControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterDropDownControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterDropDownControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.TemplateCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.TemplateDropDownControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.TemplateFilterSelectableValues'] = None,
                 type: Optional['TemplateSheetControlListType'] = None):
        TemplateFilterDropDownControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             cascading_control_configuration: Optional['outputs.TemplateCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.TemplateDropDownControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.TemplateFilterSelectableValues'] = None,
             type: Optional['TemplateSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.TemplateCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateDropDownControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.TemplateFilterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['TemplateSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class TemplateFilterGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossDataset":
            suggest = "cross_dataset"
        elif key == "filterGroupId":
            suggest = "filter_group_id"
        elif key == "scopeConfiguration":
            suggest = "scope_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cross_dataset: 'TemplateCrossDatasetTypes',
                 filter_group_id: str,
                 filters: Sequence['outputs.TemplateFilter'],
                 scope_configuration: 'outputs.TemplateFilterScopeConfiguration',
                 status: Optional['TemplateWidgetStatus'] = None):
        TemplateFilterGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cross_dataset=cross_dataset,
            filter_group_id=filter_group_id,
            filters=filters,
            scope_configuration=scope_configuration,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cross_dataset: 'TemplateCrossDatasetTypes',
             filter_group_id: str,
             filters: Sequence['outputs.TemplateFilter'],
             scope_configuration: 'outputs.TemplateFilterScopeConfiguration',
             status: Optional['TemplateWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cross_dataset", cross_dataset)
        _setter("filter_group_id", filter_group_id)
        _setter("filters", filters)
        _setter("scope_configuration", scope_configuration)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="crossDataset")
    def cross_dataset(self) -> 'TemplateCrossDatasetTypes':
        return pulumi.get(self, "cross_dataset")

    @property
    @pulumi.getter(name="filterGroupId")
    def filter_group_id(self) -> str:
        return pulumi.get(self, "filter_group_id")

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.TemplateFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="scopeConfiguration")
    def scope_configuration(self) -> 'outputs.TemplateFilterScopeConfiguration':
        return pulumi.get(self, "scope_configuration")

    @property
    @pulumi.getter
    def status(self) -> Optional['TemplateWidgetStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class TemplateFilterListConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOperator":
            suggest = "match_operator"
        elif key == "categoryValues":
            suggest = "category_values"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterListConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterListConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterListConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_operator: 'TemplateCategoryFilterMatchOperator',
                 category_values: Optional[Sequence[str]] = None,
                 select_all_options: Optional['TemplateCategoryFilterSelectAllOptions'] = None):
        TemplateFilterListConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_operator=match_operator,
            category_values=category_values,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_operator: 'TemplateCategoryFilterMatchOperator',
             category_values: Optional[Sequence[str]] = None,
             select_all_options: Optional['TemplateCategoryFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("match_operator", match_operator)
        if category_values is not None:
            _setter("category_values", category_values)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'TemplateCategoryFilterMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="categoryValues")
    def category_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "category_values")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['TemplateCategoryFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class TemplateFilterListControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterListControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterListControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterListControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.TemplateCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.TemplateListControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.TemplateFilterSelectableValues'] = None,
                 type: Optional['TemplateSheetControlListType'] = None):
        TemplateFilterListControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             cascading_control_configuration: Optional['outputs.TemplateCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.TemplateListControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.TemplateFilterSelectableValues'] = None,
             type: Optional['TemplateSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.TemplateCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateListControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.TemplateFilterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['TemplateSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class TemplateFilterOperationSelectedFieldsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedColumns":
            suggest = "selected_columns"
        elif key == "selectedFieldOptions":
            suggest = "selected_field_options"
        elif key == "selectedFields":
            suggest = "selected_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterOperationSelectedFieldsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterOperationSelectedFieldsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterOperationSelectedFieldsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_columns: Optional[Sequence['outputs.TemplateColumnIdentifier']] = None,
                 selected_field_options: Optional['TemplateSelectedFieldOptions'] = None,
                 selected_fields: Optional[Sequence[str]] = None):
        TemplateFilterOperationSelectedFieldsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_columns=selected_columns,
            selected_field_options=selected_field_options,
            selected_fields=selected_fields,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_columns: Optional[Sequence['outputs.TemplateColumnIdentifier']] = None,
             selected_field_options: Optional['TemplateSelectedFieldOptions'] = None,
             selected_fields: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if selected_columns is not None:
            _setter("selected_columns", selected_columns)
        if selected_field_options is not None:
            _setter("selected_field_options", selected_field_options)
        if selected_fields is not None:
            _setter("selected_fields", selected_fields)

    @property
    @pulumi.getter(name="selectedColumns")
    def selected_columns(self) -> Optional[Sequence['outputs.TemplateColumnIdentifier']]:
        return pulumi.get(self, "selected_columns")

    @property
    @pulumi.getter(name="selectedFieldOptions")
    def selected_field_options(self) -> Optional['TemplateSelectedFieldOptions']:
        return pulumi.get(self, "selected_field_options")

    @property
    @pulumi.getter(name="selectedFields")
    def selected_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "selected_fields")


@pulumi.output_type
class TemplateFilterOperationTargetVisualsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sameSheetTargetVisualConfiguration":
            suggest = "same_sheet_target_visual_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterOperationTargetVisualsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterOperationTargetVisualsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterOperationTargetVisualsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 same_sheet_target_visual_configuration: Optional['outputs.TemplateSameSheetTargetVisualConfiguration'] = None):
        TemplateFilterOperationTargetVisualsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            same_sheet_target_visual_configuration=same_sheet_target_visual_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             same_sheet_target_visual_configuration: Optional['outputs.TemplateSameSheetTargetVisualConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if same_sheet_target_visual_configuration is not None:
            _setter("same_sheet_target_visual_configuration", same_sheet_target_visual_configuration)

    @property
    @pulumi.getter(name="sameSheetTargetVisualConfiguration")
    def same_sheet_target_visual_configuration(self) -> Optional['outputs.TemplateSameSheetTargetVisualConfiguration']:
        return pulumi.get(self, "same_sheet_target_visual_configuration")


@pulumi.output_type
class TemplateFilterRelativeDateTimeControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterRelativeDateTimeControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterRelativeDateTimeControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterRelativeDateTimeControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 display_options: Optional['outputs.TemplateRelativeDateTimeControlDisplayOptions'] = None):
        TemplateFilterRelativeDateTimeControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             display_options: Optional['outputs.TemplateRelativeDateTimeControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateRelativeDateTimeControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class TemplateFilterScopeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allSheets":
            suggest = "all_sheets"
        elif key == "selectedSheets":
            suggest = "selected_sheets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterScopeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterScopeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterScopeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_sheets: Optional['outputs.TemplateAllSheetsFilterScopeConfiguration'] = None,
                 selected_sheets: Optional['outputs.TemplateSelectedSheetsFilterScopeConfiguration'] = None):
        TemplateFilterScopeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_sheets=all_sheets,
            selected_sheets=selected_sheets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_sheets: Optional['outputs.TemplateAllSheetsFilterScopeConfiguration'] = None,
             selected_sheets: Optional['outputs.TemplateSelectedSheetsFilterScopeConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_sheets is not None:
            _setter("all_sheets", all_sheets)
        if selected_sheets is not None:
            _setter("selected_sheets", selected_sheets)

    @property
    @pulumi.getter(name="allSheets")
    def all_sheets(self) -> Optional['outputs.TemplateAllSheetsFilterScopeConfiguration']:
        return pulumi.get(self, "all_sheets")

    @property
    @pulumi.getter(name="selectedSheets")
    def selected_sheets(self) -> Optional['outputs.TemplateSelectedSheetsFilterScopeConfiguration']:
        return pulumi.get(self, "selected_sheets")


@pulumi.output_type
class TemplateFilterSelectableValues(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence[str]] = None):
        TemplateFilterSelectableValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateFilterSliderControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "maximumValue":
            suggest = "maximum_value"
        elif key == "minimumValue":
            suggest = "minimum_value"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "stepSize":
            suggest = "step_size"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterSliderControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterSliderControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterSliderControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 maximum_value: float,
                 minimum_value: float,
                 source_filter_id: str,
                 step_size: float,
                 title: str,
                 display_options: Optional['outputs.TemplateSliderControlDisplayOptions'] = None,
                 type: Optional['TemplateSheetControlSliderType'] = None):
        TemplateFilterSliderControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            maximum_value=maximum_value,
            minimum_value=minimum_value,
            source_filter_id=source_filter_id,
            step_size=step_size,
            title=title,
            display_options=display_options,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             maximum_value: float,
             minimum_value: float,
             source_filter_id: str,
             step_size: float,
             title: str,
             display_options: Optional['outputs.TemplateSliderControlDisplayOptions'] = None,
             type: Optional['TemplateSheetControlSliderType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("maximum_value", maximum_value)
        _setter("minimum_value", minimum_value)
        _setter("source_filter_id", source_filter_id)
        _setter("step_size", step_size)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="maximumValue")
    def maximum_value(self) -> float:
        return pulumi.get(self, "maximum_value")

    @property
    @pulumi.getter(name="minimumValue")
    def minimum_value(self) -> float:
        return pulumi.get(self, "minimum_value")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> float:
        return pulumi.get(self, "step_size")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateSliderControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter
    def type(self) -> Optional['TemplateSheetControlSliderType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class TemplateFilterTextAreaControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterTextAreaControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterTextAreaControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterTextAreaControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 delimiter: Optional[str] = None,
                 display_options: Optional['outputs.TemplateTextAreaControlDisplayOptions'] = None):
        TemplateFilterTextAreaControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            delimiter=delimiter,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             delimiter: Optional[str] = None,
             display_options: Optional['outputs.TemplateTextAreaControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateTextAreaControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class TemplateFilterTextFieldControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterControlId":
            suggest = "filter_control_id"
        elif key == "sourceFilterId":
            suggest = "source_filter_id"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFilterTextFieldControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFilterTextFieldControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFilterTextFieldControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_control_id: str,
                 source_filter_id: str,
                 title: str,
                 display_options: Optional['outputs.TemplateTextFieldControlDisplayOptions'] = None):
        TemplateFilterTextFieldControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_control_id=filter_control_id,
            source_filter_id=source_filter_id,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_control_id: str,
             source_filter_id: str,
             title: str,
             display_options: Optional['outputs.TemplateTextFieldControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_control_id", filter_control_id)
        _setter("source_filter_id", source_filter_id)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="filterControlId")
    def filter_control_id(self) -> str:
        return pulumi.get(self, "filter_control_id")

    @property
    @pulumi.getter(name="sourceFilterId")
    def source_filter_id(self) -> str:
        return pulumi.get(self, "source_filter_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateTextFieldControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class TemplateFontConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontColor":
            suggest = "font_color"
        elif key == "fontDecoration":
            suggest = "font_decoration"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "fontStyle":
            suggest = "font_style"
        elif key == "fontWeight":
            suggest = "font_weight"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFontConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFontConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFontConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_color: Optional[str] = None,
                 font_decoration: Optional['TemplateFontDecoration'] = None,
                 font_size: Optional['outputs.TemplateFontSize'] = None,
                 font_style: Optional['TemplateFontStyle'] = None,
                 font_weight: Optional['outputs.TemplateFontWeight'] = None):
        TemplateFontConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_color=font_color,
            font_decoration=font_decoration,
            font_size=font_size,
            font_style=font_style,
            font_weight=font_weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_color: Optional[str] = None,
             font_decoration: Optional['TemplateFontDecoration'] = None,
             font_size: Optional['outputs.TemplateFontSize'] = None,
             font_style: Optional['TemplateFontStyle'] = None,
             font_weight: Optional['outputs.TemplateFontWeight'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if font_color is not None:
            _setter("font_color", font_color)
        if font_decoration is not None:
            _setter("font_decoration", font_decoration)
        if font_size is not None:
            _setter("font_size", font_size)
        if font_style is not None:
            _setter("font_style", font_style)
        if font_weight is not None:
            _setter("font_weight", font_weight)

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[str]:
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontDecoration")
    def font_decoration(self) -> Optional['TemplateFontDecoration']:
        return pulumi.get(self, "font_decoration")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional['outputs.TemplateFontSize']:
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="fontStyle")
    def font_style(self) -> Optional['TemplateFontStyle']:
        return pulumi.get(self, "font_style")

    @property
    @pulumi.getter(name="fontWeight")
    def font_weight(self) -> Optional['outputs.TemplateFontWeight']:
        return pulumi.get(self, "font_weight")


@pulumi.output_type
class TemplateFontSize(dict):
    def __init__(__self__, *,
                 relative: Optional['TemplateRelativeFontSize'] = None):
        TemplateFontSize._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            relative=relative,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             relative: Optional['TemplateRelativeFontSize'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if relative is not None:
            _setter("relative", relative)

    @property
    @pulumi.getter
    def relative(self) -> Optional['TemplateRelativeFontSize']:
        return pulumi.get(self, "relative")


@pulumi.output_type
class TemplateFontWeight(dict):
    def __init__(__self__, *,
                 name: Optional['TemplateFontWeightName'] = None):
        TemplateFontWeight._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional['TemplateFontWeightName'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional['TemplateFontWeightName']:
        return pulumi.get(self, "name")


@pulumi.output_type
class TemplateForecastComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "customSeasonalityValue":
            suggest = "custom_seasonality_value"
        elif key == "lowerBoundary":
            suggest = "lower_boundary"
        elif key == "periodsBackward":
            suggest = "periods_backward"
        elif key == "periodsForward":
            suggest = "periods_forward"
        elif key == "predictionInterval":
            suggest = "prediction_interval"
        elif key == "upperBoundary":
            suggest = "upper_boundary"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateForecastComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateForecastComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateForecastComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 custom_seasonality_value: Optional[float] = None,
                 lower_boundary: Optional[float] = None,
                 name: Optional[str] = None,
                 periods_backward: Optional[float] = None,
                 periods_forward: Optional[float] = None,
                 prediction_interval: Optional[float] = None,
                 seasonality: Optional['TemplateForecastComputationSeasonality'] = None,
                 time: Optional['outputs.TemplateDimensionField'] = None,
                 upper_boundary: Optional[float] = None,
                 value: Optional['outputs.TemplateMeasureField'] = None):
        TemplateForecastComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            custom_seasonality_value=custom_seasonality_value,
            lower_boundary=lower_boundary,
            name=name,
            periods_backward=periods_backward,
            periods_forward=periods_forward,
            prediction_interval=prediction_interval,
            seasonality=seasonality,
            time=time,
            upper_boundary=upper_boundary,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             custom_seasonality_value: Optional[float] = None,
             lower_boundary: Optional[float] = None,
             name: Optional[str] = None,
             periods_backward: Optional[float] = None,
             periods_forward: Optional[float] = None,
             prediction_interval: Optional[float] = None,
             seasonality: Optional['TemplateForecastComputationSeasonality'] = None,
             time: Optional['outputs.TemplateDimensionField'] = None,
             upper_boundary: Optional[float] = None,
             value: Optional['outputs.TemplateMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if custom_seasonality_value is not None:
            _setter("custom_seasonality_value", custom_seasonality_value)
        if lower_boundary is not None:
            _setter("lower_boundary", lower_boundary)
        if name is not None:
            _setter("name", name)
        if periods_backward is not None:
            _setter("periods_backward", periods_backward)
        if periods_forward is not None:
            _setter("periods_forward", periods_forward)
        if prediction_interval is not None:
            _setter("prediction_interval", prediction_interval)
        if seasonality is not None:
            _setter("seasonality", seasonality)
        if time is not None:
            _setter("time", time)
        if upper_boundary is not None:
            _setter("upper_boundary", upper_boundary)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter(name="customSeasonalityValue")
    def custom_seasonality_value(self) -> Optional[float]:
        return pulumi.get(self, "custom_seasonality_value")

    @property
    @pulumi.getter(name="lowerBoundary")
    def lower_boundary(self) -> Optional[float]:
        return pulumi.get(self, "lower_boundary")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="periodsBackward")
    def periods_backward(self) -> Optional[float]:
        return pulumi.get(self, "periods_backward")

    @property
    @pulumi.getter(name="periodsForward")
    def periods_forward(self) -> Optional[float]:
        return pulumi.get(self, "periods_forward")

    @property
    @pulumi.getter(name="predictionInterval")
    def prediction_interval(self) -> Optional[float]:
        return pulumi.get(self, "prediction_interval")

    @property
    @pulumi.getter
    def seasonality(self) -> Optional['TemplateForecastComputationSeasonality']:
        return pulumi.get(self, "seasonality")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.TemplateDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter(name="upperBoundary")
    def upper_boundary(self) -> Optional[float]:
        return pulumi.get(self, "upper_boundary")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.TemplateMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateForecastConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forecastProperties":
            suggest = "forecast_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateForecastConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateForecastConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateForecastConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forecast_properties: Optional['outputs.TemplateTimeBasedForecastProperties'] = None,
                 scenario: Optional['outputs.TemplateForecastScenario'] = None):
        TemplateForecastConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forecast_properties=forecast_properties,
            scenario=scenario,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forecast_properties: Optional['outputs.TemplateTimeBasedForecastProperties'] = None,
             scenario: Optional['outputs.TemplateForecastScenario'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if forecast_properties is not None:
            _setter("forecast_properties", forecast_properties)
        if scenario is not None:
            _setter("scenario", scenario)

    @property
    @pulumi.getter(name="forecastProperties")
    def forecast_properties(self) -> Optional['outputs.TemplateTimeBasedForecastProperties']:
        return pulumi.get(self, "forecast_properties")

    @property
    @pulumi.getter
    def scenario(self) -> Optional['outputs.TemplateForecastScenario']:
        return pulumi.get(self, "scenario")


@pulumi.output_type
class TemplateForecastScenario(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whatIfPointScenario":
            suggest = "what_if_point_scenario"
        elif key == "whatIfRangeScenario":
            suggest = "what_if_range_scenario"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateForecastScenario. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateForecastScenario.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateForecastScenario.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 what_if_point_scenario: Optional['outputs.TemplateWhatIfPointScenario'] = None,
                 what_if_range_scenario: Optional['outputs.TemplateWhatIfRangeScenario'] = None):
        TemplateForecastScenario._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            what_if_point_scenario=what_if_point_scenario,
            what_if_range_scenario=what_if_range_scenario,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             what_if_point_scenario: Optional['outputs.TemplateWhatIfPointScenario'] = None,
             what_if_range_scenario: Optional['outputs.TemplateWhatIfRangeScenario'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if what_if_point_scenario is not None:
            _setter("what_if_point_scenario", what_if_point_scenario)
        if what_if_range_scenario is not None:
            _setter("what_if_range_scenario", what_if_range_scenario)

    @property
    @pulumi.getter(name="whatIfPointScenario")
    def what_if_point_scenario(self) -> Optional['outputs.TemplateWhatIfPointScenario']:
        return pulumi.get(self, "what_if_point_scenario")

    @property
    @pulumi.getter(name="whatIfRangeScenario")
    def what_if_range_scenario(self) -> Optional['outputs.TemplateWhatIfRangeScenario']:
        return pulumi.get(self, "what_if_range_scenario")


@pulumi.output_type
class TemplateFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormatConfiguration":
            suggest = "date_time_format_configuration"
        elif key == "numberFormatConfiguration":
            suggest = "number_format_configuration"
        elif key == "stringFormatConfiguration":
            suggest = "string_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format_configuration: Optional['outputs.TemplateDateTimeFormatConfiguration'] = None,
                 number_format_configuration: Optional['outputs.TemplateNumberFormatConfiguration'] = None,
                 string_format_configuration: Optional['outputs.TemplateStringFormatConfiguration'] = None):
        TemplateFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format_configuration=date_time_format_configuration,
            number_format_configuration=number_format_configuration,
            string_format_configuration=string_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format_configuration: Optional['outputs.TemplateDateTimeFormatConfiguration'] = None,
             number_format_configuration: Optional['outputs.TemplateNumberFormatConfiguration'] = None,
             string_format_configuration: Optional['outputs.TemplateStringFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format_configuration is not None:
            _setter("date_time_format_configuration", date_time_format_configuration)
        if number_format_configuration is not None:
            _setter("number_format_configuration", number_format_configuration)
        if string_format_configuration is not None:
            _setter("string_format_configuration", string_format_configuration)

    @property
    @pulumi.getter(name="dateTimeFormatConfiguration")
    def date_time_format_configuration(self) -> Optional['outputs.TemplateDateTimeFormatConfiguration']:
        return pulumi.get(self, "date_time_format_configuration")

    @property
    @pulumi.getter(name="numberFormatConfiguration")
    def number_format_configuration(self) -> Optional['outputs.TemplateNumberFormatConfiguration']:
        return pulumi.get(self, "number_format_configuration")

    @property
    @pulumi.getter(name="stringFormatConfiguration")
    def string_format_configuration(self) -> Optional['outputs.TemplateStringFormatConfiguration']:
        return pulumi.get(self, "string_format_configuration")


@pulumi.output_type
class TemplateFreeFormLayoutCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "screenCanvasSizeOptions":
            suggest = "screen_canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFreeFormLayoutCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFreeFormLayoutCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFreeFormLayoutCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 screen_canvas_size_options: Optional['outputs.TemplateFreeFormLayoutScreenCanvasSizeOptions'] = None):
        TemplateFreeFormLayoutCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            screen_canvas_size_options=screen_canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             screen_canvas_size_options: Optional['outputs.TemplateFreeFormLayoutScreenCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if screen_canvas_size_options is not None:
            _setter("screen_canvas_size_options", screen_canvas_size_options)

    @property
    @pulumi.getter(name="screenCanvasSizeOptions")
    def screen_canvas_size_options(self) -> Optional['outputs.TemplateFreeFormLayoutScreenCanvasSizeOptions']:
        return pulumi.get(self, "screen_canvas_size_options")


@pulumi.output_type
class TemplateFreeFormLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFreeFormLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFreeFormLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFreeFormLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 elements: Sequence['outputs.TemplateFreeFormLayoutElement'],
                 canvas_size_options: Optional['outputs.TemplateFreeFormLayoutCanvasSizeOptions'] = None):
        TemplateFreeFormLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elements=elements,
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elements: Sequence['outputs.TemplateFreeFormLayoutElement'],
             canvas_size_options: Optional['outputs.TemplateFreeFormLayoutCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("elements", elements)
        if canvas_size_options is not None:
            _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter
    def elements(self) -> Sequence['outputs.TemplateFreeFormLayoutElement']:
        return pulumi.get(self, "elements")

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> Optional['outputs.TemplateFreeFormLayoutCanvasSizeOptions']:
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class TemplateFreeFormLayoutElement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elementId":
            suggest = "element_id"
        elif key == "elementType":
            suggest = "element_type"
        elif key == "xAxisLocation":
            suggest = "x_axis_location"
        elif key == "yAxisLocation":
            suggest = "y_axis_location"
        elif key == "backgroundStyle":
            suggest = "background_style"
        elif key == "borderStyle":
            suggest = "border_style"
        elif key == "loadingAnimation":
            suggest = "loading_animation"
        elif key == "renderingRules":
            suggest = "rendering_rules"
        elif key == "selectedBorderStyle":
            suggest = "selected_border_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFreeFormLayoutElement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFreeFormLayoutElement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFreeFormLayoutElement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 element_id: str,
                 element_type: 'TemplateLayoutElementType',
                 height: str,
                 width: str,
                 x_axis_location: str,
                 y_axis_location: str,
                 background_style: Optional['outputs.TemplateFreeFormLayoutElementBackgroundStyle'] = None,
                 border_style: Optional['outputs.TemplateFreeFormLayoutElementBorderStyle'] = None,
                 loading_animation: Optional['outputs.TemplateLoadingAnimation'] = None,
                 rendering_rules: Optional[Sequence['outputs.TemplateSheetElementRenderingRule']] = None,
                 selected_border_style: Optional['outputs.TemplateFreeFormLayoutElementBorderStyle'] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        """
        :param str height: String based length that is composed of value and unit in px
        :param str width: String based length that is composed of value and unit in px
        :param str x_axis_location: String based length that is composed of value and unit in px
        :param str y_axis_location: String based length that is composed of value and unit in px with Integer.MAX_VALUE as maximum value
        """
        TemplateFreeFormLayoutElement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            element_id=element_id,
            element_type=element_type,
            height=height,
            width=width,
            x_axis_location=x_axis_location,
            y_axis_location=y_axis_location,
            background_style=background_style,
            border_style=border_style,
            loading_animation=loading_animation,
            rendering_rules=rendering_rules,
            selected_border_style=selected_border_style,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             element_id: str,
             element_type: 'TemplateLayoutElementType',
             height: str,
             width: str,
             x_axis_location: str,
             y_axis_location: str,
             background_style: Optional['outputs.TemplateFreeFormLayoutElementBackgroundStyle'] = None,
             border_style: Optional['outputs.TemplateFreeFormLayoutElementBorderStyle'] = None,
             loading_animation: Optional['outputs.TemplateLoadingAnimation'] = None,
             rendering_rules: Optional[Sequence['outputs.TemplateSheetElementRenderingRule']] = None,
             selected_border_style: Optional['outputs.TemplateFreeFormLayoutElementBorderStyle'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("element_id", element_id)
        _setter("element_type", element_type)
        _setter("height", height)
        _setter("width", width)
        _setter("x_axis_location", x_axis_location)
        _setter("y_axis_location", y_axis_location)
        if background_style is not None:
            _setter("background_style", background_style)
        if border_style is not None:
            _setter("border_style", border_style)
        if loading_animation is not None:
            _setter("loading_animation", loading_animation)
        if rendering_rules is not None:
            _setter("rendering_rules", rendering_rules)
        if selected_border_style is not None:
            _setter("selected_border_style", selected_border_style)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="elementId")
    def element_id(self) -> str:
        return pulumi.get(self, "element_id")

    @property
    @pulumi.getter(name="elementType")
    def element_type(self) -> 'TemplateLayoutElementType':
        return pulumi.get(self, "element_type")

    @property
    @pulumi.getter
    def height(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter(name="xAxisLocation")
    def x_axis_location(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "x_axis_location")

    @property
    @pulumi.getter(name="yAxisLocation")
    def y_axis_location(self) -> str:
        """
        String based length that is composed of value and unit in px with Integer.MAX_VALUE as maximum value
        """
        return pulumi.get(self, "y_axis_location")

    @property
    @pulumi.getter(name="backgroundStyle")
    def background_style(self) -> Optional['outputs.TemplateFreeFormLayoutElementBackgroundStyle']:
        return pulumi.get(self, "background_style")

    @property
    @pulumi.getter(name="borderStyle")
    def border_style(self) -> Optional['outputs.TemplateFreeFormLayoutElementBorderStyle']:
        return pulumi.get(self, "border_style")

    @property
    @pulumi.getter(name="loadingAnimation")
    def loading_animation(self) -> Optional['outputs.TemplateLoadingAnimation']:
        return pulumi.get(self, "loading_animation")

    @property
    @pulumi.getter(name="renderingRules")
    def rendering_rules(self) -> Optional[Sequence['outputs.TemplateSheetElementRenderingRule']]:
        return pulumi.get(self, "rendering_rules")

    @property
    @pulumi.getter(name="selectedBorderStyle")
    def selected_border_style(self) -> Optional['outputs.TemplateFreeFormLayoutElementBorderStyle']:
        return pulumi.get(self, "selected_border_style")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateFreeFormLayoutElementBackgroundStyle(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateFreeFormLayoutElementBackgroundStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateFreeFormLayoutElementBorderStyle(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateFreeFormLayoutElementBorderStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateFreeFormLayoutScreenCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optimizedViewPortWidth":
            suggest = "optimized_view_port_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFreeFormLayoutScreenCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFreeFormLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFreeFormLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 optimized_view_port_width: str):
        """
        :param str optimized_view_port_width: String based length that is composed of value and unit in px
        """
        TemplateFreeFormLayoutScreenCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            optimized_view_port_width=optimized_view_port_width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             optimized_view_port_width: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("optimized_view_port_width", optimized_view_port_width)

    @property
    @pulumi.getter(name="optimizedViewPortWidth")
    def optimized_view_port_width(self) -> str:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "optimized_view_port_width")


@pulumi.output_type
class TemplateFreeFormSectionLayoutConfiguration(dict):
    def __init__(__self__, *,
                 elements: Sequence['outputs.TemplateFreeFormLayoutElement']):
        TemplateFreeFormSectionLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elements=elements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elements: Sequence['outputs.TemplateFreeFormLayoutElement'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("elements", elements)

    @property
    @pulumi.getter
    def elements(self) -> Sequence['outputs.TemplateFreeFormLayoutElement']:
        return pulumi.get(self, "elements")


@pulumi.output_type
class TemplateFunnelChartAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateFunnelChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateFunnelChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "dataLabelOptions":
            suggest = "data_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "valueLabelOptions":
            suggest = "value_label_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFunnelChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFunnelChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFunnelChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 data_label_options: Optional['outputs.TemplateFunnelChartDataLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateFunnelChartFieldWells'] = None,
                 sort_configuration: Optional['outputs.TemplateFunnelChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
                 value_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None):
        TemplateFunnelChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_options=category_label_options,
            data_label_options=data_label_options,
            field_wells=field_wells,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            value_label_options=value_label_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             data_label_options: Optional['outputs.TemplateFunnelChartDataLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateFunnelChartFieldWells'] = None,
             sort_configuration: Optional['outputs.TemplateFunnelChartSortConfiguration'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             value_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if data_label_options is not None:
            _setter("data_label_options", data_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if value_label_options is not None:
            _setter("value_label_options", value_label_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="dataLabelOptions")
    def data_label_options(self) -> Optional['outputs.TemplateFunnelChartDataLabelOptions']:
        return pulumi.get(self, "data_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateFunnelChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateFunnelChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="valueLabelOptions")
    def value_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "value_label_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class TemplateFunnelChartDataLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelVisibility":
            suggest = "category_label_visibility"
        elif key == "labelColor":
            suggest = "label_color"
        elif key == "labelFontConfiguration":
            suggest = "label_font_configuration"
        elif key == "measureDataLabelStyle":
            suggest = "measure_data_label_style"
        elif key == "measureLabelVisibility":
            suggest = "measure_label_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFunnelChartDataLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFunnelChartDataLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFunnelChartDataLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_visibility: Optional['TemplateVisibility'] = None,
                 label_color: Optional[str] = None,
                 label_font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
                 measure_data_label_style: Optional['TemplateFunnelChartMeasureDataLabelStyle'] = None,
                 measure_label_visibility: Optional['TemplateVisibility'] = None,
                 position: Optional['TemplateDataLabelPosition'] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateFunnelChartDataLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_visibility=category_label_visibility,
            label_color=label_color,
            label_font_configuration=label_font_configuration,
            measure_data_label_style=measure_data_label_style,
            measure_label_visibility=measure_label_visibility,
            position=position,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_visibility: Optional['TemplateVisibility'] = None,
             label_color: Optional[str] = None,
             label_font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
             measure_data_label_style: Optional['TemplateFunnelChartMeasureDataLabelStyle'] = None,
             measure_label_visibility: Optional['TemplateVisibility'] = None,
             position: Optional['TemplateDataLabelPosition'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_visibility is not None:
            _setter("category_label_visibility", category_label_visibility)
        if label_color is not None:
            _setter("label_color", label_color)
        if label_font_configuration is not None:
            _setter("label_font_configuration", label_font_configuration)
        if measure_data_label_style is not None:
            _setter("measure_data_label_style", measure_data_label_style)
        if measure_label_visibility is not None:
            _setter("measure_label_visibility", measure_label_visibility)
        if position is not None:
            _setter("position", position)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="categoryLabelVisibility")
    def category_label_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "category_label_visibility")

    @property
    @pulumi.getter(name="labelColor")
    def label_color(self) -> Optional[str]:
        return pulumi.get(self, "label_color")

    @property
    @pulumi.getter(name="labelFontConfiguration")
    def label_font_configuration(self) -> Optional['outputs.TemplateFontConfiguration']:
        return pulumi.get(self, "label_font_configuration")

    @property
    @pulumi.getter(name="measureDataLabelStyle")
    def measure_data_label_style(self) -> Optional['TemplateFunnelChartMeasureDataLabelStyle']:
        return pulumi.get(self, "measure_data_label_style")

    @property
    @pulumi.getter(name="measureLabelVisibility")
    def measure_label_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "measure_label_visibility")

    @property
    @pulumi.getter
    def position(self) -> Optional['TemplateDataLabelPosition']:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateFunnelChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "funnelChartAggregatedFieldWells":
            suggest = "funnel_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFunnelChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFunnelChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFunnelChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 funnel_chart_aggregated_field_wells: Optional['outputs.TemplateFunnelChartAggregatedFieldWells'] = None):
        TemplateFunnelChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            funnel_chart_aggregated_field_wells=funnel_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             funnel_chart_aggregated_field_wells: Optional['outputs.TemplateFunnelChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if funnel_chart_aggregated_field_wells is not None:
            _setter("funnel_chart_aggregated_field_wells", funnel_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="funnelChartAggregatedFieldWells")
    def funnel_chart_aggregated_field_wells(self) -> Optional['outputs.TemplateFunnelChartAggregatedFieldWells']:
        return pulumi.get(self, "funnel_chart_aggregated_field_wells")


@pulumi.output_type
class TemplateFunnelChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFunnelChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFunnelChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFunnelChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateFunnelChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class TemplateFunnelChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFunnelChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFunnelChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFunnelChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateFunnelChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateFunnelChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateFunnelChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateFunnelChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateGaugeChartArcConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "foregroundColor":
            suggest = "foreground_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGaugeChartArcConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGaugeChartArcConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGaugeChartArcConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 foreground_color: Optional['outputs.TemplateConditionalFormattingColor'] = None):
        TemplateGaugeChartArcConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            foreground_color=foreground_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             foreground_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if foreground_color is not None:
            _setter("foreground_color", foreground_color)

    @property
    @pulumi.getter(name="foregroundColor")
    def foreground_color(self) -> Optional['outputs.TemplateConditionalFormattingColor']:
        return pulumi.get(self, "foreground_color")


@pulumi.output_type
class TemplateGaugeChartConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGaugeChartConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGaugeChartConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGaugeChartConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.TemplateGaugeChartConditionalFormattingOption']] = None):
        TemplateGaugeChartConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.TemplateGaugeChartConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.TemplateGaugeChartConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class TemplateGaugeChartConditionalFormattingOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryValue":
            suggest = "primary_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGaugeChartConditionalFormattingOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGaugeChartConditionalFormattingOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGaugeChartConditionalFormattingOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc: Optional['outputs.TemplateGaugeChartArcConditionalFormatting'] = None,
                 primary_value: Optional['outputs.TemplateGaugeChartPrimaryValueConditionalFormatting'] = None):
        TemplateGaugeChartConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc=arc,
            primary_value=primary_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc: Optional['outputs.TemplateGaugeChartArcConditionalFormatting'] = None,
             primary_value: Optional['outputs.TemplateGaugeChartPrimaryValueConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc is not None:
            _setter("arc", arc)
        if primary_value is not None:
            _setter("primary_value", primary_value)

    @property
    @pulumi.getter
    def arc(self) -> Optional['outputs.TemplateGaugeChartArcConditionalFormatting']:
        return pulumi.get(self, "arc")

    @property
    @pulumi.getter(name="primaryValue")
    def primary_value(self) -> Optional['outputs.TemplateGaugeChartPrimaryValueConditionalFormatting']:
        return pulumi.get(self, "primary_value")


@pulumi.output_type
class TemplateGaugeChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "gaugeChartOptions":
            suggest = "gauge_chart_options"
        elif key == "tooltipOptions":
            suggest = "tooltip_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGaugeChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGaugeChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGaugeChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateGaugeChartFieldWells'] = None,
                 gauge_chart_options: Optional['outputs.TemplateGaugeChartOptions'] = None,
                 tooltip_options: Optional['outputs.TemplateTooltipOptions'] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None):
        TemplateGaugeChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_labels=data_labels,
            field_wells=field_wells,
            gauge_chart_options=gauge_chart_options,
            tooltip_options=tooltip_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateGaugeChartFieldWells'] = None,
             gauge_chart_options: Optional['outputs.TemplateGaugeChartOptions'] = None,
             tooltip_options: Optional['outputs.TemplateTooltipOptions'] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if gauge_chart_options is not None:
            _setter("gauge_chart_options", gauge_chart_options)
        if tooltip_options is not None:
            _setter("tooltip_options", tooltip_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateGaugeChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="gaugeChartOptions")
    def gauge_chart_options(self) -> Optional['outputs.TemplateGaugeChartOptions']:
        return pulumi.get(self, "gauge_chart_options")

    @property
    @pulumi.getter(name="tooltipOptions")
    def tooltip_options(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class TemplateGaugeChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValues":
            suggest = "target_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGaugeChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGaugeChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGaugeChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateGaugeChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_values=target_values,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if target_values is not None:
            _setter("target_values", target_values)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="targetValues")
    def target_values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "target_values")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateGaugeChartOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcAxis":
            suggest = "arc_axis"
        elif key == "primaryValueDisplayType":
            suggest = "primary_value_display_type"
        elif key == "primaryValueFontConfiguration":
            suggest = "primary_value_font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGaugeChartOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGaugeChartOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGaugeChartOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc: Optional['outputs.TemplateArcConfiguration'] = None,
                 arc_axis: Optional['outputs.TemplateArcAxisConfiguration'] = None,
                 comparison: Optional['outputs.TemplateComparisonConfiguration'] = None,
                 primary_value_display_type: Optional['TemplatePrimaryValueDisplayType'] = None,
                 primary_value_font_configuration: Optional['outputs.TemplateFontConfiguration'] = None):
        TemplateGaugeChartOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arc=arc,
            arc_axis=arc_axis,
            comparison=comparison,
            primary_value_display_type=primary_value_display_type,
            primary_value_font_configuration=primary_value_font_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arc: Optional['outputs.TemplateArcConfiguration'] = None,
             arc_axis: Optional['outputs.TemplateArcAxisConfiguration'] = None,
             comparison: Optional['outputs.TemplateComparisonConfiguration'] = None,
             primary_value_display_type: Optional['TemplatePrimaryValueDisplayType'] = None,
             primary_value_font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arc is not None:
            _setter("arc", arc)
        if arc_axis is not None:
            _setter("arc_axis", arc_axis)
        if comparison is not None:
            _setter("comparison", comparison)
        if primary_value_display_type is not None:
            _setter("primary_value_display_type", primary_value_display_type)
        if primary_value_font_configuration is not None:
            _setter("primary_value_font_configuration", primary_value_font_configuration)

    @property
    @pulumi.getter
    def arc(self) -> Optional['outputs.TemplateArcConfiguration']:
        return pulumi.get(self, "arc")

    @property
    @pulumi.getter(name="arcAxis")
    def arc_axis(self) -> Optional['outputs.TemplateArcAxisConfiguration']:
        return pulumi.get(self, "arc_axis")

    @property
    @pulumi.getter
    def comparison(self) -> Optional['outputs.TemplateComparisonConfiguration']:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter(name="primaryValueDisplayType")
    def primary_value_display_type(self) -> Optional['TemplatePrimaryValueDisplayType']:
        return pulumi.get(self, "primary_value_display_type")

    @property
    @pulumi.getter(name="primaryValueFontConfiguration")
    def primary_value_font_configuration(self) -> Optional['outputs.TemplateFontConfiguration']:
        return pulumi.get(self, "primary_value_font_configuration")


@pulumi.output_type
class TemplateGaugeChartPrimaryValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGaugeChartPrimaryValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGaugeChartPrimaryValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGaugeChartPrimaryValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.TemplateConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None):
        TemplateGaugeChartPrimaryValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.TemplateConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.TemplateConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.TemplateConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class TemplateGaugeChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGaugeChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGaugeChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGaugeChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateGaugeChartConfiguration'] = None,
                 conditional_formatting: Optional['outputs.TemplateGaugeChartConditionalFormatting'] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateGaugeChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateGaugeChartConfiguration'] = None,
             conditional_formatting: Optional['outputs.TemplateGaugeChartConditionalFormatting'] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateGaugeChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.TemplateGaugeChartConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateGeospatialCoordinateBounds(dict):
    def __init__(__self__, *,
                 east: float,
                 north: float,
                 south: float,
                 west: float):
        TemplateGeospatialCoordinateBounds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            east=east,
            north=north,
            south=south,
            west=west,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             east: float,
             north: float,
             south: float,
             west: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("east", east)
        _setter("north", north)
        _setter("south", south)
        _setter("west", west)

    @property
    @pulumi.getter
    def east(self) -> float:
        return pulumi.get(self, "east")

    @property
    @pulumi.getter
    def north(self) -> float:
        return pulumi.get(self, "north")

    @property
    @pulumi.getter
    def south(self) -> float:
        return pulumi.get(self, "south")

    @property
    @pulumi.getter
    def west(self) -> float:
        return pulumi.get(self, "west")


@pulumi.output_type
class TemplateGeospatialHeatmapColorScale(dict):
    def __init__(__self__, *,
                 colors: Optional[Sequence['outputs.TemplateGeospatialHeatmapDataColor']] = None):
        TemplateGeospatialHeatmapColorScale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence['outputs.TemplateGeospatialHeatmapDataColor']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if colors is not None:
            _setter("colors", colors)

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.TemplateGeospatialHeatmapDataColor']]:
        return pulumi.get(self, "colors")


@pulumi.output_type
class TemplateGeospatialHeatmapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "heatmapColor":
            suggest = "heatmap_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGeospatialHeatmapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGeospatialHeatmapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGeospatialHeatmapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 heatmap_color: Optional['outputs.TemplateGeospatialHeatmapColorScale'] = None):
        TemplateGeospatialHeatmapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            heatmap_color=heatmap_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             heatmap_color: Optional['outputs.TemplateGeospatialHeatmapColorScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if heatmap_color is not None:
            _setter("heatmap_color", heatmap_color)

    @property
    @pulumi.getter(name="heatmapColor")
    def heatmap_color(self) -> Optional['outputs.TemplateGeospatialHeatmapColorScale']:
        return pulumi.get(self, "heatmap_color")


@pulumi.output_type
class TemplateGeospatialHeatmapDataColor(dict):
    def __init__(__self__, *,
                 color: str):
        TemplateGeospatialHeatmapDataColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("color", color)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")


@pulumi.output_type
class TemplateGeospatialMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 colors: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 geospatial: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateGeospatialMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
            geospatial=geospatial,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             geospatial: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if colors is not None:
            _setter("colors", colors)
        if geospatial is not None:
            _setter("geospatial", geospatial)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter
    def geospatial(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "geospatial")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateGeospatialMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldWells":
            suggest = "field_wells"
        elif key == "mapStyleOptions":
            suggest = "map_style_options"
        elif key == "pointStyleOptions":
            suggest = "point_style_options"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "windowOptions":
            suggest = "window_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGeospatialMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGeospatialMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGeospatialMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_wells: Optional['outputs.TemplateGeospatialMapFieldWells'] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 map_style_options: Optional['outputs.TemplateGeospatialMapStyleOptions'] = None,
                 point_style_options: Optional['outputs.TemplateGeospatialPointStyleOptions'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
                 window_options: Optional['outputs.TemplateGeospatialWindowOptions'] = None):
        TemplateGeospatialMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_wells=field_wells,
            legend=legend,
            map_style_options=map_style_options,
            point_style_options=point_style_options,
            tooltip=tooltip,
            visual_palette=visual_palette,
            window_options=window_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_wells: Optional['outputs.TemplateGeospatialMapFieldWells'] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             map_style_options: Optional['outputs.TemplateGeospatialMapStyleOptions'] = None,
             point_style_options: Optional['outputs.TemplateGeospatialPointStyleOptions'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             window_options: Optional['outputs.TemplateGeospatialWindowOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if map_style_options is not None:
            _setter("map_style_options", map_style_options)
        if point_style_options is not None:
            _setter("point_style_options", point_style_options)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if window_options is not None:
            _setter("window_options", window_options)

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateGeospatialMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="mapStyleOptions")
    def map_style_options(self) -> Optional['outputs.TemplateGeospatialMapStyleOptions']:
        return pulumi.get(self, "map_style_options")

    @property
    @pulumi.getter(name="pointStyleOptions")
    def point_style_options(self) -> Optional['outputs.TemplateGeospatialPointStyleOptions']:
        return pulumi.get(self, "point_style_options")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="windowOptions")
    def window_options(self) -> Optional['outputs.TemplateGeospatialWindowOptions']:
        return pulumi.get(self, "window_options")


@pulumi.output_type
class TemplateGeospatialMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geospatialMapAggregatedFieldWells":
            suggest = "geospatial_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGeospatialMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGeospatialMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGeospatialMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geospatial_map_aggregated_field_wells: Optional['outputs.TemplateGeospatialMapAggregatedFieldWells'] = None):
        TemplateGeospatialMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            geospatial_map_aggregated_field_wells=geospatial_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             geospatial_map_aggregated_field_wells: Optional['outputs.TemplateGeospatialMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if geospatial_map_aggregated_field_wells is not None:
            _setter("geospatial_map_aggregated_field_wells", geospatial_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="geospatialMapAggregatedFieldWells")
    def geospatial_map_aggregated_field_wells(self) -> Optional['outputs.TemplateGeospatialMapAggregatedFieldWells']:
        return pulumi.get(self, "geospatial_map_aggregated_field_wells")


@pulumi.output_type
class TemplateGeospatialMapStyleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseMapStyle":
            suggest = "base_map_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGeospatialMapStyleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGeospatialMapStyleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGeospatialMapStyleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_map_style: Optional['TemplateBaseMapStyleType'] = None):
        TemplateGeospatialMapStyleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base_map_style=base_map_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base_map_style: Optional['TemplateBaseMapStyleType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if base_map_style is not None:
            _setter("base_map_style", base_map_style)

    @property
    @pulumi.getter(name="baseMapStyle")
    def base_map_style(self) -> Optional['TemplateBaseMapStyleType']:
        return pulumi.get(self, "base_map_style")


@pulumi.output_type
class TemplateGeospatialMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGeospatialMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGeospatialMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGeospatialMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateGeospatialMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateGeospatialMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateGeospatialMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateGeospatialMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateGeospatialPointStyleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterMarkerConfiguration":
            suggest = "cluster_marker_configuration"
        elif key == "heatmapConfiguration":
            suggest = "heatmap_configuration"
        elif key == "selectedPointStyle":
            suggest = "selected_point_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGeospatialPointStyleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGeospatialPointStyleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGeospatialPointStyleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_marker_configuration: Optional['outputs.TemplateClusterMarkerConfiguration'] = None,
                 heatmap_configuration: Optional['outputs.TemplateGeospatialHeatmapConfiguration'] = None,
                 selected_point_style: Optional['TemplateGeospatialSelectedPointStyle'] = None):
        TemplateGeospatialPointStyleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_marker_configuration=cluster_marker_configuration,
            heatmap_configuration=heatmap_configuration,
            selected_point_style=selected_point_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_marker_configuration: Optional['outputs.TemplateClusterMarkerConfiguration'] = None,
             heatmap_configuration: Optional['outputs.TemplateGeospatialHeatmapConfiguration'] = None,
             selected_point_style: Optional['TemplateGeospatialSelectedPointStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cluster_marker_configuration is not None:
            _setter("cluster_marker_configuration", cluster_marker_configuration)
        if heatmap_configuration is not None:
            _setter("heatmap_configuration", heatmap_configuration)
        if selected_point_style is not None:
            _setter("selected_point_style", selected_point_style)

    @property
    @pulumi.getter(name="clusterMarkerConfiguration")
    def cluster_marker_configuration(self) -> Optional['outputs.TemplateClusterMarkerConfiguration']:
        return pulumi.get(self, "cluster_marker_configuration")

    @property
    @pulumi.getter(name="heatmapConfiguration")
    def heatmap_configuration(self) -> Optional['outputs.TemplateGeospatialHeatmapConfiguration']:
        return pulumi.get(self, "heatmap_configuration")

    @property
    @pulumi.getter(name="selectedPointStyle")
    def selected_point_style(self) -> Optional['TemplateGeospatialSelectedPointStyle']:
        return pulumi.get(self, "selected_point_style")


@pulumi.output_type
class TemplateGeospatialWindowOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mapZoomMode":
            suggest = "map_zoom_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGeospatialWindowOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGeospatialWindowOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGeospatialWindowOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bounds: Optional['outputs.TemplateGeospatialCoordinateBounds'] = None,
                 map_zoom_mode: Optional['TemplateMapZoomMode'] = None):
        TemplateGeospatialWindowOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bounds=bounds,
            map_zoom_mode=map_zoom_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bounds: Optional['outputs.TemplateGeospatialCoordinateBounds'] = None,
             map_zoom_mode: Optional['TemplateMapZoomMode'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bounds is not None:
            _setter("bounds", bounds)
        if map_zoom_mode is not None:
            _setter("map_zoom_mode", map_zoom_mode)

    @property
    @pulumi.getter
    def bounds(self) -> Optional['outputs.TemplateGeospatialCoordinateBounds']:
        return pulumi.get(self, "bounds")

    @property
    @pulumi.getter(name="mapZoomMode")
    def map_zoom_mode(self) -> Optional['TemplateMapZoomMode']:
        return pulumi.get(self, "map_zoom_mode")


@pulumi.output_type
class TemplateGlobalTableBorderOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sideSpecificBorder":
            suggest = "side_specific_border"
        elif key == "uniformBorder":
            suggest = "uniform_border"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGlobalTableBorderOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGlobalTableBorderOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGlobalTableBorderOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 side_specific_border: Optional['outputs.TemplateTableSideBorderOptions'] = None,
                 uniform_border: Optional['outputs.TemplateTableBorderOptions'] = None):
        TemplateGlobalTableBorderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            side_specific_border=side_specific_border,
            uniform_border=uniform_border,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             side_specific_border: Optional['outputs.TemplateTableSideBorderOptions'] = None,
             uniform_border: Optional['outputs.TemplateTableBorderOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if side_specific_border is not None:
            _setter("side_specific_border", side_specific_border)
        if uniform_border is not None:
            _setter("uniform_border", uniform_border)

    @property
    @pulumi.getter(name="sideSpecificBorder")
    def side_specific_border(self) -> Optional['outputs.TemplateTableSideBorderOptions']:
        return pulumi.get(self, "side_specific_border")

    @property
    @pulumi.getter(name="uniformBorder")
    def uniform_border(self) -> Optional['outputs.TemplateTableBorderOptions']:
        return pulumi.get(self, "uniform_border")


@pulumi.output_type
class TemplateGradientColor(dict):
    def __init__(__self__, *,
                 stops: Optional[Sequence['outputs.TemplateGradientStop']] = None):
        TemplateGradientColor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stops=stops,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stops: Optional[Sequence['outputs.TemplateGradientStop']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if stops is not None:
            _setter("stops", stops)

    @property
    @pulumi.getter
    def stops(self) -> Optional[Sequence['outputs.TemplateGradientStop']]:
        return pulumi.get(self, "stops")


@pulumi.output_type
class TemplateGradientStop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gradientOffset":
            suggest = "gradient_offset"
        elif key == "dataValue":
            suggest = "data_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGradientStop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGradientStop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGradientStop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gradient_offset: float,
                 color: Optional[str] = None,
                 data_value: Optional[float] = None):
        TemplateGradientStop._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gradient_offset=gradient_offset,
            color=color,
            data_value=data_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gradient_offset: float,
             color: Optional[str] = None,
             data_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("gradient_offset", gradient_offset)
        if color is not None:
            _setter("color", color)
        if data_value is not None:
            _setter("data_value", data_value)

    @property
    @pulumi.getter(name="gradientOffset")
    def gradient_offset(self) -> float:
        return pulumi.get(self, "gradient_offset")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="dataValue")
    def data_value(self) -> Optional[float]:
        return pulumi.get(self, "data_value")


@pulumi.output_type
class TemplateGridLayoutCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "screenCanvasSizeOptions":
            suggest = "screen_canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGridLayoutCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGridLayoutCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGridLayoutCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 screen_canvas_size_options: Optional['outputs.TemplateGridLayoutScreenCanvasSizeOptions'] = None):
        TemplateGridLayoutCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            screen_canvas_size_options=screen_canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             screen_canvas_size_options: Optional['outputs.TemplateGridLayoutScreenCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if screen_canvas_size_options is not None:
            _setter("screen_canvas_size_options", screen_canvas_size_options)

    @property
    @pulumi.getter(name="screenCanvasSizeOptions")
    def screen_canvas_size_options(self) -> Optional['outputs.TemplateGridLayoutScreenCanvasSizeOptions']:
        return pulumi.get(self, "screen_canvas_size_options")


@pulumi.output_type
class TemplateGridLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canvasSizeOptions":
            suggest = "canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGridLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGridLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGridLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 elements: Sequence['outputs.TemplateGridLayoutElement'],
                 canvas_size_options: Optional['outputs.TemplateGridLayoutCanvasSizeOptions'] = None):
        TemplateGridLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            elements=elements,
            canvas_size_options=canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             elements: Sequence['outputs.TemplateGridLayoutElement'],
             canvas_size_options: Optional['outputs.TemplateGridLayoutCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("elements", elements)
        if canvas_size_options is not None:
            _setter("canvas_size_options", canvas_size_options)

    @property
    @pulumi.getter
    def elements(self) -> Sequence['outputs.TemplateGridLayoutElement']:
        return pulumi.get(self, "elements")

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> Optional['outputs.TemplateGridLayoutCanvasSizeOptions']:
        return pulumi.get(self, "canvas_size_options")


@pulumi.output_type
class TemplateGridLayoutElement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnSpan":
            suggest = "column_span"
        elif key == "elementId":
            suggest = "element_id"
        elif key == "elementType":
            suggest = "element_type"
        elif key == "rowSpan":
            suggest = "row_span"
        elif key == "columnIndex":
            suggest = "column_index"
        elif key == "rowIndex":
            suggest = "row_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGridLayoutElement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGridLayoutElement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGridLayoutElement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_span: float,
                 element_id: str,
                 element_type: 'TemplateLayoutElementType',
                 row_span: float,
                 column_index: Optional[float] = None,
                 row_index: Optional[float] = None):
        TemplateGridLayoutElement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_span=column_span,
            element_id=element_id,
            element_type=element_type,
            row_span=row_span,
            column_index=column_index,
            row_index=row_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_span: float,
             element_id: str,
             element_type: 'TemplateLayoutElementType',
             row_span: float,
             column_index: Optional[float] = None,
             row_index: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column_span", column_span)
        _setter("element_id", element_id)
        _setter("element_type", element_type)
        _setter("row_span", row_span)
        if column_index is not None:
            _setter("column_index", column_index)
        if row_index is not None:
            _setter("row_index", row_index)

    @property
    @pulumi.getter(name="columnSpan")
    def column_span(self) -> float:
        return pulumi.get(self, "column_span")

    @property
    @pulumi.getter(name="elementId")
    def element_id(self) -> str:
        return pulumi.get(self, "element_id")

    @property
    @pulumi.getter(name="elementType")
    def element_type(self) -> 'TemplateLayoutElementType':
        return pulumi.get(self, "element_type")

    @property
    @pulumi.getter(name="rowSpan")
    def row_span(self) -> float:
        return pulumi.get(self, "row_span")

    @property
    @pulumi.getter(name="columnIndex")
    def column_index(self) -> Optional[float]:
        return pulumi.get(self, "column_index")

    @property
    @pulumi.getter(name="rowIndex")
    def row_index(self) -> Optional[float]:
        return pulumi.get(self, "row_index")


@pulumi.output_type
class TemplateGridLayoutScreenCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resizeOption":
            suggest = "resize_option"
        elif key == "optimizedViewPortWidth":
            suggest = "optimized_view_port_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGridLayoutScreenCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGridLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGridLayoutScreenCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resize_option: 'TemplateResizeOption',
                 optimized_view_port_width: Optional[str] = None):
        """
        :param str optimized_view_port_width: String based length that is composed of value and unit in px
        """
        TemplateGridLayoutScreenCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resize_option=resize_option,
            optimized_view_port_width=optimized_view_port_width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resize_option: 'TemplateResizeOption',
             optimized_view_port_width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("resize_option", resize_option)
        if optimized_view_port_width is not None:
            _setter("optimized_view_port_width", optimized_view_port_width)

    @property
    @pulumi.getter(name="resizeOption")
    def resize_option(self) -> 'TemplateResizeOption':
        return pulumi.get(self, "resize_option")

    @property
    @pulumi.getter(name="optimizedViewPortWidth")
    def optimized_view_port_width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "optimized_view_port_width")


@pulumi.output_type
class TemplateGrowthRateComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "periodSize":
            suggest = "period_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGrowthRateComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGrowthRateComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGrowthRateComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 period_size: Optional[float] = None,
                 time: Optional['outputs.TemplateDimensionField'] = None,
                 value: Optional['outputs.TemplateMeasureField'] = None):
        TemplateGrowthRateComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            period_size=period_size,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             period_size: Optional[float] = None,
             time: Optional['outputs.TemplateDimensionField'] = None,
             value: Optional['outputs.TemplateMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if period_size is not None:
            _setter("period_size", period_size)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="periodSize")
    def period_size(self) -> Optional[float]:
        return pulumi.get(self, "period_size")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.TemplateDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.TemplateMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateHeaderFooterSectionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionId":
            suggest = "section_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateHeaderFooterSectionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateHeaderFooterSectionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateHeaderFooterSectionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layout: 'outputs.TemplateSectionLayoutConfiguration',
                 section_id: str,
                 style: Optional['outputs.TemplateSectionStyle'] = None):
        TemplateHeaderFooterSectionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            layout=layout,
            section_id=section_id,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             layout: 'outputs.TemplateSectionLayoutConfiguration',
             section_id: str,
             style: Optional['outputs.TemplateSectionStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("layout", layout)
        _setter("section_id", section_id)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter
    def layout(self) -> 'outputs.TemplateSectionLayoutConfiguration':
        return pulumi.get(self, "layout")

    @property
    @pulumi.getter(name="sectionId")
    def section_id(self) -> str:
        return pulumi.get(self, "section_id")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.TemplateSectionStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class TemplateHeatMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 columns: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 rows: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateHeatMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            rows=rows,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             rows: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if columns is not None:
            _setter("columns", columns)
        if rows is not None:
            _setter("rows", rows)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def rows(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "rows")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateHeatMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorScale":
            suggest = "color_scale"
        elif key == "columnLabelOptions":
            suggest = "column_label_options"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "rowLabelOptions":
            suggest = "row_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateHeatMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateHeatMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateHeatMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_scale: Optional['outputs.TemplateColorScale'] = None,
                 column_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateHeatMapFieldWells'] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 row_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.TemplateHeatMapSortConfiguration'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None):
        TemplateHeatMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_scale=color_scale,
            column_label_options=column_label_options,
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            row_label_options=row_label_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_scale: Optional['outputs.TemplateColorScale'] = None,
             column_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateHeatMapFieldWells'] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             row_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.TemplateHeatMapSortConfiguration'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color_scale is not None:
            _setter("color_scale", color_scale)
        if column_label_options is not None:
            _setter("column_label_options", column_label_options)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if row_label_options is not None:
            _setter("row_label_options", row_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)

    @property
    @pulumi.getter(name="colorScale")
    def color_scale(self) -> Optional['outputs.TemplateColorScale']:
        return pulumi.get(self, "color_scale")

    @property
    @pulumi.getter(name="columnLabelOptions")
    def column_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "column_label_options")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateHeatMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="rowLabelOptions")
    def row_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "row_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateHeatMapSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")


@pulumi.output_type
class TemplateHeatMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "heatMapAggregatedFieldWells":
            suggest = "heat_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateHeatMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateHeatMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateHeatMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 heat_map_aggregated_field_wells: Optional['outputs.TemplateHeatMapAggregatedFieldWells'] = None):
        TemplateHeatMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            heat_map_aggregated_field_wells=heat_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             heat_map_aggregated_field_wells: Optional['outputs.TemplateHeatMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if heat_map_aggregated_field_wells is not None:
            _setter("heat_map_aggregated_field_wells", heat_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="heatMapAggregatedFieldWells")
    def heat_map_aggregated_field_wells(self) -> Optional['outputs.TemplateHeatMapAggregatedFieldWells']:
        return pulumi.get(self, "heat_map_aggregated_field_wells")


@pulumi.output_type
class TemplateHeatMapSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "heatMapColumnItemsLimitConfiguration":
            suggest = "heat_map_column_items_limit_configuration"
        elif key == "heatMapColumnSort":
            suggest = "heat_map_column_sort"
        elif key == "heatMapRowItemsLimitConfiguration":
            suggest = "heat_map_row_items_limit_configuration"
        elif key == "heatMapRowSort":
            suggest = "heat_map_row_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateHeatMapSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateHeatMapSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateHeatMapSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 heat_map_column_items_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 heat_map_column_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
                 heat_map_row_items_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 heat_map_row_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateHeatMapSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            heat_map_column_items_limit_configuration=heat_map_column_items_limit_configuration,
            heat_map_column_sort=heat_map_column_sort,
            heat_map_row_items_limit_configuration=heat_map_row_items_limit_configuration,
            heat_map_row_sort=heat_map_row_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             heat_map_column_items_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             heat_map_column_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             heat_map_row_items_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             heat_map_row_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if heat_map_column_items_limit_configuration is not None:
            _setter("heat_map_column_items_limit_configuration", heat_map_column_items_limit_configuration)
        if heat_map_column_sort is not None:
            _setter("heat_map_column_sort", heat_map_column_sort)
        if heat_map_row_items_limit_configuration is not None:
            _setter("heat_map_row_items_limit_configuration", heat_map_row_items_limit_configuration)
        if heat_map_row_sort is not None:
            _setter("heat_map_row_sort", heat_map_row_sort)

    @property
    @pulumi.getter(name="heatMapColumnItemsLimitConfiguration")
    def heat_map_column_items_limit_configuration(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "heat_map_column_items_limit_configuration")

    @property
    @pulumi.getter(name="heatMapColumnSort")
    def heat_map_column_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "heat_map_column_sort")

    @property
    @pulumi.getter(name="heatMapRowItemsLimitConfiguration")
    def heat_map_row_items_limit_configuration(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "heat_map_row_items_limit_configuration")

    @property
    @pulumi.getter(name="heatMapRowSort")
    def heat_map_row_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "heat_map_row_sort")


@pulumi.output_type
class TemplateHeatMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateHeatMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateHeatMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateHeatMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateHeatMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateHeatMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateHeatMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateHeatMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateHistogramAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateHistogramAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateHistogramBinOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binCount":
            suggest = "bin_count"
        elif key == "binWidth":
            suggest = "bin_width"
        elif key == "selectedBinType":
            suggest = "selected_bin_type"
        elif key == "startValue":
            suggest = "start_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateHistogramBinOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateHistogramBinOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateHistogramBinOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bin_count: Optional['outputs.TemplateBinCountOptions'] = None,
                 bin_width: Optional['outputs.TemplateBinWidthOptions'] = None,
                 selected_bin_type: Optional['TemplateHistogramBinType'] = None,
                 start_value: Optional[float] = None):
        TemplateHistogramBinOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bin_count=bin_count,
            bin_width=bin_width,
            selected_bin_type=selected_bin_type,
            start_value=start_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bin_count: Optional['outputs.TemplateBinCountOptions'] = None,
             bin_width: Optional['outputs.TemplateBinWidthOptions'] = None,
             selected_bin_type: Optional['TemplateHistogramBinType'] = None,
             start_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bin_count is not None:
            _setter("bin_count", bin_count)
        if bin_width is not None:
            _setter("bin_width", bin_width)
        if selected_bin_type is not None:
            _setter("selected_bin_type", selected_bin_type)
        if start_value is not None:
            _setter("start_value", start_value)

    @property
    @pulumi.getter(name="binCount")
    def bin_count(self) -> Optional['outputs.TemplateBinCountOptions']:
        return pulumi.get(self, "bin_count")

    @property
    @pulumi.getter(name="binWidth")
    def bin_width(self) -> Optional['outputs.TemplateBinWidthOptions']:
        return pulumi.get(self, "bin_width")

    @property
    @pulumi.getter(name="selectedBinType")
    def selected_bin_type(self) -> Optional['TemplateHistogramBinType']:
        return pulumi.get(self, "selected_bin_type")

    @property
    @pulumi.getter(name="startValue")
    def start_value(self) -> Optional[float]:
        return pulumi.get(self, "start_value")


@pulumi.output_type
class TemplateHistogramConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binOptions":
            suggest = "bin_options"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "xAxisDisplayOptions":
            suggest = "x_axis_display_options"
        elif key == "xAxisLabelOptions":
            suggest = "x_axis_label_options"
        elif key == "yAxisDisplayOptions":
            suggest = "y_axis_display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateHistogramConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateHistogramConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateHistogramConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bin_options: Optional['outputs.TemplateHistogramBinOptions'] = None,
                 data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateHistogramFieldWells'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
                 x_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 x_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None):
        TemplateHistogramConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bin_options=bin_options,
            data_labels=data_labels,
            field_wells=field_wells,
            tooltip=tooltip,
            visual_palette=visual_palette,
            x_axis_display_options=x_axis_display_options,
            x_axis_label_options=x_axis_label_options,
            y_axis_display_options=y_axis_display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bin_options: Optional['outputs.TemplateHistogramBinOptions'] = None,
             data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateHistogramFieldWells'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             x_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             x_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bin_options is not None:
            _setter("bin_options", bin_options)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if x_axis_display_options is not None:
            _setter("x_axis_display_options", x_axis_display_options)
        if x_axis_label_options is not None:
            _setter("x_axis_label_options", x_axis_label_options)
        if y_axis_display_options is not None:
            _setter("y_axis_display_options", y_axis_display_options)

    @property
    @pulumi.getter(name="binOptions")
    def bin_options(self) -> Optional['outputs.TemplateHistogramBinOptions']:
        return pulumi.get(self, "bin_options")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateHistogramFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="xAxisDisplayOptions")
    def x_axis_display_options(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "x_axis_display_options")

    @property
    @pulumi.getter(name="xAxisLabelOptions")
    def x_axis_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "x_axis_label_options")

    @property
    @pulumi.getter(name="yAxisDisplayOptions")
    def y_axis_display_options(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "y_axis_display_options")


@pulumi.output_type
class TemplateHistogramFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "histogramAggregatedFieldWells":
            suggest = "histogram_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateHistogramFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateHistogramFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateHistogramFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 histogram_aggregated_field_wells: Optional['outputs.TemplateHistogramAggregatedFieldWells'] = None):
        TemplateHistogramFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            histogram_aggregated_field_wells=histogram_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             histogram_aggregated_field_wells: Optional['outputs.TemplateHistogramAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if histogram_aggregated_field_wells is not None:
            _setter("histogram_aggregated_field_wells", histogram_aggregated_field_wells)

    @property
    @pulumi.getter(name="histogramAggregatedFieldWells")
    def histogram_aggregated_field_wells(self) -> Optional['outputs.TemplateHistogramAggregatedFieldWells']:
        return pulumi.get(self, "histogram_aggregated_field_wells")


@pulumi.output_type
class TemplateHistogramVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateHistogramVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateHistogramVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateHistogramVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateHistogramConfiguration'] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateHistogramVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateHistogramConfiguration'] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateHistogramConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateInsightConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customNarrative":
            suggest = "custom_narrative"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateInsightConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateInsightConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateInsightConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computations: Optional[Sequence['outputs.TemplateComputation']] = None,
                 custom_narrative: Optional['outputs.TemplateCustomNarrativeOptions'] = None):
        TemplateInsightConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computations=computations,
            custom_narrative=custom_narrative,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computations: Optional[Sequence['outputs.TemplateComputation']] = None,
             custom_narrative: Optional['outputs.TemplateCustomNarrativeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if computations is not None:
            _setter("computations", computations)
        if custom_narrative is not None:
            _setter("custom_narrative", custom_narrative)

    @property
    @pulumi.getter
    def computations(self) -> Optional[Sequence['outputs.TemplateComputation']]:
        return pulumi.get(self, "computations")

    @property
    @pulumi.getter(name="customNarrative")
    def custom_narrative(self) -> Optional['outputs.TemplateCustomNarrativeOptions']:
        return pulumi.get(self, "custom_narrative")


@pulumi.output_type
class TemplateInsightVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "visualId":
            suggest = "visual_id"
        elif key == "insightConfiguration":
            suggest = "insight_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateInsightVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateInsightVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateInsightVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 insight_configuration: Optional['outputs.TemplateInsightConfiguration'] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateInsightVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            visual_id=visual_id,
            actions=actions,
            insight_configuration=insight_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             insight_configuration: Optional['outputs.TemplateInsightConfiguration'] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if insight_configuration is not None:
            _setter("insight_configuration", insight_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="insightConfiguration")
    def insight_configuration(self) -> Optional['outputs.TemplateInsightConfiguration']:
        return pulumi.get(self, "insight_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateIntegerDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateIntegerDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateIntegerDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateIntegerDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.TemplateDynamicDefaultValue'] = None,
                 static_values: Optional[Sequence[float]] = None):
        TemplateIntegerDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.TemplateDynamicDefaultValue'] = None,
             static_values: Optional[Sequence[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.TemplateDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class TemplateIntegerParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueType":
            suggest = "parameter_value_type"
        elif key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateIntegerParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateIntegerParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateIntegerParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 parameter_value_type: 'TemplateParameterValueType',
                 default_values: Optional['outputs.TemplateIntegerDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.TemplateMappedDataSetParameter']] = None,
                 value_when_unset: Optional['outputs.TemplateIntegerValueWhenUnsetConfiguration'] = None):
        TemplateIntegerParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameter_value_type=parameter_value_type,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             parameter_value_type: 'TemplateParameterValueType',
             default_values: Optional['outputs.TemplateIntegerDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.TemplateMappedDataSetParameter']] = None,
             value_when_unset: Optional['outputs.TemplateIntegerValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("parameter_value_type", parameter_value_type)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterValueType")
    def parameter_value_type(self) -> 'TemplateParameterValueType':
        return pulumi.get(self, "parameter_value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.TemplateIntegerDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.TemplateMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.TemplateIntegerValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class TemplateIntegerValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateIntegerValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateIntegerValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateIntegerValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[float] = None,
                 value_when_unset_option: Optional['TemplateValueWhenUnsetOption'] = None):
        TemplateIntegerValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[float] = None,
             value_when_unset_option: Optional['TemplateValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[float]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['TemplateValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class TemplateItemsLimitConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "itemsLimit":
            suggest = "items_limit"
        elif key == "otherCategories":
            suggest = "other_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateItemsLimitConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateItemsLimitConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateItemsLimitConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 items_limit: Optional[float] = None,
                 other_categories: Optional['TemplateOtherCategories'] = None):
        TemplateItemsLimitConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items_limit=items_limit,
            other_categories=other_categories,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items_limit: Optional[float] = None,
             other_categories: Optional['TemplateOtherCategories'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if items_limit is not None:
            _setter("items_limit", items_limit)
        if other_categories is not None:
            _setter("other_categories", other_categories)

    @property
    @pulumi.getter(name="itemsLimit")
    def items_limit(self) -> Optional[float]:
        return pulumi.get(self, "items_limit")

    @property
    @pulumi.getter(name="otherCategories")
    def other_categories(self) -> Optional['TemplateOtherCategories']:
        return pulumi.get(self, "other_categories")


@pulumi.output_type
class TemplateKpiActualValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiActualValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiActualValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiActualValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.TemplateConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None):
        TemplateKpiActualValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.TemplateConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.TemplateConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.TemplateConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class TemplateKpiComparisonValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiComparisonValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiComparisonValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiComparisonValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.TemplateConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None):
        TemplateKpiComparisonValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.TemplateConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.TemplateConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.TemplateConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class TemplateKpiConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.TemplateKpiConditionalFormattingOption']] = None):
        TemplateKpiConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.TemplateKpiConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.TemplateKpiConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class TemplateKpiConditionalFormattingOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actualValue":
            suggest = "actual_value"
        elif key == "comparisonValue":
            suggest = "comparison_value"
        elif key == "primaryValue":
            suggest = "primary_value"
        elif key == "progressBar":
            suggest = "progress_bar"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiConditionalFormattingOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiConditionalFormattingOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiConditionalFormattingOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actual_value: Optional['outputs.TemplateKpiActualValueConditionalFormatting'] = None,
                 comparison_value: Optional['outputs.TemplateKpiComparisonValueConditionalFormatting'] = None,
                 primary_value: Optional['outputs.TemplateKpiPrimaryValueConditionalFormatting'] = None,
                 progress_bar: Optional['outputs.TemplateKpiProgressBarConditionalFormatting'] = None):
        TemplateKpiConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actual_value=actual_value,
            comparison_value=comparison_value,
            primary_value=primary_value,
            progress_bar=progress_bar,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actual_value: Optional['outputs.TemplateKpiActualValueConditionalFormatting'] = None,
             comparison_value: Optional['outputs.TemplateKpiComparisonValueConditionalFormatting'] = None,
             primary_value: Optional['outputs.TemplateKpiPrimaryValueConditionalFormatting'] = None,
             progress_bar: Optional['outputs.TemplateKpiProgressBarConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if actual_value is not None:
            _setter("actual_value", actual_value)
        if comparison_value is not None:
            _setter("comparison_value", comparison_value)
        if primary_value is not None:
            _setter("primary_value", primary_value)
        if progress_bar is not None:
            _setter("progress_bar", progress_bar)

    @property
    @pulumi.getter(name="actualValue")
    def actual_value(self) -> Optional['outputs.TemplateKpiActualValueConditionalFormatting']:
        return pulumi.get(self, "actual_value")

    @property
    @pulumi.getter(name="comparisonValue")
    def comparison_value(self) -> Optional['outputs.TemplateKpiComparisonValueConditionalFormatting']:
        return pulumi.get(self, "comparison_value")

    @property
    @pulumi.getter(name="primaryValue")
    def primary_value(self) -> Optional['outputs.TemplateKpiPrimaryValueConditionalFormatting']:
        return pulumi.get(self, "primary_value")

    @property
    @pulumi.getter(name="progressBar")
    def progress_bar(self) -> Optional['outputs.TemplateKpiProgressBarConditionalFormatting']:
        return pulumi.get(self, "progress_bar")


@pulumi.output_type
class TemplateKpiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldWells":
            suggest = "field_wells"
        elif key == "kpiOptions":
            suggest = "kpi_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_wells: Optional['outputs.TemplateKpiFieldWells'] = None,
                 kpi_options: Optional['outputs.TemplateKpiOptions'] = None,
                 sort_configuration: Optional['outputs.TemplateKpiSortConfiguration'] = None):
        TemplateKpiConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_wells=field_wells,
            kpi_options=kpi_options,
            sort_configuration=sort_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_wells: Optional['outputs.TemplateKpiFieldWells'] = None,
             kpi_options: Optional['outputs.TemplateKpiOptions'] = None,
             sort_configuration: Optional['outputs.TemplateKpiSortConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if kpi_options is not None:
            _setter("kpi_options", kpi_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateKpiFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="kpiOptions")
    def kpi_options(self) -> Optional['outputs.TemplateKpiOptions']:
        return pulumi.get(self, "kpi_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateKpiSortConfiguration']:
        return pulumi.get(self, "sort_configuration")


@pulumi.output_type
class TemplateKpiFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValues":
            suggest = "target_values"
        elif key == "trendGroups":
            suggest = "trend_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
                 trend_groups: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateKpiFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_values=target_values,
            trend_groups=trend_groups,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             trend_groups: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if target_values is not None:
            _setter("target_values", target_values)
        if trend_groups is not None:
            _setter("trend_groups", trend_groups)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="targetValues")
    def target_values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "target_values")

    @property
    @pulumi.getter(name="trendGroups")
    def trend_groups(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "trend_groups")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateKpiOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryValueDisplayType":
            suggest = "primary_value_display_type"
        elif key == "primaryValueFontConfiguration":
            suggest = "primary_value_font_configuration"
        elif key == "progressBar":
            suggest = "progress_bar"
        elif key == "secondaryValue":
            suggest = "secondary_value"
        elif key == "secondaryValueFontConfiguration":
            suggest = "secondary_value_font_configuration"
        elif key == "trendArrows":
            suggest = "trend_arrows"
        elif key == "visualLayoutOptions":
            suggest = "visual_layout_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: Optional['outputs.TemplateComparisonConfiguration'] = None,
                 primary_value_display_type: Optional['TemplatePrimaryValueDisplayType'] = None,
                 primary_value_font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
                 progress_bar: Optional['outputs.TemplateProgressBarOptions'] = None,
                 secondary_value: Optional['outputs.TemplateSecondaryValueOptions'] = None,
                 secondary_value_font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
                 sparkline: Optional['outputs.TemplateKpiSparklineOptions'] = None,
                 trend_arrows: Optional['outputs.TemplateTrendArrowOptions'] = None,
                 visual_layout_options: Optional['outputs.TemplateKpiVisualLayoutOptions'] = None):
        TemplateKpiOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison=comparison,
            primary_value_display_type=primary_value_display_type,
            primary_value_font_configuration=primary_value_font_configuration,
            progress_bar=progress_bar,
            secondary_value=secondary_value,
            secondary_value_font_configuration=secondary_value_font_configuration,
            sparkline=sparkline,
            trend_arrows=trend_arrows,
            visual_layout_options=visual_layout_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison: Optional['outputs.TemplateComparisonConfiguration'] = None,
             primary_value_display_type: Optional['TemplatePrimaryValueDisplayType'] = None,
             primary_value_font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
             progress_bar: Optional['outputs.TemplateProgressBarOptions'] = None,
             secondary_value: Optional['outputs.TemplateSecondaryValueOptions'] = None,
             secondary_value_font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
             sparkline: Optional['outputs.TemplateKpiSparklineOptions'] = None,
             trend_arrows: Optional['outputs.TemplateTrendArrowOptions'] = None,
             visual_layout_options: Optional['outputs.TemplateKpiVisualLayoutOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if comparison is not None:
            _setter("comparison", comparison)
        if primary_value_display_type is not None:
            _setter("primary_value_display_type", primary_value_display_type)
        if primary_value_font_configuration is not None:
            _setter("primary_value_font_configuration", primary_value_font_configuration)
        if progress_bar is not None:
            _setter("progress_bar", progress_bar)
        if secondary_value is not None:
            _setter("secondary_value", secondary_value)
        if secondary_value_font_configuration is not None:
            _setter("secondary_value_font_configuration", secondary_value_font_configuration)
        if sparkline is not None:
            _setter("sparkline", sparkline)
        if trend_arrows is not None:
            _setter("trend_arrows", trend_arrows)
        if visual_layout_options is not None:
            _setter("visual_layout_options", visual_layout_options)

    @property
    @pulumi.getter
    def comparison(self) -> Optional['outputs.TemplateComparisonConfiguration']:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter(name="primaryValueDisplayType")
    def primary_value_display_type(self) -> Optional['TemplatePrimaryValueDisplayType']:
        return pulumi.get(self, "primary_value_display_type")

    @property
    @pulumi.getter(name="primaryValueFontConfiguration")
    def primary_value_font_configuration(self) -> Optional['outputs.TemplateFontConfiguration']:
        return pulumi.get(self, "primary_value_font_configuration")

    @property
    @pulumi.getter(name="progressBar")
    def progress_bar(self) -> Optional['outputs.TemplateProgressBarOptions']:
        return pulumi.get(self, "progress_bar")

    @property
    @pulumi.getter(name="secondaryValue")
    def secondary_value(self) -> Optional['outputs.TemplateSecondaryValueOptions']:
        return pulumi.get(self, "secondary_value")

    @property
    @pulumi.getter(name="secondaryValueFontConfiguration")
    def secondary_value_font_configuration(self) -> Optional['outputs.TemplateFontConfiguration']:
        return pulumi.get(self, "secondary_value_font_configuration")

    @property
    @pulumi.getter
    def sparkline(self) -> Optional['outputs.TemplateKpiSparklineOptions']:
        return pulumi.get(self, "sparkline")

    @property
    @pulumi.getter(name="trendArrows")
    def trend_arrows(self) -> Optional['outputs.TemplateTrendArrowOptions']:
        return pulumi.get(self, "trend_arrows")

    @property
    @pulumi.getter(name="visualLayoutOptions")
    def visual_layout_options(self) -> Optional['outputs.TemplateKpiVisualLayoutOptions']:
        return pulumi.get(self, "visual_layout_options")


@pulumi.output_type
class TemplateKpiPrimaryValueConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiPrimaryValueConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiPrimaryValueConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiPrimaryValueConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon: Optional['outputs.TemplateConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None):
        TemplateKpiPrimaryValueConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['outputs.TemplateConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.TemplateConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.TemplateConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class TemplateKpiProgressBarConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "foregroundColor":
            suggest = "foreground_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiProgressBarConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiProgressBarConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiProgressBarConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 foreground_color: Optional['outputs.TemplateConditionalFormattingColor'] = None):
        TemplateKpiProgressBarConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            foreground_color=foreground_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             foreground_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if foreground_color is not None:
            _setter("foreground_color", foreground_color)

    @property
    @pulumi.getter(name="foregroundColor")
    def foreground_color(self) -> Optional['outputs.TemplateConditionalFormattingColor']:
        return pulumi.get(self, "foreground_color")


@pulumi.output_type
class TemplateKpiSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trendGroupSort":
            suggest = "trend_group_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trend_group_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateKpiSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trend_group_sort=trend_group_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trend_group_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if trend_group_sort is not None:
            _setter("trend_group_sort", trend_group_sort)

    @property
    @pulumi.getter(name="trendGroupSort")
    def trend_group_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "trend_group_sort")


@pulumi.output_type
class TemplateKpiSparklineOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tooltipVisibility":
            suggest = "tooltip_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiSparklineOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiSparklineOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiSparklineOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'TemplateKpiSparklineType',
                 color: Optional[str] = None,
                 tooltip_visibility: Optional['TemplateVisibility'] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateKpiSparklineOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            color=color,
            tooltip_visibility=tooltip_visibility,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: 'TemplateKpiSparklineType',
             color: Optional[str] = None,
             tooltip_visibility: Optional['TemplateVisibility'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if color is not None:
            _setter("color", color)
        if tooltip_visibility is not None:
            _setter("tooltip_visibility", tooltip_visibility)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def type(self) -> 'TemplateKpiSparklineType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="tooltipVisibility")
    def tooltip_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "tooltip_visibility")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateKpiVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateKpiConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 conditional_formatting: Optional['outputs.TemplateKpiConditionalFormatting'] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateKpiVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateKpiConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             conditional_formatting: Optional['outputs.TemplateKpiConditionalFormatting'] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateKpiConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.TemplateKpiConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateKpiVisualLayoutOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "standardLayout":
            suggest = "standard_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateKpiVisualLayoutOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateKpiVisualLayoutOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateKpiVisualLayoutOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 standard_layout: Optional['outputs.TemplateKpiVisualStandardLayout'] = None):
        TemplateKpiVisualLayoutOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            standard_layout=standard_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             standard_layout: Optional['outputs.TemplateKpiVisualStandardLayout'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if standard_layout is not None:
            _setter("standard_layout", standard_layout)

    @property
    @pulumi.getter(name="standardLayout")
    def standard_layout(self) -> Optional['outputs.TemplateKpiVisualStandardLayout']:
        return pulumi.get(self, "standard_layout")


@pulumi.output_type
class TemplateKpiVisualStandardLayout(dict):
    def __init__(__self__, *,
                 type: 'TemplateKpiVisualStandardLayoutType'):
        TemplateKpiVisualStandardLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: 'TemplateKpiVisualStandardLayoutType',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> 'TemplateKpiVisualStandardLayoutType':
        return pulumi.get(self, "type")


@pulumi.output_type
class TemplateLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "fontConfiguration":
            suggest = "font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            font_configuration=font_configuration,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.TemplateFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateLayout(dict):
    def __init__(__self__, *,
                 configuration: 'outputs.TemplateLayoutConfiguration'):
        TemplateLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: 'outputs.TemplateLayoutConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("configuration", configuration)

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.TemplateLayoutConfiguration':
        return pulumi.get(self, "configuration")


@pulumi.output_type
class TemplateLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeFormLayout":
            suggest = "free_form_layout"
        elif key == "gridLayout":
            suggest = "grid_layout"
        elif key == "sectionBasedLayout":
            suggest = "section_based_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_form_layout: Optional['outputs.TemplateFreeFormLayoutConfiguration'] = None,
                 grid_layout: Optional['outputs.TemplateGridLayoutConfiguration'] = None,
                 section_based_layout: Optional['outputs.TemplateSectionBasedLayoutConfiguration'] = None):
        TemplateLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            free_form_layout=free_form_layout,
            grid_layout=grid_layout,
            section_based_layout=section_based_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             free_form_layout: Optional['outputs.TemplateFreeFormLayoutConfiguration'] = None,
             grid_layout: Optional['outputs.TemplateGridLayoutConfiguration'] = None,
             section_based_layout: Optional['outputs.TemplateSectionBasedLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if free_form_layout is not None:
            _setter("free_form_layout", free_form_layout)
        if grid_layout is not None:
            _setter("grid_layout", grid_layout)
        if section_based_layout is not None:
            _setter("section_based_layout", section_based_layout)

    @property
    @pulumi.getter(name="freeFormLayout")
    def free_form_layout(self) -> Optional['outputs.TemplateFreeFormLayoutConfiguration']:
        return pulumi.get(self, "free_form_layout")

    @property
    @pulumi.getter(name="gridLayout")
    def grid_layout(self) -> Optional['outputs.TemplateGridLayoutConfiguration']:
        return pulumi.get(self, "grid_layout")

    @property
    @pulumi.getter(name="sectionBasedLayout")
    def section_based_layout(self) -> Optional['outputs.TemplateSectionBasedLayoutConfiguration']:
        return pulumi.get(self, "section_based_layout")


@pulumi.output_type
class TemplateLegendOptions(dict):
    def __init__(__self__, *,
                 height: Optional[str] = None,
                 position: Optional['TemplateLegendPosition'] = None,
                 title: Optional['outputs.TemplateLabelOptions'] = None,
                 visibility: Optional['TemplateVisibility'] = None,
                 width: Optional[str] = None):
        """
        :param str height: String based length that is composed of value and unit in px
        :param str width: String based length that is composed of value and unit in px
        """
        TemplateLegendOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            height=height,
            position=position,
            title=title,
            visibility=visibility,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             height: Optional[str] = None,
             position: Optional['TemplateLegendPosition'] = None,
             title: Optional['outputs.TemplateLabelOptions'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if height is not None:
            _setter("height", height)
        if position is not None:
            _setter("position", position)
        if title is not None:
            _setter("title", title)
        if visibility is not None:
            _setter("visibility", visibility)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def position(self) -> Optional['TemplateLegendPosition']:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateLabelOptions']:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class TemplateLineChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "smallMultiples":
            suggest = "small_multiples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLineChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLineChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLineChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 colors: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 small_multiples: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateLineChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            colors=colors,
            small_multiples=small_multiples,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             colors: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             small_multiples: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if colors is not None:
            _setter("colors", colors)
        if small_multiples is not None:
            _setter("small_multiples", small_multiples)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="smallMultiples")
    def small_multiples(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "small_multiples")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateLineChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionAnalysisDefaults":
            suggest = "contribution_analysis_defaults"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "defaultSeriesSettings":
            suggest = "default_series_settings"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "forecastConfigurations":
            suggest = "forecast_configurations"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "referenceLines":
            suggest = "reference_lines"
        elif key == "secondaryYAxisDisplayOptions":
            suggest = "secondary_y_axis_display_options"
        elif key == "secondaryYAxisLabelOptions":
            suggest = "secondary_y_axis_label_options"
        elif key == "smallMultiplesOptions":
            suggest = "small_multiples_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "xAxisDisplayOptions":
            suggest = "x_axis_display_options"
        elif key == "xAxisLabelOptions":
            suggest = "x_axis_label_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLineChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLineChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLineChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_analysis_defaults: Optional[Sequence['outputs.TemplateContributionAnalysisDefault']] = None,
                 data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 default_series_settings: Optional['outputs.TemplateLineChartDefaultSeriesSettings'] = None,
                 field_wells: Optional['outputs.TemplateLineChartFieldWells'] = None,
                 forecast_configurations: Optional[Sequence['outputs.TemplateForecastConfiguration']] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.TemplateLineSeriesAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 reference_lines: Optional[Sequence['outputs.TemplateReferenceLine']] = None,
                 secondary_y_axis_display_options: Optional['outputs.TemplateLineSeriesAxisDisplayOptions'] = None,
                 secondary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 series: Optional[Sequence['outputs.TemplateSeriesItem']] = None,
                 small_multiples_options: Optional['outputs.TemplateSmallMultiplesOptions'] = None,
                 sort_configuration: Optional['outputs.TemplateLineChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
                 type: Optional['TemplateLineChartType'] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
                 x_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 x_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None):
        TemplateLineChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contribution_analysis_defaults=contribution_analysis_defaults,
            data_labels=data_labels,
            default_series_settings=default_series_settings,
            field_wells=field_wells,
            forecast_configurations=forecast_configurations,
            legend=legend,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            reference_lines=reference_lines,
            secondary_y_axis_display_options=secondary_y_axis_display_options,
            secondary_y_axis_label_options=secondary_y_axis_label_options,
            series=series,
            small_multiples_options=small_multiples_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            type=type,
            visual_palette=visual_palette,
            x_axis_display_options=x_axis_display_options,
            x_axis_label_options=x_axis_label_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contribution_analysis_defaults: Optional[Sequence['outputs.TemplateContributionAnalysisDefault']] = None,
             data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             default_series_settings: Optional['outputs.TemplateLineChartDefaultSeriesSettings'] = None,
             field_wells: Optional['outputs.TemplateLineChartFieldWells'] = None,
             forecast_configurations: Optional[Sequence['outputs.TemplateForecastConfiguration']] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.TemplateLineSeriesAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             reference_lines: Optional[Sequence['outputs.TemplateReferenceLine']] = None,
             secondary_y_axis_display_options: Optional['outputs.TemplateLineSeriesAxisDisplayOptions'] = None,
             secondary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             series: Optional[Sequence['outputs.TemplateSeriesItem']] = None,
             small_multiples_options: Optional['outputs.TemplateSmallMultiplesOptions'] = None,
             sort_configuration: Optional['outputs.TemplateLineChartSortConfiguration'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             type: Optional['TemplateLineChartType'] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             x_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             x_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if contribution_analysis_defaults is not None:
            _setter("contribution_analysis_defaults", contribution_analysis_defaults)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if default_series_settings is not None:
            _setter("default_series_settings", default_series_settings)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if forecast_configurations is not None:
            _setter("forecast_configurations", forecast_configurations)
        if legend is not None:
            _setter("legend", legend)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if reference_lines is not None:
            _setter("reference_lines", reference_lines)
        if secondary_y_axis_display_options is not None:
            _setter("secondary_y_axis_display_options", secondary_y_axis_display_options)
        if secondary_y_axis_label_options is not None:
            _setter("secondary_y_axis_label_options", secondary_y_axis_label_options)
        if series is not None:
            _setter("series", series)
        if small_multiples_options is not None:
            _setter("small_multiples_options", small_multiples_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if type is not None:
            _setter("type", type)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if x_axis_display_options is not None:
            _setter("x_axis_display_options", x_axis_display_options)
        if x_axis_label_options is not None:
            _setter("x_axis_label_options", x_axis_label_options)

    @property
    @pulumi.getter(name="contributionAnalysisDefaults")
    def contribution_analysis_defaults(self) -> Optional[Sequence['outputs.TemplateContributionAnalysisDefault']]:
        return pulumi.get(self, "contribution_analysis_defaults")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="defaultSeriesSettings")
    def default_series_settings(self) -> Optional['outputs.TemplateLineChartDefaultSeriesSettings']:
        return pulumi.get(self, "default_series_settings")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateLineChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="forecastConfigurations")
    def forecast_configurations(self) -> Optional[Sequence['outputs.TemplateForecastConfiguration']]:
        return pulumi.get(self, "forecast_configurations")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.TemplateLineSeriesAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="referenceLines")
    def reference_lines(self) -> Optional[Sequence['outputs.TemplateReferenceLine']]:
        return pulumi.get(self, "reference_lines")

    @property
    @pulumi.getter(name="secondaryYAxisDisplayOptions")
    def secondary_y_axis_display_options(self) -> Optional['outputs.TemplateLineSeriesAxisDisplayOptions']:
        return pulumi.get(self, "secondary_y_axis_display_options")

    @property
    @pulumi.getter(name="secondaryYAxisLabelOptions")
    def secondary_y_axis_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "secondary_y_axis_label_options")

    @property
    @pulumi.getter
    def series(self) -> Optional[Sequence['outputs.TemplateSeriesItem']]:
        return pulumi.get(self, "series")

    @property
    @pulumi.getter(name="smallMultiplesOptions")
    def small_multiples_options(self) -> Optional['outputs.TemplateSmallMultiplesOptions']:
        return pulumi.get(self, "small_multiples_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateLineChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter
    def type(self) -> Optional['TemplateLineChartType']:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="xAxisDisplayOptions")
    def x_axis_display_options(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "x_axis_display_options")

    @property
    @pulumi.getter(name="xAxisLabelOptions")
    def x_axis_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "x_axis_label_options")


@pulumi.output_type
class TemplateLineChartDefaultSeriesSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "lineStyleSettings":
            suggest = "line_style_settings"
        elif key == "markerStyleSettings":
            suggest = "marker_style_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLineChartDefaultSeriesSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLineChartDefaultSeriesSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLineChartDefaultSeriesSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: Optional['TemplateAxisBinding'] = None,
                 line_style_settings: Optional['outputs.TemplateLineChartLineStyleSettings'] = None,
                 marker_style_settings: Optional['outputs.TemplateLineChartMarkerStyleSettings'] = None):
        TemplateLineChartDefaultSeriesSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            line_style_settings=line_style_settings,
            marker_style_settings=marker_style_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: Optional['TemplateAxisBinding'] = None,
             line_style_settings: Optional['outputs.TemplateLineChartLineStyleSettings'] = None,
             marker_style_settings: Optional['outputs.TemplateLineChartMarkerStyleSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_binding is not None:
            _setter("axis_binding", axis_binding)
        if line_style_settings is not None:
            _setter("line_style_settings", line_style_settings)
        if marker_style_settings is not None:
            _setter("marker_style_settings", marker_style_settings)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> Optional['TemplateAxisBinding']:
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="lineStyleSettings")
    def line_style_settings(self) -> Optional['outputs.TemplateLineChartLineStyleSettings']:
        return pulumi.get(self, "line_style_settings")

    @property
    @pulumi.getter(name="markerStyleSettings")
    def marker_style_settings(self) -> Optional['outputs.TemplateLineChartMarkerStyleSettings']:
        return pulumi.get(self, "marker_style_settings")


@pulumi.output_type
class TemplateLineChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineChartAggregatedFieldWells":
            suggest = "line_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLineChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLineChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLineChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_chart_aggregated_field_wells: Optional['outputs.TemplateLineChartAggregatedFieldWells'] = None):
        TemplateLineChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            line_chart_aggregated_field_wells=line_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             line_chart_aggregated_field_wells: Optional['outputs.TemplateLineChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if line_chart_aggregated_field_wells is not None:
            _setter("line_chart_aggregated_field_wells", line_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="lineChartAggregatedFieldWells")
    def line_chart_aggregated_field_wells(self) -> Optional['outputs.TemplateLineChartAggregatedFieldWells']:
        return pulumi.get(self, "line_chart_aggregated_field_wells")


@pulumi.output_type
class TemplateLineChartLineStyleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineInterpolation":
            suggest = "line_interpolation"
        elif key == "lineStyle":
            suggest = "line_style"
        elif key == "lineVisibility":
            suggest = "line_visibility"
        elif key == "lineWidth":
            suggest = "line_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLineChartLineStyleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLineChartLineStyleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLineChartLineStyleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_interpolation: Optional['TemplateLineInterpolation'] = None,
                 line_style: Optional['TemplateLineChartLineStyle'] = None,
                 line_visibility: Optional['TemplateVisibility'] = None,
                 line_width: Optional[str] = None):
        """
        :param str line_width: String based length that is composed of value and unit in px
        """
        TemplateLineChartLineStyleSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            line_interpolation=line_interpolation,
            line_style=line_style,
            line_visibility=line_visibility,
            line_width=line_width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             line_interpolation: Optional['TemplateLineInterpolation'] = None,
             line_style: Optional['TemplateLineChartLineStyle'] = None,
             line_visibility: Optional['TemplateVisibility'] = None,
             line_width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if line_interpolation is not None:
            _setter("line_interpolation", line_interpolation)
        if line_style is not None:
            _setter("line_style", line_style)
        if line_visibility is not None:
            _setter("line_visibility", line_visibility)
        if line_width is not None:
            _setter("line_width", line_width)

    @property
    @pulumi.getter(name="lineInterpolation")
    def line_interpolation(self) -> Optional['TemplateLineInterpolation']:
        return pulumi.get(self, "line_interpolation")

    @property
    @pulumi.getter(name="lineStyle")
    def line_style(self) -> Optional['TemplateLineChartLineStyle']:
        return pulumi.get(self, "line_style")

    @property
    @pulumi.getter(name="lineVisibility")
    def line_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "line_visibility")

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "line_width")


@pulumi.output_type
class TemplateLineChartMarkerStyleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "markerColor":
            suggest = "marker_color"
        elif key == "markerShape":
            suggest = "marker_shape"
        elif key == "markerSize":
            suggest = "marker_size"
        elif key == "markerVisibility":
            suggest = "marker_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLineChartMarkerStyleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLineChartMarkerStyleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLineChartMarkerStyleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 marker_color: Optional[str] = None,
                 marker_shape: Optional['TemplateLineChartMarkerShape'] = None,
                 marker_size: Optional[str] = None,
                 marker_visibility: Optional['TemplateVisibility'] = None):
        """
        :param str marker_size: String based length that is composed of value and unit in px
        """
        TemplateLineChartMarkerStyleSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            marker_color=marker_color,
            marker_shape=marker_shape,
            marker_size=marker_size,
            marker_visibility=marker_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             marker_color: Optional[str] = None,
             marker_shape: Optional['TemplateLineChartMarkerShape'] = None,
             marker_size: Optional[str] = None,
             marker_visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if marker_color is not None:
            _setter("marker_color", marker_color)
        if marker_shape is not None:
            _setter("marker_shape", marker_shape)
        if marker_size is not None:
            _setter("marker_size", marker_size)
        if marker_visibility is not None:
            _setter("marker_visibility", marker_visibility)

    @property
    @pulumi.getter(name="markerColor")
    def marker_color(self) -> Optional[str]:
        return pulumi.get(self, "marker_color")

    @property
    @pulumi.getter(name="markerShape")
    def marker_shape(self) -> Optional['TemplateLineChartMarkerShape']:
        return pulumi.get(self, "marker_shape")

    @property
    @pulumi.getter(name="markerSize")
    def marker_size(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "marker_size")

    @property
    @pulumi.getter(name="markerVisibility")
    def marker_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "marker_visibility")


@pulumi.output_type
class TemplateLineChartSeriesSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineStyleSettings":
            suggest = "line_style_settings"
        elif key == "markerStyleSettings":
            suggest = "marker_style_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLineChartSeriesSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLineChartSeriesSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLineChartSeriesSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_style_settings: Optional['outputs.TemplateLineChartLineStyleSettings'] = None,
                 marker_style_settings: Optional['outputs.TemplateLineChartMarkerStyleSettings'] = None):
        TemplateLineChartSeriesSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            line_style_settings=line_style_settings,
            marker_style_settings=marker_style_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             line_style_settings: Optional['outputs.TemplateLineChartLineStyleSettings'] = None,
             marker_style_settings: Optional['outputs.TemplateLineChartMarkerStyleSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if line_style_settings is not None:
            _setter("line_style_settings", line_style_settings)
        if marker_style_settings is not None:
            _setter("marker_style_settings", marker_style_settings)

    @property
    @pulumi.getter(name="lineStyleSettings")
    def line_style_settings(self) -> Optional['outputs.TemplateLineChartLineStyleSettings']:
        return pulumi.get(self, "line_style_settings")

    @property
    @pulumi.getter(name="markerStyleSettings")
    def marker_style_settings(self) -> Optional['outputs.TemplateLineChartMarkerStyleSettings']:
        return pulumi.get(self, "marker_style_settings")


@pulumi.output_type
class TemplateLineChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimitConfiguration":
            suggest = "category_items_limit_configuration"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimitConfiguration":
            suggest = "color_items_limit_configuration"
        elif key == "smallMultiplesLimitConfiguration":
            suggest = "small_multiples_limit_configuration"
        elif key == "smallMultiplesSort":
            suggest = "small_multiples_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLineChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLineChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLineChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
                 color_items_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 small_multiples_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 small_multiples_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateLineChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit_configuration=category_items_limit_configuration,
            category_sort=category_sort,
            color_items_limit_configuration=color_items_limit_configuration,
            small_multiples_limit_configuration=small_multiples_limit_configuration,
            small_multiples_sort=small_multiples_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             color_items_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             small_multiples_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             small_multiples_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit_configuration is not None:
            _setter("category_items_limit_configuration", category_items_limit_configuration)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit_configuration is not None:
            _setter("color_items_limit_configuration", color_items_limit_configuration)
        if small_multiples_limit_configuration is not None:
            _setter("small_multiples_limit_configuration", small_multiples_limit_configuration)
        if small_multiples_sort is not None:
            _setter("small_multiples_sort", small_multiples_sort)

    @property
    @pulumi.getter(name="categoryItemsLimitConfiguration")
    def category_items_limit_configuration(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit_configuration")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimitConfiguration")
    def color_items_limit_configuration(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesLimitConfiguration")
    def small_multiples_limit_configuration(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "small_multiples_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesSort")
    def small_multiples_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "small_multiples_sort")


@pulumi.output_type
class TemplateLineChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLineChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLineChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLineChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateLineChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateLineChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateLineChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateLineChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateLineSeriesAxisDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisOptions":
            suggest = "axis_options"
        elif key == "missingDataConfigurations":
            suggest = "missing_data_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLineSeriesAxisDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLineSeriesAxisDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLineSeriesAxisDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 missing_data_configurations: Optional[Sequence['outputs.TemplateMissingDataConfiguration']] = None):
        TemplateLineSeriesAxisDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_options=axis_options,
            missing_data_configurations=missing_data_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             missing_data_configurations: Optional[Sequence['outputs.TemplateMissingDataConfiguration']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_options is not None:
            _setter("axis_options", axis_options)
        if missing_data_configurations is not None:
            _setter("missing_data_configurations", missing_data_configurations)

    @property
    @pulumi.getter(name="axisOptions")
    def axis_options(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "axis_options")

    @property
    @pulumi.getter(name="missingDataConfigurations")
    def missing_data_configurations(self) -> Optional[Sequence['outputs.TemplateMissingDataConfiguration']]:
        return pulumi.get(self, "missing_data_configurations")


@pulumi.output_type
class TemplateListControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "searchOptions":
            suggest = "search_options"
        elif key == "selectAllOptions":
            suggest = "select_all_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateListControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateListControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateListControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
                 search_options: Optional['outputs.TemplateListControlSearchOptions'] = None,
                 select_all_options: Optional['outputs.TemplateListControlSelectAllOptions'] = None,
                 title_options: Optional['outputs.TemplateLabelOptions'] = None):
        TemplateListControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            search_options=search_options,
            select_all_options=select_all_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
             search_options: Optional['outputs.TemplateListControlSearchOptions'] = None,
             select_all_options: Optional['outputs.TemplateListControlSelectAllOptions'] = None,
             title_options: Optional['outputs.TemplateLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if search_options is not None:
            _setter("search_options", search_options)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.TemplateSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="searchOptions")
    def search_options(self) -> Optional['outputs.TemplateListControlSearchOptions']:
        return pulumi.get(self, "search_options")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['outputs.TemplateListControlSelectAllOptions']:
        return pulumi.get(self, "select_all_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.TemplateLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class TemplateListControlSearchOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateListControlSearchOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateListControlSelectAllOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateListControlSelectAllOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateLoadingAnimation(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateLoadingAnimation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateLocalNavigationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetSheetId":
            suggest = "target_sheet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLocalNavigationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLocalNavigationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLocalNavigationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_sheet_id: str):
        TemplateLocalNavigationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_sheet_id=target_sheet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_sheet_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target_sheet_id", target_sheet_id)

    @property
    @pulumi.getter(name="targetSheetId")
    def target_sheet_id(self) -> str:
        return pulumi.get(self, "target_sheet_id")


@pulumi.output_type
class TemplateLongFormatText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "plainText":
            suggest = "plain_text"
        elif key == "richText":
            suggest = "rich_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateLongFormatText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateLongFormatText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateLongFormatText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 plain_text: Optional[str] = None,
                 rich_text: Optional[str] = None):
        TemplateLongFormatText._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            plain_text=plain_text,
            rich_text=rich_text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             plain_text: Optional[str] = None,
             rich_text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if plain_text is not None:
            _setter("plain_text", plain_text)
        if rich_text is not None:
            _setter("rich_text", rich_text)

    @property
    @pulumi.getter(name="plainText")
    def plain_text(self) -> Optional[str]:
        return pulumi.get(self, "plain_text")

    @property
    @pulumi.getter(name="richText")
    def rich_text(self) -> Optional[str]:
        return pulumi.get(self, "rich_text")


@pulumi.output_type
class TemplateMappedDataSetParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"
        elif key == "dataSetParameterName":
            suggest = "data_set_parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateMappedDataSetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateMappedDataSetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateMappedDataSetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_identifier: str,
                 data_set_parameter_name: str):
        TemplateMappedDataSetParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_identifier=data_set_identifier,
            data_set_parameter_name=data_set_parameter_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_identifier: str,
             data_set_parameter_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_identifier", data_set_identifier)
        _setter("data_set_parameter_name", data_set_parameter_name)

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> str:
        return pulumi.get(self, "data_set_identifier")

    @property
    @pulumi.getter(name="dataSetParameterName")
    def data_set_parameter_name(self) -> str:
        return pulumi.get(self, "data_set_parameter_name")


@pulumi.output_type
class TemplateMaximumLabelType(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateMaximumLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateMaximumMinimumComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateMaximumMinimumComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateMaximumMinimumComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateMaximumMinimumComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 type: 'TemplateMaximumMinimumComputationType',
                 name: Optional[str] = None,
                 time: Optional['outputs.TemplateDimensionField'] = None,
                 value: Optional['outputs.TemplateMeasureField'] = None):
        TemplateMaximumMinimumComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            type=type,
            name=name,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             type: 'TemplateMaximumMinimumComputationType',
             name: Optional[str] = None,
             time: Optional['outputs.TemplateDimensionField'] = None,
             value: Optional['outputs.TemplateMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        _setter("type", type)
        if name is not None:
            _setter("name", name)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def type(self) -> 'TemplateMaximumMinimumComputationType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.TemplateDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.TemplateMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "calculatedMeasureField":
            suggest = "calculated_measure_field"
        elif key == "categoricalMeasureField":
            suggest = "categorical_measure_field"
        elif key == "dateMeasureField":
            suggest = "date_measure_field"
        elif key == "numericalMeasureField":
            suggest = "numerical_measure_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 calculated_measure_field: Optional['outputs.TemplateCalculatedMeasureField'] = None,
                 categorical_measure_field: Optional['outputs.TemplateCategoricalMeasureField'] = None,
                 date_measure_field: Optional['outputs.TemplateDateMeasureField'] = None,
                 numerical_measure_field: Optional['outputs.TemplateNumericalMeasureField'] = None):
        TemplateMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            calculated_measure_field=calculated_measure_field,
            categorical_measure_field=categorical_measure_field,
            date_measure_field=date_measure_field,
            numerical_measure_field=numerical_measure_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             calculated_measure_field: Optional['outputs.TemplateCalculatedMeasureField'] = None,
             categorical_measure_field: Optional['outputs.TemplateCategoricalMeasureField'] = None,
             date_measure_field: Optional['outputs.TemplateDateMeasureField'] = None,
             numerical_measure_field: Optional['outputs.TemplateNumericalMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if calculated_measure_field is not None:
            _setter("calculated_measure_field", calculated_measure_field)
        if categorical_measure_field is not None:
            _setter("categorical_measure_field", categorical_measure_field)
        if date_measure_field is not None:
            _setter("date_measure_field", date_measure_field)
        if numerical_measure_field is not None:
            _setter("numerical_measure_field", numerical_measure_field)

    @property
    @pulumi.getter(name="calculatedMeasureField")
    def calculated_measure_field(self) -> Optional['outputs.TemplateCalculatedMeasureField']:
        return pulumi.get(self, "calculated_measure_field")

    @property
    @pulumi.getter(name="categoricalMeasureField")
    def categorical_measure_field(self) -> Optional['outputs.TemplateCategoricalMeasureField']:
        return pulumi.get(self, "categorical_measure_field")

    @property
    @pulumi.getter(name="dateMeasureField")
    def date_measure_field(self) -> Optional['outputs.TemplateDateMeasureField']:
        return pulumi.get(self, "date_measure_field")

    @property
    @pulumi.getter(name="numericalMeasureField")
    def numerical_measure_field(self) -> Optional['outputs.TemplateNumericalMeasureField']:
        return pulumi.get(self, "numerical_measure_field")


@pulumi.output_type
class TemplateMetricComparisonComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "fromValue":
            suggest = "from_value"
        elif key == "targetValue":
            suggest = "target_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateMetricComparisonComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateMetricComparisonComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateMetricComparisonComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 from_value: Optional['outputs.TemplateMeasureField'] = None,
                 name: Optional[str] = None,
                 target_value: Optional['outputs.TemplateMeasureField'] = None,
                 time: Optional['outputs.TemplateDimensionField'] = None):
        TemplateMetricComparisonComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            from_value=from_value,
            name=name,
            target_value=target_value,
            time=time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             from_value: Optional['outputs.TemplateMeasureField'] = None,
             name: Optional[str] = None,
             target_value: Optional['outputs.TemplateMeasureField'] = None,
             time: Optional['outputs.TemplateDimensionField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if from_value is not None:
            _setter("from_value", from_value)
        if name is not None:
            _setter("name", name)
        if target_value is not None:
            _setter("target_value", target_value)
        if time is not None:
            _setter("time", time)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional['outputs.TemplateMeasureField']:
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> Optional['outputs.TemplateMeasureField']:
        return pulumi.get(self, "target_value")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.TemplateDimensionField']:
        return pulumi.get(self, "time")


@pulumi.output_type
class TemplateMinimumLabelType(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateMinimumLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateMissingDataConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "treatmentOption":
            suggest = "treatment_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateMissingDataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateMissingDataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateMissingDataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 treatment_option: Optional['TemplateMissingDataTreatmentOption'] = None):
        TemplateMissingDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            treatment_option=treatment_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             treatment_option: Optional['TemplateMissingDataTreatmentOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if treatment_option is not None:
            _setter("treatment_option", treatment_option)

    @property
    @pulumi.getter(name="treatmentOption")
    def treatment_option(self) -> Optional['TemplateMissingDataTreatmentOption']:
        return pulumi.get(self, "treatment_option")


@pulumi.output_type
class TemplateNegativeValueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayMode":
            suggest = "display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNegativeValueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNegativeValueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNegativeValueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_mode: 'TemplateNegativeValueDisplayMode'):
        TemplateNegativeValueConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_mode=display_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_mode: 'TemplateNegativeValueDisplayMode',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("display_mode", display_mode)

    @property
    @pulumi.getter(name="displayMode")
    def display_mode(self) -> 'TemplateNegativeValueDisplayMode':
        return pulumi.get(self, "display_mode")


@pulumi.output_type
class TemplateNullValueFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nullString":
            suggest = "null_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNullValueFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNullValueFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNullValueFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 null_string: str):
        TemplateNullValueFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            null_string=null_string,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             null_string: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("null_string", null_string)

    @property
    @pulumi.getter(name="nullString")
    def null_string(self) -> str:
        return pulumi.get(self, "null_string")


@pulumi.output_type
class TemplateNumberDisplayFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlacesConfiguration":
            suggest = "decimal_places_configuration"
        elif key == "negativeValueConfiguration":
            suggest = "negative_value_configuration"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numberScale":
            suggest = "number_scale"
        elif key == "separatorConfiguration":
            suggest = "separator_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNumberDisplayFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNumberDisplayFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNumberDisplayFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places_configuration: Optional['outputs.TemplateDecimalPlacesConfiguration'] = None,
                 negative_value_configuration: Optional['outputs.TemplateNegativeValueConfiguration'] = None,
                 null_value_format_configuration: Optional['outputs.TemplateNullValueFormatConfiguration'] = None,
                 number_scale: Optional['TemplateNumberScale'] = None,
                 prefix: Optional[str] = None,
                 separator_configuration: Optional['outputs.TemplateNumericSeparatorConfiguration'] = None,
                 suffix: Optional[str] = None):
        TemplateNumberDisplayFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places_configuration=decimal_places_configuration,
            negative_value_configuration=negative_value_configuration,
            null_value_format_configuration=null_value_format_configuration,
            number_scale=number_scale,
            prefix=prefix,
            separator_configuration=separator_configuration,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places_configuration: Optional['outputs.TemplateDecimalPlacesConfiguration'] = None,
             negative_value_configuration: Optional['outputs.TemplateNegativeValueConfiguration'] = None,
             null_value_format_configuration: Optional['outputs.TemplateNullValueFormatConfiguration'] = None,
             number_scale: Optional['TemplateNumberScale'] = None,
             prefix: Optional[str] = None,
             separator_configuration: Optional['outputs.TemplateNumericSeparatorConfiguration'] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_places_configuration is not None:
            _setter("decimal_places_configuration", decimal_places_configuration)
        if negative_value_configuration is not None:
            _setter("negative_value_configuration", negative_value_configuration)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if number_scale is not None:
            _setter("number_scale", number_scale)
        if prefix is not None:
            _setter("prefix", prefix)
        if separator_configuration is not None:
            _setter("separator_configuration", separator_configuration)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter(name="decimalPlacesConfiguration")
    def decimal_places_configuration(self) -> Optional['outputs.TemplateDecimalPlacesConfiguration']:
        return pulumi.get(self, "decimal_places_configuration")

    @property
    @pulumi.getter(name="negativeValueConfiguration")
    def negative_value_configuration(self) -> Optional['outputs.TemplateNegativeValueConfiguration']:
        return pulumi.get(self, "negative_value_configuration")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.TemplateNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numberScale")
    def number_scale(self) -> Optional['TemplateNumberScale']:
        return pulumi.get(self, "number_scale")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="separatorConfiguration")
    def separator_configuration(self) -> Optional['outputs.TemplateNumericSeparatorConfiguration']:
        return pulumi.get(self, "separator_configuration")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class TemplateNumberFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNumberFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNumberFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNumberFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_configuration: Optional['outputs.TemplateNumericFormatConfiguration'] = None):
        TemplateNumberFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_configuration: Optional['outputs.TemplateNumericFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.TemplateNumericFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class TemplateNumericAxisOptions(dict):
    def __init__(__self__, *,
                 range: Optional['outputs.TemplateAxisDisplayRange'] = None,
                 scale: Optional['outputs.TemplateAxisScale'] = None):
        TemplateNumericAxisOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            range=range,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             range: Optional['outputs.TemplateAxisDisplayRange'] = None,
             scale: Optional['outputs.TemplateAxisScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if range is not None:
            _setter("range", range)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.TemplateAxisDisplayRange']:
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def scale(self) -> Optional['outputs.TemplateAxisScale']:
        return pulumi.get(self, "scale")


@pulumi.output_type
class TemplateNumericEqualityDrillDownFilter(dict):
    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 value: float):
        TemplateNumericEqualityDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("value", value)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateNumericEqualityFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "matchOperator":
            suggest = "match_operator"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNumericEqualityFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNumericEqualityFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNumericEqualityFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 filter_id: str,
                 match_operator: 'TemplateNumericEqualityMatchOperator',
                 null_option: 'TemplateFilterNullOption',
                 aggregation_function: Optional['outputs.TemplateAggregationFunction'] = None,
                 parameter_name: Optional[str] = None,
                 select_all_options: Optional['TemplateNumericFilterSelectAllOptions'] = None,
                 value: Optional[float] = None):
        TemplateNumericEqualityFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            match_operator=match_operator,
            null_option=null_option,
            aggregation_function=aggregation_function,
            parameter_name=parameter_name,
            select_all_options=select_all_options,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             filter_id: str,
             match_operator: 'TemplateNumericEqualityMatchOperator',
             null_option: 'TemplateFilterNullOption',
             aggregation_function: Optional['outputs.TemplateAggregationFunction'] = None,
             parameter_name: Optional[str] = None,
             select_all_options: Optional['TemplateNumericFilterSelectAllOptions'] = None,
             value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("match_operator", match_operator)
        _setter("null_option", null_option)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> 'TemplateNumericEqualityMatchOperator':
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'TemplateFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.TemplateAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['TemplateNumericFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateNumericFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currencyDisplayFormatConfiguration":
            suggest = "currency_display_format_configuration"
        elif key == "numberDisplayFormatConfiguration":
            suggest = "number_display_format_configuration"
        elif key == "percentageDisplayFormatConfiguration":
            suggest = "percentage_display_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNumericFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNumericFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNumericFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 currency_display_format_configuration: Optional['outputs.TemplateCurrencyDisplayFormatConfiguration'] = None,
                 number_display_format_configuration: Optional['outputs.TemplateNumberDisplayFormatConfiguration'] = None,
                 percentage_display_format_configuration: Optional['outputs.TemplatePercentageDisplayFormatConfiguration'] = None):
        TemplateNumericFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            currency_display_format_configuration=currency_display_format_configuration,
            number_display_format_configuration=number_display_format_configuration,
            percentage_display_format_configuration=percentage_display_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             currency_display_format_configuration: Optional['outputs.TemplateCurrencyDisplayFormatConfiguration'] = None,
             number_display_format_configuration: Optional['outputs.TemplateNumberDisplayFormatConfiguration'] = None,
             percentage_display_format_configuration: Optional['outputs.TemplatePercentageDisplayFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if currency_display_format_configuration is not None:
            _setter("currency_display_format_configuration", currency_display_format_configuration)
        if number_display_format_configuration is not None:
            _setter("number_display_format_configuration", number_display_format_configuration)
        if percentage_display_format_configuration is not None:
            _setter("percentage_display_format_configuration", percentage_display_format_configuration)

    @property
    @pulumi.getter(name="currencyDisplayFormatConfiguration")
    def currency_display_format_configuration(self) -> Optional['outputs.TemplateCurrencyDisplayFormatConfiguration']:
        return pulumi.get(self, "currency_display_format_configuration")

    @property
    @pulumi.getter(name="numberDisplayFormatConfiguration")
    def number_display_format_configuration(self) -> Optional['outputs.TemplateNumberDisplayFormatConfiguration']:
        return pulumi.get(self, "number_display_format_configuration")

    @property
    @pulumi.getter(name="percentageDisplayFormatConfiguration")
    def percentage_display_format_configuration(self) -> Optional['outputs.TemplatePercentageDisplayFormatConfiguration']:
        return pulumi.get(self, "percentage_display_format_configuration")


@pulumi.output_type
class TemplateNumericRangeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "includeMaximum":
            suggest = "include_maximum"
        elif key == "includeMinimum":
            suggest = "include_minimum"
        elif key == "rangeMaximum":
            suggest = "range_maximum"
        elif key == "rangeMinimum":
            suggest = "range_minimum"
        elif key == "selectAllOptions":
            suggest = "select_all_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNumericRangeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNumericRangeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNumericRangeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 filter_id: str,
                 null_option: 'TemplateFilterNullOption',
                 aggregation_function: Optional['outputs.TemplateAggregationFunction'] = None,
                 include_maximum: Optional[bool] = None,
                 include_minimum: Optional[bool] = None,
                 range_maximum: Optional['outputs.TemplateNumericRangeFilterValue'] = None,
                 range_minimum: Optional['outputs.TemplateNumericRangeFilterValue'] = None,
                 select_all_options: Optional['TemplateNumericFilterSelectAllOptions'] = None):
        TemplateNumericRangeFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            null_option=null_option,
            aggregation_function=aggregation_function,
            include_maximum=include_maximum,
            include_minimum=include_minimum,
            range_maximum=range_maximum,
            range_minimum=range_minimum,
            select_all_options=select_all_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             filter_id: str,
             null_option: 'TemplateFilterNullOption',
             aggregation_function: Optional['outputs.TemplateAggregationFunction'] = None,
             include_maximum: Optional[bool] = None,
             include_minimum: Optional[bool] = None,
             range_maximum: Optional['outputs.TemplateNumericRangeFilterValue'] = None,
             range_minimum: Optional['outputs.TemplateNumericRangeFilterValue'] = None,
             select_all_options: Optional['TemplateNumericFilterSelectAllOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("null_option", null_option)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if include_maximum is not None:
            _setter("include_maximum", include_maximum)
        if include_minimum is not None:
            _setter("include_minimum", include_minimum)
        if range_maximum is not None:
            _setter("range_maximum", range_maximum)
        if range_minimum is not None:
            _setter("range_minimum", range_minimum)
        if select_all_options is not None:
            _setter("select_all_options", select_all_options)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'TemplateFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.TemplateAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="includeMaximum")
    def include_maximum(self) -> Optional[bool]:
        return pulumi.get(self, "include_maximum")

    @property
    @pulumi.getter(name="includeMinimum")
    def include_minimum(self) -> Optional[bool]:
        return pulumi.get(self, "include_minimum")

    @property
    @pulumi.getter(name="rangeMaximum")
    def range_maximum(self) -> Optional['outputs.TemplateNumericRangeFilterValue']:
        return pulumi.get(self, "range_maximum")

    @property
    @pulumi.getter(name="rangeMinimum")
    def range_minimum(self) -> Optional['outputs.TemplateNumericRangeFilterValue']:
        return pulumi.get(self, "range_minimum")

    @property
    @pulumi.getter(name="selectAllOptions")
    def select_all_options(self) -> Optional['TemplateNumericFilterSelectAllOptions']:
        return pulumi.get(self, "select_all_options")


@pulumi.output_type
class TemplateNumericRangeFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticValue":
            suggest = "static_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNumericRangeFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNumericRangeFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNumericRangeFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 static_value: Optional[float] = None):
        TemplateNumericRangeFilterValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter=parameter,
            static_value=static_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter: Optional[str] = None,
             static_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if parameter is not None:
            _setter("parameter", parameter)
        if static_value is not None:
            _setter("static_value", static_value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter(name="staticValue")
    def static_value(self) -> Optional[float]:
        return pulumi.get(self, "static_value")


@pulumi.output_type
class TemplateNumericSeparatorConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalSeparator":
            suggest = "decimal_separator"
        elif key == "thousandsSeparator":
            suggest = "thousands_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNumericSeparatorConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNumericSeparatorConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNumericSeparatorConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_separator: Optional['TemplateNumericSeparatorSymbol'] = None,
                 thousands_separator: Optional['outputs.TemplateThousandSeparatorOptions'] = None):
        TemplateNumericSeparatorConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_separator=decimal_separator,
            thousands_separator=thousands_separator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_separator: Optional['TemplateNumericSeparatorSymbol'] = None,
             thousands_separator: Optional['outputs.TemplateThousandSeparatorOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_separator is not None:
            _setter("decimal_separator", decimal_separator)
        if thousands_separator is not None:
            _setter("thousands_separator", thousands_separator)

    @property
    @pulumi.getter(name="decimalSeparator")
    def decimal_separator(self) -> Optional['TemplateNumericSeparatorSymbol']:
        return pulumi.get(self, "decimal_separator")

    @property
    @pulumi.getter(name="thousandsSeparator")
    def thousands_separator(self) -> Optional['outputs.TemplateThousandSeparatorOptions']:
        return pulumi.get(self, "thousands_separator")


@pulumi.output_type
class TemplateNumericalAggregationFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "percentileAggregation":
            suggest = "percentile_aggregation"
        elif key == "simpleNumericalAggregation":
            suggest = "simple_numerical_aggregation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNumericalAggregationFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNumericalAggregationFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNumericalAggregationFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentile_aggregation: Optional['outputs.TemplatePercentileAggregation'] = None,
                 simple_numerical_aggregation: Optional['TemplateSimpleNumericalAggregationFunction'] = None):
        TemplateNumericalAggregationFunction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            percentile_aggregation=percentile_aggregation,
            simple_numerical_aggregation=simple_numerical_aggregation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             percentile_aggregation: Optional['outputs.TemplatePercentileAggregation'] = None,
             simple_numerical_aggregation: Optional['TemplateSimpleNumericalAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if percentile_aggregation is not None:
            _setter("percentile_aggregation", percentile_aggregation)
        if simple_numerical_aggregation is not None:
            _setter("simple_numerical_aggregation", simple_numerical_aggregation)

    @property
    @pulumi.getter(name="percentileAggregation")
    def percentile_aggregation(self) -> Optional['outputs.TemplatePercentileAggregation']:
        return pulumi.get(self, "percentile_aggregation")

    @property
    @pulumi.getter(name="simpleNumericalAggregation")
    def simple_numerical_aggregation(self) -> Optional['TemplateSimpleNumericalAggregationFunction']:
        return pulumi.get(self, "simple_numerical_aggregation")


@pulumi.output_type
class TemplateNumericalDimensionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "hierarchyId":
            suggest = "hierarchy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNumericalDimensionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNumericalDimensionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNumericalDimensionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 field_id: str,
                 format_configuration: Optional['outputs.TemplateNumberFormatConfiguration'] = None,
                 hierarchy_id: Optional[str] = None):
        TemplateNumericalDimensionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            format_configuration=format_configuration,
            hierarchy_id=hierarchy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             field_id: str,
             format_configuration: Optional['outputs.TemplateNumberFormatConfiguration'] = None,
             hierarchy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if hierarchy_id is not None:
            _setter("hierarchy_id", hierarchy_id)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.TemplateNumberFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> Optional[str]:
        return pulumi.get(self, "hierarchy_id")


@pulumi.output_type
class TemplateNumericalMeasureField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "aggregationFunction":
            suggest = "aggregation_function"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateNumericalMeasureField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateNumericalMeasureField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateNumericalMeasureField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 field_id: str,
                 aggregation_function: Optional['outputs.TemplateNumericalAggregationFunction'] = None,
                 format_configuration: Optional['outputs.TemplateNumberFormatConfiguration'] = None):
        TemplateNumericalMeasureField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            aggregation_function=aggregation_function,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             field_id: str,
             aggregation_function: Optional['outputs.TemplateNumericalAggregationFunction'] = None,
             format_configuration: Optional['outputs.TemplateNumberFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if aggregation_function is not None:
            _setter("aggregation_function", aggregation_function)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> Optional['outputs.TemplateNumericalAggregationFunction']:
        return pulumi.get(self, "aggregation_function")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.TemplateNumberFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class TemplatePaginationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageNumber":
            suggest = "page_number"
        elif key == "pageSize":
            suggest = "page_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePaginationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePaginationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePaginationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 page_number: float,
                 page_size: float):
        TemplatePaginationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            page_number=page_number,
            page_size=page_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             page_number: float,
             page_size: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("page_number", page_number)
        _setter("page_size", page_size)

    @property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> float:
        return pulumi.get(self, "page_number")

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> float:
        return pulumi.get(self, "page_size")


@pulumi.output_type
class TemplatePanelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "backgroundVisibility":
            suggest = "background_visibility"
        elif key == "borderColor":
            suggest = "border_color"
        elif key == "borderStyle":
            suggest = "border_style"
        elif key == "borderThickness":
            suggest = "border_thickness"
        elif key == "borderVisibility":
            suggest = "border_visibility"
        elif key == "gutterSpacing":
            suggest = "gutter_spacing"
        elif key == "gutterVisibility":
            suggest = "gutter_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePanelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePanelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePanelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[str] = None,
                 background_visibility: Optional['TemplateVisibility'] = None,
                 border_color: Optional[str] = None,
                 border_style: Optional['TemplatePanelBorderStyle'] = None,
                 border_thickness: Optional[str] = None,
                 border_visibility: Optional['TemplateVisibility'] = None,
                 gutter_spacing: Optional[str] = None,
                 gutter_visibility: Optional['TemplateVisibility'] = None,
                 title: Optional['outputs.TemplatePanelTitleOptions'] = None):
        """
        :param str border_thickness: String based length that is composed of value and unit in px
        :param str gutter_spacing: String based length that is composed of value and unit in px
        """
        TemplatePanelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            background_visibility=background_visibility,
            border_color=border_color,
            border_style=border_style,
            border_thickness=border_thickness,
            border_visibility=border_visibility,
            gutter_spacing=gutter_spacing,
            gutter_visibility=gutter_visibility,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional[str] = None,
             background_visibility: Optional['TemplateVisibility'] = None,
             border_color: Optional[str] = None,
             border_style: Optional['TemplatePanelBorderStyle'] = None,
             border_thickness: Optional[str] = None,
             border_visibility: Optional['TemplateVisibility'] = None,
             gutter_spacing: Optional[str] = None,
             gutter_visibility: Optional['TemplateVisibility'] = None,
             title: Optional['outputs.TemplatePanelTitleOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if background_visibility is not None:
            _setter("background_visibility", background_visibility)
        if border_color is not None:
            _setter("border_color", border_color)
        if border_style is not None:
            _setter("border_style", border_style)
        if border_thickness is not None:
            _setter("border_thickness", border_thickness)
        if border_visibility is not None:
            _setter("border_visibility", border_visibility)
        if gutter_spacing is not None:
            _setter("gutter_spacing", gutter_spacing)
        if gutter_visibility is not None:
            _setter("gutter_visibility", gutter_visibility)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="backgroundVisibility")
    def background_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "background_visibility")

    @property
    @pulumi.getter(name="borderColor")
    def border_color(self) -> Optional[str]:
        return pulumi.get(self, "border_color")

    @property
    @pulumi.getter(name="borderStyle")
    def border_style(self) -> Optional['TemplatePanelBorderStyle']:
        return pulumi.get(self, "border_style")

    @property
    @pulumi.getter(name="borderThickness")
    def border_thickness(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "border_thickness")

    @property
    @pulumi.getter(name="borderVisibility")
    def border_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "border_visibility")

    @property
    @pulumi.getter(name="gutterSpacing")
    def gutter_spacing(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "gutter_spacing")

    @property
    @pulumi.getter(name="gutterVisibility")
    def gutter_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "gutter_visibility")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplatePanelTitleOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplatePanelTitleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontConfiguration":
            suggest = "font_configuration"
        elif key == "horizontalTextAlignment":
            suggest = "horizontal_text_alignment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePanelTitleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePanelTitleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePanelTitleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
                 horizontal_text_alignment: Optional['TemplateHorizontalTextAlignment'] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplatePanelTitleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_configuration=font_configuration,
            horizontal_text_alignment=horizontal_text_alignment,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
             horizontal_text_alignment: Optional['TemplateHorizontalTextAlignment'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if horizontal_text_alignment is not None:
            _setter("horizontal_text_alignment", horizontal_text_alignment)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.TemplateFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter(name="horizontalTextAlignment")
    def horizontal_text_alignment(self) -> Optional['TemplateHorizontalTextAlignment']:
        return pulumi.get(self, "horizontal_text_alignment")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateParameterControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimePicker":
            suggest = "date_time_picker"
        elif key == "textArea":
            suggest = "text_area"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateParameterControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateParameterControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateParameterControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_picker: Optional['outputs.TemplateParameterDateTimePickerControl'] = None,
                 dropdown: Optional['outputs.TemplateParameterDropDownControl'] = None,
                 list: Optional['outputs.TemplateParameterListControl'] = None,
                 slider: Optional['outputs.TemplateParameterSliderControl'] = None,
                 text_area: Optional['outputs.TemplateParameterTextAreaControl'] = None,
                 text_field: Optional['outputs.TemplateParameterTextFieldControl'] = None):
        TemplateParameterControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_picker=date_time_picker,
            dropdown=dropdown,
            list=list,
            slider=slider,
            text_area=text_area,
            text_field=text_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_picker: Optional['outputs.TemplateParameterDateTimePickerControl'] = None,
             dropdown: Optional['outputs.TemplateParameterDropDownControl'] = None,
             list: Optional['outputs.TemplateParameterListControl'] = None,
             slider: Optional['outputs.TemplateParameterSliderControl'] = None,
             text_area: Optional['outputs.TemplateParameterTextAreaControl'] = None,
             text_field: Optional['outputs.TemplateParameterTextFieldControl'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_picker is not None:
            _setter("date_time_picker", date_time_picker)
        if dropdown is not None:
            _setter("dropdown", dropdown)
        if list is not None:
            _setter("list", list)
        if slider is not None:
            _setter("slider", slider)
        if text_area is not None:
            _setter("text_area", text_area)
        if text_field is not None:
            _setter("text_field", text_field)

    @property
    @pulumi.getter(name="dateTimePicker")
    def date_time_picker(self) -> Optional['outputs.TemplateParameterDateTimePickerControl']:
        return pulumi.get(self, "date_time_picker")

    @property
    @pulumi.getter
    def dropdown(self) -> Optional['outputs.TemplateParameterDropDownControl']:
        return pulumi.get(self, "dropdown")

    @property
    @pulumi.getter
    def list(self) -> Optional['outputs.TemplateParameterListControl']:
        return pulumi.get(self, "list")

    @property
    @pulumi.getter
    def slider(self) -> Optional['outputs.TemplateParameterSliderControl']:
        return pulumi.get(self, "slider")

    @property
    @pulumi.getter(name="textArea")
    def text_area(self) -> Optional['outputs.TemplateParameterTextAreaControl']:
        return pulumi.get(self, "text_area")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional['outputs.TemplateParameterTextFieldControl']:
        return pulumi.get(self, "text_field")


@pulumi.output_type
class TemplateParameterDateTimePickerControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateParameterDateTimePickerControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateParameterDateTimePickerControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateParameterDateTimePickerControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 display_options: Optional['outputs.TemplateDateTimePickerControlDisplayOptions'] = None):
        TemplateParameterDateTimePickerControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             display_options: Optional['outputs.TemplateDateTimePickerControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateDateTimePickerControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class TemplateParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeParameterDeclaration":
            suggest = "date_time_parameter_declaration"
        elif key == "decimalParameterDeclaration":
            suggest = "decimal_parameter_declaration"
        elif key == "integerParameterDeclaration":
            suggest = "integer_parameter_declaration"
        elif key == "stringParameterDeclaration":
            suggest = "string_parameter_declaration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_parameter_declaration: Optional['outputs.TemplateDateTimeParameterDeclaration'] = None,
                 decimal_parameter_declaration: Optional['outputs.TemplateDecimalParameterDeclaration'] = None,
                 integer_parameter_declaration: Optional['outputs.TemplateIntegerParameterDeclaration'] = None,
                 string_parameter_declaration: Optional['outputs.TemplateStringParameterDeclaration'] = None):
        TemplateParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_parameter_declaration=date_time_parameter_declaration,
            decimal_parameter_declaration=decimal_parameter_declaration,
            integer_parameter_declaration=integer_parameter_declaration,
            string_parameter_declaration=string_parameter_declaration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_parameter_declaration: Optional['outputs.TemplateDateTimeParameterDeclaration'] = None,
             decimal_parameter_declaration: Optional['outputs.TemplateDecimalParameterDeclaration'] = None,
             integer_parameter_declaration: Optional['outputs.TemplateIntegerParameterDeclaration'] = None,
             string_parameter_declaration: Optional['outputs.TemplateStringParameterDeclaration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_parameter_declaration is not None:
            _setter("date_time_parameter_declaration", date_time_parameter_declaration)
        if decimal_parameter_declaration is not None:
            _setter("decimal_parameter_declaration", decimal_parameter_declaration)
        if integer_parameter_declaration is not None:
            _setter("integer_parameter_declaration", integer_parameter_declaration)
        if string_parameter_declaration is not None:
            _setter("string_parameter_declaration", string_parameter_declaration)

    @property
    @pulumi.getter(name="dateTimeParameterDeclaration")
    def date_time_parameter_declaration(self) -> Optional['outputs.TemplateDateTimeParameterDeclaration']:
        return pulumi.get(self, "date_time_parameter_declaration")

    @property
    @pulumi.getter(name="decimalParameterDeclaration")
    def decimal_parameter_declaration(self) -> Optional['outputs.TemplateDecimalParameterDeclaration']:
        return pulumi.get(self, "decimal_parameter_declaration")

    @property
    @pulumi.getter(name="integerParameterDeclaration")
    def integer_parameter_declaration(self) -> Optional['outputs.TemplateIntegerParameterDeclaration']:
        return pulumi.get(self, "integer_parameter_declaration")

    @property
    @pulumi.getter(name="stringParameterDeclaration")
    def string_parameter_declaration(self) -> Optional['outputs.TemplateStringParameterDeclaration']:
        return pulumi.get(self, "string_parameter_declaration")


@pulumi.output_type
class TemplateParameterDropDownControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateParameterDropDownControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateParameterDropDownControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateParameterDropDownControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.TemplateCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.TemplateDropDownControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.TemplateParameterSelectableValues'] = None,
                 type: Optional['TemplateSheetControlListType'] = None):
        TemplateParameterDropDownControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             cascading_control_configuration: Optional['outputs.TemplateCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.TemplateDropDownControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.TemplateParameterSelectableValues'] = None,
             type: Optional['TemplateSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.TemplateCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateDropDownControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.TemplateParameterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['TemplateSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class TemplateParameterListControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "cascadingControlConfiguration":
            suggest = "cascading_control_configuration"
        elif key == "displayOptions":
            suggest = "display_options"
        elif key == "selectableValues":
            suggest = "selectable_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateParameterListControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateParameterListControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateParameterListControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 cascading_control_configuration: Optional['outputs.TemplateCascadingControlConfiguration'] = None,
                 display_options: Optional['outputs.TemplateListControlDisplayOptions'] = None,
                 selectable_values: Optional['outputs.TemplateParameterSelectableValues'] = None,
                 type: Optional['TemplateSheetControlListType'] = None):
        TemplateParameterListControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            cascading_control_configuration=cascading_control_configuration,
            display_options=display_options,
            selectable_values=selectable_values,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             cascading_control_configuration: Optional['outputs.TemplateCascadingControlConfiguration'] = None,
             display_options: Optional['outputs.TemplateListControlDisplayOptions'] = None,
             selectable_values: Optional['outputs.TemplateParameterSelectableValues'] = None,
             type: Optional['TemplateSheetControlListType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if cascading_control_configuration is not None:
            _setter("cascading_control_configuration", cascading_control_configuration)
        if display_options is not None:
            _setter("display_options", display_options)
        if selectable_values is not None:
            _setter("selectable_values", selectable_values)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="cascadingControlConfiguration")
    def cascading_control_configuration(self) -> Optional['outputs.TemplateCascadingControlConfiguration']:
        return pulumi.get(self, "cascading_control_configuration")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateListControlDisplayOptions']:
        return pulumi.get(self, "display_options")

    @property
    @pulumi.getter(name="selectableValues")
    def selectable_values(self) -> Optional['outputs.TemplateParameterSelectableValues']:
        return pulumi.get(self, "selectable_values")

    @property
    @pulumi.getter
    def type(self) -> Optional['TemplateSheetControlListType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class TemplateParameterSelectableValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkToDataSetColumn":
            suggest = "link_to_data_set_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateParameterSelectableValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateParameterSelectableValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateParameterSelectableValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 link_to_data_set_column: Optional['outputs.TemplateColumnIdentifier'] = None,
                 values: Optional[Sequence[str]] = None):
        TemplateParameterSelectableValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            link_to_data_set_column=link_to_data_set_column,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             link_to_data_set_column: Optional['outputs.TemplateColumnIdentifier'] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if link_to_data_set_column is not None:
            _setter("link_to_data_set_column", link_to_data_set_column)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="linkToDataSetColumn")
    def link_to_data_set_column(self) -> Optional['outputs.TemplateColumnIdentifier']:
        return pulumi.get(self, "link_to_data_set_column")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateParameterSliderControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumValue":
            suggest = "maximum_value"
        elif key == "minimumValue":
            suggest = "minimum_value"
        elif key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "stepSize":
            suggest = "step_size"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateParameterSliderControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateParameterSliderControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateParameterSliderControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_value: float,
                 minimum_value: float,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 step_size: float,
                 title: str,
                 display_options: Optional['outputs.TemplateSliderControlDisplayOptions'] = None):
        TemplateParameterSliderControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_value=maximum_value,
            minimum_value=minimum_value,
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            step_size=step_size,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_value: float,
             minimum_value: float,
             parameter_control_id: str,
             source_parameter_name: str,
             step_size: float,
             title: str,
             display_options: Optional['outputs.TemplateSliderControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("maximum_value", maximum_value)
        _setter("minimum_value", minimum_value)
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("step_size", step_size)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="maximumValue")
    def maximum_value(self) -> float:
        return pulumi.get(self, "maximum_value")

    @property
    @pulumi.getter(name="minimumValue")
    def minimum_value(self) -> float:
        return pulumi.get(self, "minimum_value")

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> float:
        return pulumi.get(self, "step_size")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateSliderControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class TemplateParameterTextAreaControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateParameterTextAreaControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateParameterTextAreaControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateParameterTextAreaControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 delimiter: Optional[str] = None,
                 display_options: Optional['outputs.TemplateTextAreaControlDisplayOptions'] = None):
        TemplateParameterTextAreaControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            delimiter=delimiter,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             delimiter: Optional[str] = None,
             display_options: Optional['outputs.TemplateTextAreaControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateTextAreaControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class TemplateParameterTextFieldControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterControlId":
            suggest = "parameter_control_id"
        elif key == "sourceParameterName":
            suggest = "source_parameter_name"
        elif key == "displayOptions":
            suggest = "display_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateParameterTextFieldControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateParameterTextFieldControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateParameterTextFieldControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_control_id: str,
                 source_parameter_name: str,
                 title: str,
                 display_options: Optional['outputs.TemplateTextFieldControlDisplayOptions'] = None):
        TemplateParameterTextFieldControl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter_control_id=parameter_control_id,
            source_parameter_name=source_parameter_name,
            title=title,
            display_options=display_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter_control_id: str,
             source_parameter_name: str,
             title: str,
             display_options: Optional['outputs.TemplateTextFieldControlDisplayOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parameter_control_id", parameter_control_id)
        _setter("source_parameter_name", source_parameter_name)
        _setter("title", title)
        if display_options is not None:
            _setter("display_options", display_options)

    @property
    @pulumi.getter(name="parameterControlId")
    def parameter_control_id(self) -> str:
        return pulumi.get(self, "parameter_control_id")

    @property
    @pulumi.getter(name="sourceParameterName")
    def source_parameter_name(self) -> str:
        return pulumi.get(self, "source_parameter_name")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="displayOptions")
    def display_options(self) -> Optional['outputs.TemplateTextFieldControlDisplayOptions']:
        return pulumi.get(self, "display_options")


@pulumi.output_type
class TemplatePercentVisibleRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePercentVisibleRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePercentVisibleRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePercentVisibleRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[float] = None,
                 to: Optional[float] = None):
        TemplatePercentVisibleRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[float] = None,
             to: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[float]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[float]:
        return pulumi.get(self, "to")


@pulumi.output_type
class TemplatePercentageDisplayFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalPlacesConfiguration":
            suggest = "decimal_places_configuration"
        elif key == "negativeValueConfiguration":
            suggest = "negative_value_configuration"
        elif key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "separatorConfiguration":
            suggest = "separator_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePercentageDisplayFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePercentageDisplayFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePercentageDisplayFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_places_configuration: Optional['outputs.TemplateDecimalPlacesConfiguration'] = None,
                 negative_value_configuration: Optional['outputs.TemplateNegativeValueConfiguration'] = None,
                 null_value_format_configuration: Optional['outputs.TemplateNullValueFormatConfiguration'] = None,
                 prefix: Optional[str] = None,
                 separator_configuration: Optional['outputs.TemplateNumericSeparatorConfiguration'] = None,
                 suffix: Optional[str] = None):
        TemplatePercentageDisplayFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decimal_places_configuration=decimal_places_configuration,
            negative_value_configuration=negative_value_configuration,
            null_value_format_configuration=null_value_format_configuration,
            prefix=prefix,
            separator_configuration=separator_configuration,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decimal_places_configuration: Optional['outputs.TemplateDecimalPlacesConfiguration'] = None,
             negative_value_configuration: Optional['outputs.TemplateNegativeValueConfiguration'] = None,
             null_value_format_configuration: Optional['outputs.TemplateNullValueFormatConfiguration'] = None,
             prefix: Optional[str] = None,
             separator_configuration: Optional['outputs.TemplateNumericSeparatorConfiguration'] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decimal_places_configuration is not None:
            _setter("decimal_places_configuration", decimal_places_configuration)
        if negative_value_configuration is not None:
            _setter("negative_value_configuration", negative_value_configuration)
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if prefix is not None:
            _setter("prefix", prefix)
        if separator_configuration is not None:
            _setter("separator_configuration", separator_configuration)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter(name="decimalPlacesConfiguration")
    def decimal_places_configuration(self) -> Optional['outputs.TemplateDecimalPlacesConfiguration']:
        return pulumi.get(self, "decimal_places_configuration")

    @property
    @pulumi.getter(name="negativeValueConfiguration")
    def negative_value_configuration(self) -> Optional['outputs.TemplateNegativeValueConfiguration']:
        return pulumi.get(self, "negative_value_configuration")

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.TemplateNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="separatorConfiguration")
    def separator_configuration(self) -> Optional['outputs.TemplateNumericSeparatorConfiguration']:
        return pulumi.get(self, "separator_configuration")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class TemplatePercentileAggregation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "percentileValue":
            suggest = "percentile_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePercentileAggregation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePercentileAggregation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePercentileAggregation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentile_value: Optional[float] = None):
        TemplatePercentileAggregation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            percentile_value=percentile_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             percentile_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if percentile_value is not None:
            _setter("percentile_value", percentile_value)

    @property
    @pulumi.getter(name="percentileValue")
    def percentile_value(self) -> Optional[float]:
        return pulumi.get(self, "percentile_value")


@pulumi.output_type
class TemplatePeriodOverPeriodComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePeriodOverPeriodComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePeriodOverPeriodComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePeriodOverPeriodComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 time: Optional['outputs.TemplateDimensionField'] = None,
                 value: Optional['outputs.TemplateMeasureField'] = None):
        TemplatePeriodOverPeriodComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             time: Optional['outputs.TemplateDimensionField'] = None,
             value: Optional['outputs.TemplateMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.TemplateDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.TemplateMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplatePeriodToDateComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "periodTimeGranularity":
            suggest = "period_time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePeriodToDateComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePeriodToDateComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePeriodToDateComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 period_time_granularity: Optional['TemplateTimeGranularity'] = None,
                 time: Optional['outputs.TemplateDimensionField'] = None,
                 value: Optional['outputs.TemplateMeasureField'] = None):
        TemplatePeriodToDateComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            period_time_granularity=period_time_granularity,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             period_time_granularity: Optional['TemplateTimeGranularity'] = None,
             time: Optional['outputs.TemplateDimensionField'] = None,
             value: Optional['outputs.TemplateMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if period_time_granularity is not None:
            _setter("period_time_granularity", period_time_granularity)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="periodTimeGranularity")
    def period_time_granularity(self) -> Optional['TemplateTimeGranularity']:
        return pulumi.get(self, "period_time_granularity")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.TemplateDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.TemplateMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplatePieChartAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "smallMultiples":
            suggest = "small_multiples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePieChartAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePieChartAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePieChartAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 small_multiples: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplatePieChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            small_multiples=small_multiples,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             small_multiples: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if small_multiples is not None:
            _setter("small_multiples", small_multiples)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="smallMultiples")
    def small_multiples(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "small_multiples")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplatePieChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "contributionAnalysisDefaults":
            suggest = "contribution_analysis_defaults"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "donutOptions":
            suggest = "donut_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "smallMultiplesOptions":
            suggest = "small_multiples_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "valueLabelOptions":
            suggest = "value_label_options"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePieChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePieChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePieChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 contribution_analysis_defaults: Optional[Sequence['outputs.TemplateContributionAnalysisDefault']] = None,
                 data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 donut_options: Optional['outputs.TemplateDonutOptions'] = None,
                 field_wells: Optional['outputs.TemplatePieChartFieldWells'] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 small_multiples_options: Optional['outputs.TemplateSmallMultiplesOptions'] = None,
                 sort_configuration: Optional['outputs.TemplatePieChartSortConfiguration'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
                 value_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None):
        TemplatePieChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_options=category_label_options,
            contribution_analysis_defaults=contribution_analysis_defaults,
            data_labels=data_labels,
            donut_options=donut_options,
            field_wells=field_wells,
            legend=legend,
            small_multiples_options=small_multiples_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
            value_label_options=value_label_options,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             contribution_analysis_defaults: Optional[Sequence['outputs.TemplateContributionAnalysisDefault']] = None,
             data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             donut_options: Optional['outputs.TemplateDonutOptions'] = None,
             field_wells: Optional['outputs.TemplatePieChartFieldWells'] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             small_multiples_options: Optional['outputs.TemplateSmallMultiplesOptions'] = None,
             sort_configuration: Optional['outputs.TemplatePieChartSortConfiguration'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             value_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if contribution_analysis_defaults is not None:
            _setter("contribution_analysis_defaults", contribution_analysis_defaults)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if donut_options is not None:
            _setter("donut_options", donut_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if small_multiples_options is not None:
            _setter("small_multiples_options", small_multiples_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if value_label_options is not None:
            _setter("value_label_options", value_label_options)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="contributionAnalysisDefaults")
    def contribution_analysis_defaults(self) -> Optional[Sequence['outputs.TemplateContributionAnalysisDefault']]:
        return pulumi.get(self, "contribution_analysis_defaults")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="donutOptions")
    def donut_options(self) -> Optional['outputs.TemplateDonutOptions']:
        return pulumi.get(self, "donut_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplatePieChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="smallMultiplesOptions")
    def small_multiples_options(self) -> Optional['outputs.TemplateSmallMultiplesOptions']:
        return pulumi.get(self, "small_multiples_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplatePieChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="valueLabelOptions")
    def value_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "value_label_options")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class TemplatePieChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pieChartAggregatedFieldWells":
            suggest = "pie_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePieChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePieChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePieChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pie_chart_aggregated_field_wells: Optional['outputs.TemplatePieChartAggregatedFieldWells'] = None):
        TemplatePieChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pie_chart_aggregated_field_wells=pie_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pie_chart_aggregated_field_wells: Optional['outputs.TemplatePieChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pie_chart_aggregated_field_wells is not None:
            _setter("pie_chart_aggregated_field_wells", pie_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="pieChartAggregatedFieldWells")
    def pie_chart_aggregated_field_wells(self) -> Optional['outputs.TemplatePieChartAggregatedFieldWells']:
        return pulumi.get(self, "pie_chart_aggregated_field_wells")


@pulumi.output_type
class TemplatePieChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "smallMultiplesLimitConfiguration":
            suggest = "small_multiples_limit_configuration"
        elif key == "smallMultiplesSort":
            suggest = "small_multiples_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePieChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePieChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePieChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
                 small_multiples_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 small_multiples_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplatePieChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            small_multiples_limit_configuration=small_multiples_limit_configuration,
            small_multiples_sort=small_multiples_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             small_multiples_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             small_multiples_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if small_multiples_limit_configuration is not None:
            _setter("small_multiples_limit_configuration", small_multiples_limit_configuration)
        if small_multiples_sort is not None:
            _setter("small_multiples_sort", small_multiples_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="smallMultiplesLimitConfiguration")
    def small_multiples_limit_configuration(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "small_multiples_limit_configuration")

    @property
    @pulumi.getter(name="smallMultiplesSort")
    def small_multiples_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "small_multiples_sort")


@pulumi.output_type
class TemplatePieChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePieChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePieChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePieChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplatePieChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplatePieChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplatePieChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplatePieChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplatePivotFieldSortOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "sortBy":
            suggest = "sort_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotFieldSortOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotFieldSortOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotFieldSortOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 sort_by: 'outputs.TemplatePivotTableSortBy'):
        TemplatePivotFieldSortOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            sort_by=sort_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             sort_by: 'outputs.TemplatePivotTableSortBy',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        _setter("sort_by", sort_by)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="sortBy")
    def sort_by(self) -> 'outputs.TemplatePivotTableSortBy':
        return pulumi.get(self, "sort_by")


@pulumi.output_type
class TemplatePivotTableAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 columns: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 rows: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplatePivotTableAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            rows=rows,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             rows: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if columns is not None:
            _setter("columns", columns)
        if rows is not None:
            _setter("rows", rows)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def rows(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "rows")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplatePivotTableCellConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "textFormat":
            suggest = "text_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableCellConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableCellConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableCellConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 scope: Optional['outputs.TemplatePivotTableConditionalFormattingScope'] = None,
                 scopes: Optional[Sequence['outputs.TemplatePivotTableConditionalFormattingScope']] = None,
                 text_format: Optional['outputs.TemplateTextConditionalFormat'] = None):
        TemplatePivotTableCellConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            scope=scope,
            scopes=scopes,
            text_format=text_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             scope: Optional['outputs.TemplatePivotTableConditionalFormattingScope'] = None,
             scopes: Optional[Sequence['outputs.TemplatePivotTableConditionalFormattingScope']] = None,
             text_format: Optional['outputs.TemplateTextConditionalFormat'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if scope is not None:
            _setter("scope", scope)
        if scopes is not None:
            _setter("scopes", scopes)
        if text_format is not None:
            _setter("text_format", text_format)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.TemplatePivotTableConditionalFormattingScope']:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence['outputs.TemplatePivotTableConditionalFormattingScope']]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="textFormat")
    def text_format(self) -> Optional['outputs.TemplateTextConditionalFormat']:
        return pulumi.get(self, "text_format")


@pulumi.output_type
class TemplatePivotTableConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.TemplatePivotTableConditionalFormattingOption']] = None):
        TemplatePivotTableConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.TemplatePivotTableConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.TemplatePivotTableConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class TemplatePivotTableConditionalFormattingOption(dict):
    def __init__(__self__, *,
                 cell: Optional['outputs.TemplatePivotTableCellConditionalFormatting'] = None):
        TemplatePivotTableConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell=cell,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell: Optional['outputs.TemplatePivotTableCellConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell is not None:
            _setter("cell", cell)

    @property
    @pulumi.getter
    def cell(self) -> Optional['outputs.TemplatePivotTableCellConditionalFormatting']:
        return pulumi.get(self, "cell")


@pulumi.output_type
class TemplatePivotTableConditionalFormattingScope(dict):
    def __init__(__self__, *,
                 role: Optional['TemplatePivotTableConditionalFormattingScopeRole'] = None):
        TemplatePivotTableConditionalFormattingScope._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role: Optional['TemplatePivotTableConditionalFormattingScopeRole'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if role is not None:
            _setter("role", role)

    @property
    @pulumi.getter
    def role(self) -> Optional['TemplatePivotTableConditionalFormattingScopeRole']:
        return pulumi.get(self, "role")


@pulumi.output_type
class TemplatePivotTableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldOptions":
            suggest = "field_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "paginatedReportOptions":
            suggest = "paginated_report_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "tableOptions":
            suggest = "table_options"
        elif key == "totalOptions":
            suggest = "total_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_options: Optional['outputs.TemplatePivotTableFieldOptions'] = None,
                 field_wells: Optional['outputs.TemplatePivotTableFieldWells'] = None,
                 paginated_report_options: Optional['outputs.TemplatePivotTablePaginatedReportOptions'] = None,
                 sort_configuration: Optional['outputs.TemplatePivotTableSortConfiguration'] = None,
                 table_options: Optional['outputs.TemplatePivotTableOptions'] = None,
                 total_options: Optional['outputs.TemplatePivotTableTotalOptions'] = None):
        TemplatePivotTableConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_options=field_options,
            field_wells=field_wells,
            paginated_report_options=paginated_report_options,
            sort_configuration=sort_configuration,
            table_options=table_options,
            total_options=total_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_options: Optional['outputs.TemplatePivotTableFieldOptions'] = None,
             field_wells: Optional['outputs.TemplatePivotTableFieldWells'] = None,
             paginated_report_options: Optional['outputs.TemplatePivotTablePaginatedReportOptions'] = None,
             sort_configuration: Optional['outputs.TemplatePivotTableSortConfiguration'] = None,
             table_options: Optional['outputs.TemplatePivotTableOptions'] = None,
             total_options: Optional['outputs.TemplatePivotTableTotalOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_options is not None:
            _setter("field_options", field_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if paginated_report_options is not None:
            _setter("paginated_report_options", paginated_report_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if table_options is not None:
            _setter("table_options", table_options)
        if total_options is not None:
            _setter("total_options", total_options)

    @property
    @pulumi.getter(name="fieldOptions")
    def field_options(self) -> Optional['outputs.TemplatePivotTableFieldOptions']:
        return pulumi.get(self, "field_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplatePivotTableFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="paginatedReportOptions")
    def paginated_report_options(self) -> Optional['outputs.TemplatePivotTablePaginatedReportOptions']:
        return pulumi.get(self, "paginated_report_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplatePivotTableSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="tableOptions")
    def table_options(self) -> Optional['outputs.TemplatePivotTableOptions']:
        return pulumi.get(self, "table_options")

    @property
    @pulumi.getter(name="totalOptions")
    def total_options(self) -> Optional['outputs.TemplatePivotTableTotalOptions']:
        return pulumi.get(self, "total_options")


@pulumi.output_type
class TemplatePivotTableDataPathOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPathList":
            suggest = "data_path_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableDataPathOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableDataPathOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableDataPathOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_path_list: Sequence['outputs.TemplateDataPathValue'],
                 width: Optional[str] = None):
        """
        :param str width: String based length that is composed of value and unit in px
        """
        TemplatePivotTableDataPathOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_path_list=data_path_list,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_path_list: Sequence['outputs.TemplateDataPathValue'],
             width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_path_list", data_path_list)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter(name="dataPathList")
    def data_path_list(self) -> Sequence['outputs.TemplateDataPathValue']:
        return pulumi.get(self, "data_path_list")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class TemplatePivotTableFieldCollapseStateOption(dict):
    def __init__(__self__, *,
                 target: 'outputs.TemplatePivotTableFieldCollapseStateTarget',
                 state: Optional['TemplatePivotTableFieldCollapseState'] = None):
        TemplatePivotTableFieldCollapseStateOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: 'outputs.TemplatePivotTableFieldCollapseStateTarget',
             state: Optional['TemplatePivotTableFieldCollapseState'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def target(self) -> 'outputs.TemplatePivotTableFieldCollapseStateTarget':
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def state(self) -> Optional['TemplatePivotTableFieldCollapseState']:
        return pulumi.get(self, "state")


@pulumi.output_type
class TemplatePivotTableFieldCollapseStateTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldDataPathValues":
            suggest = "field_data_path_values"
        elif key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableFieldCollapseStateTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableFieldCollapseStateTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableFieldCollapseStateTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_data_path_values: Optional[Sequence['outputs.TemplateDataPathValue']] = None,
                 field_id: Optional[str] = None):
        TemplatePivotTableFieldCollapseStateTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_data_path_values=field_data_path_values,
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_data_path_values: Optional[Sequence['outputs.TemplateDataPathValue']] = None,
             field_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_data_path_values is not None:
            _setter("field_data_path_values", field_data_path_values)
        if field_id is not None:
            _setter("field_id", field_id)

    @property
    @pulumi.getter(name="fieldDataPathValues")
    def field_data_path_values(self) -> Optional[Sequence['outputs.TemplateDataPathValue']]:
        return pulumi.get(self, "field_data_path_values")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class TemplatePivotTableFieldOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "customLabel":
            suggest = "custom_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableFieldOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableFieldOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableFieldOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 custom_label: Optional[str] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplatePivotTableFieldOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            custom_label=custom_label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             custom_label: Optional[str] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplatePivotTableFieldOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collapseStateOptions":
            suggest = "collapse_state_options"
        elif key == "dataPathOptions":
            suggest = "data_path_options"
        elif key == "selectedFieldOptions":
            suggest = "selected_field_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableFieldOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableFieldOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableFieldOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collapse_state_options: Optional[Sequence['outputs.TemplatePivotTableFieldCollapseStateOption']] = None,
                 data_path_options: Optional[Sequence['outputs.TemplatePivotTableDataPathOption']] = None,
                 selected_field_options: Optional[Sequence['outputs.TemplatePivotTableFieldOption']] = None):
        TemplatePivotTableFieldOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collapse_state_options=collapse_state_options,
            data_path_options=data_path_options,
            selected_field_options=selected_field_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collapse_state_options: Optional[Sequence['outputs.TemplatePivotTableFieldCollapseStateOption']] = None,
             data_path_options: Optional[Sequence['outputs.TemplatePivotTableDataPathOption']] = None,
             selected_field_options: Optional[Sequence['outputs.TemplatePivotTableFieldOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if collapse_state_options is not None:
            _setter("collapse_state_options", collapse_state_options)
        if data_path_options is not None:
            _setter("data_path_options", data_path_options)
        if selected_field_options is not None:
            _setter("selected_field_options", selected_field_options)

    @property
    @pulumi.getter(name="collapseStateOptions")
    def collapse_state_options(self) -> Optional[Sequence['outputs.TemplatePivotTableFieldCollapseStateOption']]:
        return pulumi.get(self, "collapse_state_options")

    @property
    @pulumi.getter(name="dataPathOptions")
    def data_path_options(self) -> Optional[Sequence['outputs.TemplatePivotTableDataPathOption']]:
        return pulumi.get(self, "data_path_options")

    @property
    @pulumi.getter(name="selectedFieldOptions")
    def selected_field_options(self) -> Optional[Sequence['outputs.TemplatePivotTableFieldOption']]:
        return pulumi.get(self, "selected_field_options")


@pulumi.output_type
class TemplatePivotTableFieldSubtotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableFieldSubtotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableFieldSubtotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableFieldSubtotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: Optional[str] = None):
        TemplatePivotTableFieldSubtotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_id is not None:
            _setter("field_id", field_id)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        return pulumi.get(self, "field_id")


@pulumi.output_type
class TemplatePivotTableFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pivotTableAggregatedFieldWells":
            suggest = "pivot_table_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pivot_table_aggregated_field_wells: Optional['outputs.TemplatePivotTableAggregatedFieldWells'] = None):
        TemplatePivotTableFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pivot_table_aggregated_field_wells=pivot_table_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pivot_table_aggregated_field_wells: Optional['outputs.TemplatePivotTableAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pivot_table_aggregated_field_wells is not None:
            _setter("pivot_table_aggregated_field_wells", pivot_table_aggregated_field_wells)

    @property
    @pulumi.getter(name="pivotTableAggregatedFieldWells")
    def pivot_table_aggregated_field_wells(self) -> Optional['outputs.TemplatePivotTableAggregatedFieldWells']:
        return pulumi.get(self, "pivot_table_aggregated_field_wells")


@pulumi.output_type
class TemplatePivotTableOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellStyle":
            suggest = "cell_style"
        elif key == "collapsedRowDimensionsVisibility":
            suggest = "collapsed_row_dimensions_visibility"
        elif key == "columnHeaderStyle":
            suggest = "column_header_style"
        elif key == "columnNamesVisibility":
            suggest = "column_names_visibility"
        elif key == "defaultCellWidth":
            suggest = "default_cell_width"
        elif key == "metricPlacement":
            suggest = "metric_placement"
        elif key == "rowAlternateColorOptions":
            suggest = "row_alternate_color_options"
        elif key == "rowFieldNamesStyle":
            suggest = "row_field_names_style"
        elif key == "rowHeaderStyle":
            suggest = "row_header_style"
        elif key == "rowsLabelOptions":
            suggest = "rows_label_options"
        elif key == "rowsLayout":
            suggest = "rows_layout"
        elif key == "singleMetricVisibility":
            suggest = "single_metric_visibility"
        elif key == "toggleButtonsVisibility":
            suggest = "toggle_buttons_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
                 collapsed_row_dimensions_visibility: Optional['TemplateVisibility'] = None,
                 column_header_style: Optional['outputs.TemplateTableCellStyle'] = None,
                 column_names_visibility: Optional['TemplateVisibility'] = None,
                 default_cell_width: Optional[str] = None,
                 metric_placement: Optional['TemplatePivotTableMetricPlacement'] = None,
                 row_alternate_color_options: Optional['outputs.TemplateRowAlternateColorOptions'] = None,
                 row_field_names_style: Optional['outputs.TemplateTableCellStyle'] = None,
                 row_header_style: Optional['outputs.TemplateTableCellStyle'] = None,
                 rows_label_options: Optional['outputs.TemplatePivotTableRowsLabelOptions'] = None,
                 rows_layout: Optional['TemplatePivotTableRowsLayout'] = None,
                 single_metric_visibility: Optional['TemplateVisibility'] = None,
                 toggle_buttons_visibility: Optional['TemplateVisibility'] = None):
        """
        :param str default_cell_width: String based length that is composed of value and unit in px
        """
        TemplatePivotTableOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell_style=cell_style,
            collapsed_row_dimensions_visibility=collapsed_row_dimensions_visibility,
            column_header_style=column_header_style,
            column_names_visibility=column_names_visibility,
            default_cell_width=default_cell_width,
            metric_placement=metric_placement,
            row_alternate_color_options=row_alternate_color_options,
            row_field_names_style=row_field_names_style,
            row_header_style=row_header_style,
            rows_label_options=rows_label_options,
            rows_layout=rows_layout,
            single_metric_visibility=single_metric_visibility,
            toggle_buttons_visibility=toggle_buttons_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
             collapsed_row_dimensions_visibility: Optional['TemplateVisibility'] = None,
             column_header_style: Optional['outputs.TemplateTableCellStyle'] = None,
             column_names_visibility: Optional['TemplateVisibility'] = None,
             default_cell_width: Optional[str] = None,
             metric_placement: Optional['TemplatePivotTableMetricPlacement'] = None,
             row_alternate_color_options: Optional['outputs.TemplateRowAlternateColorOptions'] = None,
             row_field_names_style: Optional['outputs.TemplateTableCellStyle'] = None,
             row_header_style: Optional['outputs.TemplateTableCellStyle'] = None,
             rows_label_options: Optional['outputs.TemplatePivotTableRowsLabelOptions'] = None,
             rows_layout: Optional['TemplatePivotTableRowsLayout'] = None,
             single_metric_visibility: Optional['TemplateVisibility'] = None,
             toggle_buttons_visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell_style is not None:
            _setter("cell_style", cell_style)
        if collapsed_row_dimensions_visibility is not None:
            _setter("collapsed_row_dimensions_visibility", collapsed_row_dimensions_visibility)
        if column_header_style is not None:
            _setter("column_header_style", column_header_style)
        if column_names_visibility is not None:
            _setter("column_names_visibility", column_names_visibility)
        if default_cell_width is not None:
            _setter("default_cell_width", default_cell_width)
        if metric_placement is not None:
            _setter("metric_placement", metric_placement)
        if row_alternate_color_options is not None:
            _setter("row_alternate_color_options", row_alternate_color_options)
        if row_field_names_style is not None:
            _setter("row_field_names_style", row_field_names_style)
        if row_header_style is not None:
            _setter("row_header_style", row_header_style)
        if rows_label_options is not None:
            _setter("rows_label_options", rows_label_options)
        if rows_layout is not None:
            _setter("rows_layout", rows_layout)
        if single_metric_visibility is not None:
            _setter("single_metric_visibility", single_metric_visibility)
        if toggle_buttons_visibility is not None:
            _setter("toggle_buttons_visibility", toggle_buttons_visibility)

    @property
    @pulumi.getter(name="cellStyle")
    def cell_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "cell_style")

    @property
    @pulumi.getter(name="collapsedRowDimensionsVisibility")
    def collapsed_row_dimensions_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "collapsed_row_dimensions_visibility")

    @property
    @pulumi.getter(name="columnHeaderStyle")
    def column_header_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "column_header_style")

    @property
    @pulumi.getter(name="columnNamesVisibility")
    def column_names_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "column_names_visibility")

    @property
    @pulumi.getter(name="defaultCellWidth")
    def default_cell_width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "default_cell_width")

    @property
    @pulumi.getter(name="metricPlacement")
    def metric_placement(self) -> Optional['TemplatePivotTableMetricPlacement']:
        return pulumi.get(self, "metric_placement")

    @property
    @pulumi.getter(name="rowAlternateColorOptions")
    def row_alternate_color_options(self) -> Optional['outputs.TemplateRowAlternateColorOptions']:
        return pulumi.get(self, "row_alternate_color_options")

    @property
    @pulumi.getter(name="rowFieldNamesStyle")
    def row_field_names_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "row_field_names_style")

    @property
    @pulumi.getter(name="rowHeaderStyle")
    def row_header_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "row_header_style")

    @property
    @pulumi.getter(name="rowsLabelOptions")
    def rows_label_options(self) -> Optional['outputs.TemplatePivotTableRowsLabelOptions']:
        return pulumi.get(self, "rows_label_options")

    @property
    @pulumi.getter(name="rowsLayout")
    def rows_layout(self) -> Optional['TemplatePivotTableRowsLayout']:
        return pulumi.get(self, "rows_layout")

    @property
    @pulumi.getter(name="singleMetricVisibility")
    def single_metric_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "single_metric_visibility")

    @property
    @pulumi.getter(name="toggleButtonsVisibility")
    def toggle_buttons_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "toggle_buttons_visibility")


@pulumi.output_type
class TemplatePivotTablePaginatedReportOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overflowColumnHeaderVisibility":
            suggest = "overflow_column_header_visibility"
        elif key == "verticalOverflowVisibility":
            suggest = "vertical_overflow_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTablePaginatedReportOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTablePaginatedReportOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTablePaginatedReportOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 overflow_column_header_visibility: Optional['TemplateVisibility'] = None,
                 vertical_overflow_visibility: Optional['TemplateVisibility'] = None):
        TemplatePivotTablePaginatedReportOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            overflow_column_header_visibility=overflow_column_header_visibility,
            vertical_overflow_visibility=vertical_overflow_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             overflow_column_header_visibility: Optional['TemplateVisibility'] = None,
             vertical_overflow_visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if overflow_column_header_visibility is not None:
            _setter("overflow_column_header_visibility", overflow_column_header_visibility)
        if vertical_overflow_visibility is not None:
            _setter("vertical_overflow_visibility", vertical_overflow_visibility)

    @property
    @pulumi.getter(name="overflowColumnHeaderVisibility")
    def overflow_column_header_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "overflow_column_header_visibility")

    @property
    @pulumi.getter(name="verticalOverflowVisibility")
    def vertical_overflow_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "vertical_overflow_visibility")


@pulumi.output_type
class TemplatePivotTableRowsLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableRowsLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableRowsLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableRowsLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplatePivotTableRowsLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplatePivotTableSortBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPath":
            suggest = "data_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableSortBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableSortBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableSortBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional['outputs.TemplateColumnSort'] = None,
                 data_path: Optional['outputs.TemplateDataPathSort'] = None,
                 field: Optional['outputs.TemplateFieldSort'] = None):
        TemplatePivotTableSortBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            data_path=data_path,
            field=field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: Optional['outputs.TemplateColumnSort'] = None,
             data_path: Optional['outputs.TemplateDataPathSort'] = None,
             field: Optional['outputs.TemplateFieldSort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column is not None:
            _setter("column", column)
        if data_path is not None:
            _setter("data_path", data_path)
        if field is not None:
            _setter("field", field)

    @property
    @pulumi.getter
    def column(self) -> Optional['outputs.TemplateColumnSort']:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="dataPath")
    def data_path(self) -> Optional['outputs.TemplateDataPathSort']:
        return pulumi.get(self, "data_path")

    @property
    @pulumi.getter
    def field(self) -> Optional['outputs.TemplateFieldSort']:
        return pulumi.get(self, "field")


@pulumi.output_type
class TemplatePivotTableSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldSortOptions":
            suggest = "field_sort_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_sort_options: Optional[Sequence['outputs.TemplatePivotFieldSortOptions']] = None):
        TemplatePivotTableSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_sort_options=field_sort_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_sort_options: Optional[Sequence['outputs.TemplatePivotFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_sort_options is not None:
            _setter("field_sort_options", field_sort_options)

    @property
    @pulumi.getter(name="fieldSortOptions")
    def field_sort_options(self) -> Optional[Sequence['outputs.TemplatePivotFieldSortOptions']]:
        return pulumi.get(self, "field_sort_options")


@pulumi.output_type
class TemplatePivotTableTotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnSubtotalOptions":
            suggest = "column_subtotal_options"
        elif key == "columnTotalOptions":
            suggest = "column_total_options"
        elif key == "rowSubtotalOptions":
            suggest = "row_subtotal_options"
        elif key == "rowTotalOptions":
            suggest = "row_total_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableTotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableTotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableTotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_subtotal_options: Optional['outputs.TemplateSubtotalOptions'] = None,
                 column_total_options: Optional['outputs.TemplatePivotTotalOptions'] = None,
                 row_subtotal_options: Optional['outputs.TemplateSubtotalOptions'] = None,
                 row_total_options: Optional['outputs.TemplatePivotTotalOptions'] = None):
        TemplatePivotTableTotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_subtotal_options=column_subtotal_options,
            column_total_options=column_total_options,
            row_subtotal_options=row_subtotal_options,
            row_total_options=row_total_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_subtotal_options: Optional['outputs.TemplateSubtotalOptions'] = None,
             column_total_options: Optional['outputs.TemplatePivotTotalOptions'] = None,
             row_subtotal_options: Optional['outputs.TemplateSubtotalOptions'] = None,
             row_total_options: Optional['outputs.TemplatePivotTotalOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_subtotal_options is not None:
            _setter("column_subtotal_options", column_subtotal_options)
        if column_total_options is not None:
            _setter("column_total_options", column_total_options)
        if row_subtotal_options is not None:
            _setter("row_subtotal_options", row_subtotal_options)
        if row_total_options is not None:
            _setter("row_total_options", row_total_options)

    @property
    @pulumi.getter(name="columnSubtotalOptions")
    def column_subtotal_options(self) -> Optional['outputs.TemplateSubtotalOptions']:
        return pulumi.get(self, "column_subtotal_options")

    @property
    @pulumi.getter(name="columnTotalOptions")
    def column_total_options(self) -> Optional['outputs.TemplatePivotTotalOptions']:
        return pulumi.get(self, "column_total_options")

    @property
    @pulumi.getter(name="rowSubtotalOptions")
    def row_subtotal_options(self) -> Optional['outputs.TemplateSubtotalOptions']:
        return pulumi.get(self, "row_subtotal_options")

    @property
    @pulumi.getter(name="rowTotalOptions")
    def row_total_options(self) -> Optional['outputs.TemplatePivotTotalOptions']:
        return pulumi.get(self, "row_total_options")


@pulumi.output_type
class TemplatePivotTableVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTableVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTableVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTableVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplatePivotTableConfiguration'] = None,
                 conditional_formatting: Optional['outputs.TemplatePivotTableConditionalFormatting'] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplatePivotTableVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplatePivotTableConfiguration'] = None,
             conditional_formatting: Optional['outputs.TemplatePivotTableConditionalFormatting'] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplatePivotTableConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.TemplatePivotTableConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplatePivotTotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "metricHeaderCellStyle":
            suggest = "metric_header_cell_style"
        elif key == "scrollStatus":
            suggest = "scroll_status"
        elif key == "totalCellStyle":
            suggest = "total_cell_style"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"
        elif key == "valueCellStyle":
            suggest = "value_cell_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePivotTotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePivotTotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePivotTotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 metric_header_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
                 placement: Optional['TemplateTableTotalsPlacement'] = None,
                 scroll_status: Optional['TemplateTableTotalsScrollStatus'] = None,
                 total_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
                 totals_visibility: Optional['TemplateVisibility'] = None,
                 value_cell_style: Optional['outputs.TemplateTableCellStyle'] = None):
        TemplatePivotTotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            metric_header_cell_style=metric_header_cell_style,
            placement=placement,
            scroll_status=scroll_status,
            total_cell_style=total_cell_style,
            totals_visibility=totals_visibility,
            value_cell_style=value_cell_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             metric_header_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
             placement: Optional['TemplateTableTotalsPlacement'] = None,
             scroll_status: Optional['TemplateTableTotalsScrollStatus'] = None,
             total_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
             totals_visibility: Optional['TemplateVisibility'] = None,
             value_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if metric_header_cell_style is not None:
            _setter("metric_header_cell_style", metric_header_cell_style)
        if placement is not None:
            _setter("placement", placement)
        if scroll_status is not None:
            _setter("scroll_status", scroll_status)
        if total_cell_style is not None:
            _setter("total_cell_style", total_cell_style)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)
        if value_cell_style is not None:
            _setter("value_cell_style", value_cell_style)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="metricHeaderCellStyle")
    def metric_header_cell_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "metric_header_cell_style")

    @property
    @pulumi.getter
    def placement(self) -> Optional['TemplateTableTotalsPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="scrollStatus")
    def scroll_status(self) -> Optional['TemplateTableTotalsScrollStatus']:
        return pulumi.get(self, "scroll_status")

    @property
    @pulumi.getter(name="totalCellStyle")
    def total_cell_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "total_cell_style")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "totals_visibility")

    @property
    @pulumi.getter(name="valueCellStyle")
    def value_cell_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "value_cell_style")


@pulumi.output_type
class TemplatePredefinedHierarchy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hierarchyId":
            suggest = "hierarchy_id"
        elif key == "drillDownFilters":
            suggest = "drill_down_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePredefinedHierarchy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePredefinedHierarchy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePredefinedHierarchy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence['outputs.TemplateColumnIdentifier'],
                 hierarchy_id: str,
                 drill_down_filters: Optional[Sequence['outputs.TemplateDrillDownFilter']] = None):
        TemplatePredefinedHierarchy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            hierarchy_id=hierarchy_id,
            drill_down_filters=drill_down_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Sequence['outputs.TemplateColumnIdentifier'],
             hierarchy_id: str,
             drill_down_filters: Optional[Sequence['outputs.TemplateDrillDownFilter']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("columns", columns)
        _setter("hierarchy_id", hierarchy_id)
        if drill_down_filters is not None:
            _setter("drill_down_filters", drill_down_filters)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.TemplateColumnIdentifier']:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="hierarchyId")
    def hierarchy_id(self) -> str:
        return pulumi.get(self, "hierarchy_id")

    @property
    @pulumi.getter(name="drillDownFilters")
    def drill_down_filters(self) -> Optional[Sequence['outputs.TemplateDrillDownFilter']]:
        return pulumi.get(self, "drill_down_filters")


@pulumi.output_type
class TemplateProgressBarOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateProgressBarOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateRadarChartAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 color: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateRadarChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            color=color,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             color: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if color is not None:
            _setter("color", color)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def color(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateRadarChartAreaStyleSettings(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateRadarChartAreaStyleSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateRadarChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alternateBandColorsVisibility":
            suggest = "alternate_band_colors_visibility"
        elif key == "alternateBandEvenColor":
            suggest = "alternate_band_even_color"
        elif key == "alternateBandOddColor":
            suggest = "alternate_band_odd_color"
        elif key == "axesRangeScale":
            suggest = "axes_range_scale"
        elif key == "baseSeriesSettings":
            suggest = "base_series_settings"
        elif key == "categoryAxis":
            suggest = "category_axis"
        elif key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "colorAxis":
            suggest = "color_axis"
        elif key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "startAngle":
            suggest = "start_angle"
        elif key == "visualPalette":
            suggest = "visual_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateRadarChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateRadarChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateRadarChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alternate_band_colors_visibility: Optional['TemplateVisibility'] = None,
                 alternate_band_even_color: Optional[str] = None,
                 alternate_band_odd_color: Optional[str] = None,
                 axes_range_scale: Optional['TemplateRadarChartAxesRangeScale'] = None,
                 base_series_settings: Optional['outputs.TemplateRadarChartSeriesSettings'] = None,
                 category_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 color_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 color_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateRadarChartFieldWells'] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 shape: Optional['TemplateRadarChartShape'] = None,
                 sort_configuration: Optional['outputs.TemplateRadarChartSortConfiguration'] = None,
                 start_angle: Optional[float] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None):
        TemplateRadarChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alternate_band_colors_visibility=alternate_band_colors_visibility,
            alternate_band_even_color=alternate_band_even_color,
            alternate_band_odd_color=alternate_band_odd_color,
            axes_range_scale=axes_range_scale,
            base_series_settings=base_series_settings,
            category_axis=category_axis,
            category_label_options=category_label_options,
            color_axis=color_axis,
            color_label_options=color_label_options,
            field_wells=field_wells,
            legend=legend,
            shape=shape,
            sort_configuration=sort_configuration,
            start_angle=start_angle,
            visual_palette=visual_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alternate_band_colors_visibility: Optional['TemplateVisibility'] = None,
             alternate_band_even_color: Optional[str] = None,
             alternate_band_odd_color: Optional[str] = None,
             axes_range_scale: Optional['TemplateRadarChartAxesRangeScale'] = None,
             base_series_settings: Optional['outputs.TemplateRadarChartSeriesSettings'] = None,
             category_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             color_axis: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             color_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateRadarChartFieldWells'] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             shape: Optional['TemplateRadarChartShape'] = None,
             sort_configuration: Optional['outputs.TemplateRadarChartSortConfiguration'] = None,
             start_angle: Optional[float] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if alternate_band_colors_visibility is not None:
            _setter("alternate_band_colors_visibility", alternate_band_colors_visibility)
        if alternate_band_even_color is not None:
            _setter("alternate_band_even_color", alternate_band_even_color)
        if alternate_band_odd_color is not None:
            _setter("alternate_band_odd_color", alternate_band_odd_color)
        if axes_range_scale is not None:
            _setter("axes_range_scale", axes_range_scale)
        if base_series_settings is not None:
            _setter("base_series_settings", base_series_settings)
        if category_axis is not None:
            _setter("category_axis", category_axis)
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if color_axis is not None:
            _setter("color_axis", color_axis)
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if shape is not None:
            _setter("shape", shape)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if start_angle is not None:
            _setter("start_angle", start_angle)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)

    @property
    @pulumi.getter(name="alternateBandColorsVisibility")
    def alternate_band_colors_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "alternate_band_colors_visibility")

    @property
    @pulumi.getter(name="alternateBandEvenColor")
    def alternate_band_even_color(self) -> Optional[str]:
        return pulumi.get(self, "alternate_band_even_color")

    @property
    @pulumi.getter(name="alternateBandOddColor")
    def alternate_band_odd_color(self) -> Optional[str]:
        return pulumi.get(self, "alternate_band_odd_color")

    @property
    @pulumi.getter(name="axesRangeScale")
    def axes_range_scale(self) -> Optional['TemplateRadarChartAxesRangeScale']:
        return pulumi.get(self, "axes_range_scale")

    @property
    @pulumi.getter(name="baseSeriesSettings")
    def base_series_settings(self) -> Optional['outputs.TemplateRadarChartSeriesSettings']:
        return pulumi.get(self, "base_series_settings")

    @property
    @pulumi.getter(name="categoryAxis")
    def category_axis(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "category_axis")

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="colorAxis")
    def color_axis(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "color_axis")

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateRadarChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter
    def shape(self) -> Optional['TemplateRadarChartShape']:
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateRadarChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="startAngle")
    def start_angle(self) -> Optional[float]:
        return pulumi.get(self, "start_angle")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")


@pulumi.output_type
class TemplateRadarChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "radarChartAggregatedFieldWells":
            suggest = "radar_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateRadarChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateRadarChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateRadarChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 radar_chart_aggregated_field_wells: Optional['outputs.TemplateRadarChartAggregatedFieldWells'] = None):
        TemplateRadarChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            radar_chart_aggregated_field_wells=radar_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             radar_chart_aggregated_field_wells: Optional['outputs.TemplateRadarChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if radar_chart_aggregated_field_wells is not None:
            _setter("radar_chart_aggregated_field_wells", radar_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="radarChartAggregatedFieldWells")
    def radar_chart_aggregated_field_wells(self) -> Optional['outputs.TemplateRadarChartAggregatedFieldWells']:
        return pulumi.get(self, "radar_chart_aggregated_field_wells")


@pulumi.output_type
class TemplateRadarChartSeriesSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "areaStyleSettings":
            suggest = "area_style_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateRadarChartSeriesSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateRadarChartSeriesSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateRadarChartSeriesSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area_style_settings: Optional['outputs.TemplateRadarChartAreaStyleSettings'] = None):
        TemplateRadarChartSeriesSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            area_style_settings=area_style_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             area_style_settings: Optional['outputs.TemplateRadarChartAreaStyleSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if area_style_settings is not None:
            _setter("area_style_settings", area_style_settings)

    @property
    @pulumi.getter(name="areaStyleSettings")
    def area_style_settings(self) -> Optional['outputs.TemplateRadarChartAreaStyleSettings']:
        return pulumi.get(self, "area_style_settings")


@pulumi.output_type
class TemplateRadarChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"
        elif key == "colorItemsLimit":
            suggest = "color_items_limit"
        elif key == "colorSort":
            suggest = "color_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateRadarChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateRadarChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateRadarChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
                 color_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 color_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateRadarChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
            color_items_limit=color_items_limit,
            color_sort=color_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             color_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             color_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)
        if color_items_limit is not None:
            _setter("color_items_limit", color_items_limit)
        if color_sort is not None:
            _setter("color_sort", color_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "category_sort")

    @property
    @pulumi.getter(name="colorItemsLimit")
    def color_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "color_items_limit")

    @property
    @pulumi.getter(name="colorSort")
    def color_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "color_sort")


@pulumi.output_type
class TemplateRadarChartVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateRadarChartVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateRadarChartVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateRadarChartVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateRadarChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateRadarChartVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateRadarChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateRadarChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateRangeEndsLabelType(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateRangeEndsLabelType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateReferenceLine(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataConfiguration":
            suggest = "data_configuration"
        elif key == "labelConfiguration":
            suggest = "label_configuration"
        elif key == "styleConfiguration":
            suggest = "style_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateReferenceLine. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateReferenceLine.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateReferenceLine.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_configuration: 'outputs.TemplateReferenceLineDataConfiguration',
                 label_configuration: Optional['outputs.TemplateReferenceLineLabelConfiguration'] = None,
                 status: Optional['TemplateWidgetStatus'] = None,
                 style_configuration: Optional['outputs.TemplateReferenceLineStyleConfiguration'] = None):
        TemplateReferenceLine._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_configuration=data_configuration,
            label_configuration=label_configuration,
            status=status,
            style_configuration=style_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_configuration: 'outputs.TemplateReferenceLineDataConfiguration',
             label_configuration: Optional['outputs.TemplateReferenceLineLabelConfiguration'] = None,
             status: Optional['TemplateWidgetStatus'] = None,
             style_configuration: Optional['outputs.TemplateReferenceLineStyleConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_configuration", data_configuration)
        if label_configuration is not None:
            _setter("label_configuration", label_configuration)
        if status is not None:
            _setter("status", status)
        if style_configuration is not None:
            _setter("style_configuration", style_configuration)

    @property
    @pulumi.getter(name="dataConfiguration")
    def data_configuration(self) -> 'outputs.TemplateReferenceLineDataConfiguration':
        return pulumi.get(self, "data_configuration")

    @property
    @pulumi.getter(name="labelConfiguration")
    def label_configuration(self) -> Optional['outputs.TemplateReferenceLineLabelConfiguration']:
        return pulumi.get(self, "label_configuration")

    @property
    @pulumi.getter
    def status(self) -> Optional['TemplateWidgetStatus']:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="styleConfiguration")
    def style_configuration(self) -> Optional['outputs.TemplateReferenceLineStyleConfiguration']:
        return pulumi.get(self, "style_configuration")


@pulumi.output_type
class TemplateReferenceLineCustomLabelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateReferenceLineCustomLabelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateReferenceLineCustomLabelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateReferenceLineCustomLabelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: str):
        TemplateReferenceLineCustomLabelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_label", custom_label)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> str:
        return pulumi.get(self, "custom_label")


@pulumi.output_type
class TemplateReferenceLineDataConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisBinding":
            suggest = "axis_binding"
        elif key == "dynamicConfiguration":
            suggest = "dynamic_configuration"
        elif key == "staticConfiguration":
            suggest = "static_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateReferenceLineDataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateReferenceLineDataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateReferenceLineDataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 axis_binding: Optional['TemplateAxisBinding'] = None,
                 dynamic_configuration: Optional['outputs.TemplateReferenceLineDynamicDataConfiguration'] = None,
                 static_configuration: Optional['outputs.TemplateReferenceLineStaticDataConfiguration'] = None):
        TemplateReferenceLineDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            axis_binding=axis_binding,
            dynamic_configuration=dynamic_configuration,
            static_configuration=static_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             axis_binding: Optional['TemplateAxisBinding'] = None,
             dynamic_configuration: Optional['outputs.TemplateReferenceLineDynamicDataConfiguration'] = None,
             static_configuration: Optional['outputs.TemplateReferenceLineStaticDataConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if axis_binding is not None:
            _setter("axis_binding", axis_binding)
        if dynamic_configuration is not None:
            _setter("dynamic_configuration", dynamic_configuration)
        if static_configuration is not None:
            _setter("static_configuration", static_configuration)

    @property
    @pulumi.getter(name="axisBinding")
    def axis_binding(self) -> Optional['TemplateAxisBinding']:
        return pulumi.get(self, "axis_binding")

    @property
    @pulumi.getter(name="dynamicConfiguration")
    def dynamic_configuration(self) -> Optional['outputs.TemplateReferenceLineDynamicDataConfiguration']:
        return pulumi.get(self, "dynamic_configuration")

    @property
    @pulumi.getter(name="staticConfiguration")
    def static_configuration(self) -> Optional['outputs.TemplateReferenceLineStaticDataConfiguration']:
        return pulumi.get(self, "static_configuration")


@pulumi.output_type
class TemplateReferenceLineDynamicDataConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "measureAggregationFunction":
            suggest = "measure_aggregation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateReferenceLineDynamicDataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateReferenceLineDynamicDataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateReferenceLineDynamicDataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 calculation: 'outputs.TemplateNumericalAggregationFunction',
                 column: 'outputs.TemplateColumnIdentifier',
                 measure_aggregation_function: Optional['outputs.TemplateAggregationFunction'] = None):
        TemplateReferenceLineDynamicDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            calculation=calculation,
            column=column,
            measure_aggregation_function=measure_aggregation_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             calculation: 'outputs.TemplateNumericalAggregationFunction',
             column: 'outputs.TemplateColumnIdentifier',
             measure_aggregation_function: Optional['outputs.TemplateAggregationFunction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("calculation", calculation)
        _setter("column", column)
        if measure_aggregation_function is not None:
            _setter("measure_aggregation_function", measure_aggregation_function)

    @property
    @pulumi.getter
    def calculation(self) -> 'outputs.TemplateNumericalAggregationFunction':
        return pulumi.get(self, "calculation")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="measureAggregationFunction")
    def measure_aggregation_function(self) -> Optional['outputs.TemplateAggregationFunction']:
        return pulumi.get(self, "measure_aggregation_function")


@pulumi.output_type
class TemplateReferenceLineLabelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabelConfiguration":
            suggest = "custom_label_configuration"
        elif key == "fontColor":
            suggest = "font_color"
        elif key == "fontConfiguration":
            suggest = "font_configuration"
        elif key == "horizontalPosition":
            suggest = "horizontal_position"
        elif key == "valueLabelConfiguration":
            suggest = "value_label_configuration"
        elif key == "verticalPosition":
            suggest = "vertical_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateReferenceLineLabelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateReferenceLineLabelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateReferenceLineLabelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label_configuration: Optional['outputs.TemplateReferenceLineCustomLabelConfiguration'] = None,
                 font_color: Optional[str] = None,
                 font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
                 horizontal_position: Optional['TemplateReferenceLineLabelHorizontalPosition'] = None,
                 value_label_configuration: Optional['outputs.TemplateReferenceLineValueLabelConfiguration'] = None,
                 vertical_position: Optional['TemplateReferenceLineLabelVerticalPosition'] = None):
        TemplateReferenceLineLabelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label_configuration=custom_label_configuration,
            font_color=font_color,
            font_configuration=font_configuration,
            horizontal_position=horizontal_position,
            value_label_configuration=value_label_configuration,
            vertical_position=vertical_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label_configuration: Optional['outputs.TemplateReferenceLineCustomLabelConfiguration'] = None,
             font_color: Optional[str] = None,
             font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
             horizontal_position: Optional['TemplateReferenceLineLabelHorizontalPosition'] = None,
             value_label_configuration: Optional['outputs.TemplateReferenceLineValueLabelConfiguration'] = None,
             vertical_position: Optional['TemplateReferenceLineLabelVerticalPosition'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label_configuration is not None:
            _setter("custom_label_configuration", custom_label_configuration)
        if font_color is not None:
            _setter("font_color", font_color)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if horizontal_position is not None:
            _setter("horizontal_position", horizontal_position)
        if value_label_configuration is not None:
            _setter("value_label_configuration", value_label_configuration)
        if vertical_position is not None:
            _setter("vertical_position", vertical_position)

    @property
    @pulumi.getter(name="customLabelConfiguration")
    def custom_label_configuration(self) -> Optional['outputs.TemplateReferenceLineCustomLabelConfiguration']:
        return pulumi.get(self, "custom_label_configuration")

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[str]:
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.TemplateFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter(name="horizontalPosition")
    def horizontal_position(self) -> Optional['TemplateReferenceLineLabelHorizontalPosition']:
        return pulumi.get(self, "horizontal_position")

    @property
    @pulumi.getter(name="valueLabelConfiguration")
    def value_label_configuration(self) -> Optional['outputs.TemplateReferenceLineValueLabelConfiguration']:
        return pulumi.get(self, "value_label_configuration")

    @property
    @pulumi.getter(name="verticalPosition")
    def vertical_position(self) -> Optional['TemplateReferenceLineLabelVerticalPosition']:
        return pulumi.get(self, "vertical_position")


@pulumi.output_type
class TemplateReferenceLineStaticDataConfiguration(dict):
    def __init__(__self__, *,
                 value: float):
        TemplateReferenceLineStaticDataConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateReferenceLineStyleConfiguration(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 pattern: Optional['TemplateReferenceLinePatternType'] = None):
        TemplateReferenceLineStyleConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            pattern=pattern,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             pattern: Optional['TemplateReferenceLinePatternType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if pattern is not None:
            _setter("pattern", pattern)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def pattern(self) -> Optional['TemplateReferenceLinePatternType']:
        return pulumi.get(self, "pattern")


@pulumi.output_type
class TemplateReferenceLineValueLabelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatConfiguration":
            suggest = "format_configuration"
        elif key == "relativePosition":
            suggest = "relative_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateReferenceLineValueLabelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateReferenceLineValueLabelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateReferenceLineValueLabelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_configuration: Optional['outputs.TemplateNumericFormatConfiguration'] = None,
                 relative_position: Optional['TemplateReferenceLineValueLabelRelativePosition'] = None):
        TemplateReferenceLineValueLabelConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_configuration=format_configuration,
            relative_position=relative_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_configuration: Optional['outputs.TemplateNumericFormatConfiguration'] = None,
             relative_position: Optional['TemplateReferenceLineValueLabelRelativePosition'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)
        if relative_position is not None:
            _setter("relative_position", relative_position)

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.TemplateNumericFormatConfiguration']:
        return pulumi.get(self, "format_configuration")

    @property
    @pulumi.getter(name="relativePosition")
    def relative_position(self) -> Optional['TemplateReferenceLineValueLabelRelativePosition']:
        return pulumi.get(self, "relative_position")


@pulumi.output_type
class TemplateRelativeDateTimeControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeFormat":
            suggest = "date_time_format"
        elif key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateRelativeDateTimeControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateRelativeDateTimeControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateRelativeDateTimeControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_format: Optional[str] = None,
                 info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
                 title_options: Optional['outputs.TemplateLabelOptions'] = None):
        TemplateRelativeDateTimeControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_format=date_time_format,
            info_icon_label_options=info_icon_label_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_format: Optional[str] = None,
             info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
             title_options: Optional['outputs.TemplateLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if date_time_format is not None:
            _setter("date_time_format", date_time_format)
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="dateTimeFormat")
    def date_time_format(self) -> Optional[str]:
        return pulumi.get(self, "date_time_format")

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.TemplateSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.TemplateLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class TemplateRelativeDatesFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anchorDateConfiguration":
            suggest = "anchor_date_configuration"
        elif key == "filterId":
            suggest = "filter_id"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "relativeDateType":
            suggest = "relative_date_type"
        elif key == "timeGranularity":
            suggest = "time_granularity"
        elif key == "excludePeriodConfiguration":
            suggest = "exclude_period_configuration"
        elif key == "minimumGranularity":
            suggest = "minimum_granularity"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "relativeDateValue":
            suggest = "relative_date_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateRelativeDatesFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateRelativeDatesFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateRelativeDatesFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anchor_date_configuration: 'outputs.TemplateAnchorDateConfiguration',
                 column: 'outputs.TemplateColumnIdentifier',
                 filter_id: str,
                 null_option: 'TemplateFilterNullOption',
                 relative_date_type: 'TemplateRelativeDateType',
                 time_granularity: 'TemplateTimeGranularity',
                 exclude_period_configuration: Optional['outputs.TemplateExcludePeriodConfiguration'] = None,
                 minimum_granularity: Optional['TemplateTimeGranularity'] = None,
                 parameter_name: Optional[str] = None,
                 relative_date_value: Optional[float] = None):
        TemplateRelativeDatesFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            anchor_date_configuration=anchor_date_configuration,
            column=column,
            filter_id=filter_id,
            null_option=null_option,
            relative_date_type=relative_date_type,
            time_granularity=time_granularity,
            exclude_period_configuration=exclude_period_configuration,
            minimum_granularity=minimum_granularity,
            parameter_name=parameter_name,
            relative_date_value=relative_date_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             anchor_date_configuration: 'outputs.TemplateAnchorDateConfiguration',
             column: 'outputs.TemplateColumnIdentifier',
             filter_id: str,
             null_option: 'TemplateFilterNullOption',
             relative_date_type: 'TemplateRelativeDateType',
             time_granularity: 'TemplateTimeGranularity',
             exclude_period_configuration: Optional['outputs.TemplateExcludePeriodConfiguration'] = None,
             minimum_granularity: Optional['TemplateTimeGranularity'] = None,
             parameter_name: Optional[str] = None,
             relative_date_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("anchor_date_configuration", anchor_date_configuration)
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("null_option", null_option)
        _setter("relative_date_type", relative_date_type)
        _setter("time_granularity", time_granularity)
        if exclude_period_configuration is not None:
            _setter("exclude_period_configuration", exclude_period_configuration)
        if minimum_granularity is not None:
            _setter("minimum_granularity", minimum_granularity)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if relative_date_value is not None:
            _setter("relative_date_value", relative_date_value)

    @property
    @pulumi.getter(name="anchorDateConfiguration")
    def anchor_date_configuration(self) -> 'outputs.TemplateAnchorDateConfiguration':
        return pulumi.get(self, "anchor_date_configuration")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'TemplateFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="relativeDateType")
    def relative_date_type(self) -> 'TemplateRelativeDateType':
        return pulumi.get(self, "relative_date_type")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> 'TemplateTimeGranularity':
        return pulumi.get(self, "time_granularity")

    @property
    @pulumi.getter(name="excludePeriodConfiguration")
    def exclude_period_configuration(self) -> Optional['outputs.TemplateExcludePeriodConfiguration']:
        return pulumi.get(self, "exclude_period_configuration")

    @property
    @pulumi.getter(name="minimumGranularity")
    def minimum_granularity(self) -> Optional['TemplateTimeGranularity']:
        return pulumi.get(self, "minimum_granularity")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="relativeDateValue")
    def relative_date_value(self) -> Optional[float]:
        return pulumi.get(self, "relative_date_value")


@pulumi.output_type
class TemplateResourcePermission(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str,
                 resource: Optional[str] = None):
        TemplateResourcePermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
            resource=resource,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Sequence[str],
             principal: str,
             resource: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        _setter("principal", principal)
        if resource is not None:
            _setter("resource", resource)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        return pulumi.get(self, "principal")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")


@pulumi.output_type
class TemplateRollingDateConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetIdentifier":
            suggest = "data_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateRollingDateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateRollingDateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateRollingDateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 data_set_identifier: Optional[str] = None):
        TemplateRollingDateConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            data_set_identifier=data_set_identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             data_set_identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if data_set_identifier is not None:
            _setter("data_set_identifier", data_set_identifier)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="dataSetIdentifier")
    def data_set_identifier(self) -> Optional[str]:
        return pulumi.get(self, "data_set_identifier")


@pulumi.output_type
class TemplateRowAlternateColorOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowAlternateColors":
            suggest = "row_alternate_colors"
        elif key == "usePrimaryBackgroundColor":
            suggest = "use_primary_background_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateRowAlternateColorOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateRowAlternateColorOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateRowAlternateColorOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 row_alternate_colors: Optional[Sequence[str]] = None,
                 status: Optional['TemplateWidgetStatus'] = None,
                 use_primary_background_color: Optional['TemplateWidgetStatus'] = None):
        TemplateRowAlternateColorOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            row_alternate_colors=row_alternate_colors,
            status=status,
            use_primary_background_color=use_primary_background_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             row_alternate_colors: Optional[Sequence[str]] = None,
             status: Optional['TemplateWidgetStatus'] = None,
             use_primary_background_color: Optional['TemplateWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if row_alternate_colors is not None:
            _setter("row_alternate_colors", row_alternate_colors)
        if status is not None:
            _setter("status", status)
        if use_primary_background_color is not None:
            _setter("use_primary_background_color", use_primary_background_color)

    @property
    @pulumi.getter(name="rowAlternateColors")
    def row_alternate_colors(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "row_alternate_colors")

    @property
    @pulumi.getter
    def status(self) -> Optional['TemplateWidgetStatus']:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="usePrimaryBackgroundColor")
    def use_primary_background_color(self) -> Optional['TemplateWidgetStatus']:
        return pulumi.get(self, "use_primary_background_color")


@pulumi.output_type
class TemplateSameSheetTargetVisualConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetVisualOptions":
            suggest = "target_visual_options"
        elif key == "targetVisuals":
            suggest = "target_visuals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSameSheetTargetVisualConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSameSheetTargetVisualConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSameSheetTargetVisualConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_visual_options: Optional['TemplateTargetVisualOptions'] = None,
                 target_visuals: Optional[Sequence[str]] = None):
        TemplateSameSheetTargetVisualConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_visual_options=target_visual_options,
            target_visuals=target_visuals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_visual_options: Optional['TemplateTargetVisualOptions'] = None,
             target_visuals: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if target_visual_options is not None:
            _setter("target_visual_options", target_visual_options)
        if target_visuals is not None:
            _setter("target_visuals", target_visuals)

    @property
    @pulumi.getter(name="targetVisualOptions")
    def target_visual_options(self) -> Optional['TemplateTargetVisualOptions']:
        return pulumi.get(self, "target_visual_options")

    @property
    @pulumi.getter(name="targetVisuals")
    def target_visuals(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "target_visuals")


@pulumi.output_type
class TemplateSankeyDiagramAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 destination: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 source: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 weight: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateSankeyDiagramAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            source=source,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             source: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             weight: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination is not None:
            _setter("destination", destination)
        if source is not None:
            _setter("source", source)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter
    def destination(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def source(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def weight(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class TemplateSankeyDiagramChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSankeyDiagramChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSankeyDiagramChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSankeyDiagramChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateSankeyDiagramFieldWells'] = None,
                 sort_configuration: Optional['outputs.TemplateSankeyDiagramSortConfiguration'] = None):
        TemplateSankeyDiagramChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_labels=data_labels,
            field_wells=field_wells,
            sort_configuration=sort_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateSankeyDiagramFieldWells'] = None,
             sort_configuration: Optional['outputs.TemplateSankeyDiagramSortConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateSankeyDiagramFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateSankeyDiagramSortConfiguration']:
        return pulumi.get(self, "sort_configuration")


@pulumi.output_type
class TemplateSankeyDiagramFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sankeyDiagramAggregatedFieldWells":
            suggest = "sankey_diagram_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSankeyDiagramFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSankeyDiagramFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSankeyDiagramFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sankey_diagram_aggregated_field_wells: Optional['outputs.TemplateSankeyDiagramAggregatedFieldWells'] = None):
        TemplateSankeyDiagramFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sankey_diagram_aggregated_field_wells=sankey_diagram_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sankey_diagram_aggregated_field_wells: Optional['outputs.TemplateSankeyDiagramAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sankey_diagram_aggregated_field_wells is not None:
            _setter("sankey_diagram_aggregated_field_wells", sankey_diagram_aggregated_field_wells)

    @property
    @pulumi.getter(name="sankeyDiagramAggregatedFieldWells")
    def sankey_diagram_aggregated_field_wells(self) -> Optional['outputs.TemplateSankeyDiagramAggregatedFieldWells']:
        return pulumi.get(self, "sankey_diagram_aggregated_field_wells")


@pulumi.output_type
class TemplateSankeyDiagramSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationItemsLimit":
            suggest = "destination_items_limit"
        elif key == "sourceItemsLimit":
            suggest = "source_items_limit"
        elif key == "weightSort":
            suggest = "weight_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSankeyDiagramSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSankeyDiagramSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSankeyDiagramSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 source_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 weight_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateSankeyDiagramSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_items_limit=destination_items_limit,
            source_items_limit=source_items_limit,
            weight_sort=weight_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             source_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             weight_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination_items_limit is not None:
            _setter("destination_items_limit", destination_items_limit)
        if source_items_limit is not None:
            _setter("source_items_limit", source_items_limit)
        if weight_sort is not None:
            _setter("weight_sort", weight_sort)

    @property
    @pulumi.getter(name="destinationItemsLimit")
    def destination_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "destination_items_limit")

    @property
    @pulumi.getter(name="sourceItemsLimit")
    def source_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "source_items_limit")

    @property
    @pulumi.getter(name="weightSort")
    def weight_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "weight_sort")


@pulumi.output_type
class TemplateSankeyDiagramVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSankeyDiagramVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSankeyDiagramVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSankeyDiagramVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateSankeyDiagramChartConfiguration'] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateSankeyDiagramVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateSankeyDiagramChartConfiguration'] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateSankeyDiagramChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateScatterPlotCategoricallyAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAxis":
            suggest = "x_axis"
        elif key == "yAxis":
            suggest = "y_axis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateScatterPlotCategoricallyAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateScatterPlotCategoricallyAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateScatterPlotCategoricallyAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 label: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 size: Optional[Sequence['outputs.TemplateMeasureField']] = None,
                 x_axis: Optional[Sequence['outputs.TemplateMeasureField']] = None,
                 y_axis: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateScatterPlotCategoricallyAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            label=label,
            size=size,
            x_axis=x_axis,
            y_axis=y_axis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             label: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             size: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             x_axis: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             y_axis: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if label is not None:
            _setter("label", label)
        if size is not None:
            _setter("size", size)
        if x_axis is not None:
            _setter("x_axis", x_axis)
        if y_axis is not None:
            _setter("y_axis", y_axis)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def label(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def size(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="xAxis")
    def x_axis(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "x_axis")

    @property
    @pulumi.getter(name="yAxis")
    def y_axis(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "y_axis")


@pulumi.output_type
class TemplateScatterPlotConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "xAxisDisplayOptions":
            suggest = "x_axis_display_options"
        elif key == "xAxisLabelOptions":
            suggest = "x_axis_label_options"
        elif key == "yAxisDisplayOptions":
            suggest = "y_axis_display_options"
        elif key == "yAxisLabelOptions":
            suggest = "y_axis_label_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateScatterPlotConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateScatterPlotConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateScatterPlotConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateScatterPlotFieldWells'] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
                 x_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 x_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None):
        TemplateScatterPlotConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            tooltip=tooltip,
            visual_palette=visual_palette,
            x_axis_display_options=x_axis_display_options,
            x_axis_label_options=x_axis_label_options,
            y_axis_display_options=y_axis_display_options,
            y_axis_label_options=y_axis_label_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateScatterPlotFieldWells'] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             x_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             x_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if tooltip is not None:
            _setter("tooltip", tooltip)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if x_axis_display_options is not None:
            _setter("x_axis_display_options", x_axis_display_options)
        if x_axis_label_options is not None:
            _setter("x_axis_label_options", x_axis_label_options)
        if y_axis_display_options is not None:
            _setter("y_axis_display_options", y_axis_display_options)
        if y_axis_label_options is not None:
            _setter("y_axis_label_options", y_axis_label_options)

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateScatterPlotFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="xAxisDisplayOptions")
    def x_axis_display_options(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "x_axis_display_options")

    @property
    @pulumi.getter(name="xAxisLabelOptions")
    def x_axis_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "x_axis_label_options")

    @property
    @pulumi.getter(name="yAxisDisplayOptions")
    def y_axis_display_options(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "y_axis_display_options")

    @property
    @pulumi.getter(name="yAxisLabelOptions")
    def y_axis_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "y_axis_label_options")


@pulumi.output_type
class TemplateScatterPlotFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scatterPlotCategoricallyAggregatedFieldWells":
            suggest = "scatter_plot_categorically_aggregated_field_wells"
        elif key == "scatterPlotUnaggregatedFieldWells":
            suggest = "scatter_plot_unaggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateScatterPlotFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateScatterPlotFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateScatterPlotFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scatter_plot_categorically_aggregated_field_wells: Optional['outputs.TemplateScatterPlotCategoricallyAggregatedFieldWells'] = None,
                 scatter_plot_unaggregated_field_wells: Optional['outputs.TemplateScatterPlotUnaggregatedFieldWells'] = None):
        TemplateScatterPlotFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scatter_plot_categorically_aggregated_field_wells=scatter_plot_categorically_aggregated_field_wells,
            scatter_plot_unaggregated_field_wells=scatter_plot_unaggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scatter_plot_categorically_aggregated_field_wells: Optional['outputs.TemplateScatterPlotCategoricallyAggregatedFieldWells'] = None,
             scatter_plot_unaggregated_field_wells: Optional['outputs.TemplateScatterPlotUnaggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if scatter_plot_categorically_aggregated_field_wells is not None:
            _setter("scatter_plot_categorically_aggregated_field_wells", scatter_plot_categorically_aggregated_field_wells)
        if scatter_plot_unaggregated_field_wells is not None:
            _setter("scatter_plot_unaggregated_field_wells", scatter_plot_unaggregated_field_wells)

    @property
    @pulumi.getter(name="scatterPlotCategoricallyAggregatedFieldWells")
    def scatter_plot_categorically_aggregated_field_wells(self) -> Optional['outputs.TemplateScatterPlotCategoricallyAggregatedFieldWells']:
        return pulumi.get(self, "scatter_plot_categorically_aggregated_field_wells")

    @property
    @pulumi.getter(name="scatterPlotUnaggregatedFieldWells")
    def scatter_plot_unaggregated_field_wells(self) -> Optional['outputs.TemplateScatterPlotUnaggregatedFieldWells']:
        return pulumi.get(self, "scatter_plot_unaggregated_field_wells")


@pulumi.output_type
class TemplateScatterPlotUnaggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xAxis":
            suggest = "x_axis"
        elif key == "yAxis":
            suggest = "y_axis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateScatterPlotUnaggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateScatterPlotUnaggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateScatterPlotUnaggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 label: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 size: Optional[Sequence['outputs.TemplateMeasureField']] = None,
                 x_axis: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 y_axis: Optional[Sequence['outputs.TemplateDimensionField']] = None):
        TemplateScatterPlotUnaggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            label=label,
            size=size,
            x_axis=x_axis,
            y_axis=y_axis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             label: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             size: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             x_axis: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             y_axis: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if label is not None:
            _setter("label", label)
        if size is not None:
            _setter("size", size)
        if x_axis is not None:
            _setter("x_axis", x_axis)
        if y_axis is not None:
            _setter("y_axis", y_axis)

    @property
    @pulumi.getter
    def category(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def label(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def size(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="xAxis")
    def x_axis(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "x_axis")

    @property
    @pulumi.getter(name="yAxis")
    def y_axis(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "y_axis")


@pulumi.output_type
class TemplateScatterPlotVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateScatterPlotVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateScatterPlotVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateScatterPlotVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateScatterPlotConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateScatterPlotVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateScatterPlotConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateScatterPlotConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateScrollBarOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibleRange":
            suggest = "visible_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateScrollBarOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateScrollBarOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateScrollBarOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None,
                 visible_range: Optional['outputs.TemplateVisibleRangeOptions'] = None):
        TemplateScrollBarOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
            visible_range=visible_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             visible_range: Optional['outputs.TemplateVisibleRangeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)
        if visible_range is not None:
            _setter("visible_range", visible_range)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter(name="visibleRange")
    def visible_range(self) -> Optional['outputs.TemplateVisibleRangeOptions']:
        return pulumi.get(self, "visible_range")


@pulumi.output_type
class TemplateSecondaryValueOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateSecondaryValueOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateSectionAfterPageBreak(dict):
    def __init__(__self__, *,
                 status: Optional['TemplateSectionPageBreakStatus'] = None):
        TemplateSectionAfterPageBreak._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: Optional['TemplateSectionPageBreakStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional['TemplateSectionPageBreakStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class TemplateSectionBasedLayoutCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paperCanvasSizeOptions":
            suggest = "paper_canvas_size_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSectionBasedLayoutCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSectionBasedLayoutCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSectionBasedLayoutCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paper_canvas_size_options: Optional['outputs.TemplateSectionBasedLayoutPaperCanvasSizeOptions'] = None):
        TemplateSectionBasedLayoutCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            paper_canvas_size_options=paper_canvas_size_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             paper_canvas_size_options: Optional['outputs.TemplateSectionBasedLayoutPaperCanvasSizeOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if paper_canvas_size_options is not None:
            _setter("paper_canvas_size_options", paper_canvas_size_options)

    @property
    @pulumi.getter(name="paperCanvasSizeOptions")
    def paper_canvas_size_options(self) -> Optional['outputs.TemplateSectionBasedLayoutPaperCanvasSizeOptions']:
        return pulumi.get(self, "paper_canvas_size_options")


@pulumi.output_type
class TemplateSectionBasedLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodySections":
            suggest = "body_sections"
        elif key == "canvasSizeOptions":
            suggest = "canvas_size_options"
        elif key == "footerSections":
            suggest = "footer_sections"
        elif key == "headerSections":
            suggest = "header_sections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSectionBasedLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSectionBasedLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSectionBasedLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_sections: Sequence['outputs.TemplateBodySectionConfiguration'],
                 canvas_size_options: 'outputs.TemplateSectionBasedLayoutCanvasSizeOptions',
                 footer_sections: Sequence['outputs.TemplateHeaderFooterSectionConfiguration'],
                 header_sections: Sequence['outputs.TemplateHeaderFooterSectionConfiguration']):
        TemplateSectionBasedLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            body_sections=body_sections,
            canvas_size_options=canvas_size_options,
            footer_sections=footer_sections,
            header_sections=header_sections,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             body_sections: Sequence['outputs.TemplateBodySectionConfiguration'],
             canvas_size_options: 'outputs.TemplateSectionBasedLayoutCanvasSizeOptions',
             footer_sections: Sequence['outputs.TemplateHeaderFooterSectionConfiguration'],
             header_sections: Sequence['outputs.TemplateHeaderFooterSectionConfiguration'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("body_sections", body_sections)
        _setter("canvas_size_options", canvas_size_options)
        _setter("footer_sections", footer_sections)
        _setter("header_sections", header_sections)

    @property
    @pulumi.getter(name="bodySections")
    def body_sections(self) -> Sequence['outputs.TemplateBodySectionConfiguration']:
        return pulumi.get(self, "body_sections")

    @property
    @pulumi.getter(name="canvasSizeOptions")
    def canvas_size_options(self) -> 'outputs.TemplateSectionBasedLayoutCanvasSizeOptions':
        return pulumi.get(self, "canvas_size_options")

    @property
    @pulumi.getter(name="footerSections")
    def footer_sections(self) -> Sequence['outputs.TemplateHeaderFooterSectionConfiguration']:
        return pulumi.get(self, "footer_sections")

    @property
    @pulumi.getter(name="headerSections")
    def header_sections(self) -> Sequence['outputs.TemplateHeaderFooterSectionConfiguration']:
        return pulumi.get(self, "header_sections")


@pulumi.output_type
class TemplateSectionBasedLayoutPaperCanvasSizeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paperMargin":
            suggest = "paper_margin"
        elif key == "paperOrientation":
            suggest = "paper_orientation"
        elif key == "paperSize":
            suggest = "paper_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSectionBasedLayoutPaperCanvasSizeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSectionBasedLayoutPaperCanvasSizeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSectionBasedLayoutPaperCanvasSizeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paper_margin: Optional['outputs.TemplateSpacing'] = None,
                 paper_orientation: Optional['TemplatePaperOrientation'] = None,
                 paper_size: Optional['TemplatePaperSize'] = None):
        TemplateSectionBasedLayoutPaperCanvasSizeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            paper_margin=paper_margin,
            paper_orientation=paper_orientation,
            paper_size=paper_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             paper_margin: Optional['outputs.TemplateSpacing'] = None,
             paper_orientation: Optional['TemplatePaperOrientation'] = None,
             paper_size: Optional['TemplatePaperSize'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if paper_margin is not None:
            _setter("paper_margin", paper_margin)
        if paper_orientation is not None:
            _setter("paper_orientation", paper_orientation)
        if paper_size is not None:
            _setter("paper_size", paper_size)

    @property
    @pulumi.getter(name="paperMargin")
    def paper_margin(self) -> Optional['outputs.TemplateSpacing']:
        return pulumi.get(self, "paper_margin")

    @property
    @pulumi.getter(name="paperOrientation")
    def paper_orientation(self) -> Optional['TemplatePaperOrientation']:
        return pulumi.get(self, "paper_orientation")

    @property
    @pulumi.getter(name="paperSize")
    def paper_size(self) -> Optional['TemplatePaperSize']:
        return pulumi.get(self, "paper_size")


@pulumi.output_type
class TemplateSectionLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeFormLayout":
            suggest = "free_form_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSectionLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSectionLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSectionLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_form_layout: 'outputs.TemplateFreeFormSectionLayoutConfiguration'):
        TemplateSectionLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            free_form_layout=free_form_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             free_form_layout: 'outputs.TemplateFreeFormSectionLayoutConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("free_form_layout", free_form_layout)

    @property
    @pulumi.getter(name="freeFormLayout")
    def free_form_layout(self) -> 'outputs.TemplateFreeFormSectionLayoutConfiguration':
        return pulumi.get(self, "free_form_layout")


@pulumi.output_type
class TemplateSectionPageBreakConfiguration(dict):
    def __init__(__self__, *,
                 after: Optional['outputs.TemplateSectionAfterPageBreak'] = None):
        TemplateSectionPageBreakConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            after=after,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             after: Optional['outputs.TemplateSectionAfterPageBreak'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if after is not None:
            _setter("after", after)

    @property
    @pulumi.getter
    def after(self) -> Optional['outputs.TemplateSectionAfterPageBreak']:
        return pulumi.get(self, "after")


@pulumi.output_type
class TemplateSectionStyle(dict):
    def __init__(__self__, *,
                 height: Optional[str] = None,
                 padding: Optional['outputs.TemplateSpacing'] = None):
        """
        :param str height: String based length that is composed of value and unit in px
        """
        TemplateSectionStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            height=height,
            padding=padding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             height: Optional[str] = None,
             padding: Optional['outputs.TemplateSpacing'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if height is not None:
            _setter("height", height)
        if padding is not None:
            _setter("padding", padding)

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def padding(self) -> Optional['outputs.TemplateSpacing']:
        return pulumi.get(self, "padding")


@pulumi.output_type
class TemplateSelectedSheetsFilterScopeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetVisualScopingConfigurations":
            suggest = "sheet_visual_scoping_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSelectedSheetsFilterScopeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSelectedSheetsFilterScopeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSelectedSheetsFilterScopeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sheet_visual_scoping_configurations: Optional[Sequence['outputs.TemplateSheetVisualScopingConfiguration']] = None):
        TemplateSelectedSheetsFilterScopeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sheet_visual_scoping_configurations=sheet_visual_scoping_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sheet_visual_scoping_configurations: Optional[Sequence['outputs.TemplateSheetVisualScopingConfiguration']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sheet_visual_scoping_configurations is not None:
            _setter("sheet_visual_scoping_configurations", sheet_visual_scoping_configurations)

    @property
    @pulumi.getter(name="sheetVisualScopingConfigurations")
    def sheet_visual_scoping_configurations(self) -> Optional[Sequence['outputs.TemplateSheetVisualScopingConfiguration']]:
        return pulumi.get(self, "sheet_visual_scoping_configurations")


@pulumi.output_type
class TemplateSeriesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataFieldSeriesItem":
            suggest = "data_field_series_item"
        elif key == "fieldSeriesItem":
            suggest = "field_series_item"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSeriesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSeriesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSeriesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_field_series_item: Optional['outputs.TemplateDataFieldSeriesItem'] = None,
                 field_series_item: Optional['outputs.TemplateFieldSeriesItem'] = None):
        TemplateSeriesItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_field_series_item=data_field_series_item,
            field_series_item=field_series_item,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_field_series_item: Optional['outputs.TemplateDataFieldSeriesItem'] = None,
             field_series_item: Optional['outputs.TemplateFieldSeriesItem'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_field_series_item is not None:
            _setter("data_field_series_item", data_field_series_item)
        if field_series_item is not None:
            _setter("field_series_item", field_series_item)

    @property
    @pulumi.getter(name="dataFieldSeriesItem")
    def data_field_series_item(self) -> Optional['outputs.TemplateDataFieldSeriesItem']:
        return pulumi.get(self, "data_field_series_item")

    @property
    @pulumi.getter(name="fieldSeriesItem")
    def field_series_item(self) -> Optional['outputs.TemplateFieldSeriesItem']:
        return pulumi.get(self, "field_series_item")


@pulumi.output_type
class TemplateSetParameterValueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationParameterName":
            suggest = "destination_parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSetParameterValueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSetParameterValueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSetParameterValueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_parameter_name: str,
                 value: 'outputs.TemplateDestinationParameterValueConfiguration'):
        TemplateSetParameterValueConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_parameter_name=destination_parameter_name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_parameter_name: str,
             value: 'outputs.TemplateDestinationParameterValueConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("destination_parameter_name", destination_parameter_name)
        _setter("value", value)

    @property
    @pulumi.getter(name="destinationParameterName")
    def destination_parameter_name(self) -> str:
        return pulumi.get(self, "destination_parameter_name")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.TemplateDestinationParameterValueConfiguration':
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateShapeConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateShapeConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateShapeConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateShapeConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: 'outputs.TemplateConditionalFormattingColor'):
        TemplateShapeConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: 'outputs.TemplateConditionalFormattingColor',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("background_color", background_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> 'outputs.TemplateConditionalFormattingColor':
        return pulumi.get(self, "background_color")


@pulumi.output_type
class TemplateSheet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetId":
            suggest = "sheet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSheet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSheet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSheet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 sheet_id: Optional[str] = None):
        TemplateSheet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            sheet_id=sheet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             sheet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if sheet_id is not None:
            _setter("sheet_id", sheet_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sheetId")
    def sheet_id(self) -> Optional[str]:
        return pulumi.get(self, "sheet_id")


@pulumi.output_type
class TemplateSheetControlInfoIconLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconText":
            suggest = "info_icon_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSheetControlInfoIconLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSheetControlInfoIconLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSheetControlInfoIconLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_text: Optional[str] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateSheetControlInfoIconLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_text=info_icon_text,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_text: Optional[str] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_text is not None:
            _setter("info_icon_text", info_icon_text)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="infoIconText")
    def info_icon_text(self) -> Optional[str]:
        return pulumi.get(self, "info_icon_text")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateSheetControlLayout(dict):
    def __init__(__self__, *,
                 configuration: 'outputs.TemplateSheetControlLayoutConfiguration'):
        TemplateSheetControlLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: 'outputs.TemplateSheetControlLayoutConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("configuration", configuration)

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.TemplateSheetControlLayoutConfiguration':
        return pulumi.get(self, "configuration")


@pulumi.output_type
class TemplateSheetControlLayoutConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gridLayout":
            suggest = "grid_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSheetControlLayoutConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSheetControlLayoutConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSheetControlLayoutConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grid_layout: Optional['outputs.TemplateGridLayoutConfiguration'] = None):
        TemplateSheetControlLayoutConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grid_layout=grid_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grid_layout: Optional['outputs.TemplateGridLayoutConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if grid_layout is not None:
            _setter("grid_layout", grid_layout)

    @property
    @pulumi.getter(name="gridLayout")
    def grid_layout(self) -> Optional['outputs.TemplateGridLayoutConfiguration']:
        return pulumi.get(self, "grid_layout")


@pulumi.output_type
class TemplateSheetDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetId":
            suggest = "sheet_id"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "filterControls":
            suggest = "filter_controls"
        elif key == "parameterControls":
            suggest = "parameter_controls"
        elif key == "sheetControlLayouts":
            suggest = "sheet_control_layouts"
        elif key == "textBoxes":
            suggest = "text_boxes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSheetDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSheetDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSheetDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sheet_id: str,
                 content_type: Optional['TemplateSheetContentType'] = None,
                 description: Optional[str] = None,
                 filter_controls: Optional[Sequence['outputs.TemplateFilterControl']] = None,
                 layouts: Optional[Sequence['outputs.TemplateLayout']] = None,
                 name: Optional[str] = None,
                 parameter_controls: Optional[Sequence['outputs.TemplateParameterControl']] = None,
                 sheet_control_layouts: Optional[Sequence['outputs.TemplateSheetControlLayout']] = None,
                 text_boxes: Optional[Sequence['outputs.TemplateSheetTextBox']] = None,
                 title: Optional[str] = None,
                 visuals: Optional[Sequence['outputs.TemplateVisual']] = None):
        TemplateSheetDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sheet_id=sheet_id,
            content_type=content_type,
            description=description,
            filter_controls=filter_controls,
            layouts=layouts,
            name=name,
            parameter_controls=parameter_controls,
            sheet_control_layouts=sheet_control_layouts,
            text_boxes=text_boxes,
            title=title,
            visuals=visuals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sheet_id: str,
             content_type: Optional['TemplateSheetContentType'] = None,
             description: Optional[str] = None,
             filter_controls: Optional[Sequence['outputs.TemplateFilterControl']] = None,
             layouts: Optional[Sequence['outputs.TemplateLayout']] = None,
             name: Optional[str] = None,
             parameter_controls: Optional[Sequence['outputs.TemplateParameterControl']] = None,
             sheet_control_layouts: Optional[Sequence['outputs.TemplateSheetControlLayout']] = None,
             text_boxes: Optional[Sequence['outputs.TemplateSheetTextBox']] = None,
             title: Optional[str] = None,
             visuals: Optional[Sequence['outputs.TemplateVisual']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sheet_id", sheet_id)
        if content_type is not None:
            _setter("content_type", content_type)
        if description is not None:
            _setter("description", description)
        if filter_controls is not None:
            _setter("filter_controls", filter_controls)
        if layouts is not None:
            _setter("layouts", layouts)
        if name is not None:
            _setter("name", name)
        if parameter_controls is not None:
            _setter("parameter_controls", parameter_controls)
        if sheet_control_layouts is not None:
            _setter("sheet_control_layouts", sheet_control_layouts)
        if text_boxes is not None:
            _setter("text_boxes", text_boxes)
        if title is not None:
            _setter("title", title)
        if visuals is not None:
            _setter("visuals", visuals)

    @property
    @pulumi.getter(name="sheetId")
    def sheet_id(self) -> str:
        return pulumi.get(self, "sheet_id")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional['TemplateSheetContentType']:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="filterControls")
    def filter_controls(self) -> Optional[Sequence['outputs.TemplateFilterControl']]:
        return pulumi.get(self, "filter_controls")

    @property
    @pulumi.getter
    def layouts(self) -> Optional[Sequence['outputs.TemplateLayout']]:
        return pulumi.get(self, "layouts")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterControls")
    def parameter_controls(self) -> Optional[Sequence['outputs.TemplateParameterControl']]:
        return pulumi.get(self, "parameter_controls")

    @property
    @pulumi.getter(name="sheetControlLayouts")
    def sheet_control_layouts(self) -> Optional[Sequence['outputs.TemplateSheetControlLayout']]:
        return pulumi.get(self, "sheet_control_layouts")

    @property
    @pulumi.getter(name="textBoxes")
    def text_boxes(self) -> Optional[Sequence['outputs.TemplateSheetTextBox']]:
        return pulumi.get(self, "text_boxes")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def visuals(self) -> Optional[Sequence['outputs.TemplateVisual']]:
        return pulumi.get(self, "visuals")


@pulumi.output_type
class TemplateSheetElementConfigurationOverrides(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateSheetElementConfigurationOverrides._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateSheetElementRenderingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationOverrides":
            suggest = "configuration_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSheetElementRenderingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSheetElementRenderingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSheetElementRenderingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_overrides: 'outputs.TemplateSheetElementConfigurationOverrides',
                 expression: str):
        TemplateSheetElementRenderingRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration_overrides=configuration_overrides,
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration_overrides: 'outputs.TemplateSheetElementConfigurationOverrides',
             expression: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("configuration_overrides", configuration_overrides)
        _setter("expression", expression)

    @property
    @pulumi.getter(name="configurationOverrides")
    def configuration_overrides(self) -> 'outputs.TemplateSheetElementConfigurationOverrides':
        return pulumi.get(self, "configuration_overrides")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")


@pulumi.output_type
class TemplateSheetTextBox(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetTextBoxId":
            suggest = "sheet_text_box_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSheetTextBox. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSheetTextBox.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSheetTextBox.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sheet_text_box_id: str,
                 content: Optional[str] = None):
        TemplateSheetTextBox._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sheet_text_box_id=sheet_text_box_id,
            content=content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sheet_text_box_id: str,
             content: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sheet_text_box_id", sheet_text_box_id)
        if content is not None:
            _setter("content", content)

    @property
    @pulumi.getter(name="sheetTextBoxId")
    def sheet_text_box_id(self) -> str:
        return pulumi.get(self, "sheet_text_box_id")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")


@pulumi.output_type
class TemplateSheetVisualScopingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sheetId":
            suggest = "sheet_id"
        elif key == "visualIds":
            suggest = "visual_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSheetVisualScopingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSheetVisualScopingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSheetVisualScopingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scope: 'TemplateFilterVisualScope',
                 sheet_id: str,
                 visual_ids: Optional[Sequence[str]] = None):
        TemplateSheetVisualScopingConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scope=scope,
            sheet_id=sheet_id,
            visual_ids=visual_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scope: 'TemplateFilterVisualScope',
             sheet_id: str,
             visual_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("scope", scope)
        _setter("sheet_id", sheet_id)
        if visual_ids is not None:
            _setter("visual_ids", visual_ids)

    @property
    @pulumi.getter
    def scope(self) -> 'TemplateFilterVisualScope':
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="sheetId")
    def sheet_id(self) -> str:
        return pulumi.get(self, "sheet_id")

    @property
    @pulumi.getter(name="visualIds")
    def visual_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "visual_ids")


@pulumi.output_type
class TemplateShortFormatText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "plainText":
            suggest = "plain_text"
        elif key == "richText":
            suggest = "rich_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateShortFormatText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateShortFormatText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateShortFormatText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 plain_text: Optional[str] = None,
                 rich_text: Optional[str] = None):
        TemplateShortFormatText._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            plain_text=plain_text,
            rich_text=rich_text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             plain_text: Optional[str] = None,
             rich_text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if plain_text is not None:
            _setter("plain_text", plain_text)
        if rich_text is not None:
            _setter("rich_text", rich_text)

    @property
    @pulumi.getter(name="plainText")
    def plain_text(self) -> Optional[str]:
        return pulumi.get(self, "plain_text")

    @property
    @pulumi.getter(name="richText")
    def rich_text(self) -> Optional[str]:
        return pulumi.get(self, "rich_text")


@pulumi.output_type
class TemplateSimpleClusterMarker(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None):
        TemplateSimpleClusterMarker._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")


@pulumi.output_type
class TemplateSliderControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSliderControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSliderControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSliderControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
                 title_options: Optional['outputs.TemplateLabelOptions'] = None):
        TemplateSliderControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
             title_options: Optional['outputs.TemplateLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.TemplateSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.TemplateLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class TemplateSmallMultiplesAxisProperties(dict):
    def __init__(__self__, *,
                 placement: Optional['TemplateSmallMultiplesAxisPlacement'] = None,
                 scale: Optional['TemplateSmallMultiplesAxisScale'] = None):
        TemplateSmallMultiplesAxisProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            placement=placement,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             placement: Optional['TemplateSmallMultiplesAxisPlacement'] = None,
             scale: Optional['TemplateSmallMultiplesAxisScale'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if placement is not None:
            _setter("placement", placement)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter
    def placement(self) -> Optional['TemplateSmallMultiplesAxisPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter
    def scale(self) -> Optional['TemplateSmallMultiplesAxisScale']:
        return pulumi.get(self, "scale")


@pulumi.output_type
class TemplateSmallMultiplesOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVisibleColumns":
            suggest = "max_visible_columns"
        elif key == "maxVisibleRows":
            suggest = "max_visible_rows"
        elif key == "panelConfiguration":
            suggest = "panel_configuration"
        elif key == "xAxis":
            suggest = "x_axis"
        elif key == "yAxis":
            suggest = "y_axis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSmallMultiplesOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSmallMultiplesOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSmallMultiplesOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_visible_columns: Optional[float] = None,
                 max_visible_rows: Optional[float] = None,
                 panel_configuration: Optional['outputs.TemplatePanelConfiguration'] = None,
                 x_axis: Optional['outputs.TemplateSmallMultiplesAxisProperties'] = None,
                 y_axis: Optional['outputs.TemplateSmallMultiplesAxisProperties'] = None):
        TemplateSmallMultiplesOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_visible_columns=max_visible_columns,
            max_visible_rows=max_visible_rows,
            panel_configuration=panel_configuration,
            x_axis=x_axis,
            y_axis=y_axis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_visible_columns: Optional[float] = None,
             max_visible_rows: Optional[float] = None,
             panel_configuration: Optional['outputs.TemplatePanelConfiguration'] = None,
             x_axis: Optional['outputs.TemplateSmallMultiplesAxisProperties'] = None,
             y_axis: Optional['outputs.TemplateSmallMultiplesAxisProperties'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_visible_columns is not None:
            _setter("max_visible_columns", max_visible_columns)
        if max_visible_rows is not None:
            _setter("max_visible_rows", max_visible_rows)
        if panel_configuration is not None:
            _setter("panel_configuration", panel_configuration)
        if x_axis is not None:
            _setter("x_axis", x_axis)
        if y_axis is not None:
            _setter("y_axis", y_axis)

    @property
    @pulumi.getter(name="maxVisibleColumns")
    def max_visible_columns(self) -> Optional[float]:
        return pulumi.get(self, "max_visible_columns")

    @property
    @pulumi.getter(name="maxVisibleRows")
    def max_visible_rows(self) -> Optional[float]:
        return pulumi.get(self, "max_visible_rows")

    @property
    @pulumi.getter(name="panelConfiguration")
    def panel_configuration(self) -> Optional['outputs.TemplatePanelConfiguration']:
        return pulumi.get(self, "panel_configuration")

    @property
    @pulumi.getter(name="xAxis")
    def x_axis(self) -> Optional['outputs.TemplateSmallMultiplesAxisProperties']:
        return pulumi.get(self, "x_axis")

    @property
    @pulumi.getter(name="yAxis")
    def y_axis(self) -> Optional['outputs.TemplateSmallMultiplesAxisProperties']:
        return pulumi.get(self, "y_axis")


@pulumi.output_type
class TemplateSourceAnalysis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetReferences":
            suggest = "data_set_references"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSourceAnalysis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSourceAnalysis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSourceAnalysis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 data_set_references: Sequence['outputs.TemplateDataSetReference']):
        TemplateSourceAnalysis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            data_set_references=data_set_references,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: str,
             data_set_references: Sequence['outputs.TemplateDataSetReference'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("arn", arn)
        _setter("data_set_references", data_set_references)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> Sequence['outputs.TemplateDataSetReference']:
        return pulumi.get(self, "data_set_references")


@pulumi.output_type
class TemplateSourceEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceAnalysis":
            suggest = "source_analysis"
        elif key == "sourceTemplate":
            suggest = "source_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSourceEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSourceEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSourceEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_analysis: Optional['outputs.TemplateSourceAnalysis'] = None,
                 source_template: Optional['outputs.TemplateSourceTemplate'] = None):
        TemplateSourceEntity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_analysis=source_analysis,
            source_template=source_template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_analysis: Optional['outputs.TemplateSourceAnalysis'] = None,
             source_template: Optional['outputs.TemplateSourceTemplate'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if source_analysis is not None:
            _setter("source_analysis", source_analysis)
        if source_template is not None:
            _setter("source_template", source_template)

    @property
    @pulumi.getter(name="sourceAnalysis")
    def source_analysis(self) -> Optional['outputs.TemplateSourceAnalysis']:
        return pulumi.get(self, "source_analysis")

    @property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional['outputs.TemplateSourceTemplate']:
        return pulumi.get(self, "source_template")


@pulumi.output_type
class TemplateSourceTemplate(dict):
    def __init__(__self__, *,
                 arn: str):
        TemplateSourceTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")


@pulumi.output_type
class TemplateSpacing(dict):
    def __init__(__self__, *,
                 bottom: Optional[str] = None,
                 left: Optional[str] = None,
                 right: Optional[str] = None,
                 top: Optional[str] = None):
        """
        :param str bottom: String based length that is composed of value and unit
        :param str left: String based length that is composed of value and unit
        :param str right: String based length that is composed of value and unit
        :param str top: String based length that is composed of value and unit
        """
        TemplateSpacing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bottom=bottom,
            left=left,
            right=right,
            top=top,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bottom: Optional[str] = None,
             left: Optional[str] = None,
             right: Optional[str] = None,
             top: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bottom is not None:
            _setter("bottom", bottom)
        if left is not None:
            _setter("left", left)
        if right is not None:
            _setter("right", right)
        if top is not None:
            _setter("top", top)

    @property
    @pulumi.getter
    def bottom(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "bottom")

    @property
    @pulumi.getter
    def left(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "left")

    @property
    @pulumi.getter
    def right(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "right")

    @property
    @pulumi.getter
    def top(self) -> Optional[str]:
        """
        String based length that is composed of value and unit
        """
        return pulumi.get(self, "top")


@pulumi.output_type
class TemplateStringDefaultValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicValue":
            suggest = "dynamic_value"
        elif key == "staticValues":
            suggest = "static_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateStringDefaultValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateStringDefaultValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateStringDefaultValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_value: Optional['outputs.TemplateDynamicDefaultValue'] = None,
                 static_values: Optional[Sequence[str]] = None):
        TemplateStringDefaultValues._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_value=dynamic_value,
            static_values=static_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_value: Optional['outputs.TemplateDynamicDefaultValue'] = None,
             static_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dynamic_value is not None:
            _setter("dynamic_value", dynamic_value)
        if static_values is not None:
            _setter("static_values", static_values)

    @property
    @pulumi.getter(name="dynamicValue")
    def dynamic_value(self) -> Optional['outputs.TemplateDynamicDefaultValue']:
        return pulumi.get(self, "dynamic_value")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "static_values")


@pulumi.output_type
class TemplateStringFormatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nullValueFormatConfiguration":
            suggest = "null_value_format_configuration"
        elif key == "numericFormatConfiguration":
            suggest = "numeric_format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateStringFormatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateStringFormatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateStringFormatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 null_value_format_configuration: Optional['outputs.TemplateNullValueFormatConfiguration'] = None,
                 numeric_format_configuration: Optional['outputs.TemplateNumericFormatConfiguration'] = None):
        TemplateStringFormatConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            null_value_format_configuration=null_value_format_configuration,
            numeric_format_configuration=numeric_format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             null_value_format_configuration: Optional['outputs.TemplateNullValueFormatConfiguration'] = None,
             numeric_format_configuration: Optional['outputs.TemplateNumericFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if null_value_format_configuration is not None:
            _setter("null_value_format_configuration", null_value_format_configuration)
        if numeric_format_configuration is not None:
            _setter("numeric_format_configuration", numeric_format_configuration)

    @property
    @pulumi.getter(name="nullValueFormatConfiguration")
    def null_value_format_configuration(self) -> Optional['outputs.TemplateNullValueFormatConfiguration']:
        return pulumi.get(self, "null_value_format_configuration")

    @property
    @pulumi.getter(name="numericFormatConfiguration")
    def numeric_format_configuration(self) -> Optional['outputs.TemplateNumericFormatConfiguration']:
        return pulumi.get(self, "numeric_format_configuration")


@pulumi.output_type
class TemplateStringParameterDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValueType":
            suggest = "parameter_value_type"
        elif key == "defaultValues":
            suggest = "default_values"
        elif key == "mappedDataSetParameters":
            suggest = "mapped_data_set_parameters"
        elif key == "valueWhenUnset":
            suggest = "value_when_unset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateStringParameterDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateStringParameterDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateStringParameterDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 parameter_value_type: 'TemplateParameterValueType',
                 default_values: Optional['outputs.TemplateStringDefaultValues'] = None,
                 mapped_data_set_parameters: Optional[Sequence['outputs.TemplateMappedDataSetParameter']] = None,
                 value_when_unset: Optional['outputs.TemplateStringValueWhenUnsetConfiguration'] = None):
        TemplateStringParameterDeclaration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameter_value_type=parameter_value_type,
            default_values=default_values,
            mapped_data_set_parameters=mapped_data_set_parameters,
            value_when_unset=value_when_unset,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             parameter_value_type: 'TemplateParameterValueType',
             default_values: Optional['outputs.TemplateStringDefaultValues'] = None,
             mapped_data_set_parameters: Optional[Sequence['outputs.TemplateMappedDataSetParameter']] = None,
             value_when_unset: Optional['outputs.TemplateStringValueWhenUnsetConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("parameter_value_type", parameter_value_type)
        if default_values is not None:
            _setter("default_values", default_values)
        if mapped_data_set_parameters is not None:
            _setter("mapped_data_set_parameters", mapped_data_set_parameters)
        if value_when_unset is not None:
            _setter("value_when_unset", value_when_unset)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterValueType")
    def parameter_value_type(self) -> 'TemplateParameterValueType':
        return pulumi.get(self, "parameter_value_type")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional['outputs.TemplateStringDefaultValues']:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="mappedDataSetParameters")
    def mapped_data_set_parameters(self) -> Optional[Sequence['outputs.TemplateMappedDataSetParameter']]:
        return pulumi.get(self, "mapped_data_set_parameters")

    @property
    @pulumi.getter(name="valueWhenUnset")
    def value_when_unset(self) -> Optional['outputs.TemplateStringValueWhenUnsetConfiguration']:
        return pulumi.get(self, "value_when_unset")


@pulumi.output_type
class TemplateStringValueWhenUnsetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customValue":
            suggest = "custom_value"
        elif key == "valueWhenUnsetOption":
            suggest = "value_when_unset_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateStringValueWhenUnsetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateStringValueWhenUnsetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateStringValueWhenUnsetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_value: Optional[str] = None,
                 value_when_unset_option: Optional['TemplateValueWhenUnsetOption'] = None):
        TemplateStringValueWhenUnsetConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_value=custom_value,
            value_when_unset_option=value_when_unset_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_value: Optional[str] = None,
             value_when_unset_option: Optional['TemplateValueWhenUnsetOption'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_value is not None:
            _setter("custom_value", custom_value)
        if value_when_unset_option is not None:
            _setter("value_when_unset_option", value_when_unset_option)

    @property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[str]:
        return pulumi.get(self, "custom_value")

    @property
    @pulumi.getter(name="valueWhenUnsetOption")
    def value_when_unset_option(self) -> Optional['TemplateValueWhenUnsetOption']:
        return pulumi.get(self, "value_when_unset_option")


@pulumi.output_type
class TemplateSubtotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "fieldLevel":
            suggest = "field_level"
        elif key == "fieldLevelOptions":
            suggest = "field_level_options"
        elif key == "metricHeaderCellStyle":
            suggest = "metric_header_cell_style"
        elif key == "styleTargets":
            suggest = "style_targets"
        elif key == "totalCellStyle":
            suggest = "total_cell_style"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"
        elif key == "valueCellStyle":
            suggest = "value_cell_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSubtotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSubtotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSubtotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 field_level: Optional['TemplatePivotTableSubtotalLevel'] = None,
                 field_level_options: Optional[Sequence['outputs.TemplatePivotTableFieldSubtotalOptions']] = None,
                 metric_header_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
                 style_targets: Optional[Sequence['outputs.TemplateTableStyleTarget']] = None,
                 total_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
                 totals_visibility: Optional['TemplateVisibility'] = None,
                 value_cell_style: Optional['outputs.TemplateTableCellStyle'] = None):
        TemplateSubtotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            field_level=field_level,
            field_level_options=field_level_options,
            metric_header_cell_style=metric_header_cell_style,
            style_targets=style_targets,
            total_cell_style=total_cell_style,
            totals_visibility=totals_visibility,
            value_cell_style=value_cell_style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             field_level: Optional['TemplatePivotTableSubtotalLevel'] = None,
             field_level_options: Optional[Sequence['outputs.TemplatePivotTableFieldSubtotalOptions']] = None,
             metric_header_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
             style_targets: Optional[Sequence['outputs.TemplateTableStyleTarget']] = None,
             total_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
             totals_visibility: Optional['TemplateVisibility'] = None,
             value_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if field_level is not None:
            _setter("field_level", field_level)
        if field_level_options is not None:
            _setter("field_level_options", field_level_options)
        if metric_header_cell_style is not None:
            _setter("metric_header_cell_style", metric_header_cell_style)
        if style_targets is not None:
            _setter("style_targets", style_targets)
        if total_cell_style is not None:
            _setter("total_cell_style", total_cell_style)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)
        if value_cell_style is not None:
            _setter("value_cell_style", value_cell_style)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="fieldLevel")
    def field_level(self) -> Optional['TemplatePivotTableSubtotalLevel']:
        return pulumi.get(self, "field_level")

    @property
    @pulumi.getter(name="fieldLevelOptions")
    def field_level_options(self) -> Optional[Sequence['outputs.TemplatePivotTableFieldSubtotalOptions']]:
        return pulumi.get(self, "field_level_options")

    @property
    @pulumi.getter(name="metricHeaderCellStyle")
    def metric_header_cell_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "metric_header_cell_style")

    @property
    @pulumi.getter(name="styleTargets")
    def style_targets(self) -> Optional[Sequence['outputs.TemplateTableStyleTarget']]:
        return pulumi.get(self, "style_targets")

    @property
    @pulumi.getter(name="totalCellStyle")
    def total_cell_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "total_cell_style")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "totals_visibility")

    @property
    @pulumi.getter(name="valueCellStyle")
    def value_cell_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "value_cell_style")


@pulumi.output_type
class TemplateTableAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_by: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateTableAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_by=group_by,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_by: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_by is not None:
            _setter("group_by", group_by)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateTableBorderOptions(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 style: Optional['TemplateTableBorderStyle'] = None,
                 thickness: Optional[float] = None):
        TemplateTableBorderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color=color,
            style=style,
            thickness=thickness,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color: Optional[str] = None,
             style: Optional['TemplateTableBorderStyle'] = None,
             thickness: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color is not None:
            _setter("color", color)
        if style is not None:
            _setter("style", style)
        if thickness is not None:
            _setter("thickness", thickness)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def style(self) -> Optional['TemplateTableBorderStyle']:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def thickness(self) -> Optional[float]:
        return pulumi.get(self, "thickness")


@pulumi.output_type
class TemplateTableCellConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "textFormat":
            suggest = "text_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableCellConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableCellConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableCellConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 text_format: Optional['outputs.TemplateTextConditionalFormat'] = None):
        TemplateTableCellConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            text_format=text_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             text_format: Optional['outputs.TemplateTextConditionalFormat'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if text_format is not None:
            _setter("text_format", text_format)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="textFormat")
    def text_format(self) -> Optional['outputs.TemplateTextConditionalFormat']:
        return pulumi.get(self, "text_format")


@pulumi.output_type
class TemplateTableCellImageSizingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableCellImageScalingConfiguration":
            suggest = "table_cell_image_scaling_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableCellImageSizingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableCellImageSizingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableCellImageSizingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_cell_image_scaling_configuration: Optional['TemplateTableCellImageScalingConfiguration'] = None):
        TemplateTableCellImageSizingConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            table_cell_image_scaling_configuration=table_cell_image_scaling_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             table_cell_image_scaling_configuration: Optional['TemplateTableCellImageScalingConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if table_cell_image_scaling_configuration is not None:
            _setter("table_cell_image_scaling_configuration", table_cell_image_scaling_configuration)

    @property
    @pulumi.getter(name="tableCellImageScalingConfiguration")
    def table_cell_image_scaling_configuration(self) -> Optional['TemplateTableCellImageScalingConfiguration']:
        return pulumi.get(self, "table_cell_image_scaling_configuration")


@pulumi.output_type
class TemplateTableCellStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "fontConfiguration":
            suggest = "font_configuration"
        elif key == "horizontalTextAlignment":
            suggest = "horizontal_text_alignment"
        elif key == "textWrap":
            suggest = "text_wrap"
        elif key == "verticalTextAlignment":
            suggest = "vertical_text_alignment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableCellStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableCellStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableCellStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional[str] = None,
                 border: Optional['outputs.TemplateGlobalTableBorderOptions'] = None,
                 font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
                 height: Optional[float] = None,
                 horizontal_text_alignment: Optional['TemplateHorizontalTextAlignment'] = None,
                 text_wrap: Optional['TemplateTextWrap'] = None,
                 vertical_text_alignment: Optional['TemplateVerticalTextAlignment'] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateTableCellStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            border=border,
            font_configuration=font_configuration,
            height=height,
            horizontal_text_alignment=horizontal_text_alignment,
            text_wrap=text_wrap,
            vertical_text_alignment=vertical_text_alignment,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional[str] = None,
             border: Optional['outputs.TemplateGlobalTableBorderOptions'] = None,
             font_configuration: Optional['outputs.TemplateFontConfiguration'] = None,
             height: Optional[float] = None,
             horizontal_text_alignment: Optional['TemplateHorizontalTextAlignment'] = None,
             text_wrap: Optional['TemplateTextWrap'] = None,
             vertical_text_alignment: Optional['TemplateVerticalTextAlignment'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if border is not None:
            _setter("border", border)
        if font_configuration is not None:
            _setter("font_configuration", font_configuration)
        if height is not None:
            _setter("height", height)
        if horizontal_text_alignment is not None:
            _setter("horizontal_text_alignment", horizontal_text_alignment)
        if text_wrap is not None:
            _setter("text_wrap", text_wrap)
        if vertical_text_alignment is not None:
            _setter("vertical_text_alignment", vertical_text_alignment)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def border(self) -> Optional['outputs.TemplateGlobalTableBorderOptions']:
        return pulumi.get(self, "border")

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> Optional['outputs.TemplateFontConfiguration']:
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter
    def height(self) -> Optional[float]:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="horizontalTextAlignment")
    def horizontal_text_alignment(self) -> Optional['TemplateHorizontalTextAlignment']:
        return pulumi.get(self, "horizontal_text_alignment")

    @property
    @pulumi.getter(name="textWrap")
    def text_wrap(self) -> Optional['TemplateTextWrap']:
        return pulumi.get(self, "text_wrap")

    @property
    @pulumi.getter(name="verticalTextAlignment")
    def vertical_text_alignment(self) -> Optional['TemplateVerticalTextAlignment']:
        return pulumi.get(self, "vertical_text_alignment")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateTableConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalFormattingOptions":
            suggest = "conditional_formatting_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_formatting_options: Optional[Sequence['outputs.TemplateTableConditionalFormattingOption']] = None):
        TemplateTableConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditional_formatting_options=conditional_formatting_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditional_formatting_options: Optional[Sequence['outputs.TemplateTableConditionalFormattingOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditional_formatting_options is not None:
            _setter("conditional_formatting_options", conditional_formatting_options)

    @property
    @pulumi.getter(name="conditionalFormattingOptions")
    def conditional_formatting_options(self) -> Optional[Sequence['outputs.TemplateTableConditionalFormattingOption']]:
        return pulumi.get(self, "conditional_formatting_options")


@pulumi.output_type
class TemplateTableConditionalFormattingOption(dict):
    def __init__(__self__, *,
                 cell: Optional['outputs.TemplateTableCellConditionalFormatting'] = None,
                 row: Optional['outputs.TemplateTableRowConditionalFormatting'] = None):
        TemplateTableConditionalFormattingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell=cell,
            row=row,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell: Optional['outputs.TemplateTableCellConditionalFormatting'] = None,
             row: Optional['outputs.TemplateTableRowConditionalFormatting'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell is not None:
            _setter("cell", cell)
        if row is not None:
            _setter("row", row)

    @property
    @pulumi.getter
    def cell(self) -> Optional['outputs.TemplateTableCellConditionalFormatting']:
        return pulumi.get(self, "cell")

    @property
    @pulumi.getter
    def row(self) -> Optional['outputs.TemplateTableRowConditionalFormatting']:
        return pulumi.get(self, "row")


@pulumi.output_type
class TemplateTableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldOptions":
            suggest = "field_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "paginatedReportOptions":
            suggest = "paginated_report_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "tableInlineVisualizations":
            suggest = "table_inline_visualizations"
        elif key == "tableOptions":
            suggest = "table_options"
        elif key == "totalOptions":
            suggest = "total_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_options: Optional['outputs.TemplateTableFieldOptions'] = None,
                 field_wells: Optional['outputs.TemplateTableFieldWells'] = None,
                 paginated_report_options: Optional['outputs.TemplateTablePaginatedReportOptions'] = None,
                 sort_configuration: Optional['outputs.TemplateTableSortConfiguration'] = None,
                 table_inline_visualizations: Optional[Sequence['outputs.TemplateTableInlineVisualization']] = None,
                 table_options: Optional['outputs.TemplateTableOptions'] = None,
                 total_options: Optional['outputs.TemplateTotalOptions'] = None):
        TemplateTableConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_options=field_options,
            field_wells=field_wells,
            paginated_report_options=paginated_report_options,
            sort_configuration=sort_configuration,
            table_inline_visualizations=table_inline_visualizations,
            table_options=table_options,
            total_options=total_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_options: Optional['outputs.TemplateTableFieldOptions'] = None,
             field_wells: Optional['outputs.TemplateTableFieldWells'] = None,
             paginated_report_options: Optional['outputs.TemplateTablePaginatedReportOptions'] = None,
             sort_configuration: Optional['outputs.TemplateTableSortConfiguration'] = None,
             table_inline_visualizations: Optional[Sequence['outputs.TemplateTableInlineVisualization']] = None,
             table_options: Optional['outputs.TemplateTableOptions'] = None,
             total_options: Optional['outputs.TemplateTotalOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_options is not None:
            _setter("field_options", field_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if paginated_report_options is not None:
            _setter("paginated_report_options", paginated_report_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if table_inline_visualizations is not None:
            _setter("table_inline_visualizations", table_inline_visualizations)
        if table_options is not None:
            _setter("table_options", table_options)
        if total_options is not None:
            _setter("total_options", total_options)

    @property
    @pulumi.getter(name="fieldOptions")
    def field_options(self) -> Optional['outputs.TemplateTableFieldOptions']:
        return pulumi.get(self, "field_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateTableFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="paginatedReportOptions")
    def paginated_report_options(self) -> Optional['outputs.TemplateTablePaginatedReportOptions']:
        return pulumi.get(self, "paginated_report_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateTableSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="tableInlineVisualizations")
    def table_inline_visualizations(self) -> Optional[Sequence['outputs.TemplateTableInlineVisualization']]:
        return pulumi.get(self, "table_inline_visualizations")

    @property
    @pulumi.getter(name="tableOptions")
    def table_options(self) -> Optional['outputs.TemplateTableOptions']:
        return pulumi.get(self, "table_options")

    @property
    @pulumi.getter(name="totalOptions")
    def total_options(self) -> Optional['outputs.TemplateTotalOptions']:
        return pulumi.get(self, "total_options")


@pulumi.output_type
class TemplateTableFieldCustomIconContent(dict):
    def __init__(__self__, *,
                 icon: Optional['TemplateTableFieldIconSetType'] = None):
        TemplateTableFieldCustomIconContent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            icon=icon,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             icon: Optional['TemplateTableFieldIconSetType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if icon is not None:
            _setter("icon", icon)

    @property
    @pulumi.getter
    def icon(self) -> Optional['TemplateTableFieldIconSetType']:
        return pulumi.get(self, "icon")


@pulumi.output_type
class TemplateTableFieldCustomTextContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontConfiguration":
            suggest = "font_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableFieldCustomTextContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableFieldCustomTextContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableFieldCustomTextContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_configuration: 'outputs.TemplateFontConfiguration',
                 value: Optional[str] = None):
        TemplateTableFieldCustomTextContent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_configuration=font_configuration,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_configuration: 'outputs.TemplateFontConfiguration',
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("font_configuration", font_configuration)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="fontConfiguration")
    def font_configuration(self) -> 'outputs.TemplateFontConfiguration':
        return pulumi.get(self, "font_configuration")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateTableFieldImageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizingOptions":
            suggest = "sizing_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableFieldImageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableFieldImageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableFieldImageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sizing_options: Optional['outputs.TemplateTableCellImageSizingConfiguration'] = None):
        TemplateTableFieldImageConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sizing_options=sizing_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sizing_options: Optional['outputs.TemplateTableCellImageSizingConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sizing_options is not None:
            _setter("sizing_options", sizing_options)

    @property
    @pulumi.getter(name="sizingOptions")
    def sizing_options(self) -> Optional['outputs.TemplateTableCellImageSizingConfiguration']:
        return pulumi.get(self, "sizing_options")


@pulumi.output_type
class TemplateTableFieldLinkConfiguration(dict):
    def __init__(__self__, *,
                 content: 'outputs.TemplateTableFieldLinkContentConfiguration',
                 target: 'TemplateUrlTargetConfiguration'):
        TemplateTableFieldLinkConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: 'outputs.TemplateTableFieldLinkContentConfiguration',
             target: 'TemplateUrlTargetConfiguration',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        _setter("target", target)

    @property
    @pulumi.getter
    def content(self) -> 'outputs.TemplateTableFieldLinkContentConfiguration':
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def target(self) -> 'TemplateUrlTargetConfiguration':
        return pulumi.get(self, "target")


@pulumi.output_type
class TemplateTableFieldLinkContentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customIconContent":
            suggest = "custom_icon_content"
        elif key == "customTextContent":
            suggest = "custom_text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableFieldLinkContentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableFieldLinkContentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableFieldLinkContentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_icon_content: Optional['outputs.TemplateTableFieldCustomIconContent'] = None,
                 custom_text_content: Optional['outputs.TemplateTableFieldCustomTextContent'] = None):
        TemplateTableFieldLinkContentConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_icon_content=custom_icon_content,
            custom_text_content=custom_text_content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_icon_content: Optional['outputs.TemplateTableFieldCustomIconContent'] = None,
             custom_text_content: Optional['outputs.TemplateTableFieldCustomTextContent'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_icon_content is not None:
            _setter("custom_icon_content", custom_icon_content)
        if custom_text_content is not None:
            _setter("custom_text_content", custom_text_content)

    @property
    @pulumi.getter(name="customIconContent")
    def custom_icon_content(self) -> Optional['outputs.TemplateTableFieldCustomIconContent']:
        return pulumi.get(self, "custom_icon_content")

    @property
    @pulumi.getter(name="customTextContent")
    def custom_text_content(self) -> Optional['outputs.TemplateTableFieldCustomTextContent']:
        return pulumi.get(self, "custom_text_content")


@pulumi.output_type
class TemplateTableFieldOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "customLabel":
            suggest = "custom_label"
        elif key == "urlStyling":
            suggest = "url_styling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableFieldOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableFieldOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableFieldOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: str,
                 custom_label: Optional[str] = None,
                 url_styling: Optional['outputs.TemplateTableFieldUrlConfiguration'] = None,
                 visibility: Optional['TemplateVisibility'] = None,
                 width: Optional[str] = None):
        """
        :param str width: String based length that is composed of value and unit in px
        """
        TemplateTableFieldOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_id=field_id,
            custom_label=custom_label,
            url_styling=url_styling,
            visibility=visibility,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_id: str,
             custom_label: Optional[str] = None,
             url_styling: Optional['outputs.TemplateTableFieldUrlConfiguration'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             width: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_id", field_id)
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if url_styling is not None:
            _setter("url_styling", url_styling)
        if visibility is not None:
            _setter("visibility", visibility)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter(name="urlStyling")
    def url_styling(self) -> Optional['outputs.TemplateTableFieldUrlConfiguration']:
        return pulumi.get(self, "url_styling")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        String based length that is composed of value and unit in px
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class TemplateTableFieldOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pinnedFieldOptions":
            suggest = "pinned_field_options"
        elif key == "selectedFieldOptions":
            suggest = "selected_field_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableFieldOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableFieldOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableFieldOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 order: Optional[Sequence[str]] = None,
                 pinned_field_options: Optional['outputs.TemplateTablePinnedFieldOptions'] = None,
                 selected_field_options: Optional[Sequence['outputs.TemplateTableFieldOption']] = None):
        TemplateTableFieldOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            order=order,
            pinned_field_options=pinned_field_options,
            selected_field_options=selected_field_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             order: Optional[Sequence[str]] = None,
             pinned_field_options: Optional['outputs.TemplateTablePinnedFieldOptions'] = None,
             selected_field_options: Optional[Sequence['outputs.TemplateTableFieldOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if order is not None:
            _setter("order", order)
        if pinned_field_options is not None:
            _setter("pinned_field_options", pinned_field_options)
        if selected_field_options is not None:
            _setter("selected_field_options", selected_field_options)

    @property
    @pulumi.getter
    def order(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="pinnedFieldOptions")
    def pinned_field_options(self) -> Optional['outputs.TemplateTablePinnedFieldOptions']:
        return pulumi.get(self, "pinned_field_options")

    @property
    @pulumi.getter(name="selectedFieldOptions")
    def selected_field_options(self) -> Optional[Sequence['outputs.TemplateTableFieldOption']]:
        return pulumi.get(self, "selected_field_options")


@pulumi.output_type
class TemplateTableFieldUrlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageConfiguration":
            suggest = "image_configuration"
        elif key == "linkConfiguration":
            suggest = "link_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableFieldUrlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableFieldUrlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableFieldUrlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_configuration: Optional['outputs.TemplateTableFieldImageConfiguration'] = None,
                 link_configuration: Optional['outputs.TemplateTableFieldLinkConfiguration'] = None):
        TemplateTableFieldUrlConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            image_configuration=image_configuration,
            link_configuration=link_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             image_configuration: Optional['outputs.TemplateTableFieldImageConfiguration'] = None,
             link_configuration: Optional['outputs.TemplateTableFieldLinkConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if image_configuration is not None:
            _setter("image_configuration", image_configuration)
        if link_configuration is not None:
            _setter("link_configuration", link_configuration)

    @property
    @pulumi.getter(name="imageConfiguration")
    def image_configuration(self) -> Optional['outputs.TemplateTableFieldImageConfiguration']:
        return pulumi.get(self, "image_configuration")

    @property
    @pulumi.getter(name="linkConfiguration")
    def link_configuration(self) -> Optional['outputs.TemplateTableFieldLinkConfiguration']:
        return pulumi.get(self, "link_configuration")


@pulumi.output_type
class TemplateTableFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableAggregatedFieldWells":
            suggest = "table_aggregated_field_wells"
        elif key == "tableUnaggregatedFieldWells":
            suggest = "table_unaggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_aggregated_field_wells: Optional['outputs.TemplateTableAggregatedFieldWells'] = None,
                 table_unaggregated_field_wells: Optional['outputs.TemplateTableUnaggregatedFieldWells'] = None):
        TemplateTableFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            table_aggregated_field_wells=table_aggregated_field_wells,
            table_unaggregated_field_wells=table_unaggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             table_aggregated_field_wells: Optional['outputs.TemplateTableAggregatedFieldWells'] = None,
             table_unaggregated_field_wells: Optional['outputs.TemplateTableUnaggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if table_aggregated_field_wells is not None:
            _setter("table_aggregated_field_wells", table_aggregated_field_wells)
        if table_unaggregated_field_wells is not None:
            _setter("table_unaggregated_field_wells", table_unaggregated_field_wells)

    @property
    @pulumi.getter(name="tableAggregatedFieldWells")
    def table_aggregated_field_wells(self) -> Optional['outputs.TemplateTableAggregatedFieldWells']:
        return pulumi.get(self, "table_aggregated_field_wells")

    @property
    @pulumi.getter(name="tableUnaggregatedFieldWells")
    def table_unaggregated_field_wells(self) -> Optional['outputs.TemplateTableUnaggregatedFieldWells']:
        return pulumi.get(self, "table_unaggregated_field_wells")


@pulumi.output_type
class TemplateTableInlineVisualization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataBars":
            suggest = "data_bars"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableInlineVisualization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableInlineVisualization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableInlineVisualization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_bars: Optional['outputs.TemplateDataBarsOptions'] = None):
        TemplateTableInlineVisualization._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_bars=data_bars,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_bars: Optional['outputs.TemplateDataBarsOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_bars is not None:
            _setter("data_bars", data_bars)

    @property
    @pulumi.getter(name="dataBars")
    def data_bars(self) -> Optional['outputs.TemplateDataBarsOptions']:
        return pulumi.get(self, "data_bars")


@pulumi.output_type
class TemplateTableOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellStyle":
            suggest = "cell_style"
        elif key == "headerStyle":
            suggest = "header_style"
        elif key == "rowAlternateColorOptions":
            suggest = "row_alternate_color_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
                 header_style: Optional['outputs.TemplateTableCellStyle'] = None,
                 orientation: Optional['TemplateTableOrientation'] = None,
                 row_alternate_color_options: Optional['outputs.TemplateRowAlternateColorOptions'] = None):
        TemplateTableOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell_style=cell_style,
            header_style=header_style,
            orientation=orientation,
            row_alternate_color_options=row_alternate_color_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
             header_style: Optional['outputs.TemplateTableCellStyle'] = None,
             orientation: Optional['TemplateTableOrientation'] = None,
             row_alternate_color_options: Optional['outputs.TemplateRowAlternateColorOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell_style is not None:
            _setter("cell_style", cell_style)
        if header_style is not None:
            _setter("header_style", header_style)
        if orientation is not None:
            _setter("orientation", orientation)
        if row_alternate_color_options is not None:
            _setter("row_alternate_color_options", row_alternate_color_options)

    @property
    @pulumi.getter(name="cellStyle")
    def cell_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "cell_style")

    @property
    @pulumi.getter(name="headerStyle")
    def header_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "header_style")

    @property
    @pulumi.getter
    def orientation(self) -> Optional['TemplateTableOrientation']:
        return pulumi.get(self, "orientation")

    @property
    @pulumi.getter(name="rowAlternateColorOptions")
    def row_alternate_color_options(self) -> Optional['outputs.TemplateRowAlternateColorOptions']:
        return pulumi.get(self, "row_alternate_color_options")


@pulumi.output_type
class TemplateTablePaginatedReportOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overflowColumnHeaderVisibility":
            suggest = "overflow_column_header_visibility"
        elif key == "verticalOverflowVisibility":
            suggest = "vertical_overflow_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTablePaginatedReportOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTablePaginatedReportOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTablePaginatedReportOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 overflow_column_header_visibility: Optional['TemplateVisibility'] = None,
                 vertical_overflow_visibility: Optional['TemplateVisibility'] = None):
        TemplateTablePaginatedReportOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            overflow_column_header_visibility=overflow_column_header_visibility,
            vertical_overflow_visibility=vertical_overflow_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             overflow_column_header_visibility: Optional['TemplateVisibility'] = None,
             vertical_overflow_visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if overflow_column_header_visibility is not None:
            _setter("overflow_column_header_visibility", overflow_column_header_visibility)
        if vertical_overflow_visibility is not None:
            _setter("vertical_overflow_visibility", vertical_overflow_visibility)

    @property
    @pulumi.getter(name="overflowColumnHeaderVisibility")
    def overflow_column_header_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "overflow_column_header_visibility")

    @property
    @pulumi.getter(name="verticalOverflowVisibility")
    def vertical_overflow_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "vertical_overflow_visibility")


@pulumi.output_type
class TemplateTablePinnedFieldOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pinnedLeftFields":
            suggest = "pinned_left_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTablePinnedFieldOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTablePinnedFieldOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTablePinnedFieldOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pinned_left_fields: Optional[Sequence[str]] = None):
        TemplateTablePinnedFieldOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pinned_left_fields=pinned_left_fields,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pinned_left_fields: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pinned_left_fields is not None:
            _setter("pinned_left_fields", pinned_left_fields)

    @property
    @pulumi.getter(name="pinnedLeftFields")
    def pinned_left_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "pinned_left_fields")


@pulumi.output_type
class TemplateTableRowConditionalFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableRowConditionalFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableRowConditionalFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableRowConditionalFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
                 text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None):
        TemplateTableRowConditionalFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
             text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional['outputs.TemplateConditionalFormattingColor']:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.TemplateConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class TemplateTableSideBorderOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "innerHorizontal":
            suggest = "inner_horizontal"
        elif key == "innerVertical":
            suggest = "inner_vertical"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableSideBorderOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableSideBorderOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableSideBorderOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bottom: Optional['outputs.TemplateTableBorderOptions'] = None,
                 inner_horizontal: Optional['outputs.TemplateTableBorderOptions'] = None,
                 inner_vertical: Optional['outputs.TemplateTableBorderOptions'] = None,
                 left: Optional['outputs.TemplateTableBorderOptions'] = None,
                 right: Optional['outputs.TemplateTableBorderOptions'] = None,
                 top: Optional['outputs.TemplateTableBorderOptions'] = None):
        TemplateTableSideBorderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bottom=bottom,
            inner_horizontal=inner_horizontal,
            inner_vertical=inner_vertical,
            left=left,
            right=right,
            top=top,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bottom: Optional['outputs.TemplateTableBorderOptions'] = None,
             inner_horizontal: Optional['outputs.TemplateTableBorderOptions'] = None,
             inner_vertical: Optional['outputs.TemplateTableBorderOptions'] = None,
             left: Optional['outputs.TemplateTableBorderOptions'] = None,
             right: Optional['outputs.TemplateTableBorderOptions'] = None,
             top: Optional['outputs.TemplateTableBorderOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bottom is not None:
            _setter("bottom", bottom)
        if inner_horizontal is not None:
            _setter("inner_horizontal", inner_horizontal)
        if inner_vertical is not None:
            _setter("inner_vertical", inner_vertical)
        if left is not None:
            _setter("left", left)
        if right is not None:
            _setter("right", right)
        if top is not None:
            _setter("top", top)

    @property
    @pulumi.getter
    def bottom(self) -> Optional['outputs.TemplateTableBorderOptions']:
        return pulumi.get(self, "bottom")

    @property
    @pulumi.getter(name="innerHorizontal")
    def inner_horizontal(self) -> Optional['outputs.TemplateTableBorderOptions']:
        return pulumi.get(self, "inner_horizontal")

    @property
    @pulumi.getter(name="innerVertical")
    def inner_vertical(self) -> Optional['outputs.TemplateTableBorderOptions']:
        return pulumi.get(self, "inner_vertical")

    @property
    @pulumi.getter
    def left(self) -> Optional['outputs.TemplateTableBorderOptions']:
        return pulumi.get(self, "left")

    @property
    @pulumi.getter
    def right(self) -> Optional['outputs.TemplateTableBorderOptions']:
        return pulumi.get(self, "right")

    @property
    @pulumi.getter
    def top(self) -> Optional['outputs.TemplateTableBorderOptions']:
        return pulumi.get(self, "top")


@pulumi.output_type
class TemplateTableSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paginationConfiguration":
            suggest = "pagination_configuration"
        elif key == "rowSort":
            suggest = "row_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pagination_configuration: Optional['outputs.TemplatePaginationConfiguration'] = None,
                 row_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateTableSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pagination_configuration=pagination_configuration,
            row_sort=row_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pagination_configuration: Optional['outputs.TemplatePaginationConfiguration'] = None,
             row_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pagination_configuration is not None:
            _setter("pagination_configuration", pagination_configuration)
        if row_sort is not None:
            _setter("row_sort", row_sort)

    @property
    @pulumi.getter(name="paginationConfiguration")
    def pagination_configuration(self) -> Optional['outputs.TemplatePaginationConfiguration']:
        return pulumi.get(self, "pagination_configuration")

    @property
    @pulumi.getter(name="rowSort")
    def row_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "row_sort")


@pulumi.output_type
class TemplateTableStyleTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellType":
            suggest = "cell_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableStyleTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableStyleTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableStyleTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cell_type: 'TemplateStyledCellType'):
        TemplateTableStyleTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell_type=cell_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell_type: 'TemplateStyledCellType',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cell_type", cell_type)

    @property
    @pulumi.getter(name="cellType")
    def cell_type(self) -> 'TemplateStyledCellType':
        return pulumi.get(self, "cell_type")


@pulumi.output_type
class TemplateTableUnaggregatedFieldWells(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.TemplateUnaggregatedField']] = None):
        TemplateTableUnaggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Optional[Sequence['outputs.TemplateUnaggregatedField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateUnaggregatedField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateTableVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "conditionalFormatting":
            suggest = "conditional_formatting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTableVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTableVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTableVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateTableConfiguration'] = None,
                 conditional_formatting: Optional['outputs.TemplateTableConditionalFormatting'] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateTableVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            conditional_formatting=conditional_formatting,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateTableConfiguration'] = None,
             conditional_formatting: Optional['outputs.TemplateTableConditionalFormatting'] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if conditional_formatting is not None:
            _setter("conditional_formatting", conditional_formatting)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateTableConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="conditionalFormatting")
    def conditional_formatting(self) -> Optional['outputs.TemplateTableConditionalFormatting']:
        return pulumi.get(self, "conditional_formatting")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        TemplateTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateTextAreaControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "placeholderOptions":
            suggest = "placeholder_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTextAreaControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTextAreaControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTextAreaControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
                 placeholder_options: Optional['outputs.TemplateTextControlPlaceholderOptions'] = None,
                 title_options: Optional['outputs.TemplateLabelOptions'] = None):
        TemplateTextAreaControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            placeholder_options=placeholder_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
             placeholder_options: Optional['outputs.TemplateTextControlPlaceholderOptions'] = None,
             title_options: Optional['outputs.TemplateLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if placeholder_options is not None:
            _setter("placeholder_options", placeholder_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.TemplateSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="placeholderOptions")
    def placeholder_options(self) -> Optional['outputs.TemplateTextControlPlaceholderOptions']:
        return pulumi.get(self, "placeholder_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.TemplateLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class TemplateTextConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "textColor":
            suggest = "text_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTextConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTextConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTextConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
                 icon: Optional['outputs.TemplateConditionalFormattingIcon'] = None,
                 text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None):
        TemplateTextConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            background_color=background_color,
            icon=icon,
            text_color=text_color,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             background_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
             icon: Optional['outputs.TemplateConditionalFormattingIcon'] = None,
             text_color: Optional['outputs.TemplateConditionalFormattingColor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if background_color is not None:
            _setter("background_color", background_color)
        if icon is not None:
            _setter("icon", icon)
        if text_color is not None:
            _setter("text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional['outputs.TemplateConditionalFormattingColor']:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter
    def icon(self) -> Optional['outputs.TemplateConditionalFormattingIcon']:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional['outputs.TemplateConditionalFormattingColor']:
        return pulumi.get(self, "text_color")


@pulumi.output_type
class TemplateTextControlPlaceholderOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateTextControlPlaceholderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateTextFieldControlDisplayOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infoIconLabelOptions":
            suggest = "info_icon_label_options"
        elif key == "placeholderOptions":
            suggest = "placeholder_options"
        elif key == "titleOptions":
            suggest = "title_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTextFieldControlDisplayOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTextFieldControlDisplayOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTextFieldControlDisplayOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
                 placeholder_options: Optional['outputs.TemplateTextControlPlaceholderOptions'] = None,
                 title_options: Optional['outputs.TemplateLabelOptions'] = None):
        TemplateTextFieldControlDisplayOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info_icon_label_options=info_icon_label_options,
            placeholder_options=placeholder_options,
            title_options=title_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info_icon_label_options: Optional['outputs.TemplateSheetControlInfoIconLabelOptions'] = None,
             placeholder_options: Optional['outputs.TemplateTextControlPlaceholderOptions'] = None,
             title_options: Optional['outputs.TemplateLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if info_icon_label_options is not None:
            _setter("info_icon_label_options", info_icon_label_options)
        if placeholder_options is not None:
            _setter("placeholder_options", placeholder_options)
        if title_options is not None:
            _setter("title_options", title_options)

    @property
    @pulumi.getter(name="infoIconLabelOptions")
    def info_icon_label_options(self) -> Optional['outputs.TemplateSheetControlInfoIconLabelOptions']:
        return pulumi.get(self, "info_icon_label_options")

    @property
    @pulumi.getter(name="placeholderOptions")
    def placeholder_options(self) -> Optional['outputs.TemplateTextControlPlaceholderOptions']:
        return pulumi.get(self, "placeholder_options")

    @property
    @pulumi.getter(name="titleOptions")
    def title_options(self) -> Optional['outputs.TemplateLabelOptions']:
        return pulumi.get(self, "title_options")


@pulumi.output_type
class TemplateThousandSeparatorOptions(dict):
    def __init__(__self__, *,
                 symbol: Optional['TemplateNumericSeparatorSymbol'] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateThousandSeparatorOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            symbol=symbol,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             symbol: Optional['TemplateNumericSeparatorSymbol'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if symbol is not None:
            _setter("symbol", symbol)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def symbol(self) -> Optional['TemplateNumericSeparatorSymbol']:
        return pulumi.get(self, "symbol")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateTimeBasedForecastProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lowerBoundary":
            suggest = "lower_boundary"
        elif key == "periodsBackward":
            suggest = "periods_backward"
        elif key == "periodsForward":
            suggest = "periods_forward"
        elif key == "predictionInterval":
            suggest = "prediction_interval"
        elif key == "upperBoundary":
            suggest = "upper_boundary"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTimeBasedForecastProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTimeBasedForecastProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTimeBasedForecastProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lower_boundary: Optional[float] = None,
                 periods_backward: Optional[float] = None,
                 periods_forward: Optional[float] = None,
                 prediction_interval: Optional[float] = None,
                 seasonality: Optional[float] = None,
                 upper_boundary: Optional[float] = None):
        TemplateTimeBasedForecastProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lower_boundary=lower_boundary,
            periods_backward=periods_backward,
            periods_forward=periods_forward,
            prediction_interval=prediction_interval,
            seasonality=seasonality,
            upper_boundary=upper_boundary,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lower_boundary: Optional[float] = None,
             periods_backward: Optional[float] = None,
             periods_forward: Optional[float] = None,
             prediction_interval: Optional[float] = None,
             seasonality: Optional[float] = None,
             upper_boundary: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if lower_boundary is not None:
            _setter("lower_boundary", lower_boundary)
        if periods_backward is not None:
            _setter("periods_backward", periods_backward)
        if periods_forward is not None:
            _setter("periods_forward", periods_forward)
        if prediction_interval is not None:
            _setter("prediction_interval", prediction_interval)
        if seasonality is not None:
            _setter("seasonality", seasonality)
        if upper_boundary is not None:
            _setter("upper_boundary", upper_boundary)

    @property
    @pulumi.getter(name="lowerBoundary")
    def lower_boundary(self) -> Optional[float]:
        return pulumi.get(self, "lower_boundary")

    @property
    @pulumi.getter(name="periodsBackward")
    def periods_backward(self) -> Optional[float]:
        return pulumi.get(self, "periods_backward")

    @property
    @pulumi.getter(name="periodsForward")
    def periods_forward(self) -> Optional[float]:
        return pulumi.get(self, "periods_forward")

    @property
    @pulumi.getter(name="predictionInterval")
    def prediction_interval(self) -> Optional[float]:
        return pulumi.get(self, "prediction_interval")

    @property
    @pulumi.getter
    def seasonality(self) -> Optional[float]:
        return pulumi.get(self, "seasonality")

    @property
    @pulumi.getter(name="upperBoundary")
    def upper_boundary(self) -> Optional[float]:
        return pulumi.get(self, "upper_boundary")


@pulumi.output_type
class TemplateTimeEqualityFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTimeEqualityFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTimeEqualityFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTimeEqualityFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 filter_id: str,
                 parameter_name: Optional[str] = None,
                 time_granularity: Optional['TemplateTimeGranularity'] = None,
                 value: Optional[str] = None):
        TemplateTimeEqualityFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            parameter_name=parameter_name,
            time_granularity=time_granularity,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             filter_id: str,
             parameter_name: Optional[str] = None,
             time_granularity: Optional['TemplateTimeGranularity'] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['TemplateTimeGranularity']:
        return pulumi.get(self, "time_granularity")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateTimeRangeDrillDownFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeMaximum":
            suggest = "range_maximum"
        elif key == "rangeMinimum":
            suggest = "range_minimum"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTimeRangeDrillDownFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTimeRangeDrillDownFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTimeRangeDrillDownFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 range_maximum: str,
                 range_minimum: str,
                 time_granularity: 'TemplateTimeGranularity'):
        TemplateTimeRangeDrillDownFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            range_maximum=range_maximum,
            range_minimum=range_minimum,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             range_maximum: str,
             range_minimum: str,
             time_granularity: 'TemplateTimeGranularity',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("range_maximum", range_maximum)
        _setter("range_minimum", range_minimum)
        _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="rangeMaximum")
    def range_maximum(self) -> str:
        return pulumi.get(self, "range_maximum")

    @property
    @pulumi.getter(name="rangeMinimum")
    def range_minimum(self) -> str:
        return pulumi.get(self, "range_minimum")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> 'TemplateTimeGranularity':
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class TemplateTimeRangeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterId":
            suggest = "filter_id"
        elif key == "nullOption":
            suggest = "null_option"
        elif key == "excludePeriodConfiguration":
            suggest = "exclude_period_configuration"
        elif key == "includeMaximum":
            suggest = "include_maximum"
        elif key == "includeMinimum":
            suggest = "include_minimum"
        elif key == "rangeMaximumValue":
            suggest = "range_maximum_value"
        elif key == "rangeMinimumValue":
            suggest = "range_minimum_value"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTimeRangeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTimeRangeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTimeRangeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 filter_id: str,
                 null_option: 'TemplateFilterNullOption',
                 exclude_period_configuration: Optional['outputs.TemplateExcludePeriodConfiguration'] = None,
                 include_maximum: Optional[bool] = None,
                 include_minimum: Optional[bool] = None,
                 range_maximum_value: Optional['outputs.TemplateTimeRangeFilterValue'] = None,
                 range_minimum_value: Optional['outputs.TemplateTimeRangeFilterValue'] = None,
                 time_granularity: Optional['TemplateTimeGranularity'] = None):
        TemplateTimeRangeFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            filter_id=filter_id,
            null_option=null_option,
            exclude_period_configuration=exclude_period_configuration,
            include_maximum=include_maximum,
            include_minimum=include_minimum,
            range_maximum_value=range_maximum_value,
            range_minimum_value=range_minimum_value,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             filter_id: str,
             null_option: 'TemplateFilterNullOption',
             exclude_period_configuration: Optional['outputs.TemplateExcludePeriodConfiguration'] = None,
             include_maximum: Optional[bool] = None,
             include_minimum: Optional[bool] = None,
             range_maximum_value: Optional['outputs.TemplateTimeRangeFilterValue'] = None,
             range_minimum_value: Optional['outputs.TemplateTimeRangeFilterValue'] = None,
             time_granularity: Optional['TemplateTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("filter_id", filter_id)
        _setter("null_option", null_option)
        if exclude_period_configuration is not None:
            _setter("exclude_period_configuration", exclude_period_configuration)
        if include_maximum is not None:
            _setter("include_maximum", include_maximum)
        if include_minimum is not None:
            _setter("include_minimum", include_minimum)
        if range_maximum_value is not None:
            _setter("range_maximum_value", range_maximum_value)
        if range_minimum_value is not None:
            _setter("range_minimum_value", range_minimum_value)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="nullOption")
    def null_option(self) -> 'TemplateFilterNullOption':
        return pulumi.get(self, "null_option")

    @property
    @pulumi.getter(name="excludePeriodConfiguration")
    def exclude_period_configuration(self) -> Optional['outputs.TemplateExcludePeriodConfiguration']:
        return pulumi.get(self, "exclude_period_configuration")

    @property
    @pulumi.getter(name="includeMaximum")
    def include_maximum(self) -> Optional[bool]:
        return pulumi.get(self, "include_maximum")

    @property
    @pulumi.getter(name="includeMinimum")
    def include_minimum(self) -> Optional[bool]:
        return pulumi.get(self, "include_minimum")

    @property
    @pulumi.getter(name="rangeMaximumValue")
    def range_maximum_value(self) -> Optional['outputs.TemplateTimeRangeFilterValue']:
        return pulumi.get(self, "range_maximum_value")

    @property
    @pulumi.getter(name="rangeMinimumValue")
    def range_minimum_value(self) -> Optional['outputs.TemplateTimeRangeFilterValue']:
        return pulumi.get(self, "range_minimum_value")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['TemplateTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class TemplateTimeRangeFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollingDate":
            suggest = "rolling_date"
        elif key == "staticValue":
            suggest = "static_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTimeRangeFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTimeRangeFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTimeRangeFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 rolling_date: Optional['outputs.TemplateRollingDateConfiguration'] = None,
                 static_value: Optional[str] = None):
        TemplateTimeRangeFilterValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter=parameter,
            rolling_date=rolling_date,
            static_value=static_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter: Optional[str] = None,
             rolling_date: Optional['outputs.TemplateRollingDateConfiguration'] = None,
             static_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if parameter is not None:
            _setter("parameter", parameter)
        if rolling_date is not None:
            _setter("rolling_date", rolling_date)
        if static_value is not None:
            _setter("static_value", static_value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter(name="rollingDate")
    def rolling_date(self) -> Optional['outputs.TemplateRollingDateConfiguration']:
        return pulumi.get(self, "rolling_date")

    @property
    @pulumi.getter(name="staticValue")
    def static_value(self) -> Optional[str]:
        return pulumi.get(self, "static_value")


@pulumi.output_type
class TemplateTooltipItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnTooltipItem":
            suggest = "column_tooltip_item"
        elif key == "fieldTooltipItem":
            suggest = "field_tooltip_item"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTooltipItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTooltipItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTooltipItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_tooltip_item: Optional['outputs.TemplateColumnTooltipItem'] = None,
                 field_tooltip_item: Optional['outputs.TemplateFieldTooltipItem'] = None):
        TemplateTooltipItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_tooltip_item=column_tooltip_item,
            field_tooltip_item=field_tooltip_item,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_tooltip_item: Optional['outputs.TemplateColumnTooltipItem'] = None,
             field_tooltip_item: Optional['outputs.TemplateFieldTooltipItem'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_tooltip_item is not None:
            _setter("column_tooltip_item", column_tooltip_item)
        if field_tooltip_item is not None:
            _setter("field_tooltip_item", field_tooltip_item)

    @property
    @pulumi.getter(name="columnTooltipItem")
    def column_tooltip_item(self) -> Optional['outputs.TemplateColumnTooltipItem']:
        return pulumi.get(self, "column_tooltip_item")

    @property
    @pulumi.getter(name="fieldTooltipItem")
    def field_tooltip_item(self) -> Optional['outputs.TemplateFieldTooltipItem']:
        return pulumi.get(self, "field_tooltip_item")


@pulumi.output_type
class TemplateTooltipOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldBasedTooltip":
            suggest = "field_based_tooltip"
        elif key == "selectedTooltipType":
            suggest = "selected_tooltip_type"
        elif key == "tooltipVisibility":
            suggest = "tooltip_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTooltipOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTooltipOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTooltipOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_based_tooltip: Optional['outputs.TemplateFieldBasedTooltip'] = None,
                 selected_tooltip_type: Optional['TemplateSelectedTooltipType'] = None,
                 tooltip_visibility: Optional['TemplateVisibility'] = None):
        TemplateTooltipOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_based_tooltip=field_based_tooltip,
            selected_tooltip_type=selected_tooltip_type,
            tooltip_visibility=tooltip_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_based_tooltip: Optional['outputs.TemplateFieldBasedTooltip'] = None,
             selected_tooltip_type: Optional['TemplateSelectedTooltipType'] = None,
             tooltip_visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_based_tooltip is not None:
            _setter("field_based_tooltip", field_based_tooltip)
        if selected_tooltip_type is not None:
            _setter("selected_tooltip_type", selected_tooltip_type)
        if tooltip_visibility is not None:
            _setter("tooltip_visibility", tooltip_visibility)

    @property
    @pulumi.getter(name="fieldBasedTooltip")
    def field_based_tooltip(self) -> Optional['outputs.TemplateFieldBasedTooltip']:
        return pulumi.get(self, "field_based_tooltip")

    @property
    @pulumi.getter(name="selectedTooltipType")
    def selected_tooltip_type(self) -> Optional['TemplateSelectedTooltipType']:
        return pulumi.get(self, "selected_tooltip_type")

    @property
    @pulumi.getter(name="tooltipVisibility")
    def tooltip_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "tooltip_visibility")


@pulumi.output_type
class TemplateTopBottomFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationSortConfigurations":
            suggest = "aggregation_sort_configurations"
        elif key == "filterId":
            suggest = "filter_id"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTopBottomFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTopBottomFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTopBottomFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_sort_configurations: Sequence['outputs.TemplateAggregationSortConfiguration'],
                 column: 'outputs.TemplateColumnIdentifier',
                 filter_id: str,
                 limit: Optional[float] = None,
                 parameter_name: Optional[str] = None,
                 time_granularity: Optional['TemplateTimeGranularity'] = None):
        TemplateTopBottomFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_sort_configurations=aggregation_sort_configurations,
            column=column,
            filter_id=filter_id,
            limit=limit,
            parameter_name=parameter_name,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_sort_configurations: Sequence['outputs.TemplateAggregationSortConfiguration'],
             column: 'outputs.TemplateColumnIdentifier',
             filter_id: str,
             limit: Optional[float] = None,
             parameter_name: Optional[str] = None,
             time_granularity: Optional['TemplateTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation_sort_configurations", aggregation_sort_configurations)
        _setter("column", column)
        _setter("filter_id", filter_id)
        if limit is not None:
            _setter("limit", limit)
        if parameter_name is not None:
            _setter("parameter_name", parameter_name)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter(name="aggregationSortConfigurations")
    def aggregation_sort_configurations(self) -> Sequence['outputs.TemplateAggregationSortConfiguration']:
        return pulumi.get(self, "aggregation_sort_configurations")

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter
    def limit(self) -> Optional[float]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['TemplateTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class TemplateTopBottomMoversComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "moverSize":
            suggest = "mover_size"
        elif key == "sortOrder":
            suggest = "sort_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTopBottomMoversComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTopBottomMoversComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTopBottomMoversComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 type: 'TemplateTopBottomComputationType',
                 category: Optional['outputs.TemplateDimensionField'] = None,
                 mover_size: Optional[float] = None,
                 name: Optional[str] = None,
                 sort_order: Optional['TemplateTopBottomSortOrder'] = None,
                 time: Optional['outputs.TemplateDimensionField'] = None,
                 value: Optional['outputs.TemplateMeasureField'] = None):
        TemplateTopBottomMoversComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            type=type,
            category=category,
            mover_size=mover_size,
            name=name,
            sort_order=sort_order,
            time=time,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             type: 'TemplateTopBottomComputationType',
             category: Optional['outputs.TemplateDimensionField'] = None,
             mover_size: Optional[float] = None,
             name: Optional[str] = None,
             sort_order: Optional['TemplateTopBottomSortOrder'] = None,
             time: Optional['outputs.TemplateDimensionField'] = None,
             value: Optional['outputs.TemplateMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        _setter("type", type)
        if category is not None:
            _setter("category", category)
        if mover_size is not None:
            _setter("mover_size", mover_size)
        if name is not None:
            _setter("name", name)
        if sort_order is not None:
            _setter("sort_order", sort_order)
        if time is not None:
            _setter("time", time)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def type(self) -> 'TemplateTopBottomComputationType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional['outputs.TemplateDimensionField']:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="moverSize")
    def mover_size(self) -> Optional[float]:
        return pulumi.get(self, "mover_size")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> Optional['TemplateTopBottomSortOrder']:
        return pulumi.get(self, "sort_order")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.TemplateDimensionField']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.TemplateMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateTopBottomRankedComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"
        elif key == "resultSize":
            suggest = "result_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTopBottomRankedComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTopBottomRankedComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTopBottomRankedComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 type: 'TemplateTopBottomComputationType',
                 category: Optional['outputs.TemplateDimensionField'] = None,
                 name: Optional[str] = None,
                 result_size: Optional[float] = None,
                 value: Optional['outputs.TemplateMeasureField'] = None):
        TemplateTopBottomRankedComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            type=type,
            category=category,
            name=name,
            result_size=result_size,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             type: 'TemplateTopBottomComputationType',
             category: Optional['outputs.TemplateDimensionField'] = None,
             name: Optional[str] = None,
             result_size: Optional[float] = None,
             value: Optional['outputs.TemplateMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        _setter("type", type)
        if category is not None:
            _setter("category", category)
        if name is not None:
            _setter("name", name)
        if result_size is not None:
            _setter("result_size", result_size)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def type(self) -> 'TemplateTopBottomComputationType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional['outputs.TemplateDimensionField']:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resultSize")
    def result_size(self) -> Optional[float]:
        return pulumi.get(self, "result_size")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.TemplateMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateTotalAggregationComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTotalAggregationComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTotalAggregationComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTotalAggregationComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 name: Optional[str] = None,
                 value: Optional['outputs.TemplateMeasureField'] = None):
        TemplateTotalAggregationComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             name: Optional[str] = None,
             value: Optional['outputs.TemplateMeasureField'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.TemplateMeasureField']:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateTotalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLabel":
            suggest = "custom_label"
        elif key == "scrollStatus":
            suggest = "scroll_status"
        elif key == "totalCellStyle":
            suggest = "total_cell_style"
        elif key == "totalsVisibility":
            suggest = "totals_visibility"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTotalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTotalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTotalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_label: Optional[str] = None,
                 placement: Optional['TemplateTableTotalsPlacement'] = None,
                 scroll_status: Optional['TemplateTableTotalsScrollStatus'] = None,
                 total_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
                 totals_visibility: Optional['TemplateVisibility'] = None):
        TemplateTotalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_label=custom_label,
            placement=placement,
            scroll_status=scroll_status,
            total_cell_style=total_cell_style,
            totals_visibility=totals_visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_label: Optional[str] = None,
             placement: Optional['TemplateTableTotalsPlacement'] = None,
             scroll_status: Optional['TemplateTableTotalsScrollStatus'] = None,
             total_cell_style: Optional['outputs.TemplateTableCellStyle'] = None,
             totals_visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_label is not None:
            _setter("custom_label", custom_label)
        if placement is not None:
            _setter("placement", placement)
        if scroll_status is not None:
            _setter("scroll_status", scroll_status)
        if total_cell_style is not None:
            _setter("total_cell_style", total_cell_style)
        if totals_visibility is not None:
            _setter("totals_visibility", totals_visibility)

    @property
    @pulumi.getter(name="customLabel")
    def custom_label(self) -> Optional[str]:
        return pulumi.get(self, "custom_label")

    @property
    @pulumi.getter
    def placement(self) -> Optional['TemplateTableTotalsPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="scrollStatus")
    def scroll_status(self) -> Optional['TemplateTableTotalsScrollStatus']:
        return pulumi.get(self, "scroll_status")

    @property
    @pulumi.getter(name="totalCellStyle")
    def total_cell_style(self) -> Optional['outputs.TemplateTableCellStyle']:
        return pulumi.get(self, "total_cell_style")

    @property
    @pulumi.getter(name="totalsVisibility")
    def totals_visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "totals_visibility")


@pulumi.output_type
class TemplateTreeMapAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 colors: Optional[Sequence['outputs.TemplateMeasureField']] = None,
                 groups: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 sizes: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateTreeMapAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
            groups=groups,
            sizes=sizes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             groups: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             sizes: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if colors is not None:
            _setter("colors", colors)
        if groups is not None:
            _setter("groups", groups)
        if sizes is not None:
            _setter("sizes", sizes)

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def sizes(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "sizes")


@pulumi.output_type
class TemplateTreeMapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorLabelOptions":
            suggest = "color_label_options"
        elif key == "colorScale":
            suggest = "color_scale"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "groupLabelOptions":
            suggest = "group_label_options"
        elif key == "sizeLabelOptions":
            suggest = "size_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTreeMapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTreeMapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTreeMapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 color_scale: Optional['outputs.TemplateColorScale'] = None,
                 data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateTreeMapFieldWells'] = None,
                 group_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 size_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.TemplateTreeMapSortConfiguration'] = None,
                 tooltip: Optional['outputs.TemplateTooltipOptions'] = None):
        TemplateTreeMapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_label_options=color_label_options,
            color_scale=color_scale,
            data_labels=data_labels,
            field_wells=field_wells,
            group_label_options=group_label_options,
            legend=legend,
            size_label_options=size_label_options,
            sort_configuration=sort_configuration,
            tooltip=tooltip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             color_scale: Optional['outputs.TemplateColorScale'] = None,
             data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateTreeMapFieldWells'] = None,
             group_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             size_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.TemplateTreeMapSortConfiguration'] = None,
             tooltip: Optional['outputs.TemplateTooltipOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color_label_options is not None:
            _setter("color_label_options", color_label_options)
        if color_scale is not None:
            _setter("color_scale", color_scale)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if group_label_options is not None:
            _setter("group_label_options", group_label_options)
        if legend is not None:
            _setter("legend", legend)
        if size_label_options is not None:
            _setter("size_label_options", size_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if tooltip is not None:
            _setter("tooltip", tooltip)

    @property
    @pulumi.getter(name="colorLabelOptions")
    def color_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "color_label_options")

    @property
    @pulumi.getter(name="colorScale")
    def color_scale(self) -> Optional['outputs.TemplateColorScale']:
        return pulumi.get(self, "color_scale")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateTreeMapFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="groupLabelOptions")
    def group_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "group_label_options")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="sizeLabelOptions")
    def size_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "size_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateTreeMapSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional['outputs.TemplateTooltipOptions']:
        return pulumi.get(self, "tooltip")


@pulumi.output_type
class TemplateTreeMapFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "treeMapAggregatedFieldWells":
            suggest = "tree_map_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTreeMapFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTreeMapFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTreeMapFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tree_map_aggregated_field_wells: Optional['outputs.TemplateTreeMapAggregatedFieldWells'] = None):
        TemplateTreeMapFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tree_map_aggregated_field_wells=tree_map_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tree_map_aggregated_field_wells: Optional['outputs.TemplateTreeMapAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if tree_map_aggregated_field_wells is not None:
            _setter("tree_map_aggregated_field_wells", tree_map_aggregated_field_wells)

    @property
    @pulumi.getter(name="treeMapAggregatedFieldWells")
    def tree_map_aggregated_field_wells(self) -> Optional['outputs.TemplateTreeMapAggregatedFieldWells']:
        return pulumi.get(self, "tree_map_aggregated_field_wells")


@pulumi.output_type
class TemplateTreeMapSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "treeMapGroupItemsLimitConfiguration":
            suggest = "tree_map_group_items_limit_configuration"
        elif key == "treeMapSort":
            suggest = "tree_map_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTreeMapSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTreeMapSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTreeMapSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tree_map_group_items_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 tree_map_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateTreeMapSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tree_map_group_items_limit_configuration=tree_map_group_items_limit_configuration,
            tree_map_sort=tree_map_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tree_map_group_items_limit_configuration: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             tree_map_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if tree_map_group_items_limit_configuration is not None:
            _setter("tree_map_group_items_limit_configuration", tree_map_group_items_limit_configuration)
        if tree_map_sort is not None:
            _setter("tree_map_sort", tree_map_sort)

    @property
    @pulumi.getter(name="treeMapGroupItemsLimitConfiguration")
    def tree_map_group_items_limit_configuration(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "tree_map_group_items_limit_configuration")

    @property
    @pulumi.getter(name="treeMapSort")
    def tree_map_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "tree_map_sort")


@pulumi.output_type
class TemplateTreeMapVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTreeMapVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTreeMapVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTreeMapVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateTreeMapConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateTreeMapVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateTreeMapConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateTreeMapConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateTrendArrowOptions(dict):
    def __init__(__self__, *,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateTrendArrowOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateUnaggregatedField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"
        elif key == "formatConfiguration":
            suggest = "format_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateUnaggregatedField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateUnaggregatedField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateUnaggregatedField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: 'outputs.TemplateColumnIdentifier',
                 field_id: str,
                 format_configuration: Optional['outputs.TemplateFormatConfiguration'] = None):
        TemplateUnaggregatedField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            field_id=field_id,
            format_configuration=format_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: 'outputs.TemplateColumnIdentifier',
             field_id: str,
             format_configuration: Optional['outputs.TemplateFormatConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("field_id", field_id)
        if format_configuration is not None:
            _setter("format_configuration", format_configuration)

    @property
    @pulumi.getter
    def column(self) -> 'outputs.TemplateColumnIdentifier':
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        return pulumi.get(self, "field_id")

    @property
    @pulumi.getter(name="formatConfiguration")
    def format_configuration(self) -> Optional['outputs.TemplateFormatConfiguration']:
        return pulumi.get(self, "format_configuration")


@pulumi.output_type
class TemplateUniqueValuesComputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computationId":
            suggest = "computation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateUniqueValuesComputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateUniqueValuesComputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateUniqueValuesComputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computation_id: str,
                 category: Optional['outputs.TemplateDimensionField'] = None,
                 name: Optional[str] = None):
        TemplateUniqueValuesComputation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computation_id=computation_id,
            category=category,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computation_id: str,
             category: Optional['outputs.TemplateDimensionField'] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computation_id", computation_id)
        if category is not None:
            _setter("category", category)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="computationId")
    def computation_id(self) -> str:
        return pulumi.get(self, "computation_id")

    @property
    @pulumi.getter
    def category(self) -> Optional['outputs.TemplateDimensionField']:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class TemplateVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdTime":
            suggest = "created_time"
        elif key == "dataSetConfigurations":
            suggest = "data_set_configurations"
        elif key == "sourceEntityArn":
            suggest = "source_entity_arn"
        elif key == "themeArn":
            suggest = "theme_arn"
        elif key == "versionNumber":
            suggest = "version_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_time: Optional[str] = None,
                 data_set_configurations: Optional[Sequence['outputs.TemplateDataSetConfiguration']] = None,
                 description: Optional[str] = None,
                 errors: Optional[Sequence['outputs.TemplateError']] = None,
                 sheets: Optional[Sequence['outputs.TemplateSheet']] = None,
                 source_entity_arn: Optional[str] = None,
                 status: Optional['TemplateResourceStatus'] = None,
                 theme_arn: Optional[str] = None,
                 version_number: Optional[float] = None):
        TemplateVersion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_time=created_time,
            data_set_configurations=data_set_configurations,
            description=description,
            errors=errors,
            sheets=sheets,
            source_entity_arn=source_entity_arn,
            status=status,
            theme_arn=theme_arn,
            version_number=version_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_time: Optional[str] = None,
             data_set_configurations: Optional[Sequence['outputs.TemplateDataSetConfiguration']] = None,
             description: Optional[str] = None,
             errors: Optional[Sequence['outputs.TemplateError']] = None,
             sheets: Optional[Sequence['outputs.TemplateSheet']] = None,
             source_entity_arn: Optional[str] = None,
             status: Optional['TemplateResourceStatus'] = None,
             theme_arn: Optional[str] = None,
             version_number: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if created_time is not None:
            _setter("created_time", created_time)
        if data_set_configurations is not None:
            _setter("data_set_configurations", data_set_configurations)
        if description is not None:
            _setter("description", description)
        if errors is not None:
            _setter("errors", errors)
        if sheets is not None:
            _setter("sheets", sheets)
        if source_entity_arn is not None:
            _setter("source_entity_arn", source_entity_arn)
        if status is not None:
            _setter("status", status)
        if theme_arn is not None:
            _setter("theme_arn", theme_arn)
        if version_number is not None:
            _setter("version_number", version_number)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[str]:
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="dataSetConfigurations")
    def data_set_configurations(self) -> Optional[Sequence['outputs.TemplateDataSetConfiguration']]:
        return pulumi.get(self, "data_set_configurations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.TemplateError']]:
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def sheets(self) -> Optional[Sequence['outputs.TemplateSheet']]:
        return pulumi.get(self, "sheets")

    @property
    @pulumi.getter(name="sourceEntityArn")
    def source_entity_arn(self) -> Optional[str]:
        return pulumi.get(self, "source_entity_arn")

    @property
    @pulumi.getter
    def status(self) -> Optional['TemplateResourceStatus']:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="themeArn")
    def theme_arn(self) -> Optional[str]:
        return pulumi.get(self, "theme_arn")

    @property
    @pulumi.getter(name="versionNumber")
    def version_number(self) -> Optional[float]:
        return pulumi.get(self, "version_number")


@pulumi.output_type
class TemplateVersionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetConfigurations":
            suggest = "data_set_configurations"
        elif key == "analysisDefaults":
            suggest = "analysis_defaults"
        elif key == "calculatedFields":
            suggest = "calculated_fields"
        elif key == "columnConfigurations":
            suggest = "column_configurations"
        elif key == "filterGroups":
            suggest = "filter_groups"
        elif key == "parameterDeclarations":
            suggest = "parameter_declarations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateVersionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateVersionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateVersionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_configurations: Sequence['outputs.TemplateDataSetConfiguration'],
                 analysis_defaults: Optional['outputs.TemplateAnalysisDefaults'] = None,
                 calculated_fields: Optional[Sequence['outputs.TemplateCalculatedField']] = None,
                 column_configurations: Optional[Sequence['outputs.TemplateColumnConfiguration']] = None,
                 filter_groups: Optional[Sequence['outputs.TemplateFilterGroup']] = None,
                 parameter_declarations: Optional[Sequence['outputs.TemplateParameterDeclaration']] = None,
                 sheets: Optional[Sequence['outputs.TemplateSheetDefinition']] = None):
        TemplateVersionDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_configurations=data_set_configurations,
            analysis_defaults=analysis_defaults,
            calculated_fields=calculated_fields,
            column_configurations=column_configurations,
            filter_groups=filter_groups,
            parameter_declarations=parameter_declarations,
            sheets=sheets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_configurations: Sequence['outputs.TemplateDataSetConfiguration'],
             analysis_defaults: Optional['outputs.TemplateAnalysisDefaults'] = None,
             calculated_fields: Optional[Sequence['outputs.TemplateCalculatedField']] = None,
             column_configurations: Optional[Sequence['outputs.TemplateColumnConfiguration']] = None,
             filter_groups: Optional[Sequence['outputs.TemplateFilterGroup']] = None,
             parameter_declarations: Optional[Sequence['outputs.TemplateParameterDeclaration']] = None,
             sheets: Optional[Sequence['outputs.TemplateSheetDefinition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_set_configurations", data_set_configurations)
        if analysis_defaults is not None:
            _setter("analysis_defaults", analysis_defaults)
        if calculated_fields is not None:
            _setter("calculated_fields", calculated_fields)
        if column_configurations is not None:
            _setter("column_configurations", column_configurations)
        if filter_groups is not None:
            _setter("filter_groups", filter_groups)
        if parameter_declarations is not None:
            _setter("parameter_declarations", parameter_declarations)
        if sheets is not None:
            _setter("sheets", sheets)

    @property
    @pulumi.getter(name="dataSetConfigurations")
    def data_set_configurations(self) -> Sequence['outputs.TemplateDataSetConfiguration']:
        return pulumi.get(self, "data_set_configurations")

    @property
    @pulumi.getter(name="analysisDefaults")
    def analysis_defaults(self) -> Optional['outputs.TemplateAnalysisDefaults']:
        return pulumi.get(self, "analysis_defaults")

    @property
    @pulumi.getter(name="calculatedFields")
    def calculated_fields(self) -> Optional[Sequence['outputs.TemplateCalculatedField']]:
        return pulumi.get(self, "calculated_fields")

    @property
    @pulumi.getter(name="columnConfigurations")
    def column_configurations(self) -> Optional[Sequence['outputs.TemplateColumnConfiguration']]:
        return pulumi.get(self, "column_configurations")

    @property
    @pulumi.getter(name="filterGroups")
    def filter_groups(self) -> Optional[Sequence['outputs.TemplateFilterGroup']]:
        return pulumi.get(self, "filter_groups")

    @property
    @pulumi.getter(name="parameterDeclarations")
    def parameter_declarations(self) -> Optional[Sequence['outputs.TemplateParameterDeclaration']]:
        return pulumi.get(self, "parameter_declarations")

    @property
    @pulumi.getter
    def sheets(self) -> Optional[Sequence['outputs.TemplateSheetDefinition']]:
        return pulumi.get(self, "sheets")


@pulumi.output_type
class TemplateVisibleRangeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "percentRange":
            suggest = "percent_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateVisibleRangeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateVisibleRangeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateVisibleRangeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percent_range: Optional['outputs.TemplatePercentVisibleRange'] = None):
        TemplateVisibleRangeOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            percent_range=percent_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             percent_range: Optional['outputs.TemplatePercentVisibleRange'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if percent_range is not None:
            _setter("percent_range", percent_range)

    @property
    @pulumi.getter(name="percentRange")
    def percent_range(self) -> Optional['outputs.TemplatePercentVisibleRange']:
        return pulumi.get(self, "percent_range")


@pulumi.output_type
class TemplateVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "barChartVisual":
            suggest = "bar_chart_visual"
        elif key == "boxPlotVisual":
            suggest = "box_plot_visual"
        elif key == "comboChartVisual":
            suggest = "combo_chart_visual"
        elif key == "customContentVisual":
            suggest = "custom_content_visual"
        elif key == "emptyVisual":
            suggest = "empty_visual"
        elif key == "filledMapVisual":
            suggest = "filled_map_visual"
        elif key == "funnelChartVisual":
            suggest = "funnel_chart_visual"
        elif key == "gaugeChartVisual":
            suggest = "gauge_chart_visual"
        elif key == "geospatialMapVisual":
            suggest = "geospatial_map_visual"
        elif key == "heatMapVisual":
            suggest = "heat_map_visual"
        elif key == "histogramVisual":
            suggest = "histogram_visual"
        elif key == "insightVisual":
            suggest = "insight_visual"
        elif key == "kpiVisual":
            suggest = "kpi_visual"
        elif key == "lineChartVisual":
            suggest = "line_chart_visual"
        elif key == "pieChartVisual":
            suggest = "pie_chart_visual"
        elif key == "pivotTableVisual":
            suggest = "pivot_table_visual"
        elif key == "radarChartVisual":
            suggest = "radar_chart_visual"
        elif key == "sankeyDiagramVisual":
            suggest = "sankey_diagram_visual"
        elif key == "scatterPlotVisual":
            suggest = "scatter_plot_visual"
        elif key == "tableVisual":
            suggest = "table_visual"
        elif key == "treeMapVisual":
            suggest = "tree_map_visual"
        elif key == "waterfallVisual":
            suggest = "waterfall_visual"
        elif key == "wordCloudVisual":
            suggest = "word_cloud_visual"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bar_chart_visual: Optional['outputs.TemplateBarChartVisual'] = None,
                 box_plot_visual: Optional['outputs.TemplateBoxPlotVisual'] = None,
                 combo_chart_visual: Optional['outputs.TemplateComboChartVisual'] = None,
                 custom_content_visual: Optional['outputs.TemplateCustomContentVisual'] = None,
                 empty_visual: Optional['outputs.TemplateEmptyVisual'] = None,
                 filled_map_visual: Optional['outputs.TemplateFilledMapVisual'] = None,
                 funnel_chart_visual: Optional['outputs.TemplateFunnelChartVisual'] = None,
                 gauge_chart_visual: Optional['outputs.TemplateGaugeChartVisual'] = None,
                 geospatial_map_visual: Optional['outputs.TemplateGeospatialMapVisual'] = None,
                 heat_map_visual: Optional['outputs.TemplateHeatMapVisual'] = None,
                 histogram_visual: Optional['outputs.TemplateHistogramVisual'] = None,
                 insight_visual: Optional['outputs.TemplateInsightVisual'] = None,
                 kpi_visual: Optional['outputs.TemplateKpiVisual'] = None,
                 line_chart_visual: Optional['outputs.TemplateLineChartVisual'] = None,
                 pie_chart_visual: Optional['outputs.TemplatePieChartVisual'] = None,
                 pivot_table_visual: Optional['outputs.TemplatePivotTableVisual'] = None,
                 radar_chart_visual: Optional['outputs.TemplateRadarChartVisual'] = None,
                 sankey_diagram_visual: Optional['outputs.TemplateSankeyDiagramVisual'] = None,
                 scatter_plot_visual: Optional['outputs.TemplateScatterPlotVisual'] = None,
                 table_visual: Optional['outputs.TemplateTableVisual'] = None,
                 tree_map_visual: Optional['outputs.TemplateTreeMapVisual'] = None,
                 waterfall_visual: Optional['outputs.TemplateWaterfallVisual'] = None,
                 word_cloud_visual: Optional['outputs.TemplateWordCloudVisual'] = None):
        TemplateVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bar_chart_visual=bar_chart_visual,
            box_plot_visual=box_plot_visual,
            combo_chart_visual=combo_chart_visual,
            custom_content_visual=custom_content_visual,
            empty_visual=empty_visual,
            filled_map_visual=filled_map_visual,
            funnel_chart_visual=funnel_chart_visual,
            gauge_chart_visual=gauge_chart_visual,
            geospatial_map_visual=geospatial_map_visual,
            heat_map_visual=heat_map_visual,
            histogram_visual=histogram_visual,
            insight_visual=insight_visual,
            kpi_visual=kpi_visual,
            line_chart_visual=line_chart_visual,
            pie_chart_visual=pie_chart_visual,
            pivot_table_visual=pivot_table_visual,
            radar_chart_visual=radar_chart_visual,
            sankey_diagram_visual=sankey_diagram_visual,
            scatter_plot_visual=scatter_plot_visual,
            table_visual=table_visual,
            tree_map_visual=tree_map_visual,
            waterfall_visual=waterfall_visual,
            word_cloud_visual=word_cloud_visual,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bar_chart_visual: Optional['outputs.TemplateBarChartVisual'] = None,
             box_plot_visual: Optional['outputs.TemplateBoxPlotVisual'] = None,
             combo_chart_visual: Optional['outputs.TemplateComboChartVisual'] = None,
             custom_content_visual: Optional['outputs.TemplateCustomContentVisual'] = None,
             empty_visual: Optional['outputs.TemplateEmptyVisual'] = None,
             filled_map_visual: Optional['outputs.TemplateFilledMapVisual'] = None,
             funnel_chart_visual: Optional['outputs.TemplateFunnelChartVisual'] = None,
             gauge_chart_visual: Optional['outputs.TemplateGaugeChartVisual'] = None,
             geospatial_map_visual: Optional['outputs.TemplateGeospatialMapVisual'] = None,
             heat_map_visual: Optional['outputs.TemplateHeatMapVisual'] = None,
             histogram_visual: Optional['outputs.TemplateHistogramVisual'] = None,
             insight_visual: Optional['outputs.TemplateInsightVisual'] = None,
             kpi_visual: Optional['outputs.TemplateKpiVisual'] = None,
             line_chart_visual: Optional['outputs.TemplateLineChartVisual'] = None,
             pie_chart_visual: Optional['outputs.TemplatePieChartVisual'] = None,
             pivot_table_visual: Optional['outputs.TemplatePivotTableVisual'] = None,
             radar_chart_visual: Optional['outputs.TemplateRadarChartVisual'] = None,
             sankey_diagram_visual: Optional['outputs.TemplateSankeyDiagramVisual'] = None,
             scatter_plot_visual: Optional['outputs.TemplateScatterPlotVisual'] = None,
             table_visual: Optional['outputs.TemplateTableVisual'] = None,
             tree_map_visual: Optional['outputs.TemplateTreeMapVisual'] = None,
             waterfall_visual: Optional['outputs.TemplateWaterfallVisual'] = None,
             word_cloud_visual: Optional['outputs.TemplateWordCloudVisual'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bar_chart_visual is not None:
            _setter("bar_chart_visual", bar_chart_visual)
        if box_plot_visual is not None:
            _setter("box_plot_visual", box_plot_visual)
        if combo_chart_visual is not None:
            _setter("combo_chart_visual", combo_chart_visual)
        if custom_content_visual is not None:
            _setter("custom_content_visual", custom_content_visual)
        if empty_visual is not None:
            _setter("empty_visual", empty_visual)
        if filled_map_visual is not None:
            _setter("filled_map_visual", filled_map_visual)
        if funnel_chart_visual is not None:
            _setter("funnel_chart_visual", funnel_chart_visual)
        if gauge_chart_visual is not None:
            _setter("gauge_chart_visual", gauge_chart_visual)
        if geospatial_map_visual is not None:
            _setter("geospatial_map_visual", geospatial_map_visual)
        if heat_map_visual is not None:
            _setter("heat_map_visual", heat_map_visual)
        if histogram_visual is not None:
            _setter("histogram_visual", histogram_visual)
        if insight_visual is not None:
            _setter("insight_visual", insight_visual)
        if kpi_visual is not None:
            _setter("kpi_visual", kpi_visual)
        if line_chart_visual is not None:
            _setter("line_chart_visual", line_chart_visual)
        if pie_chart_visual is not None:
            _setter("pie_chart_visual", pie_chart_visual)
        if pivot_table_visual is not None:
            _setter("pivot_table_visual", pivot_table_visual)
        if radar_chart_visual is not None:
            _setter("radar_chart_visual", radar_chart_visual)
        if sankey_diagram_visual is not None:
            _setter("sankey_diagram_visual", sankey_diagram_visual)
        if scatter_plot_visual is not None:
            _setter("scatter_plot_visual", scatter_plot_visual)
        if table_visual is not None:
            _setter("table_visual", table_visual)
        if tree_map_visual is not None:
            _setter("tree_map_visual", tree_map_visual)
        if waterfall_visual is not None:
            _setter("waterfall_visual", waterfall_visual)
        if word_cloud_visual is not None:
            _setter("word_cloud_visual", word_cloud_visual)

    @property
    @pulumi.getter(name="barChartVisual")
    def bar_chart_visual(self) -> Optional['outputs.TemplateBarChartVisual']:
        return pulumi.get(self, "bar_chart_visual")

    @property
    @pulumi.getter(name="boxPlotVisual")
    def box_plot_visual(self) -> Optional['outputs.TemplateBoxPlotVisual']:
        return pulumi.get(self, "box_plot_visual")

    @property
    @pulumi.getter(name="comboChartVisual")
    def combo_chart_visual(self) -> Optional['outputs.TemplateComboChartVisual']:
        return pulumi.get(self, "combo_chart_visual")

    @property
    @pulumi.getter(name="customContentVisual")
    def custom_content_visual(self) -> Optional['outputs.TemplateCustomContentVisual']:
        return pulumi.get(self, "custom_content_visual")

    @property
    @pulumi.getter(name="emptyVisual")
    def empty_visual(self) -> Optional['outputs.TemplateEmptyVisual']:
        return pulumi.get(self, "empty_visual")

    @property
    @pulumi.getter(name="filledMapVisual")
    def filled_map_visual(self) -> Optional['outputs.TemplateFilledMapVisual']:
        return pulumi.get(self, "filled_map_visual")

    @property
    @pulumi.getter(name="funnelChartVisual")
    def funnel_chart_visual(self) -> Optional['outputs.TemplateFunnelChartVisual']:
        return pulumi.get(self, "funnel_chart_visual")

    @property
    @pulumi.getter(name="gaugeChartVisual")
    def gauge_chart_visual(self) -> Optional['outputs.TemplateGaugeChartVisual']:
        return pulumi.get(self, "gauge_chart_visual")

    @property
    @pulumi.getter(name="geospatialMapVisual")
    def geospatial_map_visual(self) -> Optional['outputs.TemplateGeospatialMapVisual']:
        return pulumi.get(self, "geospatial_map_visual")

    @property
    @pulumi.getter(name="heatMapVisual")
    def heat_map_visual(self) -> Optional['outputs.TemplateHeatMapVisual']:
        return pulumi.get(self, "heat_map_visual")

    @property
    @pulumi.getter(name="histogramVisual")
    def histogram_visual(self) -> Optional['outputs.TemplateHistogramVisual']:
        return pulumi.get(self, "histogram_visual")

    @property
    @pulumi.getter(name="insightVisual")
    def insight_visual(self) -> Optional['outputs.TemplateInsightVisual']:
        return pulumi.get(self, "insight_visual")

    @property
    @pulumi.getter(name="kpiVisual")
    def kpi_visual(self) -> Optional['outputs.TemplateKpiVisual']:
        return pulumi.get(self, "kpi_visual")

    @property
    @pulumi.getter(name="lineChartVisual")
    def line_chart_visual(self) -> Optional['outputs.TemplateLineChartVisual']:
        return pulumi.get(self, "line_chart_visual")

    @property
    @pulumi.getter(name="pieChartVisual")
    def pie_chart_visual(self) -> Optional['outputs.TemplatePieChartVisual']:
        return pulumi.get(self, "pie_chart_visual")

    @property
    @pulumi.getter(name="pivotTableVisual")
    def pivot_table_visual(self) -> Optional['outputs.TemplatePivotTableVisual']:
        return pulumi.get(self, "pivot_table_visual")

    @property
    @pulumi.getter(name="radarChartVisual")
    def radar_chart_visual(self) -> Optional['outputs.TemplateRadarChartVisual']:
        return pulumi.get(self, "radar_chart_visual")

    @property
    @pulumi.getter(name="sankeyDiagramVisual")
    def sankey_diagram_visual(self) -> Optional['outputs.TemplateSankeyDiagramVisual']:
        return pulumi.get(self, "sankey_diagram_visual")

    @property
    @pulumi.getter(name="scatterPlotVisual")
    def scatter_plot_visual(self) -> Optional['outputs.TemplateScatterPlotVisual']:
        return pulumi.get(self, "scatter_plot_visual")

    @property
    @pulumi.getter(name="tableVisual")
    def table_visual(self) -> Optional['outputs.TemplateTableVisual']:
        return pulumi.get(self, "table_visual")

    @property
    @pulumi.getter(name="treeMapVisual")
    def tree_map_visual(self) -> Optional['outputs.TemplateTreeMapVisual']:
        return pulumi.get(self, "tree_map_visual")

    @property
    @pulumi.getter(name="waterfallVisual")
    def waterfall_visual(self) -> Optional['outputs.TemplateWaterfallVisual']:
        return pulumi.get(self, "waterfall_visual")

    @property
    @pulumi.getter(name="wordCloudVisual")
    def word_cloud_visual(self) -> Optional['outputs.TemplateWordCloudVisual']:
        return pulumi.get(self, "word_cloud_visual")


@pulumi.output_type
class TemplateVisualCustomAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionOperations":
            suggest = "action_operations"
        elif key == "customActionId":
            suggest = "custom_action_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateVisualCustomAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateVisualCustomAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateVisualCustomAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_operations: Sequence['outputs.TemplateVisualCustomActionOperation'],
                 custom_action_id: str,
                 name: str,
                 trigger: 'TemplateVisualCustomActionTrigger',
                 status: Optional['TemplateWidgetStatus'] = None):
        TemplateVisualCustomAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_operations=action_operations,
            custom_action_id=custom_action_id,
            name=name,
            trigger=trigger,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_operations: Sequence['outputs.TemplateVisualCustomActionOperation'],
             custom_action_id: str,
             name: str,
             trigger: 'TemplateVisualCustomActionTrigger',
             status: Optional['TemplateWidgetStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action_operations", action_operations)
        _setter("custom_action_id", custom_action_id)
        _setter("name", name)
        _setter("trigger", trigger)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="actionOperations")
    def action_operations(self) -> Sequence['outputs.TemplateVisualCustomActionOperation']:
        return pulumi.get(self, "action_operations")

    @property
    @pulumi.getter(name="customActionId")
    def custom_action_id(self) -> str:
        return pulumi.get(self, "custom_action_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def trigger(self) -> 'TemplateVisualCustomActionTrigger':
        return pulumi.get(self, "trigger")

    @property
    @pulumi.getter
    def status(self) -> Optional['TemplateWidgetStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class TemplateVisualCustomActionOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterOperation":
            suggest = "filter_operation"
        elif key == "navigationOperation":
            suggest = "navigation_operation"
        elif key == "setParametersOperation":
            suggest = "set_parameters_operation"
        elif key == "urlOperation":
            suggest = "url_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateVisualCustomActionOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateVisualCustomActionOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateVisualCustomActionOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_operation: Optional['outputs.TemplateCustomActionFilterOperation'] = None,
                 navigation_operation: Optional['outputs.TemplateCustomActionNavigationOperation'] = None,
                 set_parameters_operation: Optional['outputs.TemplateCustomActionSetParametersOperation'] = None,
                 url_operation: Optional['outputs.TemplateCustomActionUrlOperation'] = None):
        TemplateVisualCustomActionOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_operation=filter_operation,
            navigation_operation=navigation_operation,
            set_parameters_operation=set_parameters_operation,
            url_operation=url_operation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_operation: Optional['outputs.TemplateCustomActionFilterOperation'] = None,
             navigation_operation: Optional['outputs.TemplateCustomActionNavigationOperation'] = None,
             set_parameters_operation: Optional['outputs.TemplateCustomActionSetParametersOperation'] = None,
             url_operation: Optional['outputs.TemplateCustomActionUrlOperation'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if filter_operation is not None:
            _setter("filter_operation", filter_operation)
        if navigation_operation is not None:
            _setter("navigation_operation", navigation_operation)
        if set_parameters_operation is not None:
            _setter("set_parameters_operation", set_parameters_operation)
        if url_operation is not None:
            _setter("url_operation", url_operation)

    @property
    @pulumi.getter(name="filterOperation")
    def filter_operation(self) -> Optional['outputs.TemplateCustomActionFilterOperation']:
        return pulumi.get(self, "filter_operation")

    @property
    @pulumi.getter(name="navigationOperation")
    def navigation_operation(self) -> Optional['outputs.TemplateCustomActionNavigationOperation']:
        return pulumi.get(self, "navigation_operation")

    @property
    @pulumi.getter(name="setParametersOperation")
    def set_parameters_operation(self) -> Optional['outputs.TemplateCustomActionSetParametersOperation']:
        return pulumi.get(self, "set_parameters_operation")

    @property
    @pulumi.getter(name="urlOperation")
    def url_operation(self) -> Optional['outputs.TemplateCustomActionUrlOperation']:
        return pulumi.get(self, "url_operation")


@pulumi.output_type
class TemplateVisualPalette(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chartColor":
            suggest = "chart_color"
        elif key == "colorMap":
            suggest = "color_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateVisualPalette. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateVisualPalette.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateVisualPalette.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chart_color: Optional[str] = None,
                 color_map: Optional[Sequence['outputs.TemplateDataPathColor']] = None):
        TemplateVisualPalette._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            chart_color=chart_color,
            color_map=color_map,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             chart_color: Optional[str] = None,
             color_map: Optional[Sequence['outputs.TemplateDataPathColor']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if chart_color is not None:
            _setter("chart_color", chart_color)
        if color_map is not None:
            _setter("color_map", color_map)

    @property
    @pulumi.getter(name="chartColor")
    def chart_color(self) -> Optional[str]:
        return pulumi.get(self, "chart_color")

    @property
    @pulumi.getter(name="colorMap")
    def color_map(self) -> Optional[Sequence['outputs.TemplateDataPathColor']]:
        return pulumi.get(self, "color_map")


@pulumi.output_type
class TemplateVisualSubtitleLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatText":
            suggest = "format_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateVisualSubtitleLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateVisualSubtitleLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateVisualSubtitleLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_text: Optional['outputs.TemplateLongFormatText'] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateVisualSubtitleLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_text=format_text,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_text: Optional['outputs.TemplateLongFormatText'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_text is not None:
            _setter("format_text", format_text)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="formatText")
    def format_text(self) -> Optional['outputs.TemplateLongFormatText']:
        return pulumi.get(self, "format_text")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateVisualTitleLabelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatText":
            suggest = "format_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateVisualTitleLabelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateVisualTitleLabelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateVisualTitleLabelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format_text: Optional['outputs.TemplateShortFormatText'] = None,
                 visibility: Optional['TemplateVisibility'] = None):
        TemplateVisualTitleLabelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format_text=format_text,
            visibility=visibility,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format_text: Optional['outputs.TemplateShortFormatText'] = None,
             visibility: Optional['TemplateVisibility'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if format_text is not None:
            _setter("format_text", format_text)
        if visibility is not None:
            _setter("visibility", visibility)

    @property
    @pulumi.getter(name="formatText")
    def format_text(self) -> Optional['outputs.TemplateShortFormatText']:
        return pulumi.get(self, "format_text")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['TemplateVisibility']:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class TemplateWaterfallChartAggregatedFieldWells(dict):
    def __init__(__self__, *,
                 breakdowns: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 categories: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 values: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateWaterfallChartAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            breakdowns=breakdowns,
            categories=categories,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             breakdowns: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             categories: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             values: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if breakdowns is not None:
            _setter("breakdowns", breakdowns)
        if categories is not None:
            _setter("categories", categories)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def breakdowns(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "breakdowns")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class TemplateWaterfallChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryAxisDisplayOptions":
            suggest = "category_axis_display_options"
        elif key == "categoryAxisLabelOptions":
            suggest = "category_axis_label_options"
        elif key == "dataLabels":
            suggest = "data_labels"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "primaryYAxisDisplayOptions":
            suggest = "primary_y_axis_display_options"
        elif key == "primaryYAxisLabelOptions":
            suggest = "primary_y_axis_label_options"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "visualPalette":
            suggest = "visual_palette"
        elif key == "waterfallChartOptions":
            suggest = "waterfall_chart_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWaterfallChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWaterfallChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWaterfallChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 category_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateWaterfallChartFieldWells'] = None,
                 legend: Optional['outputs.TemplateLegendOptions'] = None,
                 primary_y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
                 primary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 sort_configuration: Optional['outputs.TemplateWaterfallChartSortConfiguration'] = None,
                 visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
                 waterfall_chart_options: Optional['outputs.TemplateWaterfallChartOptions'] = None):
        TemplateWaterfallChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_axis_display_options=category_axis_display_options,
            category_axis_label_options=category_axis_label_options,
            data_labels=data_labels,
            field_wells=field_wells,
            legend=legend,
            primary_y_axis_display_options=primary_y_axis_display_options,
            primary_y_axis_label_options=primary_y_axis_label_options,
            sort_configuration=sort_configuration,
            visual_palette=visual_palette,
            waterfall_chart_options=waterfall_chart_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             category_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             data_labels: Optional['outputs.TemplateDataLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateWaterfallChartFieldWells'] = None,
             legend: Optional['outputs.TemplateLegendOptions'] = None,
             primary_y_axis_display_options: Optional['outputs.TemplateAxisDisplayOptions'] = None,
             primary_y_axis_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             sort_configuration: Optional['outputs.TemplateWaterfallChartSortConfiguration'] = None,
             visual_palette: Optional['outputs.TemplateVisualPalette'] = None,
             waterfall_chart_options: Optional['outputs.TemplateWaterfallChartOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_axis_display_options is not None:
            _setter("category_axis_display_options", category_axis_display_options)
        if category_axis_label_options is not None:
            _setter("category_axis_label_options", category_axis_label_options)
        if data_labels is not None:
            _setter("data_labels", data_labels)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if legend is not None:
            _setter("legend", legend)
        if primary_y_axis_display_options is not None:
            _setter("primary_y_axis_display_options", primary_y_axis_display_options)
        if primary_y_axis_label_options is not None:
            _setter("primary_y_axis_label_options", primary_y_axis_label_options)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if visual_palette is not None:
            _setter("visual_palette", visual_palette)
        if waterfall_chart_options is not None:
            _setter("waterfall_chart_options", waterfall_chart_options)

    @property
    @pulumi.getter(name="categoryAxisDisplayOptions")
    def category_axis_display_options(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "category_axis_display_options")

    @property
    @pulumi.getter(name="categoryAxisLabelOptions")
    def category_axis_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "category_axis_label_options")

    @property
    @pulumi.getter(name="dataLabels")
    def data_labels(self) -> Optional['outputs.TemplateDataLabelOptions']:
        return pulumi.get(self, "data_labels")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateWaterfallChartFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.TemplateLegendOptions']:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="primaryYAxisDisplayOptions")
    def primary_y_axis_display_options(self) -> Optional['outputs.TemplateAxisDisplayOptions']:
        return pulumi.get(self, "primary_y_axis_display_options")

    @property
    @pulumi.getter(name="primaryYAxisLabelOptions")
    def primary_y_axis_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "primary_y_axis_label_options")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateWaterfallChartSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="visualPalette")
    def visual_palette(self) -> Optional['outputs.TemplateVisualPalette']:
        return pulumi.get(self, "visual_palette")

    @property
    @pulumi.getter(name="waterfallChartOptions")
    def waterfall_chart_options(self) -> Optional['outputs.TemplateWaterfallChartOptions']:
        return pulumi.get(self, "waterfall_chart_options")


@pulumi.output_type
class TemplateWaterfallChartFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waterfallChartAggregatedFieldWells":
            suggest = "waterfall_chart_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWaterfallChartFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWaterfallChartFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWaterfallChartFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 waterfall_chart_aggregated_field_wells: Optional['outputs.TemplateWaterfallChartAggregatedFieldWells'] = None):
        TemplateWaterfallChartFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            waterfall_chart_aggregated_field_wells=waterfall_chart_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             waterfall_chart_aggregated_field_wells: Optional['outputs.TemplateWaterfallChartAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if waterfall_chart_aggregated_field_wells is not None:
            _setter("waterfall_chart_aggregated_field_wells", waterfall_chart_aggregated_field_wells)

    @property
    @pulumi.getter(name="waterfallChartAggregatedFieldWells")
    def waterfall_chart_aggregated_field_wells(self) -> Optional['outputs.TemplateWaterfallChartAggregatedFieldWells']:
        return pulumi.get(self, "waterfall_chart_aggregated_field_wells")


@pulumi.output_type
class TemplateWaterfallChartOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalBarLabel":
            suggest = "total_bar_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWaterfallChartOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWaterfallChartOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWaterfallChartOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_bar_label: Optional[str] = None):
        TemplateWaterfallChartOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            total_bar_label=total_bar_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             total_bar_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if total_bar_label is not None:
            _setter("total_bar_label", total_bar_label)

    @property
    @pulumi.getter(name="totalBarLabel")
    def total_bar_label(self) -> Optional[str]:
        return pulumi.get(self, "total_bar_label")


@pulumi.output_type
class TemplateWaterfallChartSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "breakdownItemsLimit":
            suggest = "breakdown_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWaterfallChartSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWaterfallChartSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWaterfallChartSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 breakdown_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateWaterfallChartSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            breakdown_items_limit=breakdown_items_limit,
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             breakdown_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if breakdown_items_limit is not None:
            _setter("breakdown_items_limit", breakdown_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="breakdownItemsLimit")
    def breakdown_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "breakdown_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class TemplateWaterfallVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWaterfallVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWaterfallVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWaterfallVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateWaterfallChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateWaterfallVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateWaterfallChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateWaterfallChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class TemplateWhatIfPointScenario(dict):
    def __init__(__self__, *,
                 date: str,
                 value: float):
        TemplateWhatIfPointScenario._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date=date,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date: str,
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("date", date)
        _setter("value", value)

    @property
    @pulumi.getter
    def date(self) -> str:
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateWhatIfRangeScenario(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWhatIfRangeScenario. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWhatIfRangeScenario.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWhatIfRangeScenario.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str,
                 value: float):
        TemplateWhatIfRangeScenario._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_date=end_date,
            start_date=start_date,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_date: str,
             start_date: str,
             value: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_date", end_date)
        _setter("start_date", start_date)
        _setter("value", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class TemplateWordCloudAggregatedFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWordCloudAggregatedFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWordCloudAggregatedFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWordCloudAggregatedFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_by: Optional[Sequence['outputs.TemplateDimensionField']] = None,
                 size: Optional[Sequence['outputs.TemplateMeasureField']] = None):
        TemplateWordCloudAggregatedFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_by=group_by,
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_by: Optional[Sequence['outputs.TemplateDimensionField']] = None,
             size: Optional[Sequence['outputs.TemplateMeasureField']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_by is not None:
            _setter("group_by", group_by)
        if size is not None:
            _setter("size", size)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[Sequence['outputs.TemplateDimensionField']]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def size(self) -> Optional[Sequence['outputs.TemplateMeasureField']]:
        return pulumi.get(self, "size")


@pulumi.output_type
class TemplateWordCloudChartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryLabelOptions":
            suggest = "category_label_options"
        elif key == "fieldWells":
            suggest = "field_wells"
        elif key == "sortConfiguration":
            suggest = "sort_configuration"
        elif key == "wordCloudOptions":
            suggest = "word_cloud_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWordCloudChartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWordCloudChartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWordCloudChartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
                 field_wells: Optional['outputs.TemplateWordCloudFieldWells'] = None,
                 sort_configuration: Optional['outputs.TemplateWordCloudSortConfiguration'] = None,
                 word_cloud_options: Optional['outputs.TemplateWordCloudOptions'] = None):
        TemplateWordCloudChartConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_label_options=category_label_options,
            field_wells=field_wells,
            sort_configuration=sort_configuration,
            word_cloud_options=word_cloud_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_label_options: Optional['outputs.TemplateChartAxisLabelOptions'] = None,
             field_wells: Optional['outputs.TemplateWordCloudFieldWells'] = None,
             sort_configuration: Optional['outputs.TemplateWordCloudSortConfiguration'] = None,
             word_cloud_options: Optional['outputs.TemplateWordCloudOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_label_options is not None:
            _setter("category_label_options", category_label_options)
        if field_wells is not None:
            _setter("field_wells", field_wells)
        if sort_configuration is not None:
            _setter("sort_configuration", sort_configuration)
        if word_cloud_options is not None:
            _setter("word_cloud_options", word_cloud_options)

    @property
    @pulumi.getter(name="categoryLabelOptions")
    def category_label_options(self) -> Optional['outputs.TemplateChartAxisLabelOptions']:
        return pulumi.get(self, "category_label_options")

    @property
    @pulumi.getter(name="fieldWells")
    def field_wells(self) -> Optional['outputs.TemplateWordCloudFieldWells']:
        return pulumi.get(self, "field_wells")

    @property
    @pulumi.getter(name="sortConfiguration")
    def sort_configuration(self) -> Optional['outputs.TemplateWordCloudSortConfiguration']:
        return pulumi.get(self, "sort_configuration")

    @property
    @pulumi.getter(name="wordCloudOptions")
    def word_cloud_options(self) -> Optional['outputs.TemplateWordCloudOptions']:
        return pulumi.get(self, "word_cloud_options")


@pulumi.output_type
class TemplateWordCloudFieldWells(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wordCloudAggregatedFieldWells":
            suggest = "word_cloud_aggregated_field_wells"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWordCloudFieldWells. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWordCloudFieldWells.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWordCloudFieldWells.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 word_cloud_aggregated_field_wells: Optional['outputs.TemplateWordCloudAggregatedFieldWells'] = None):
        TemplateWordCloudFieldWells._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            word_cloud_aggregated_field_wells=word_cloud_aggregated_field_wells,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             word_cloud_aggregated_field_wells: Optional['outputs.TemplateWordCloudAggregatedFieldWells'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if word_cloud_aggregated_field_wells is not None:
            _setter("word_cloud_aggregated_field_wells", word_cloud_aggregated_field_wells)

    @property
    @pulumi.getter(name="wordCloudAggregatedFieldWells")
    def word_cloud_aggregated_field_wells(self) -> Optional['outputs.TemplateWordCloudAggregatedFieldWells']:
        return pulumi.get(self, "word_cloud_aggregated_field_wells")


@pulumi.output_type
class TemplateWordCloudOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudLayout":
            suggest = "cloud_layout"
        elif key == "maximumStringLength":
            suggest = "maximum_string_length"
        elif key == "wordCasing":
            suggest = "word_casing"
        elif key == "wordOrientation":
            suggest = "word_orientation"
        elif key == "wordPadding":
            suggest = "word_padding"
        elif key == "wordScaling":
            suggest = "word_scaling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWordCloudOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWordCloudOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWordCloudOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_layout: Optional['TemplateWordCloudCloudLayout'] = None,
                 maximum_string_length: Optional[float] = None,
                 word_casing: Optional['TemplateWordCloudWordCasing'] = None,
                 word_orientation: Optional['TemplateWordCloudWordOrientation'] = None,
                 word_padding: Optional['TemplateWordCloudWordPadding'] = None,
                 word_scaling: Optional['TemplateWordCloudWordScaling'] = None):
        TemplateWordCloudOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_layout=cloud_layout,
            maximum_string_length=maximum_string_length,
            word_casing=word_casing,
            word_orientation=word_orientation,
            word_padding=word_padding,
            word_scaling=word_scaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_layout: Optional['TemplateWordCloudCloudLayout'] = None,
             maximum_string_length: Optional[float] = None,
             word_casing: Optional['TemplateWordCloudWordCasing'] = None,
             word_orientation: Optional['TemplateWordCloudWordOrientation'] = None,
             word_padding: Optional['TemplateWordCloudWordPadding'] = None,
             word_scaling: Optional['TemplateWordCloudWordScaling'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cloud_layout is not None:
            _setter("cloud_layout", cloud_layout)
        if maximum_string_length is not None:
            _setter("maximum_string_length", maximum_string_length)
        if word_casing is not None:
            _setter("word_casing", word_casing)
        if word_orientation is not None:
            _setter("word_orientation", word_orientation)
        if word_padding is not None:
            _setter("word_padding", word_padding)
        if word_scaling is not None:
            _setter("word_scaling", word_scaling)

    @property
    @pulumi.getter(name="cloudLayout")
    def cloud_layout(self) -> Optional['TemplateWordCloudCloudLayout']:
        return pulumi.get(self, "cloud_layout")

    @property
    @pulumi.getter(name="maximumStringLength")
    def maximum_string_length(self) -> Optional[float]:
        return pulumi.get(self, "maximum_string_length")

    @property
    @pulumi.getter(name="wordCasing")
    def word_casing(self) -> Optional['TemplateWordCloudWordCasing']:
        return pulumi.get(self, "word_casing")

    @property
    @pulumi.getter(name="wordOrientation")
    def word_orientation(self) -> Optional['TemplateWordCloudWordOrientation']:
        return pulumi.get(self, "word_orientation")

    @property
    @pulumi.getter(name="wordPadding")
    def word_padding(self) -> Optional['TemplateWordCloudWordPadding']:
        return pulumi.get(self, "word_padding")

    @property
    @pulumi.getter(name="wordScaling")
    def word_scaling(self) -> Optional['TemplateWordCloudWordScaling']:
        return pulumi.get(self, "word_scaling")


@pulumi.output_type
class TemplateWordCloudSortConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryItemsLimit":
            suggest = "category_items_limit"
        elif key == "categorySort":
            suggest = "category_sort"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWordCloudSortConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWordCloudSortConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWordCloudSortConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
                 category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None):
        TemplateWordCloudSortConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_items_limit=category_items_limit,
            category_sort=category_sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_items_limit: Optional['outputs.TemplateItemsLimitConfiguration'] = None,
             category_sort: Optional[Sequence['outputs.TemplateFieldSortOptions']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_items_limit is not None:
            _setter("category_items_limit", category_items_limit)
        if category_sort is not None:
            _setter("category_sort", category_sort)

    @property
    @pulumi.getter(name="categoryItemsLimit")
    def category_items_limit(self) -> Optional['outputs.TemplateItemsLimitConfiguration']:
        return pulumi.get(self, "category_items_limit")

    @property
    @pulumi.getter(name="categorySort")
    def category_sort(self) -> Optional[Sequence['outputs.TemplateFieldSortOptions']]:
        return pulumi.get(self, "category_sort")


@pulumi.output_type
class TemplateWordCloudVisual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visualId":
            suggest = "visual_id"
        elif key == "chartConfiguration":
            suggest = "chart_configuration"
        elif key == "columnHierarchies":
            suggest = "column_hierarchies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateWordCloudVisual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateWordCloudVisual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateWordCloudVisual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visual_id: str,
                 actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
                 chart_configuration: Optional['outputs.TemplateWordCloudChartConfiguration'] = None,
                 column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
                 subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
                 title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None):
        TemplateWordCloudVisual._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visual_id=visual_id,
            actions=actions,
            chart_configuration=chart_configuration,
            column_hierarchies=column_hierarchies,
            subtitle=subtitle,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visual_id: str,
             actions: Optional[Sequence['outputs.TemplateVisualCustomAction']] = None,
             chart_configuration: Optional['outputs.TemplateWordCloudChartConfiguration'] = None,
             column_hierarchies: Optional[Sequence['outputs.TemplateColumnHierarchy']] = None,
             subtitle: Optional['outputs.TemplateVisualSubtitleLabelOptions'] = None,
             title: Optional['outputs.TemplateVisualTitleLabelOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("visual_id", visual_id)
        if actions is not None:
            _setter("actions", actions)
        if chart_configuration is not None:
            _setter("chart_configuration", chart_configuration)
        if column_hierarchies is not None:
            _setter("column_hierarchies", column_hierarchies)
        if subtitle is not None:
            _setter("subtitle", subtitle)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="visualId")
    def visual_id(self) -> str:
        return pulumi.get(self, "visual_id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.TemplateVisualCustomAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="chartConfiguration")
    def chart_configuration(self) -> Optional['outputs.TemplateWordCloudChartConfiguration']:
        return pulumi.get(self, "chart_configuration")

    @property
    @pulumi.getter(name="columnHierarchies")
    def column_hierarchies(self) -> Optional[Sequence['outputs.TemplateColumnHierarchy']]:
        return pulumi.get(self, "column_hierarchies")

    @property
    @pulumi.getter
    def subtitle(self) -> Optional['outputs.TemplateVisualSubtitleLabelOptions']:
        return pulumi.get(self, "subtitle")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.TemplateVisualTitleLabelOptions']:
        return pulumi.get(self, "title")


@pulumi.output_type
class ThemeBorderStyle(dict):
    def __init__(__self__, *,
                 show: Optional[bool] = None):
        ThemeBorderStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            show=show,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             show: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if show is not None:
            _setter("show", show)

    @property
    @pulumi.getter
    def show(self) -> Optional[bool]:
        return pulumi.get(self, "show")


@pulumi.output_type
class ThemeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataColorPalette":
            suggest = "data_color_palette"
        elif key == "uiColorPalette":
            suggest = "ui_color_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_color_palette: Optional['outputs.ThemeDataColorPalette'] = None,
                 sheet: Optional['outputs.ThemeSheetStyle'] = None,
                 typography: Optional['outputs.ThemeTypography'] = None,
                 ui_color_palette: Optional['outputs.ThemeUiColorPalette'] = None):
        ThemeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_color_palette=data_color_palette,
            sheet=sheet,
            typography=typography,
            ui_color_palette=ui_color_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_color_palette: Optional['outputs.ThemeDataColorPalette'] = None,
             sheet: Optional['outputs.ThemeSheetStyle'] = None,
             typography: Optional['outputs.ThemeTypography'] = None,
             ui_color_palette: Optional['outputs.ThemeUiColorPalette'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_color_palette is not None:
            _setter("data_color_palette", data_color_palette)
        if sheet is not None:
            _setter("sheet", sheet)
        if typography is not None:
            _setter("typography", typography)
        if ui_color_palette is not None:
            _setter("ui_color_palette", ui_color_palette)

    @property
    @pulumi.getter(name="dataColorPalette")
    def data_color_palette(self) -> Optional['outputs.ThemeDataColorPalette']:
        return pulumi.get(self, "data_color_palette")

    @property
    @pulumi.getter
    def sheet(self) -> Optional['outputs.ThemeSheetStyle']:
        return pulumi.get(self, "sheet")

    @property
    @pulumi.getter
    def typography(self) -> Optional['outputs.ThemeTypography']:
        return pulumi.get(self, "typography")

    @property
    @pulumi.getter(name="uiColorPalette")
    def ui_color_palette(self) -> Optional['outputs.ThemeUiColorPalette']:
        return pulumi.get(self, "ui_color_palette")


@pulumi.output_type
class ThemeDataColorPalette(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emptyFillColor":
            suggest = "empty_fill_color"
        elif key == "minMaxGradient":
            suggest = "min_max_gradient"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeDataColorPalette. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeDataColorPalette.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeDataColorPalette.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 colors: Optional[Sequence[str]] = None,
                 empty_fill_color: Optional[str] = None,
                 min_max_gradient: Optional[Sequence[str]] = None):
        ThemeDataColorPalette._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
            empty_fill_color=empty_fill_color,
            min_max_gradient=min_max_gradient,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence[str]] = None,
             empty_fill_color: Optional[str] = None,
             min_max_gradient: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if colors is not None:
            _setter("colors", colors)
        if empty_fill_color is not None:
            _setter("empty_fill_color", empty_fill_color)
        if min_max_gradient is not None:
            _setter("min_max_gradient", min_max_gradient)

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="emptyFillColor")
    def empty_fill_color(self) -> Optional[str]:
        return pulumi.get(self, "empty_fill_color")

    @property
    @pulumi.getter(name="minMaxGradient")
    def min_max_gradient(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "min_max_gradient")


@pulumi.output_type
class ThemeError(dict):
    def __init__(__self__, *,
                 message: Optional[str] = None,
                 type: Optional['ThemeErrorType'] = None):
        ThemeError._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: Optional[str] = None,
             type: Optional['ThemeErrorType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if message is not None:
            _setter("message", message)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def type(self) -> Optional['ThemeErrorType']:
        return pulumi.get(self, "type")


@pulumi.output_type
class ThemeFont(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontFamily":
            suggest = "font_family"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeFont. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeFont.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeFont.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_family: Optional[str] = None):
        ThemeFont._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_family=font_family,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_family: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if font_family is not None:
            _setter("font_family", font_family)

    @property
    @pulumi.getter(name="fontFamily")
    def font_family(self) -> Optional[str]:
        return pulumi.get(self, "font_family")


@pulumi.output_type
class ThemeGutterStyle(dict):
    def __init__(__self__, *,
                 show: Optional[bool] = None):
        ThemeGutterStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            show=show,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             show: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if show is not None:
            _setter("show", show)

    @property
    @pulumi.getter
    def show(self) -> Optional[bool]:
        return pulumi.get(self, "show")


@pulumi.output_type
class ThemeMarginStyle(dict):
    def __init__(__self__, *,
                 show: Optional[bool] = None):
        ThemeMarginStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            show=show,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             show: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if show is not None:
            _setter("show", show)

    @property
    @pulumi.getter
    def show(self) -> Optional[bool]:
        return pulumi.get(self, "show")


@pulumi.output_type
class ThemeResourcePermission(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str,
                 resource: Optional[str] = None):
        ThemeResourcePermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
            resource=resource,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Sequence[str],
             principal: str,
             resource: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        _setter("principal", principal)
        if resource is not None:
            _setter("resource", resource)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        return pulumi.get(self, "principal")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")


@pulumi.output_type
class ThemeSheetStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tileLayout":
            suggest = "tile_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeSheetStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeSheetStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeSheetStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tile: Optional['outputs.ThemeTileStyle'] = None,
                 tile_layout: Optional['outputs.ThemeTileLayoutStyle'] = None):
        ThemeSheetStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tile=tile,
            tile_layout=tile_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tile: Optional['outputs.ThemeTileStyle'] = None,
             tile_layout: Optional['outputs.ThemeTileLayoutStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if tile is not None:
            _setter("tile", tile)
        if tile_layout is not None:
            _setter("tile_layout", tile_layout)

    @property
    @pulumi.getter
    def tile(self) -> Optional['outputs.ThemeTileStyle']:
        return pulumi.get(self, "tile")

    @property
    @pulumi.getter(name="tileLayout")
    def tile_layout(self) -> Optional['outputs.ThemeTileLayoutStyle']:
        return pulumi.get(self, "tile_layout")


@pulumi.output_type
class ThemeTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        ThemeTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ThemeTileLayoutStyle(dict):
    def __init__(__self__, *,
                 gutter: Optional['outputs.ThemeGutterStyle'] = None,
                 margin: Optional['outputs.ThemeMarginStyle'] = None):
        ThemeTileLayoutStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gutter=gutter,
            margin=margin,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gutter: Optional['outputs.ThemeGutterStyle'] = None,
             margin: Optional['outputs.ThemeMarginStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if gutter is not None:
            _setter("gutter", gutter)
        if margin is not None:
            _setter("margin", margin)

    @property
    @pulumi.getter
    def gutter(self) -> Optional['outputs.ThemeGutterStyle']:
        return pulumi.get(self, "gutter")

    @property
    @pulumi.getter
    def margin(self) -> Optional['outputs.ThemeMarginStyle']:
        return pulumi.get(self, "margin")


@pulumi.output_type
class ThemeTileStyle(dict):
    def __init__(__self__, *,
                 border: Optional['outputs.ThemeBorderStyle'] = None):
        ThemeTileStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            border=border,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             border: Optional['outputs.ThemeBorderStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if border is not None:
            _setter("border", border)

    @property
    @pulumi.getter
    def border(self) -> Optional['outputs.ThemeBorderStyle']:
        return pulumi.get(self, "border")


@pulumi.output_type
class ThemeTypography(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontFamilies":
            suggest = "font_families"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeTypography. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeTypography.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeTypography.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_families: Optional[Sequence['outputs.ThemeFont']] = None):
        ThemeTypography._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_families=font_families,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_families: Optional[Sequence['outputs.ThemeFont']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if font_families is not None:
            _setter("font_families", font_families)

    @property
    @pulumi.getter(name="fontFamilies")
    def font_families(self) -> Optional[Sequence['outputs.ThemeFont']]:
        return pulumi.get(self, "font_families")


@pulumi.output_type
class ThemeUiColorPalette(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accentForeground":
            suggest = "accent_foreground"
        elif key == "dangerForeground":
            suggest = "danger_foreground"
        elif key == "dimensionForeground":
            suggest = "dimension_foreground"
        elif key == "measureForeground":
            suggest = "measure_foreground"
        elif key == "primaryBackground":
            suggest = "primary_background"
        elif key == "primaryForeground":
            suggest = "primary_foreground"
        elif key == "secondaryBackground":
            suggest = "secondary_background"
        elif key == "secondaryForeground":
            suggest = "secondary_foreground"
        elif key == "successForeground":
            suggest = "success_foreground"
        elif key == "warningForeground":
            suggest = "warning_foreground"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeUiColorPalette. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeUiColorPalette.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeUiColorPalette.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accent: Optional[str] = None,
                 accent_foreground: Optional[str] = None,
                 danger: Optional[str] = None,
                 danger_foreground: Optional[str] = None,
                 dimension: Optional[str] = None,
                 dimension_foreground: Optional[str] = None,
                 measure: Optional[str] = None,
                 measure_foreground: Optional[str] = None,
                 primary_background: Optional[str] = None,
                 primary_foreground: Optional[str] = None,
                 secondary_background: Optional[str] = None,
                 secondary_foreground: Optional[str] = None,
                 success: Optional[str] = None,
                 success_foreground: Optional[str] = None,
                 warning: Optional[str] = None,
                 warning_foreground: Optional[str] = None):
        ThemeUiColorPalette._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            accent=accent,
            accent_foreground=accent_foreground,
            danger=danger,
            danger_foreground=danger_foreground,
            dimension=dimension,
            dimension_foreground=dimension_foreground,
            measure=measure,
            measure_foreground=measure_foreground,
            primary_background=primary_background,
            primary_foreground=primary_foreground,
            secondary_background=secondary_background,
            secondary_foreground=secondary_foreground,
            success=success,
            success_foreground=success_foreground,
            warning=warning,
            warning_foreground=warning_foreground,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             accent: Optional[str] = None,
             accent_foreground: Optional[str] = None,
             danger: Optional[str] = None,
             danger_foreground: Optional[str] = None,
             dimension: Optional[str] = None,
             dimension_foreground: Optional[str] = None,
             measure: Optional[str] = None,
             measure_foreground: Optional[str] = None,
             primary_background: Optional[str] = None,
             primary_foreground: Optional[str] = None,
             secondary_background: Optional[str] = None,
             secondary_foreground: Optional[str] = None,
             success: Optional[str] = None,
             success_foreground: Optional[str] = None,
             warning: Optional[str] = None,
             warning_foreground: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if accent is not None:
            _setter("accent", accent)
        if accent_foreground is not None:
            _setter("accent_foreground", accent_foreground)
        if danger is not None:
            _setter("danger", danger)
        if danger_foreground is not None:
            _setter("danger_foreground", danger_foreground)
        if dimension is not None:
            _setter("dimension", dimension)
        if dimension_foreground is not None:
            _setter("dimension_foreground", dimension_foreground)
        if measure is not None:
            _setter("measure", measure)
        if measure_foreground is not None:
            _setter("measure_foreground", measure_foreground)
        if primary_background is not None:
            _setter("primary_background", primary_background)
        if primary_foreground is not None:
            _setter("primary_foreground", primary_foreground)
        if secondary_background is not None:
            _setter("secondary_background", secondary_background)
        if secondary_foreground is not None:
            _setter("secondary_foreground", secondary_foreground)
        if success is not None:
            _setter("success", success)
        if success_foreground is not None:
            _setter("success_foreground", success_foreground)
        if warning is not None:
            _setter("warning", warning)
        if warning_foreground is not None:
            _setter("warning_foreground", warning_foreground)

    @property
    @pulumi.getter
    def accent(self) -> Optional[str]:
        return pulumi.get(self, "accent")

    @property
    @pulumi.getter(name="accentForeground")
    def accent_foreground(self) -> Optional[str]:
        return pulumi.get(self, "accent_foreground")

    @property
    @pulumi.getter
    def danger(self) -> Optional[str]:
        return pulumi.get(self, "danger")

    @property
    @pulumi.getter(name="dangerForeground")
    def danger_foreground(self) -> Optional[str]:
        return pulumi.get(self, "danger_foreground")

    @property
    @pulumi.getter
    def dimension(self) -> Optional[str]:
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="dimensionForeground")
    def dimension_foreground(self) -> Optional[str]:
        return pulumi.get(self, "dimension_foreground")

    @property
    @pulumi.getter
    def measure(self) -> Optional[str]:
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="measureForeground")
    def measure_foreground(self) -> Optional[str]:
        return pulumi.get(self, "measure_foreground")

    @property
    @pulumi.getter(name="primaryBackground")
    def primary_background(self) -> Optional[str]:
        return pulumi.get(self, "primary_background")

    @property
    @pulumi.getter(name="primaryForeground")
    def primary_foreground(self) -> Optional[str]:
        return pulumi.get(self, "primary_foreground")

    @property
    @pulumi.getter(name="secondaryBackground")
    def secondary_background(self) -> Optional[str]:
        return pulumi.get(self, "secondary_background")

    @property
    @pulumi.getter(name="secondaryForeground")
    def secondary_foreground(self) -> Optional[str]:
        return pulumi.get(self, "secondary_foreground")

    @property
    @pulumi.getter
    def success(self) -> Optional[str]:
        return pulumi.get(self, "success")

    @property
    @pulumi.getter(name="successForeground")
    def success_foreground(self) -> Optional[str]:
        return pulumi.get(self, "success_foreground")

    @property
    @pulumi.getter
    def warning(self) -> Optional[str]:
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningForeground")
    def warning_foreground(self) -> Optional[str]:
        return pulumi.get(self, "warning_foreground")


@pulumi.output_type
class ThemeVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseThemeId":
            suggest = "base_theme_id"
        elif key == "createdTime":
            suggest = "created_time"
        elif key == "versionNumber":
            suggest = "version_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 base_theme_id: Optional[str] = None,
                 configuration: Optional['outputs.ThemeConfiguration'] = None,
                 created_time: Optional[str] = None,
                 description: Optional[str] = None,
                 errors: Optional[Sequence['outputs.ThemeError']] = None,
                 status: Optional['ThemeResourceStatus'] = None,
                 version_number: Optional[float] = None):
        ThemeVersion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            base_theme_id=base_theme_id,
            configuration=configuration,
            created_time=created_time,
            description=description,
            errors=errors,
            status=status,
            version_number=version_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             base_theme_id: Optional[str] = None,
             configuration: Optional['outputs.ThemeConfiguration'] = None,
             created_time: Optional[str] = None,
             description: Optional[str] = None,
             errors: Optional[Sequence['outputs.ThemeError']] = None,
             status: Optional['ThemeResourceStatus'] = None,
             version_number: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arn is not None:
            _setter("arn", arn)
        if base_theme_id is not None:
            _setter("base_theme_id", base_theme_id)
        if configuration is not None:
            _setter("configuration", configuration)
        if created_time is not None:
            _setter("created_time", created_time)
        if description is not None:
            _setter("description", description)
        if errors is not None:
            _setter("errors", errors)
        if status is not None:
            _setter("status", status)
        if version_number is not None:
            _setter("version_number", version_number)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="baseThemeId")
    def base_theme_id(self) -> Optional[str]:
        return pulumi.get(self, "base_theme_id")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.ThemeConfiguration']:
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[str]:
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.ThemeError']]:
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def status(self) -> Optional['ThemeResourceStatus']:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="versionNumber")
    def version_number(self) -> Optional[float]:
        return pulumi.get(self, "version_number")


@pulumi.output_type
class TopicAggregationFunctionParameters(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class TopicCalculatedField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "calculatedFieldName":
            suggest = "calculated_field_name"
        elif key == "allowedAggregations":
            suggest = "allowed_aggregations"
        elif key == "calculatedFieldDescription":
            suggest = "calculated_field_description"
        elif key == "calculatedFieldSynonyms":
            suggest = "calculated_field_synonyms"
        elif key == "cellValueSynonyms":
            suggest = "cell_value_synonyms"
        elif key == "columnDataRole":
            suggest = "column_data_role"
        elif key == "comparativeOrder":
            suggest = "comparative_order"
        elif key == "defaultFormatting":
            suggest = "default_formatting"
        elif key == "isIncludedInTopic":
            suggest = "is_included_in_topic"
        elif key == "neverAggregateInFilter":
            suggest = "never_aggregate_in_filter"
        elif key == "notAllowedAggregations":
            suggest = "not_allowed_aggregations"
        elif key == "semanticType":
            suggest = "semantic_type"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicCalculatedField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicCalculatedField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicCalculatedField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 calculated_field_name: str,
                 expression: str,
                 aggregation: Optional['TopicDefaultAggregation'] = None,
                 allowed_aggregations: Optional[Sequence['TopicAuthorSpecifiedAggregation']] = None,
                 calculated_field_description: Optional[str] = None,
                 calculated_field_synonyms: Optional[Sequence[str]] = None,
                 cell_value_synonyms: Optional[Sequence['outputs.TopicCellValueSynonym']] = None,
                 column_data_role: Optional['TopicColumnDataRole'] = None,
                 comparative_order: Optional['outputs.TopicComparativeOrder'] = None,
                 default_formatting: Optional['outputs.TopicDefaultFormatting'] = None,
                 is_included_in_topic: Optional[bool] = None,
                 never_aggregate_in_filter: Optional[bool] = None,
                 not_allowed_aggregations: Optional[Sequence['TopicAuthorSpecifiedAggregation']] = None,
                 semantic_type: Optional['outputs.TopicSemanticType'] = None,
                 time_granularity: Optional['TopicTimeGranularity'] = None):
        TopicCalculatedField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            calculated_field_name=calculated_field_name,
            expression=expression,
            aggregation=aggregation,
            allowed_aggregations=allowed_aggregations,
            calculated_field_description=calculated_field_description,
            calculated_field_synonyms=calculated_field_synonyms,
            cell_value_synonyms=cell_value_synonyms,
            column_data_role=column_data_role,
            comparative_order=comparative_order,
            default_formatting=default_formatting,
            is_included_in_topic=is_included_in_topic,
            never_aggregate_in_filter=never_aggregate_in_filter,
            not_allowed_aggregations=not_allowed_aggregations,
            semantic_type=semantic_type,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             calculated_field_name: str,
             expression: str,
             aggregation: Optional['TopicDefaultAggregation'] = None,
             allowed_aggregations: Optional[Sequence['TopicAuthorSpecifiedAggregation']] = None,
             calculated_field_description: Optional[str] = None,
             calculated_field_synonyms: Optional[Sequence[str]] = None,
             cell_value_synonyms: Optional[Sequence['outputs.TopicCellValueSynonym']] = None,
             column_data_role: Optional['TopicColumnDataRole'] = None,
             comparative_order: Optional['outputs.TopicComparativeOrder'] = None,
             default_formatting: Optional['outputs.TopicDefaultFormatting'] = None,
             is_included_in_topic: Optional[bool] = None,
             never_aggregate_in_filter: Optional[bool] = None,
             not_allowed_aggregations: Optional[Sequence['TopicAuthorSpecifiedAggregation']] = None,
             semantic_type: Optional['outputs.TopicSemanticType'] = None,
             time_granularity: Optional['TopicTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("calculated_field_name", calculated_field_name)
        _setter("expression", expression)
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if allowed_aggregations is not None:
            _setter("allowed_aggregations", allowed_aggregations)
        if calculated_field_description is not None:
            _setter("calculated_field_description", calculated_field_description)
        if calculated_field_synonyms is not None:
            _setter("calculated_field_synonyms", calculated_field_synonyms)
        if cell_value_synonyms is not None:
            _setter("cell_value_synonyms", cell_value_synonyms)
        if column_data_role is not None:
            _setter("column_data_role", column_data_role)
        if comparative_order is not None:
            _setter("comparative_order", comparative_order)
        if default_formatting is not None:
            _setter("default_formatting", default_formatting)
        if is_included_in_topic is not None:
            _setter("is_included_in_topic", is_included_in_topic)
        if never_aggregate_in_filter is not None:
            _setter("never_aggregate_in_filter", never_aggregate_in_filter)
        if not_allowed_aggregations is not None:
            _setter("not_allowed_aggregations", not_allowed_aggregations)
        if semantic_type is not None:
            _setter("semantic_type", semantic_type)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter(name="calculatedFieldName")
    def calculated_field_name(self) -> str:
        return pulumi.get(self, "calculated_field_name")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional['TopicDefaultAggregation']:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="allowedAggregations")
    def allowed_aggregations(self) -> Optional[Sequence['TopicAuthorSpecifiedAggregation']]:
        return pulumi.get(self, "allowed_aggregations")

    @property
    @pulumi.getter(name="calculatedFieldDescription")
    def calculated_field_description(self) -> Optional[str]:
        return pulumi.get(self, "calculated_field_description")

    @property
    @pulumi.getter(name="calculatedFieldSynonyms")
    def calculated_field_synonyms(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "calculated_field_synonyms")

    @property
    @pulumi.getter(name="cellValueSynonyms")
    def cell_value_synonyms(self) -> Optional[Sequence['outputs.TopicCellValueSynonym']]:
        return pulumi.get(self, "cell_value_synonyms")

    @property
    @pulumi.getter(name="columnDataRole")
    def column_data_role(self) -> Optional['TopicColumnDataRole']:
        return pulumi.get(self, "column_data_role")

    @property
    @pulumi.getter(name="comparativeOrder")
    def comparative_order(self) -> Optional['outputs.TopicComparativeOrder']:
        return pulumi.get(self, "comparative_order")

    @property
    @pulumi.getter(name="defaultFormatting")
    def default_formatting(self) -> Optional['outputs.TopicDefaultFormatting']:
        return pulumi.get(self, "default_formatting")

    @property
    @pulumi.getter(name="isIncludedInTopic")
    def is_included_in_topic(self) -> Optional[bool]:
        return pulumi.get(self, "is_included_in_topic")

    @property
    @pulumi.getter(name="neverAggregateInFilter")
    def never_aggregate_in_filter(self) -> Optional[bool]:
        return pulumi.get(self, "never_aggregate_in_filter")

    @property
    @pulumi.getter(name="notAllowedAggregations")
    def not_allowed_aggregations(self) -> Optional[Sequence['TopicAuthorSpecifiedAggregation']]:
        return pulumi.get(self, "not_allowed_aggregations")

    @property
    @pulumi.getter(name="semanticType")
    def semantic_type(self) -> Optional['outputs.TopicSemanticType']:
        return pulumi.get(self, "semantic_type")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['TopicTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class TopicCategoryFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryFilterFunction":
            suggest = "category_filter_function"
        elif key == "categoryFilterType":
            suggest = "category_filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicCategoryFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicCategoryFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicCategoryFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_filter_function: Optional['TopicCategoryFilterFunction'] = None,
                 category_filter_type: Optional['TopicCategoryFilterType'] = None,
                 constant: Optional['outputs.TopicCategoryFilterConstant'] = None,
                 inverse: Optional[bool] = None):
        TopicCategoryFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_filter_function=category_filter_function,
            category_filter_type=category_filter_type,
            constant=constant,
            inverse=inverse,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_filter_function: Optional['TopicCategoryFilterFunction'] = None,
             category_filter_type: Optional['TopicCategoryFilterType'] = None,
             constant: Optional['outputs.TopicCategoryFilterConstant'] = None,
             inverse: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category_filter_function is not None:
            _setter("category_filter_function", category_filter_function)
        if category_filter_type is not None:
            _setter("category_filter_type", category_filter_type)
        if constant is not None:
            _setter("constant", constant)
        if inverse is not None:
            _setter("inverse", inverse)

    @property
    @pulumi.getter(name="categoryFilterFunction")
    def category_filter_function(self) -> Optional['TopicCategoryFilterFunction']:
        return pulumi.get(self, "category_filter_function")

    @property
    @pulumi.getter(name="categoryFilterType")
    def category_filter_type(self) -> Optional['TopicCategoryFilterType']:
        return pulumi.get(self, "category_filter_type")

    @property
    @pulumi.getter
    def constant(self) -> Optional['outputs.TopicCategoryFilterConstant']:
        return pulumi.get(self, "constant")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        return pulumi.get(self, "inverse")


@pulumi.output_type
class TopicCategoryFilterConstant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectiveConstant":
            suggest = "collective_constant"
        elif key == "constantType":
            suggest = "constant_type"
        elif key == "singularConstant":
            suggest = "singular_constant"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicCategoryFilterConstant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicCategoryFilterConstant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicCategoryFilterConstant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collective_constant: Optional['outputs.TopicCollectiveConstant'] = None,
                 constant_type: Optional['TopicConstantType'] = None,
                 singular_constant: Optional[str] = None):
        TopicCategoryFilterConstant._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collective_constant=collective_constant,
            constant_type=constant_type,
            singular_constant=singular_constant,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collective_constant: Optional['outputs.TopicCollectiveConstant'] = None,
             constant_type: Optional['TopicConstantType'] = None,
             singular_constant: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if collective_constant is not None:
            _setter("collective_constant", collective_constant)
        if constant_type is not None:
            _setter("constant_type", constant_type)
        if singular_constant is not None:
            _setter("singular_constant", singular_constant)

    @property
    @pulumi.getter(name="collectiveConstant")
    def collective_constant(self) -> Optional['outputs.TopicCollectiveConstant']:
        return pulumi.get(self, "collective_constant")

    @property
    @pulumi.getter(name="constantType")
    def constant_type(self) -> Optional['TopicConstantType']:
        return pulumi.get(self, "constant_type")

    @property
    @pulumi.getter(name="singularConstant")
    def singular_constant(self) -> Optional[str]:
        return pulumi.get(self, "singular_constant")


@pulumi.output_type
class TopicCellValueSynonym(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellValue":
            suggest = "cell_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicCellValueSynonym. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicCellValueSynonym.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicCellValueSynonym.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cell_value: Optional[str] = None,
                 synonyms: Optional[Sequence[str]] = None):
        TopicCellValueSynonym._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cell_value=cell_value,
            synonyms=synonyms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cell_value: Optional[str] = None,
             synonyms: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cell_value is not None:
            _setter("cell_value", cell_value)
        if synonyms is not None:
            _setter("synonyms", synonyms)

    @property
    @pulumi.getter(name="cellValue")
    def cell_value(self) -> Optional[str]:
        return pulumi.get(self, "cell_value")

    @property
    @pulumi.getter
    def synonyms(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "synonyms")


@pulumi.output_type
class TopicCollectiveConstant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueList":
            suggest = "value_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicCollectiveConstant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicCollectiveConstant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicCollectiveConstant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_list: Optional[Sequence[str]] = None):
        TopicCollectiveConstant._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value_list=value_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value_list: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value_list is not None:
            _setter("value_list", value_list)

    @property
    @pulumi.getter(name="valueList")
    def value_list(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "value_list")


@pulumi.output_type
class TopicColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "allowedAggregations":
            suggest = "allowed_aggregations"
        elif key == "cellValueSynonyms":
            suggest = "cell_value_synonyms"
        elif key == "columnDataRole":
            suggest = "column_data_role"
        elif key == "columnDescription":
            suggest = "column_description"
        elif key == "columnFriendlyName":
            suggest = "column_friendly_name"
        elif key == "columnSynonyms":
            suggest = "column_synonyms"
        elif key == "comparativeOrder":
            suggest = "comparative_order"
        elif key == "defaultFormatting":
            suggest = "default_formatting"
        elif key == "isIncludedInTopic":
            suggest = "is_included_in_topic"
        elif key == "neverAggregateInFilter":
            suggest = "never_aggregate_in_filter"
        elif key == "notAllowedAggregations":
            suggest = "not_allowed_aggregations"
        elif key == "semanticType":
            suggest = "semantic_type"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 aggregation: Optional['TopicDefaultAggregation'] = None,
                 allowed_aggregations: Optional[Sequence['TopicAuthorSpecifiedAggregation']] = None,
                 cell_value_synonyms: Optional[Sequence['outputs.TopicCellValueSynonym']] = None,
                 column_data_role: Optional['TopicColumnDataRole'] = None,
                 column_description: Optional[str] = None,
                 column_friendly_name: Optional[str] = None,
                 column_synonyms: Optional[Sequence[str]] = None,
                 comparative_order: Optional['outputs.TopicComparativeOrder'] = None,
                 default_formatting: Optional['outputs.TopicDefaultFormatting'] = None,
                 is_included_in_topic: Optional[bool] = None,
                 never_aggregate_in_filter: Optional[bool] = None,
                 not_allowed_aggregations: Optional[Sequence['TopicAuthorSpecifiedAggregation']] = None,
                 semantic_type: Optional['outputs.TopicSemanticType'] = None,
                 time_granularity: Optional['TopicTimeGranularity'] = None):
        TopicColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            aggregation=aggregation,
            allowed_aggregations=allowed_aggregations,
            cell_value_synonyms=cell_value_synonyms,
            column_data_role=column_data_role,
            column_description=column_description,
            column_friendly_name=column_friendly_name,
            column_synonyms=column_synonyms,
            comparative_order=comparative_order,
            default_formatting=default_formatting,
            is_included_in_topic=is_included_in_topic,
            never_aggregate_in_filter=never_aggregate_in_filter,
            not_allowed_aggregations=not_allowed_aggregations,
            semantic_type=semantic_type,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: str,
             aggregation: Optional['TopicDefaultAggregation'] = None,
             allowed_aggregations: Optional[Sequence['TopicAuthorSpecifiedAggregation']] = None,
             cell_value_synonyms: Optional[Sequence['outputs.TopicCellValueSynonym']] = None,
             column_data_role: Optional['TopicColumnDataRole'] = None,
             column_description: Optional[str] = None,
             column_friendly_name: Optional[str] = None,
             column_synonyms: Optional[Sequence[str]] = None,
             comparative_order: Optional['outputs.TopicComparativeOrder'] = None,
             default_formatting: Optional['outputs.TopicDefaultFormatting'] = None,
             is_included_in_topic: Optional[bool] = None,
             never_aggregate_in_filter: Optional[bool] = None,
             not_allowed_aggregations: Optional[Sequence['TopicAuthorSpecifiedAggregation']] = None,
             semantic_type: Optional['outputs.TopicSemanticType'] = None,
             time_granularity: Optional['TopicTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column_name", column_name)
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if allowed_aggregations is not None:
            _setter("allowed_aggregations", allowed_aggregations)
        if cell_value_synonyms is not None:
            _setter("cell_value_synonyms", cell_value_synonyms)
        if column_data_role is not None:
            _setter("column_data_role", column_data_role)
        if column_description is not None:
            _setter("column_description", column_description)
        if column_friendly_name is not None:
            _setter("column_friendly_name", column_friendly_name)
        if column_synonyms is not None:
            _setter("column_synonyms", column_synonyms)
        if comparative_order is not None:
            _setter("comparative_order", comparative_order)
        if default_formatting is not None:
            _setter("default_formatting", default_formatting)
        if is_included_in_topic is not None:
            _setter("is_included_in_topic", is_included_in_topic)
        if never_aggregate_in_filter is not None:
            _setter("never_aggregate_in_filter", never_aggregate_in_filter)
        if not_allowed_aggregations is not None:
            _setter("not_allowed_aggregations", not_allowed_aggregations)
        if semantic_type is not None:
            _setter("semantic_type", semantic_type)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional['TopicDefaultAggregation']:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="allowedAggregations")
    def allowed_aggregations(self) -> Optional[Sequence['TopicAuthorSpecifiedAggregation']]:
        return pulumi.get(self, "allowed_aggregations")

    @property
    @pulumi.getter(name="cellValueSynonyms")
    def cell_value_synonyms(self) -> Optional[Sequence['outputs.TopicCellValueSynonym']]:
        return pulumi.get(self, "cell_value_synonyms")

    @property
    @pulumi.getter(name="columnDataRole")
    def column_data_role(self) -> Optional['TopicColumnDataRole']:
        return pulumi.get(self, "column_data_role")

    @property
    @pulumi.getter(name="columnDescription")
    def column_description(self) -> Optional[str]:
        return pulumi.get(self, "column_description")

    @property
    @pulumi.getter(name="columnFriendlyName")
    def column_friendly_name(self) -> Optional[str]:
        return pulumi.get(self, "column_friendly_name")

    @property
    @pulumi.getter(name="columnSynonyms")
    def column_synonyms(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "column_synonyms")

    @property
    @pulumi.getter(name="comparativeOrder")
    def comparative_order(self) -> Optional['outputs.TopicComparativeOrder']:
        return pulumi.get(self, "comparative_order")

    @property
    @pulumi.getter(name="defaultFormatting")
    def default_formatting(self) -> Optional['outputs.TopicDefaultFormatting']:
        return pulumi.get(self, "default_formatting")

    @property
    @pulumi.getter(name="isIncludedInTopic")
    def is_included_in_topic(self) -> Optional[bool]:
        return pulumi.get(self, "is_included_in_topic")

    @property
    @pulumi.getter(name="neverAggregateInFilter")
    def never_aggregate_in_filter(self) -> Optional[bool]:
        return pulumi.get(self, "never_aggregate_in_filter")

    @property
    @pulumi.getter(name="notAllowedAggregations")
    def not_allowed_aggregations(self) -> Optional[Sequence['TopicAuthorSpecifiedAggregation']]:
        return pulumi.get(self, "not_allowed_aggregations")

    @property
    @pulumi.getter(name="semanticType")
    def semantic_type(self) -> Optional['outputs.TopicSemanticType']:
        return pulumi.get(self, "semantic_type")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['TopicTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class TopicComparativeOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "specifedOrder":
            suggest = "specifed_order"
        elif key == "treatUndefinedSpecifiedValues":
            suggest = "treat_undefined_specified_values"
        elif key == "useOrdering":
            suggest = "use_ordering"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicComparativeOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicComparativeOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicComparativeOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 specifed_order: Optional[Sequence[str]] = None,
                 treat_undefined_specified_values: Optional['TopicUndefinedSpecifiedValueType'] = None,
                 use_ordering: Optional['TopicColumnOrderingType'] = None):
        TopicComparativeOrder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            specifed_order=specifed_order,
            treat_undefined_specified_values=treat_undefined_specified_values,
            use_ordering=use_ordering,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             specifed_order: Optional[Sequence[str]] = None,
             treat_undefined_specified_values: Optional['TopicUndefinedSpecifiedValueType'] = None,
             use_ordering: Optional['TopicColumnOrderingType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if specifed_order is not None:
            _setter("specifed_order", specifed_order)
        if treat_undefined_specified_values is not None:
            _setter("treat_undefined_specified_values", treat_undefined_specified_values)
        if use_ordering is not None:
            _setter("use_ordering", use_ordering)

    @property
    @pulumi.getter(name="specifedOrder")
    def specifed_order(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "specifed_order")

    @property
    @pulumi.getter(name="treatUndefinedSpecifiedValues")
    def treat_undefined_specified_values(self) -> Optional['TopicUndefinedSpecifiedValueType']:
        return pulumi.get(self, "treat_undefined_specified_values")

    @property
    @pulumi.getter(name="useOrdering")
    def use_ordering(self) -> Optional['TopicColumnOrderingType']:
        return pulumi.get(self, "use_ordering")


@pulumi.output_type
class TopicDataAggregation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetRowDateGranularity":
            suggest = "dataset_row_date_granularity"
        elif key == "defaultDateColumnName":
            suggest = "default_date_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicDataAggregation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicDataAggregation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicDataAggregation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_row_date_granularity: Optional['TopicTimeGranularity'] = None,
                 default_date_column_name: Optional[str] = None):
        TopicDataAggregation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dataset_row_date_granularity=dataset_row_date_granularity,
            default_date_column_name=default_date_column_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dataset_row_date_granularity: Optional['TopicTimeGranularity'] = None,
             default_date_column_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dataset_row_date_granularity is not None:
            _setter("dataset_row_date_granularity", dataset_row_date_granularity)
        if default_date_column_name is not None:
            _setter("default_date_column_name", default_date_column_name)

    @property
    @pulumi.getter(name="datasetRowDateGranularity")
    def dataset_row_date_granularity(self) -> Optional['TopicTimeGranularity']:
        return pulumi.get(self, "dataset_row_date_granularity")

    @property
    @pulumi.getter(name="defaultDateColumnName")
    def default_date_column_name(self) -> Optional[str]:
        return pulumi.get(self, "default_date_column_name")


@pulumi.output_type
class TopicDatasetMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetArn":
            suggest = "dataset_arn"
        elif key == "calculatedFields":
            suggest = "calculated_fields"
        elif key == "dataAggregation":
            suggest = "data_aggregation"
        elif key == "datasetDescription":
            suggest = "dataset_description"
        elif key == "datasetName":
            suggest = "dataset_name"
        elif key == "namedEntities":
            suggest = "named_entities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicDatasetMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicDatasetMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicDatasetMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_arn: str,
                 calculated_fields: Optional[Sequence['outputs.TopicCalculatedField']] = None,
                 columns: Optional[Sequence['outputs.TopicColumn']] = None,
                 data_aggregation: Optional['outputs.TopicDataAggregation'] = None,
                 dataset_description: Optional[str] = None,
                 dataset_name: Optional[str] = None,
                 filters: Optional[Sequence['outputs.TopicFilter']] = None,
                 named_entities: Optional[Sequence['outputs.TopicNamedEntity']] = None):
        TopicDatasetMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dataset_arn=dataset_arn,
            calculated_fields=calculated_fields,
            columns=columns,
            data_aggregation=data_aggregation,
            dataset_description=dataset_description,
            dataset_name=dataset_name,
            filters=filters,
            named_entities=named_entities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dataset_arn: str,
             calculated_fields: Optional[Sequence['outputs.TopicCalculatedField']] = None,
             columns: Optional[Sequence['outputs.TopicColumn']] = None,
             data_aggregation: Optional['outputs.TopicDataAggregation'] = None,
             dataset_description: Optional[str] = None,
             dataset_name: Optional[str] = None,
             filters: Optional[Sequence['outputs.TopicFilter']] = None,
             named_entities: Optional[Sequence['outputs.TopicNamedEntity']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dataset_arn", dataset_arn)
        if calculated_fields is not None:
            _setter("calculated_fields", calculated_fields)
        if columns is not None:
            _setter("columns", columns)
        if data_aggregation is not None:
            _setter("data_aggregation", data_aggregation)
        if dataset_description is not None:
            _setter("dataset_description", dataset_description)
        if dataset_name is not None:
            _setter("dataset_name", dataset_name)
        if filters is not None:
            _setter("filters", filters)
        if named_entities is not None:
            _setter("named_entities", named_entities)

    @property
    @pulumi.getter(name="datasetArn")
    def dataset_arn(self) -> str:
        return pulumi.get(self, "dataset_arn")

    @property
    @pulumi.getter(name="calculatedFields")
    def calculated_fields(self) -> Optional[Sequence['outputs.TopicCalculatedField']]:
        return pulumi.get(self, "calculated_fields")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.TopicColumn']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="dataAggregation")
    def data_aggregation(self) -> Optional['outputs.TopicDataAggregation']:
        return pulumi.get(self, "data_aggregation")

    @property
    @pulumi.getter(name="datasetDescription")
    def dataset_description(self) -> Optional[str]:
        return pulumi.get(self, "dataset_description")

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> Optional[str]:
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.TopicFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="namedEntities")
    def named_entities(self) -> Optional[Sequence['outputs.TopicNamedEntity']]:
        return pulumi.get(self, "named_entities")


@pulumi.output_type
class TopicDateRangeFilter(dict):
    def __init__(__self__, *,
                 constant: Optional['outputs.TopicRangeFilterConstant'] = None,
                 inclusive: Optional[bool] = None):
        TopicDateRangeFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            constant=constant,
            inclusive=inclusive,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             constant: Optional['outputs.TopicRangeFilterConstant'] = None,
             inclusive: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if constant is not None:
            _setter("constant", constant)
        if inclusive is not None:
            _setter("inclusive", inclusive)

    @property
    @pulumi.getter
    def constant(self) -> Optional['outputs.TopicRangeFilterConstant']:
        return pulumi.get(self, "constant")

    @property
    @pulumi.getter
    def inclusive(self) -> Optional[bool]:
        return pulumi.get(self, "inclusive")


@pulumi.output_type
class TopicDefaultFormatting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayFormat":
            suggest = "display_format"
        elif key == "displayFormatOptions":
            suggest = "display_format_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicDefaultFormatting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicDefaultFormatting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicDefaultFormatting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_format: Optional['TopicDisplayFormat'] = None,
                 display_format_options: Optional['outputs.TopicDisplayFormatOptions'] = None):
        TopicDefaultFormatting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_format=display_format,
            display_format_options=display_format_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_format: Optional['TopicDisplayFormat'] = None,
             display_format_options: Optional['outputs.TopicDisplayFormatOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if display_format is not None:
            _setter("display_format", display_format)
        if display_format_options is not None:
            _setter("display_format_options", display_format_options)

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional['TopicDisplayFormat']:
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="displayFormatOptions")
    def display_format_options(self) -> Optional['outputs.TopicDisplayFormatOptions']:
        return pulumi.get(self, "display_format_options")


@pulumi.output_type
class TopicDisplayFormatOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blankCellFormat":
            suggest = "blank_cell_format"
        elif key == "currencySymbol":
            suggest = "currency_symbol"
        elif key == "dateFormat":
            suggest = "date_format"
        elif key == "decimalSeparator":
            suggest = "decimal_separator"
        elif key == "fractionDigits":
            suggest = "fraction_digits"
        elif key == "groupingSeparator":
            suggest = "grouping_separator"
        elif key == "negativeFormat":
            suggest = "negative_format"
        elif key == "unitScaler":
            suggest = "unit_scaler"
        elif key == "useBlankCellFormat":
            suggest = "use_blank_cell_format"
        elif key == "useGrouping":
            suggest = "use_grouping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicDisplayFormatOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicDisplayFormatOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicDisplayFormatOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blank_cell_format: Optional[str] = None,
                 currency_symbol: Optional[str] = None,
                 date_format: Optional[str] = None,
                 decimal_separator: Optional['TopicNumericSeparatorSymbol'] = None,
                 fraction_digits: Optional[float] = None,
                 grouping_separator: Optional[str] = None,
                 negative_format: Optional['outputs.TopicNegativeFormat'] = None,
                 prefix: Optional[str] = None,
                 suffix: Optional[str] = None,
                 unit_scaler: Optional['TopicNumberScale'] = None,
                 use_blank_cell_format: Optional[bool] = None,
                 use_grouping: Optional[bool] = None):
        TopicDisplayFormatOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            blank_cell_format=blank_cell_format,
            currency_symbol=currency_symbol,
            date_format=date_format,
            decimal_separator=decimal_separator,
            fraction_digits=fraction_digits,
            grouping_separator=grouping_separator,
            negative_format=negative_format,
            prefix=prefix,
            suffix=suffix,
            unit_scaler=unit_scaler,
            use_blank_cell_format=use_blank_cell_format,
            use_grouping=use_grouping,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             blank_cell_format: Optional[str] = None,
             currency_symbol: Optional[str] = None,
             date_format: Optional[str] = None,
             decimal_separator: Optional['TopicNumericSeparatorSymbol'] = None,
             fraction_digits: Optional[float] = None,
             grouping_separator: Optional[str] = None,
             negative_format: Optional['outputs.TopicNegativeFormat'] = None,
             prefix: Optional[str] = None,
             suffix: Optional[str] = None,
             unit_scaler: Optional['TopicNumberScale'] = None,
             use_blank_cell_format: Optional[bool] = None,
             use_grouping: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if blank_cell_format is not None:
            _setter("blank_cell_format", blank_cell_format)
        if currency_symbol is not None:
            _setter("currency_symbol", currency_symbol)
        if date_format is not None:
            _setter("date_format", date_format)
        if decimal_separator is not None:
            _setter("decimal_separator", decimal_separator)
        if fraction_digits is not None:
            _setter("fraction_digits", fraction_digits)
        if grouping_separator is not None:
            _setter("grouping_separator", grouping_separator)
        if negative_format is not None:
            _setter("negative_format", negative_format)
        if prefix is not None:
            _setter("prefix", prefix)
        if suffix is not None:
            _setter("suffix", suffix)
        if unit_scaler is not None:
            _setter("unit_scaler", unit_scaler)
        if use_blank_cell_format is not None:
            _setter("use_blank_cell_format", use_blank_cell_format)
        if use_grouping is not None:
            _setter("use_grouping", use_grouping)

    @property
    @pulumi.getter(name="blankCellFormat")
    def blank_cell_format(self) -> Optional[str]:
        return pulumi.get(self, "blank_cell_format")

    @property
    @pulumi.getter(name="currencySymbol")
    def currency_symbol(self) -> Optional[str]:
        return pulumi.get(self, "currency_symbol")

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> Optional[str]:
        return pulumi.get(self, "date_format")

    @property
    @pulumi.getter(name="decimalSeparator")
    def decimal_separator(self) -> Optional['TopicNumericSeparatorSymbol']:
        return pulumi.get(self, "decimal_separator")

    @property
    @pulumi.getter(name="fractionDigits")
    def fraction_digits(self) -> Optional[float]:
        return pulumi.get(self, "fraction_digits")

    @property
    @pulumi.getter(name="groupingSeparator")
    def grouping_separator(self) -> Optional[str]:
        return pulumi.get(self, "grouping_separator")

    @property
    @pulumi.getter(name="negativeFormat")
    def negative_format(self) -> Optional['outputs.TopicNegativeFormat']:
        return pulumi.get(self, "negative_format")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="unitScaler")
    def unit_scaler(self) -> Optional['TopicNumberScale']:
        return pulumi.get(self, "unit_scaler")

    @property
    @pulumi.getter(name="useBlankCellFormat")
    def use_blank_cell_format(self) -> Optional[bool]:
        return pulumi.get(self, "use_blank_cell_format")

    @property
    @pulumi.getter(name="useGrouping")
    def use_grouping(self) -> Optional[bool]:
        return pulumi.get(self, "use_grouping")


@pulumi.output_type
class TopicFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterName":
            suggest = "filter_name"
        elif key == "operandFieldName":
            suggest = "operand_field_name"
        elif key == "categoryFilter":
            suggest = "category_filter"
        elif key == "dateRangeFilter":
            suggest = "date_range_filter"
        elif key == "filterClass":
            suggest = "filter_class"
        elif key == "filterDescription":
            suggest = "filter_description"
        elif key == "filterSynonyms":
            suggest = "filter_synonyms"
        elif key == "filterType":
            suggest = "filter_type"
        elif key == "numericEqualityFilter":
            suggest = "numeric_equality_filter"
        elif key == "numericRangeFilter":
            suggest = "numeric_range_filter"
        elif key == "relativeDateFilter":
            suggest = "relative_date_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_name: str,
                 operand_field_name: str,
                 category_filter: Optional['outputs.TopicCategoryFilter'] = None,
                 date_range_filter: Optional['outputs.TopicDateRangeFilter'] = None,
                 filter_class: Optional['TopicFilterClass'] = None,
                 filter_description: Optional[str] = None,
                 filter_synonyms: Optional[Sequence[str]] = None,
                 filter_type: Optional['TopicNamedFilterType'] = None,
                 numeric_equality_filter: Optional['outputs.TopicNumericEqualityFilter'] = None,
                 numeric_range_filter: Optional['outputs.TopicNumericRangeFilter'] = None,
                 relative_date_filter: Optional['outputs.TopicRelativeDateFilter'] = None):
        TopicFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter_name=filter_name,
            operand_field_name=operand_field_name,
            category_filter=category_filter,
            date_range_filter=date_range_filter,
            filter_class=filter_class,
            filter_description=filter_description,
            filter_synonyms=filter_synonyms,
            filter_type=filter_type,
            numeric_equality_filter=numeric_equality_filter,
            numeric_range_filter=numeric_range_filter,
            relative_date_filter=relative_date_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter_name: str,
             operand_field_name: str,
             category_filter: Optional['outputs.TopicCategoryFilter'] = None,
             date_range_filter: Optional['outputs.TopicDateRangeFilter'] = None,
             filter_class: Optional['TopicFilterClass'] = None,
             filter_description: Optional[str] = None,
             filter_synonyms: Optional[Sequence[str]] = None,
             filter_type: Optional['TopicNamedFilterType'] = None,
             numeric_equality_filter: Optional['outputs.TopicNumericEqualityFilter'] = None,
             numeric_range_filter: Optional['outputs.TopicNumericRangeFilter'] = None,
             relative_date_filter: Optional['outputs.TopicRelativeDateFilter'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter_name", filter_name)
        _setter("operand_field_name", operand_field_name)
        if category_filter is not None:
            _setter("category_filter", category_filter)
        if date_range_filter is not None:
            _setter("date_range_filter", date_range_filter)
        if filter_class is not None:
            _setter("filter_class", filter_class)
        if filter_description is not None:
            _setter("filter_description", filter_description)
        if filter_synonyms is not None:
            _setter("filter_synonyms", filter_synonyms)
        if filter_type is not None:
            _setter("filter_type", filter_type)
        if numeric_equality_filter is not None:
            _setter("numeric_equality_filter", numeric_equality_filter)
        if numeric_range_filter is not None:
            _setter("numeric_range_filter", numeric_range_filter)
        if relative_date_filter is not None:
            _setter("relative_date_filter", relative_date_filter)

    @property
    @pulumi.getter(name="filterName")
    def filter_name(self) -> str:
        return pulumi.get(self, "filter_name")

    @property
    @pulumi.getter(name="operandFieldName")
    def operand_field_name(self) -> str:
        return pulumi.get(self, "operand_field_name")

    @property
    @pulumi.getter(name="categoryFilter")
    def category_filter(self) -> Optional['outputs.TopicCategoryFilter']:
        return pulumi.get(self, "category_filter")

    @property
    @pulumi.getter(name="dateRangeFilter")
    def date_range_filter(self) -> Optional['outputs.TopicDateRangeFilter']:
        return pulumi.get(self, "date_range_filter")

    @property
    @pulumi.getter(name="filterClass")
    def filter_class(self) -> Optional['TopicFilterClass']:
        return pulumi.get(self, "filter_class")

    @property
    @pulumi.getter(name="filterDescription")
    def filter_description(self) -> Optional[str]:
        return pulumi.get(self, "filter_description")

    @property
    @pulumi.getter(name="filterSynonyms")
    def filter_synonyms(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_synonyms")

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> Optional['TopicNamedFilterType']:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter(name="numericEqualityFilter")
    def numeric_equality_filter(self) -> Optional['outputs.TopicNumericEqualityFilter']:
        return pulumi.get(self, "numeric_equality_filter")

    @property
    @pulumi.getter(name="numericRangeFilter")
    def numeric_range_filter(self) -> Optional['outputs.TopicNumericRangeFilter']:
        return pulumi.get(self, "numeric_range_filter")

    @property
    @pulumi.getter(name="relativeDateFilter")
    def relative_date_filter(self) -> Optional['outputs.TopicRelativeDateFilter']:
        return pulumi.get(self, "relative_date_filter")


@pulumi.output_type
class TopicNamedEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityName":
            suggest = "entity_name"
        elif key == "entityDescription":
            suggest = "entity_description"
        elif key == "entitySynonyms":
            suggest = "entity_synonyms"
        elif key == "semanticEntityType":
            suggest = "semantic_entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicNamedEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicNamedEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicNamedEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_name: str,
                 definition: Optional[Sequence['outputs.TopicNamedEntityDefinition']] = None,
                 entity_description: Optional[str] = None,
                 entity_synonyms: Optional[Sequence[str]] = None,
                 semantic_entity_type: Optional['outputs.TopicSemanticEntityType'] = None):
        TopicNamedEntity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_name=entity_name,
            definition=definition,
            entity_description=entity_description,
            entity_synonyms=entity_synonyms,
            semantic_entity_type=semantic_entity_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_name: str,
             definition: Optional[Sequence['outputs.TopicNamedEntityDefinition']] = None,
             entity_description: Optional[str] = None,
             entity_synonyms: Optional[Sequence[str]] = None,
             semantic_entity_type: Optional['outputs.TopicSemanticEntityType'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("entity_name", entity_name)
        if definition is not None:
            _setter("definition", definition)
        if entity_description is not None:
            _setter("entity_description", entity_description)
        if entity_synonyms is not None:
            _setter("entity_synonyms", entity_synonyms)
        if semantic_entity_type is not None:
            _setter("semantic_entity_type", semantic_entity_type)

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> str:
        return pulumi.get(self, "entity_name")

    @property
    @pulumi.getter
    def definition(self) -> Optional[Sequence['outputs.TopicNamedEntityDefinition']]:
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="entityDescription")
    def entity_description(self) -> Optional[str]:
        return pulumi.get(self, "entity_description")

    @property
    @pulumi.getter(name="entitySynonyms")
    def entity_synonyms(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "entity_synonyms")

    @property
    @pulumi.getter(name="semanticEntityType")
    def semantic_entity_type(self) -> Optional['outputs.TopicSemanticEntityType']:
        return pulumi.get(self, "semantic_entity_type")


@pulumi.output_type
class TopicNamedEntityDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "propertyName":
            suggest = "property_name"
        elif key == "propertyRole":
            suggest = "property_role"
        elif key == "propertyUsage":
            suggest = "property_usage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicNamedEntityDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicNamedEntityDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicNamedEntityDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: Optional[str] = None,
                 metric: Optional['outputs.TopicNamedEntityDefinitionMetric'] = None,
                 property_name: Optional[str] = None,
                 property_role: Optional['TopicPropertyRole'] = None,
                 property_usage: Optional['TopicPropertyUsage'] = None):
        TopicNamedEntityDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            metric=metric,
            property_name=property_name,
            property_role=property_role,
            property_usage=property_usage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: Optional[str] = None,
             metric: Optional['outputs.TopicNamedEntityDefinitionMetric'] = None,
             property_name: Optional[str] = None,
             property_role: Optional['TopicPropertyRole'] = None,
             property_usage: Optional['TopicPropertyUsage'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field_name is not None:
            _setter("field_name", field_name)
        if metric is not None:
            _setter("metric", metric)
        if property_name is not None:
            _setter("property_name", property_name)
        if property_role is not None:
            _setter("property_role", property_role)
        if property_usage is not None:
            _setter("property_usage", property_usage)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[str]:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def metric(self) -> Optional['outputs.TopicNamedEntityDefinitionMetric']:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[str]:
        return pulumi.get(self, "property_name")

    @property
    @pulumi.getter(name="propertyRole")
    def property_role(self) -> Optional['TopicPropertyRole']:
        return pulumi.get(self, "property_role")

    @property
    @pulumi.getter(name="propertyUsage")
    def property_usage(self) -> Optional['TopicPropertyUsage']:
        return pulumi.get(self, "property_usage")


@pulumi.output_type
class TopicNamedEntityDefinitionMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationFunctionParameters":
            suggest = "aggregation_function_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicNamedEntityDefinitionMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicNamedEntityDefinitionMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicNamedEntityDefinitionMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: Optional['TopicNamedEntityAggType'] = None,
                 aggregation_function_parameters: Optional['outputs.TopicAggregationFunctionParameters'] = None):
        TopicNamedEntityDefinitionMetric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            aggregation_function_parameters=aggregation_function_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: Optional['TopicNamedEntityAggType'] = None,
             aggregation_function_parameters: Optional['outputs.TopicAggregationFunctionParameters'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if aggregation_function_parameters is not None:
            _setter("aggregation_function_parameters", aggregation_function_parameters)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional['TopicNamedEntityAggType']:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="aggregationFunctionParameters")
    def aggregation_function_parameters(self) -> Optional['outputs.TopicAggregationFunctionParameters']:
        return pulumi.get(self, "aggregation_function_parameters")


@pulumi.output_type
class TopicNegativeFormat(dict):
    def __init__(__self__, *,
                 prefix: Optional[str] = None,
                 suffix: Optional[str] = None):
        TopicNegativeFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prefix=prefix,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prefix: Optional[str] = None,
             suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if prefix is not None:
            _setter("prefix", prefix)
        if suffix is not None:
            _setter("suffix", suffix)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class TopicNumericEqualityFilter(dict):
    def __init__(__self__, *,
                 aggregation: Optional['TopicNamedFilterAggType'] = None,
                 constant: Optional['outputs.TopicSingularFilterConstant'] = None):
        TopicNumericEqualityFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            constant=constant,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: Optional['TopicNamedFilterAggType'] = None,
             constant: Optional['outputs.TopicSingularFilterConstant'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if constant is not None:
            _setter("constant", constant)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional['TopicNamedFilterAggType']:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def constant(self) -> Optional['outputs.TopicSingularFilterConstant']:
        return pulumi.get(self, "constant")


@pulumi.output_type
class TopicNumericRangeFilter(dict):
    def __init__(__self__, *,
                 aggregation: Optional['TopicNamedFilterAggType'] = None,
                 constant: Optional['outputs.TopicRangeFilterConstant'] = None,
                 inclusive: Optional[bool] = None):
        TopicNumericRangeFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            constant=constant,
            inclusive=inclusive,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: Optional['TopicNamedFilterAggType'] = None,
             constant: Optional['outputs.TopicRangeFilterConstant'] = None,
             inclusive: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if constant is not None:
            _setter("constant", constant)
        if inclusive is not None:
            _setter("inclusive", inclusive)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional['TopicNamedFilterAggType']:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def constant(self) -> Optional['outputs.TopicRangeFilterConstant']:
        return pulumi.get(self, "constant")

    @property
    @pulumi.getter
    def inclusive(self) -> Optional[bool]:
        return pulumi.get(self, "inclusive")


@pulumi.output_type
class TopicRangeConstant(dict):
    def __init__(__self__, *,
                 maximum: Optional[str] = None,
                 minimum: Optional[str] = None):
        TopicRangeConstant._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum=maximum,
            minimum=minimum,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum: Optional[str] = None,
             minimum: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if maximum is not None:
            _setter("maximum", maximum)
        if minimum is not None:
            _setter("minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        return pulumi.get(self, "minimum")


@pulumi.output_type
class TopicRangeFilterConstant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "constantType":
            suggest = "constant_type"
        elif key == "rangeConstant":
            suggest = "range_constant"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRangeFilterConstant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRangeFilterConstant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRangeFilterConstant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 constant_type: Optional['TopicConstantType'] = None,
                 range_constant: Optional['outputs.TopicRangeConstant'] = None):
        TopicRangeFilterConstant._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            constant_type=constant_type,
            range_constant=range_constant,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             constant_type: Optional['TopicConstantType'] = None,
             range_constant: Optional['outputs.TopicRangeConstant'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if constant_type is not None:
            _setter("constant_type", constant_type)
        if range_constant is not None:
            _setter("range_constant", range_constant)

    @property
    @pulumi.getter(name="constantType")
    def constant_type(self) -> Optional['TopicConstantType']:
        return pulumi.get(self, "constant_type")

    @property
    @pulumi.getter(name="rangeConstant")
    def range_constant(self) -> Optional['outputs.TopicRangeConstant']:
        return pulumi.get(self, "range_constant")


@pulumi.output_type
class TopicRelativeDateFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeDateFilterFunction":
            suggest = "relative_date_filter_function"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRelativeDateFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRelativeDateFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRelativeDateFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 constant: Optional['outputs.TopicSingularFilterConstant'] = None,
                 relative_date_filter_function: Optional['TopicRelativeDateFilterFunction'] = None,
                 time_granularity: Optional['TopicTimeGranularity'] = None):
        TopicRelativeDateFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            constant=constant,
            relative_date_filter_function=relative_date_filter_function,
            time_granularity=time_granularity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             constant: Optional['outputs.TopicSingularFilterConstant'] = None,
             relative_date_filter_function: Optional['TopicRelativeDateFilterFunction'] = None,
             time_granularity: Optional['TopicTimeGranularity'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if constant is not None:
            _setter("constant", constant)
        if relative_date_filter_function is not None:
            _setter("relative_date_filter_function", relative_date_filter_function)
        if time_granularity is not None:
            _setter("time_granularity", time_granularity)

    @property
    @pulumi.getter
    def constant(self) -> Optional['outputs.TopicSingularFilterConstant']:
        return pulumi.get(self, "constant")

    @property
    @pulumi.getter(name="relativeDateFilterFunction")
    def relative_date_filter_function(self) -> Optional['TopicRelativeDateFilterFunction']:
        return pulumi.get(self, "relative_date_filter_function")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> Optional['TopicTimeGranularity']:
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class TopicSemanticEntityType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subTypeName":
            suggest = "sub_type_name"
        elif key == "typeName":
            suggest = "type_name"
        elif key == "typeParameters":
            suggest = "type_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicSemanticEntityType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicSemanticEntityType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicSemanticEntityType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sub_type_name: Optional[str] = None,
                 type_name: Optional[str] = None,
                 type_parameters: Optional['outputs.TopicTypeParameters'] = None):
        TopicSemanticEntityType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sub_type_name=sub_type_name,
            type_name=type_name,
            type_parameters=type_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sub_type_name: Optional[str] = None,
             type_name: Optional[str] = None,
             type_parameters: Optional['outputs.TopicTypeParameters'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sub_type_name is not None:
            _setter("sub_type_name", sub_type_name)
        if type_name is not None:
            _setter("type_name", type_name)
        if type_parameters is not None:
            _setter("type_parameters", type_parameters)

    @property
    @pulumi.getter(name="subTypeName")
    def sub_type_name(self) -> Optional[str]:
        return pulumi.get(self, "sub_type_name")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> Optional[str]:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="typeParameters")
    def type_parameters(self) -> Optional['outputs.TopicTypeParameters']:
        return pulumi.get(self, "type_parameters")


@pulumi.output_type
class TopicSemanticType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "falseyCellValue":
            suggest = "falsey_cell_value"
        elif key == "falseyCellValueSynonyms":
            suggest = "falsey_cell_value_synonyms"
        elif key == "subTypeName":
            suggest = "sub_type_name"
        elif key == "truthyCellValue":
            suggest = "truthy_cell_value"
        elif key == "truthyCellValueSynonyms":
            suggest = "truthy_cell_value_synonyms"
        elif key == "typeName":
            suggest = "type_name"
        elif key == "typeParameters":
            suggest = "type_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicSemanticType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicSemanticType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicSemanticType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 falsey_cell_value: Optional[str] = None,
                 falsey_cell_value_synonyms: Optional[Sequence[str]] = None,
                 sub_type_name: Optional[str] = None,
                 truthy_cell_value: Optional[str] = None,
                 truthy_cell_value_synonyms: Optional[Sequence[str]] = None,
                 type_name: Optional[str] = None,
                 type_parameters: Optional['outputs.TopicTypeParameters'] = None):
        TopicSemanticType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            falsey_cell_value=falsey_cell_value,
            falsey_cell_value_synonyms=falsey_cell_value_synonyms,
            sub_type_name=sub_type_name,
            truthy_cell_value=truthy_cell_value,
            truthy_cell_value_synonyms=truthy_cell_value_synonyms,
            type_name=type_name,
            type_parameters=type_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             falsey_cell_value: Optional[str] = None,
             falsey_cell_value_synonyms: Optional[Sequence[str]] = None,
             sub_type_name: Optional[str] = None,
             truthy_cell_value: Optional[str] = None,
             truthy_cell_value_synonyms: Optional[Sequence[str]] = None,
             type_name: Optional[str] = None,
             type_parameters: Optional['outputs.TopicTypeParameters'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if falsey_cell_value is not None:
            _setter("falsey_cell_value", falsey_cell_value)
        if falsey_cell_value_synonyms is not None:
            _setter("falsey_cell_value_synonyms", falsey_cell_value_synonyms)
        if sub_type_name is not None:
            _setter("sub_type_name", sub_type_name)
        if truthy_cell_value is not None:
            _setter("truthy_cell_value", truthy_cell_value)
        if truthy_cell_value_synonyms is not None:
            _setter("truthy_cell_value_synonyms", truthy_cell_value_synonyms)
        if type_name is not None:
            _setter("type_name", type_name)
        if type_parameters is not None:
            _setter("type_parameters", type_parameters)

    @property
    @pulumi.getter(name="falseyCellValue")
    def falsey_cell_value(self) -> Optional[str]:
        return pulumi.get(self, "falsey_cell_value")

    @property
    @pulumi.getter(name="falseyCellValueSynonyms")
    def falsey_cell_value_synonyms(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "falsey_cell_value_synonyms")

    @property
    @pulumi.getter(name="subTypeName")
    def sub_type_name(self) -> Optional[str]:
        return pulumi.get(self, "sub_type_name")

    @property
    @pulumi.getter(name="truthyCellValue")
    def truthy_cell_value(self) -> Optional[str]:
        return pulumi.get(self, "truthy_cell_value")

    @property
    @pulumi.getter(name="truthyCellValueSynonyms")
    def truthy_cell_value_synonyms(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "truthy_cell_value_synonyms")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> Optional[str]:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="typeParameters")
    def type_parameters(self) -> Optional['outputs.TopicTypeParameters']:
        return pulumi.get(self, "type_parameters")


@pulumi.output_type
class TopicSingularFilterConstant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "constantType":
            suggest = "constant_type"
        elif key == "singularConstant":
            suggest = "singular_constant"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicSingularFilterConstant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicSingularFilterConstant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicSingularFilterConstant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 constant_type: Optional['TopicConstantType'] = None,
                 singular_constant: Optional[str] = None):
        TopicSingularFilterConstant._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            constant_type=constant_type,
            singular_constant=singular_constant,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             constant_type: Optional['TopicConstantType'] = None,
             singular_constant: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if constant_type is not None:
            _setter("constant_type", constant_type)
        if singular_constant is not None:
            _setter("singular_constant", singular_constant)

    @property
    @pulumi.getter(name="constantType")
    def constant_type(self) -> Optional['TopicConstantType']:
        return pulumi.get(self, "constant_type")

    @property
    @pulumi.getter(name="singularConstant")
    def singular_constant(self) -> Optional[str]:
        return pulumi.get(self, "singular_constant")


@pulumi.output_type
class TopicTypeParameters(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class VpcConnectionNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "errorMessage":
            suggest = "error_message"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcConnectionNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcConnectionNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcConnectionNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 error_message: Optional[str] = None,
                 network_interface_id: Optional[str] = None,
                 status: Optional['VpcConnectionNetworkInterfaceStatus'] = None,
                 subnet_id: Optional[str] = None):
        VpcConnectionNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            error_message=error_message,
            network_interface_id=network_interface_id,
            status=status,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             error_message: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             status: Optional['VpcConnectionNetworkInterfaceStatus'] = None,
             subnet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_zone is not None:
            _setter("availability_zone", availability_zone)
        if error_message is not None:
            _setter("error_message", error_message)
        if network_interface_id is not None:
            _setter("network_interface_id", network_interface_id)
        if status is not None:
            _setter("status", status)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter
    def status(self) -> Optional['VpcConnectionNetworkInterfaceStatus']:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class VpcConnectionTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        VpcConnectionTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


