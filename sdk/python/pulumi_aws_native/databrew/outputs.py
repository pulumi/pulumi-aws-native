# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'DatasetCsvOptions',
    'DatasetDataCatalogInputDefinition',
    'DatasetDatabaseInputDefinition',
    'DatasetDatetimeOptions',
    'DatasetExcelOptions',
    'DatasetFilesLimit',
    'DatasetFilterExpression',
    'DatasetFilterValue',
    'DatasetFormatOptions',
    'DatasetInput',
    'DatasetJsonOptions',
    'DatasetMetadata',
    'DatasetParameter',
    'DatasetPathOptions',
    'DatasetPathParameter',
    'DatasetS3Location',
    'JobAllowedStatistics',
    'JobColumnSelector',
    'JobColumnStatisticsConfiguration',
    'JobCsvOutputOptions',
    'JobDataCatalogOutput',
    'JobDatabaseOutput',
    'JobDatabaseTableOutputOptions',
    'JobEntityDetectorConfiguration',
    'JobOutput',
    'JobOutputFormatOptions',
    'JobOutputLocation',
    'JobProfileConfiguration',
    'JobRecipe',
    'JobS3Location',
    'JobS3TableOutputOptions',
    'JobSample',
    'JobStatisticOverride',
    'JobStatisticsConfiguration',
    'JobValidationConfiguration',
    'ProjectSample',
    'RecipeAction',
    'RecipeConditionExpression',
    'RecipeDataCatalogInputDefinition',
    'RecipeParameters',
    'RecipeParametersInputProperties',
    'RecipeS3Location',
    'RecipeSecondaryInput',
    'RecipeStep',
    'RulesetColumnSelector',
    'RulesetRule',
    'RulesetSubstitutionValue',
    'RulesetThreshold',
]

@pulumi.output_type
class DatasetCsvOptions(dict):
    """
    Csv options
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerRow":
            suggest = "header_row"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetCsvOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetCsvOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetCsvOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[_builtins.str] = None,
                 header_row: Optional[_builtins.bool] = None):
        """
        Csv options
        :param _builtins.str delimiter: A single character that specifies the delimiter being used in the CSV file.
        :param _builtins.bool header_row: A variable that specifies whether the first row in the file is parsed as the header. If this value is false, column names are auto-generated.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if header_row is not None:
            pulumi.set(__self__, "header_row", header_row)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        """
        A single character that specifies the delimiter being used in the CSV file.
        """
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="headerRow")
    def header_row(self) -> Optional[_builtins.bool]:
        """
        A variable that specifies whether the first row in the file is parsed as the header. If this value is false, column names are auto-generated.
        """
        return pulumi.get(self, "header_row")


@pulumi.output_type
class DatasetDataCatalogInputDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogId":
            suggest = "catalog_id"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "tempDirectory":
            suggest = "temp_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetDataCatalogInputDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetDataCatalogInputDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetDataCatalogInputDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_id: Optional[_builtins.str] = None,
                 database_name: Optional[_builtins.str] = None,
                 table_name: Optional[_builtins.str] = None,
                 temp_directory: Optional['outputs.DatasetS3Location'] = None):
        """
        :param _builtins.str catalog_id: Catalog id
        :param _builtins.str database_name: Database name
        :param _builtins.str table_name: Table name
        :param 'DatasetS3Location' temp_directory: An Amazon location that AWS Glue Data Catalog can use as a temporary directory.
        """
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)
        if temp_directory is not None:
            pulumi.set(__self__, "temp_directory", temp_directory)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[_builtins.str]:
        """
        Catalog id
        """
        return pulumi.get(self, "catalog_id")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        Database name
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[_builtins.str]:
        """
        Table name
        """
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="tempDirectory")
    def temp_directory(self) -> Optional['outputs.DatasetS3Location']:
        """
        An Amazon location that AWS Glue Data Catalog can use as a temporary directory.
        """
        return pulumi.get(self, "temp_directory")


@pulumi.output_type
class DatasetDatabaseInputDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "glueConnectionName":
            suggest = "glue_connection_name"
        elif key == "databaseTableName":
            suggest = "database_table_name"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "tempDirectory":
            suggest = "temp_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetDatabaseInputDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetDatabaseInputDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetDatabaseInputDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 glue_connection_name: _builtins.str,
                 database_table_name: Optional[_builtins.str] = None,
                 query_string: Optional[_builtins.str] = None,
                 temp_directory: Optional['outputs.DatasetS3Location'] = None):
        """
        :param _builtins.str glue_connection_name: Glue connection name
        :param _builtins.str database_table_name: Database table name
        :param _builtins.str query_string: Custom SQL to run against the provided AWS Glue connection. This SQL will be used as the input for DataBrew projects and jobs.
        :param 'DatasetS3Location' temp_directory: An Amazon location that AWS Glue Data Catalog can use as a temporary directory.
        """
        pulumi.set(__self__, "glue_connection_name", glue_connection_name)
        if database_table_name is not None:
            pulumi.set(__self__, "database_table_name", database_table_name)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if temp_directory is not None:
            pulumi.set(__self__, "temp_directory", temp_directory)

    @_builtins.property
    @pulumi.getter(name="glueConnectionName")
    def glue_connection_name(self) -> _builtins.str:
        """
        Glue connection name
        """
        return pulumi.get(self, "glue_connection_name")

    @_builtins.property
    @pulumi.getter(name="databaseTableName")
    def database_table_name(self) -> Optional[_builtins.str]:
        """
        Database table name
        """
        return pulumi.get(self, "database_table_name")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[_builtins.str]:
        """
        Custom SQL to run against the provided AWS Glue connection. This SQL will be used as the input for DataBrew projects and jobs.
        """
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="tempDirectory")
    def temp_directory(self) -> Optional['outputs.DatasetS3Location']:
        """
        An Amazon location that AWS Glue Data Catalog can use as a temporary directory.
        """
        return pulumi.get(self, "temp_directory")


@pulumi.output_type
class DatasetDatetimeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localeCode":
            suggest = "locale_code"
        elif key == "timezoneOffset":
            suggest = "timezone_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetDatetimeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetDatetimeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetDatetimeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: _builtins.str,
                 locale_code: Optional[_builtins.str] = None,
                 timezone_offset: Optional[_builtins.str] = None):
        """
        :param _builtins.str format: Date/time format of a date parameter
        :param _builtins.str locale_code: Locale code for a date parameter
        :param _builtins.str timezone_offset: Timezone offset
        """
        pulumi.set(__self__, "format", format)
        if locale_code is not None:
            pulumi.set(__self__, "locale_code", locale_code)
        if timezone_offset is not None:
            pulumi.set(__self__, "timezone_offset", timezone_offset)

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        Date/time format of a date parameter
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="localeCode")
    def locale_code(self) -> Optional[_builtins.str]:
        """
        Locale code for a date parameter
        """
        return pulumi.get(self, "locale_code")

    @_builtins.property
    @pulumi.getter(name="timezoneOffset")
    def timezone_offset(self) -> Optional[_builtins.str]:
        """
        Timezone offset
        """
        return pulumi.get(self, "timezone_offset")


@pulumi.output_type
class DatasetExcelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerRow":
            suggest = "header_row"
        elif key == "sheetIndexes":
            suggest = "sheet_indexes"
        elif key == "sheetNames":
            suggest = "sheet_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetExcelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetExcelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetExcelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_row: Optional[_builtins.bool] = None,
                 sheet_indexes: Optional[Sequence[_builtins.int]] = None,
                 sheet_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool header_row: A variable that specifies whether the first row in the file is parsed as the header. If this value is false, column names are auto-generated.
        :param Sequence[_builtins.int] sheet_indexes: One or more sheet numbers in the Excel file that will be included in the dataset.
        :param Sequence[_builtins.str] sheet_names: One or more named sheets in the Excel file that will be included in the dataset.
        """
        if header_row is not None:
            pulumi.set(__self__, "header_row", header_row)
        if sheet_indexes is not None:
            pulumi.set(__self__, "sheet_indexes", sheet_indexes)
        if sheet_names is not None:
            pulumi.set(__self__, "sheet_names", sheet_names)

    @_builtins.property
    @pulumi.getter(name="headerRow")
    def header_row(self) -> Optional[_builtins.bool]:
        """
        A variable that specifies whether the first row in the file is parsed as the header. If this value is false, column names are auto-generated.
        """
        return pulumi.get(self, "header_row")

    @_builtins.property
    @pulumi.getter(name="sheetIndexes")
    def sheet_indexes(self) -> Optional[Sequence[_builtins.int]]:
        """
        One or more sheet numbers in the Excel file that will be included in the dataset.
        """
        return pulumi.get(self, "sheet_indexes")

    @_builtins.property
    @pulumi.getter(name="sheetNames")
    def sheet_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        One or more named sheets in the Excel file that will be included in the dataset.
        """
        return pulumi.get(self, "sheet_names")


@pulumi.output_type
class DatasetFilesLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxFiles":
            suggest = "max_files"
        elif key == "orderedBy":
            suggest = "ordered_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetFilesLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetFilesLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetFilesLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_files: _builtins.int,
                 order: Optional['DatasetFilesLimitOrder'] = None,
                 ordered_by: Optional['DatasetFilesLimitOrderedBy'] = None):
        """
        :param _builtins.int max_files: Maximum number of files
        :param 'DatasetFilesLimitOrder' order: Order
        :param 'DatasetFilesLimitOrderedBy' ordered_by: Ordered by
        """
        pulumi.set(__self__, "max_files", max_files)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if ordered_by is not None:
            pulumi.set(__self__, "ordered_by", ordered_by)

    @_builtins.property
    @pulumi.getter(name="maxFiles")
    def max_files(self) -> _builtins.int:
        """
        Maximum number of files
        """
        return pulumi.get(self, "max_files")

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional['DatasetFilesLimitOrder']:
        """
        Order
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="orderedBy")
    def ordered_by(self) -> Optional['DatasetFilesLimitOrderedBy']:
        """
        Ordered by
        """
        return pulumi.get(self, "ordered_by")


@pulumi.output_type
class DatasetFilterExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valuesMap":
            suggest = "values_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetFilterExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetFilterExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetFilterExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: _builtins.str,
                 values_map: Sequence['outputs.DatasetFilterValue']):
        """
        :param _builtins.str expression: Filtering expression for a parameter
        :param Sequence['DatasetFilterValue'] values_map: The map of substitution variable names to their values used in this filter expression.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "values_map", values_map)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Filtering expression for a parameter
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter(name="valuesMap")
    def values_map(self) -> Sequence['outputs.DatasetFilterValue']:
        """
        The map of substitution variable names to their values used in this filter expression.
        """
        return pulumi.get(self, "values_map")


@pulumi.output_type
class DatasetFilterValue(dict):
    """
    A key-value pair to associate expression variable names with their values
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueReference":
            suggest = "value_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: _builtins.str,
                 value_reference: _builtins.str):
        """
        A key-value pair to associate expression variable names with their values
        :param _builtins.str value: The value to be associated with the substitution variable.
        :param _builtins.str value_reference: Variable name
        """
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_reference", value_reference)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value to be associated with the substitution variable.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueReference")
    def value_reference(self) -> _builtins.str:
        """
        Variable name
        """
        return pulumi.get(self, "value_reference")


@pulumi.output_type
class DatasetFormatOptions(dict):
    """
    Format options for dataset
    """
    def __init__(__self__, *,
                 csv: Optional['outputs.DatasetCsvOptions'] = None,
                 excel: Optional['outputs.DatasetExcelOptions'] = None,
                 json: Optional['outputs.DatasetJsonOptions'] = None):
        """
        Format options for dataset
        :param 'DatasetCsvOptions' csv: Options that define how CSV input is to be interpreted by DataBrew.
        :param 'DatasetExcelOptions' excel: Options that define how Excel input is to be interpreted by DataBrew.
        :param 'DatasetJsonOptions' json: Options that define how JSON input is to be interpreted by DataBrew.
        """
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if excel is not None:
            pulumi.set(__self__, "excel", excel)
        if json is not None:
            pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def csv(self) -> Optional['outputs.DatasetCsvOptions']:
        """
        Options that define how CSV input is to be interpreted by DataBrew.
        """
        return pulumi.get(self, "csv")

    @_builtins.property
    @pulumi.getter
    def excel(self) -> Optional['outputs.DatasetExcelOptions']:
        """
        Options that define how Excel input is to be interpreted by DataBrew.
        """
        return pulumi.get(self, "excel")

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional['outputs.DatasetJsonOptions']:
        """
        Options that define how JSON input is to be interpreted by DataBrew.
        """
        return pulumi.get(self, "json")


@pulumi.output_type
class DatasetInput(dict):
    """
    Input
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataCatalogInputDefinition":
            suggest = "data_catalog_input_definition"
        elif key == "databaseInputDefinition":
            suggest = "database_input_definition"
        elif key == "s3InputDefinition":
            suggest = "s3_input_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_catalog_input_definition: Optional['outputs.DatasetDataCatalogInputDefinition'] = None,
                 database_input_definition: Optional['outputs.DatasetDatabaseInputDefinition'] = None,
                 metadata: Optional['outputs.DatasetMetadata'] = None,
                 s3_input_definition: Optional['outputs.DatasetS3Location'] = None):
        """
        Input
        :param 'DatasetDataCatalogInputDefinition' data_catalog_input_definition: The AWS Glue Data Catalog parameters for the data.
        :param 'DatasetDatabaseInputDefinition' database_input_definition: Connection information for dataset input files stored in a database.
        :param 'DatasetMetadata' metadata: Contains additional resource information needed for specific datasets.
        :param 'DatasetS3Location' s3_input_definition: The Amazon S3 location where the data is stored.
        """
        if data_catalog_input_definition is not None:
            pulumi.set(__self__, "data_catalog_input_definition", data_catalog_input_definition)
        if database_input_definition is not None:
            pulumi.set(__self__, "database_input_definition", database_input_definition)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if s3_input_definition is not None:
            pulumi.set(__self__, "s3_input_definition", s3_input_definition)

    @_builtins.property
    @pulumi.getter(name="dataCatalogInputDefinition")
    def data_catalog_input_definition(self) -> Optional['outputs.DatasetDataCatalogInputDefinition']:
        """
        The AWS Glue Data Catalog parameters for the data.
        """
        return pulumi.get(self, "data_catalog_input_definition")

    @_builtins.property
    @pulumi.getter(name="databaseInputDefinition")
    def database_input_definition(self) -> Optional['outputs.DatasetDatabaseInputDefinition']:
        """
        Connection information for dataset input files stored in a database.
        """
        return pulumi.get(self, "database_input_definition")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.DatasetMetadata']:
        """
        Contains additional resource information needed for specific datasets.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="s3InputDefinition")
    def s3_input_definition(self) -> Optional['outputs.DatasetS3Location']:
        """
        The Amazon S3 location where the data is stored.
        """
        return pulumi.get(self, "s3_input_definition")


@pulumi.output_type
class DatasetJsonOptions(dict):
    """
    Json options
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multiLine":
            suggest = "multi_line"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetJsonOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetJsonOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetJsonOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 multi_line: Optional[_builtins.bool] = None):
        """
        Json options
        :param _builtins.bool multi_line: A value that specifies whether JSON input contains embedded new line characters.
        """
        if multi_line is not None:
            pulumi.set(__self__, "multi_line", multi_line)

    @_builtins.property
    @pulumi.getter(name="multiLine")
    def multi_line(self) -> Optional[_builtins.bool]:
        """
        A value that specifies whether JSON input contains embedded new line characters.
        """
        return pulumi.get(self, "multi_line")


@pulumi.output_type
class DatasetMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceArn":
            suggest = "source_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str source_arn: Arn of the source of the dataset. For e.g.: AppFlow Flow ARN.
        """
        if source_arn is not None:
            pulumi.set(__self__, "source_arn", source_arn)

    @_builtins.property
    @pulumi.getter(name="sourceArn")
    def source_arn(self) -> Optional[_builtins.str]:
        """
        Arn of the source of the dataset. For e.g.: AppFlow Flow ARN.
        """
        return pulumi.get(self, "source_arn")


@pulumi.output_type
class DatasetParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createColumn":
            suggest = "create_column"
        elif key == "datetimeOptions":
            suggest = "datetime_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 type: 'DatasetParameterType',
                 create_column: Optional[_builtins.bool] = None,
                 datetime_options: Optional['outputs.DatasetDatetimeOptions'] = None,
                 filter: Optional['outputs.DatasetFilterExpression'] = None):
        """
        :param _builtins.str name: The name of the parameter that is used in the dataset's Amazon S3 path.
        :param 'DatasetParameterType' type: Parameter type
        :param _builtins.bool create_column: Add the value of this parameter as a column in a dataset.
        :param 'DatasetDatetimeOptions' datetime_options: Additional parameter options such as a format and a timezone. Required for datetime parameters.
        :param 'DatasetFilterExpression' filter: The optional filter expression structure to apply additional matching criteria to the parameter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if create_column is not None:
            pulumi.set(__self__, "create_column", create_column)
        if datetime_options is not None:
            pulumi.set(__self__, "datetime_options", datetime_options)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the parameter that is used in the dataset's Amazon S3 path.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'DatasetParameterType':
        """
        Parameter type
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="createColumn")
    def create_column(self) -> Optional[_builtins.bool]:
        """
        Add the value of this parameter as a column in a dataset.
        """
        return pulumi.get(self, "create_column")

    @_builtins.property
    @pulumi.getter(name="datetimeOptions")
    def datetime_options(self) -> Optional['outputs.DatasetDatetimeOptions']:
        """
        Additional parameter options such as a format and a timezone. Required for datetime parameters.
        """
        return pulumi.get(self, "datetime_options")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional['outputs.DatasetFilterExpression']:
        """
        The optional filter expression structure to apply additional matching criteria to the parameter.
        """
        return pulumi.get(self, "filter")


@pulumi.output_type
class DatasetPathOptions(dict):
    """
    Path options for dataset
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filesLimit":
            suggest = "files_limit"
        elif key == "lastModifiedDateCondition":
            suggest = "last_modified_date_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetPathOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetPathOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetPathOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 files_limit: Optional['outputs.DatasetFilesLimit'] = None,
                 last_modified_date_condition: Optional['outputs.DatasetFilterExpression'] = None,
                 parameters: Optional[Sequence['outputs.DatasetPathParameter']] = None):
        """
        Path options for dataset
        :param 'DatasetFilesLimit' files_limit: If provided, this structure imposes a limit on a number of files that should be selected.
        :param 'DatasetFilterExpression' last_modified_date_condition: If provided, this structure defines a date range for matching Amazon S3 objects based on their LastModifiedDate attribute in Amazon S3 .
        :param Sequence['DatasetPathParameter'] parameters: A structure that maps names of parameters used in the Amazon S3 path of a dataset to their definitions.
        """
        if files_limit is not None:
            pulumi.set(__self__, "files_limit", files_limit)
        if last_modified_date_condition is not None:
            pulumi.set(__self__, "last_modified_date_condition", last_modified_date_condition)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="filesLimit")
    def files_limit(self) -> Optional['outputs.DatasetFilesLimit']:
        """
        If provided, this structure imposes a limit on a number of files that should be selected.
        """
        return pulumi.get(self, "files_limit")

    @_builtins.property
    @pulumi.getter(name="lastModifiedDateCondition")
    def last_modified_date_condition(self) -> Optional['outputs.DatasetFilterExpression']:
        """
        If provided, this structure defines a date range for matching Amazon S3 objects based on their LastModifiedDate attribute in Amazon S3 .
        """
        return pulumi.get(self, "last_modified_date_condition")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.DatasetPathParameter']]:
        """
        A structure that maps names of parameters used in the Amazon S3 path of a dataset to their definitions.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DatasetPathParameter(dict):
    """
    A key-value pair to associate dataset parameter name with its definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetParameter":
            suggest = "dataset_parameter"
        elif key == "pathParameterName":
            suggest = "path_parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetPathParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetPathParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetPathParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_parameter: 'outputs.DatasetParameter',
                 path_parameter_name: _builtins.str):
        """
        A key-value pair to associate dataset parameter name with its definition.
        :param 'DatasetParameter' dataset_parameter: The path parameter definition.
        :param _builtins.str path_parameter_name: The name of the path parameter.
        """
        pulumi.set(__self__, "dataset_parameter", dataset_parameter)
        pulumi.set(__self__, "path_parameter_name", path_parameter_name)

    @_builtins.property
    @pulumi.getter(name="datasetParameter")
    def dataset_parameter(self) -> 'outputs.DatasetParameter':
        """
        The path parameter definition.
        """
        return pulumi.get(self, "dataset_parameter")

    @_builtins.property
    @pulumi.getter(name="pathParameterName")
    def path_parameter_name(self) -> _builtins.str:
        """
        The name of the path parameter.
        """
        return pulumi.get(self, "path_parameter_name")


@pulumi.output_type
class DatasetS3Location(dict):
    """
    Input location
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketOwner":
            suggest = "bucket_owner"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetS3Location. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetS3Location.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetS3Location.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 bucket_owner: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None):
        """
        Input location
        :param _builtins.str bucket: The Amazon S3 bucket name.
        :param _builtins.str bucket_owner: The AWS account ID of the bucket owner.
        :param _builtins.str key: The unique name of the object in the bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        if bucket_owner is not None:
            pulumi.set(__self__, "bucket_owner", bucket_owner)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The Amazon S3 bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="bucketOwner")
    def bucket_owner(self) -> Optional[_builtins.str]:
        """
        The AWS account ID of the bucket owner.
        """
        return pulumi.get(self, "bucket_owner")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The unique name of the object in the bucket.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class JobAllowedStatistics(dict):
    def __init__(__self__, *,
                 statistics: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] statistics: One or more column statistics to allow for columns that contain detected entities.
        """
        pulumi.set(__self__, "statistics", statistics)

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Sequence[_builtins.str]:
        """
        One or more column statistics to allow for columns that contain detected entities.
        """
        return pulumi.get(self, "statistics")


@pulumi.output_type
class JobColumnSelector(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of a column from a dataset.
        :param _builtins.str regex: A regular expression for selecting a column from a dataset.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of a column from a dataset.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        A regular expression for selecting a column from a dataset.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class JobColumnStatisticsConfiguration(dict):
    def __init__(__self__, *,
                 statistics: 'outputs.JobStatisticsConfiguration',
                 selectors: Optional[Sequence['outputs.JobColumnSelector']] = None):
        """
        :param 'JobStatisticsConfiguration' statistics: Configuration for evaluations. Statistics can be used to select evaluations and override parameters of evaluations.
        :param Sequence['JobColumnSelector'] selectors: List of column selectors. Selectors can be used to select columns from the dataset. When selectors are undefined, configuration will be applied to all supported columns.
        """
        pulumi.set(__self__, "statistics", statistics)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> 'outputs.JobStatisticsConfiguration':
        """
        Configuration for evaluations. Statistics can be used to select evaluations and override parameters of evaluations.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> Optional[Sequence['outputs.JobColumnSelector']]:
        """
        List of column selectors. Selectors can be used to select columns from the dataset. When selectors are undefined, configuration will be applied to all supported columns.
        """
        return pulumi.get(self, "selectors")


@pulumi.output_type
class JobCsvOutputOptions(dict):
    """
    Output Csv options
    """
    def __init__(__self__, *,
                 delimiter: Optional[_builtins.str] = None):
        """
        Output Csv options
        :param _builtins.str delimiter: A single character that specifies the delimiter used to create CSV job output.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        """
        A single character that specifies the delimiter used to create CSV job output.
        """
        return pulumi.get(self, "delimiter")


@pulumi.output_type
class JobDataCatalogOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "catalogId":
            suggest = "catalog_id"
        elif key == "databaseOptions":
            suggest = "database_options"
        elif key == "s3Options":
            suggest = "s3_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobDataCatalogOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobDataCatalogOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobDataCatalogOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 table_name: _builtins.str,
                 catalog_id: Optional[_builtins.str] = None,
                 database_options: Optional['outputs.JobDatabaseTableOutputOptions'] = None,
                 overwrite: Optional[_builtins.bool] = None,
                 s3_options: Optional['outputs.JobS3TableOutputOptions'] = None):
        """
        :param _builtins.str database_name: The name of a database in the Data Catalog.
        :param _builtins.str table_name: The name of a table in the Data Catalog.
        :param _builtins.str catalog_id: The unique identifier of the AWS account that holds the Data Catalog that stores the data.
        :param 'JobDatabaseTableOutputOptions' database_options: Represents options that specify how and where DataBrew writes the database output generated by recipe jobs.
        :param _builtins.bool overwrite: A value that, if true, means that any data in the location specified for output is overwritten with new output. Not supported with DatabaseOptions.
        :param 'JobS3TableOutputOptions' s3_options: Represents options that specify how and where DataBrew writes the Amazon S3 output generated by recipe jobs.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if database_options is not None:
            pulumi.set(__self__, "database_options", database_options)
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)
        if s3_options is not None:
            pulumi.set(__self__, "s3_options", s3_options)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of a database in the Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        """
        The name of a table in the Data Catalog.
        """
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the AWS account that holds the Data Catalog that stores the data.
        """
        return pulumi.get(self, "catalog_id")

    @_builtins.property
    @pulumi.getter(name="databaseOptions")
    def database_options(self) -> Optional['outputs.JobDatabaseTableOutputOptions']:
        """
        Represents options that specify how and where DataBrew writes the database output generated by recipe jobs.
        """
        return pulumi.get(self, "database_options")

    @_builtins.property
    @pulumi.getter
    def overwrite(self) -> Optional[_builtins.bool]:
        """
        A value that, if true, means that any data in the location specified for output is overwritten with new output. Not supported with DatabaseOptions.
        """
        return pulumi.get(self, "overwrite")

    @_builtins.property
    @pulumi.getter(name="s3Options")
    def s3_options(self) -> Optional['outputs.JobS3TableOutputOptions']:
        """
        Represents options that specify how and where DataBrew writes the Amazon S3 output generated by recipe jobs.
        """
        return pulumi.get(self, "s3_options")


@pulumi.output_type
class JobDatabaseOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseOptions":
            suggest = "database_options"
        elif key == "glueConnectionName":
            suggest = "glue_connection_name"
        elif key == "databaseOutputMode":
            suggest = "database_output_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobDatabaseOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobDatabaseOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobDatabaseOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_options: 'outputs.JobDatabaseTableOutputOptions',
                 glue_connection_name: _builtins.str,
                 database_output_mode: Optional['JobDatabaseOutputDatabaseOutputMode'] = None):
        """
        :param 'JobDatabaseTableOutputOptions' database_options: Represents options that specify how and where DataBrew writes the database output generated by recipe jobs.
        :param _builtins.str glue_connection_name: Glue connection name
        :param 'JobDatabaseOutputDatabaseOutputMode' database_output_mode: Database table name
        """
        pulumi.set(__self__, "database_options", database_options)
        pulumi.set(__self__, "glue_connection_name", glue_connection_name)
        if database_output_mode is not None:
            pulumi.set(__self__, "database_output_mode", database_output_mode)

    @_builtins.property
    @pulumi.getter(name="databaseOptions")
    def database_options(self) -> 'outputs.JobDatabaseTableOutputOptions':
        """
        Represents options that specify how and where DataBrew writes the database output generated by recipe jobs.
        """
        return pulumi.get(self, "database_options")

    @_builtins.property
    @pulumi.getter(name="glueConnectionName")
    def glue_connection_name(self) -> _builtins.str:
        """
        Glue connection name
        """
        return pulumi.get(self, "glue_connection_name")

    @_builtins.property
    @pulumi.getter(name="databaseOutputMode")
    def database_output_mode(self) -> Optional['JobDatabaseOutputDatabaseOutputMode']:
        """
        Database table name
        """
        return pulumi.get(self, "database_output_mode")


@pulumi.output_type
class JobDatabaseTableOutputOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableName":
            suggest = "table_name"
        elif key == "tempDirectory":
            suggest = "temp_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobDatabaseTableOutputOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobDatabaseTableOutputOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobDatabaseTableOutputOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_name: _builtins.str,
                 temp_directory: Optional['outputs.JobS3Location'] = None):
        """
        :param _builtins.str table_name: A prefix for the name of a table DataBrew will create in the database.
        :param 'JobS3Location' temp_directory: Represents an Amazon S3 location (bucket name and object key) where DataBrew can store intermediate results.
        """
        pulumi.set(__self__, "table_name", table_name)
        if temp_directory is not None:
            pulumi.set(__self__, "temp_directory", temp_directory)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        """
        A prefix for the name of a table DataBrew will create in the database.
        """
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="tempDirectory")
    def temp_directory(self) -> Optional['outputs.JobS3Location']:
        """
        Represents an Amazon S3 location (bucket name and object key) where DataBrew can store intermediate results.
        """
        return pulumi.get(self, "temp_directory")


@pulumi.output_type
class JobEntityDetectorConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityTypes":
            suggest = "entity_types"
        elif key == "allowedStatistics":
            suggest = "allowed_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobEntityDetectorConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobEntityDetectorConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobEntityDetectorConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_types: Sequence[_builtins.str],
                 allowed_statistics: Optional['outputs.JobAllowedStatistics'] = None):
        """
        :param Sequence[_builtins.str] entity_types: Entity types to detect. Can be any of the following:
               
               - USA_SSN
               - EMAIL
               - USA_ITIN
               - USA_PASSPORT_NUMBER
               - PHONE_NUMBER
               - USA_DRIVING_LICENSE
               - BANK_ACCOUNT
               - CREDIT_CARD
               - IP_ADDRESS
               - MAC_ADDRESS
               - USA_DEA_NUMBER
               - USA_HCPCS_CODE
               - USA_NATIONAL_PROVIDER_IDENTIFIER
               - USA_NATIONAL_DRUG_CODE
               - USA_HEALTH_INSURANCE_CLAIM_NUMBER
               - USA_MEDICARE_BENEFICIARY_IDENTIFIER
               - USA_CPT_CODE
               - PERSON_NAME
               - DATE
               
               The Entity type group USA_ALL is also supported, and includes all of the above entity types except PERSON_NAME and DATE.
        :param 'JobAllowedStatistics' allowed_statistics: Configuration of statistics that are allowed to be run on columns that contain detected entities. When undefined, no statistics will be computed on columns that contain detected entities.
        """
        pulumi.set(__self__, "entity_types", entity_types)
        if allowed_statistics is not None:
            pulumi.set(__self__, "allowed_statistics", allowed_statistics)

    @_builtins.property
    @pulumi.getter(name="entityTypes")
    def entity_types(self) -> Sequence[_builtins.str]:
        """
        Entity types to detect. Can be any of the following:

        - USA_SSN
        - EMAIL
        - USA_ITIN
        - USA_PASSPORT_NUMBER
        - PHONE_NUMBER
        - USA_DRIVING_LICENSE
        - BANK_ACCOUNT
        - CREDIT_CARD
        - IP_ADDRESS
        - MAC_ADDRESS
        - USA_DEA_NUMBER
        - USA_HCPCS_CODE
        - USA_NATIONAL_PROVIDER_IDENTIFIER
        - USA_NATIONAL_DRUG_CODE
        - USA_HEALTH_INSURANCE_CLAIM_NUMBER
        - USA_MEDICARE_BENEFICIARY_IDENTIFIER
        - USA_CPT_CODE
        - PERSON_NAME
        - DATE

        The Entity type group USA_ALL is also supported, and includes all of the above entity types except PERSON_NAME and DATE.
        """
        return pulumi.get(self, "entity_types")

    @_builtins.property
    @pulumi.getter(name="allowedStatistics")
    def allowed_statistics(self) -> Optional['outputs.JobAllowedStatistics']:
        """
        Configuration of statistics that are allowed to be run on columns that contain detected entities. When undefined, no statistics will be computed on columns that contain detected entities.
        """
        return pulumi.get(self, "allowed_statistics")


@pulumi.output_type
class JobOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionFormat":
            suggest = "compression_format"
        elif key == "formatOptions":
            suggest = "format_options"
        elif key == "maxOutputFiles":
            suggest = "max_output_files"
        elif key == "partitionColumns":
            suggest = "partition_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: 'outputs.JobS3Location',
                 compression_format: Optional['JobOutputCompressionFormat'] = None,
                 format: Optional['JobOutputFormat'] = None,
                 format_options: Optional['outputs.JobOutputFormatOptions'] = None,
                 max_output_files: Optional[_builtins.int] = None,
                 overwrite: Optional[_builtins.bool] = None,
                 partition_columns: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'JobS3Location' location: The location in Amazon S3 where the job writes its output.
        :param 'JobOutputCompressionFormat' compression_format: The compression algorithm used to compress the output text of the job.
        :param 'JobOutputFormat' format: The data format of the output of the job.
        :param 'JobOutputFormatOptions' format_options: Represents options that define how DataBrew formats job output files.
        :param _builtins.int max_output_files: The maximum number of files to be generated by the job and written to the output folder.
        :param _builtins.bool overwrite: A value that, if true, means that any data in the location specified for output is overwritten with new output.
        :param Sequence[_builtins.str] partition_columns: The names of one or more partition columns for the output of the job.
        """
        pulumi.set(__self__, "location", location)
        if compression_format is not None:
            pulumi.set(__self__, "compression_format", compression_format)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_options is not None:
            pulumi.set(__self__, "format_options", format_options)
        if max_output_files is not None:
            pulumi.set(__self__, "max_output_files", max_output_files)
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)
        if partition_columns is not None:
            pulumi.set(__self__, "partition_columns", partition_columns)

    @_builtins.property
    @pulumi.getter
    def location(self) -> 'outputs.JobS3Location':
        """
        The location in Amazon S3 where the job writes its output.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="compressionFormat")
    def compression_format(self) -> Optional['JobOutputCompressionFormat']:
        """
        The compression algorithm used to compress the output text of the job.
        """
        return pulumi.get(self, "compression_format")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['JobOutputFormat']:
        """
        The data format of the output of the job.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="formatOptions")
    def format_options(self) -> Optional['outputs.JobOutputFormatOptions']:
        """
        Represents options that define how DataBrew formats job output files.
        """
        return pulumi.get(self, "format_options")

    @_builtins.property
    @pulumi.getter(name="maxOutputFiles")
    def max_output_files(self) -> Optional[_builtins.int]:
        """
        The maximum number of files to be generated by the job and written to the output folder.
        """
        return pulumi.get(self, "max_output_files")

    @_builtins.property
    @pulumi.getter
    def overwrite(self) -> Optional[_builtins.bool]:
        """
        A value that, if true, means that any data in the location specified for output is overwritten with new output.
        """
        return pulumi.get(self, "overwrite")

    @_builtins.property
    @pulumi.getter(name="partitionColumns")
    def partition_columns(self) -> Optional[Sequence[_builtins.str]]:
        """
        The names of one or more partition columns for the output of the job.
        """
        return pulumi.get(self, "partition_columns")


@pulumi.output_type
class JobOutputFormatOptions(dict):
    """
    Format options for job Output
    """
    def __init__(__self__, *,
                 csv: Optional['outputs.JobCsvOutputOptions'] = None):
        """
        Format options for job Output
        :param 'JobCsvOutputOptions' csv: Represents a set of options that define the structure of comma-separated value (CSV) job output.
        """
        if csv is not None:
            pulumi.set(__self__, "csv", csv)

    @_builtins.property
    @pulumi.getter
    def csv(self) -> Optional['outputs.JobCsvOutputOptions']:
        """
        Represents a set of options that define the structure of comma-separated value (CSV) job output.
        """
        return pulumi.get(self, "csv")


@pulumi.output_type
class JobOutputLocation(dict):
    """
    Output location
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketOwner":
            suggest = "bucket_owner"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobOutputLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobOutputLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobOutputLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 bucket_owner: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None):
        """
        Output location
        :param _builtins.str bucket: The Amazon S3 bucket name.
        :param _builtins.str key: The unique name of the object in the bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        if bucket_owner is not None:
            pulumi.set(__self__, "bucket_owner", bucket_owner)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The Amazon S3 bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="bucketOwner")
    def bucket_owner(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_owner")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The unique name of the object in the bucket.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class JobProfileConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnStatisticsConfigurations":
            suggest = "column_statistics_configurations"
        elif key == "datasetStatisticsConfiguration":
            suggest = "dataset_statistics_configuration"
        elif key == "entityDetectorConfiguration":
            suggest = "entity_detector_configuration"
        elif key == "profileColumns":
            suggest = "profile_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobProfileConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobProfileConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobProfileConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_statistics_configurations: Optional[Sequence['outputs.JobColumnStatisticsConfiguration']] = None,
                 dataset_statistics_configuration: Optional['outputs.JobStatisticsConfiguration'] = None,
                 entity_detector_configuration: Optional['outputs.JobEntityDetectorConfiguration'] = None,
                 profile_columns: Optional[Sequence['outputs.JobColumnSelector']] = None):
        """
        :param Sequence['JobColumnStatisticsConfiguration'] column_statistics_configurations: List of configurations for column evaluations. ColumnStatisticsConfigurations are used to select evaluations and override parameters of evaluations for particular columns. When ColumnStatisticsConfigurations is undefined, the profile job will profile all supported columns and run all supported evaluations.
        :param 'JobStatisticsConfiguration' dataset_statistics_configuration: Configuration for inter-column evaluations. Configuration can be used to select evaluations and override parameters of evaluations. When configuration is undefined, the profile job will run all supported inter-column evaluations.
        :param 'JobEntityDetectorConfiguration' entity_detector_configuration: Configuration of entity detection for a profile job. When undefined, entity detection is disabled.
        :param Sequence['JobColumnSelector'] profile_columns: List of column selectors. ProfileColumns can be used to select columns from the dataset. When ProfileColumns is undefined, the profile job will profile all supported columns.
        """
        if column_statistics_configurations is not None:
            pulumi.set(__self__, "column_statistics_configurations", column_statistics_configurations)
        if dataset_statistics_configuration is not None:
            pulumi.set(__self__, "dataset_statistics_configuration", dataset_statistics_configuration)
        if entity_detector_configuration is not None:
            pulumi.set(__self__, "entity_detector_configuration", entity_detector_configuration)
        if profile_columns is not None:
            pulumi.set(__self__, "profile_columns", profile_columns)

    @_builtins.property
    @pulumi.getter(name="columnStatisticsConfigurations")
    def column_statistics_configurations(self) -> Optional[Sequence['outputs.JobColumnStatisticsConfiguration']]:
        """
        List of configurations for column evaluations. ColumnStatisticsConfigurations are used to select evaluations and override parameters of evaluations for particular columns. When ColumnStatisticsConfigurations is undefined, the profile job will profile all supported columns and run all supported evaluations.
        """
        return pulumi.get(self, "column_statistics_configurations")

    @_builtins.property
    @pulumi.getter(name="datasetStatisticsConfiguration")
    def dataset_statistics_configuration(self) -> Optional['outputs.JobStatisticsConfiguration']:
        """
        Configuration for inter-column evaluations. Configuration can be used to select evaluations and override parameters of evaluations. When configuration is undefined, the profile job will run all supported inter-column evaluations.
        """
        return pulumi.get(self, "dataset_statistics_configuration")

    @_builtins.property
    @pulumi.getter(name="entityDetectorConfiguration")
    def entity_detector_configuration(self) -> Optional['outputs.JobEntityDetectorConfiguration']:
        """
        Configuration of entity detection for a profile job. When undefined, entity detection is disabled.
        """
        return pulumi.get(self, "entity_detector_configuration")

    @_builtins.property
    @pulumi.getter(name="profileColumns")
    def profile_columns(self) -> Optional[Sequence['outputs.JobColumnSelector']]:
        """
        List of column selectors. ProfileColumns can be used to select columns from the dataset. When ProfileColumns is undefined, the profile job will profile all supported columns.
        """
        return pulumi.get(self, "profile_columns")


@pulumi.output_type
class JobRecipe(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Recipe name
        :param _builtins.str version: Recipe version
        """
        pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Recipe name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Recipe version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class JobS3Location(dict):
    """
    S3 Output location
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketOwner":
            suggest = "bucket_owner"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobS3Location. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobS3Location.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobS3Location.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 bucket_owner: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None):
        """
        S3 Output location
        :param _builtins.str bucket: The Amazon S3 bucket name.
        :param _builtins.str bucket_owner: The AWS account ID of the bucket owner.
        :param _builtins.str key: The unique name of the object in the bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        if bucket_owner is not None:
            pulumi.set(__self__, "bucket_owner", bucket_owner)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The Amazon S3 bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="bucketOwner")
    def bucket_owner(self) -> Optional[_builtins.str]:
        """
        The AWS account ID of the bucket owner.
        """
        return pulumi.get(self, "bucket_owner")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The unique name of the object in the bucket.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class JobS3TableOutputOptions(dict):
    def __init__(__self__, *,
                 location: 'outputs.JobS3Location'):
        """
        :param 'JobS3Location' location: Represents an Amazon S3 location (bucket name and object key) where DataBrew can write output from a job.
        """
        pulumi.set(__self__, "location", location)

    @_builtins.property
    @pulumi.getter
    def location(self) -> 'outputs.JobS3Location':
        """
        Represents an Amazon S3 location (bucket name and object key) where DataBrew can write output from a job.
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class JobSample(dict):
    """
    Job Sample
    """
    def __init__(__self__, *,
                 mode: Optional['JobSampleMode'] = None,
                 size: Optional[_builtins.int] = None):
        """
        Job Sample
        :param 'JobSampleMode' mode: A value that determines whether the profile job is run on the entire dataset or a specified number of rows. This value must be one of the following:
               
               - FULL_DATASET - The profile job is run on the entire dataset.
               - CUSTOM_ROWS - The profile job is run on the number of rows specified in the `Size` parameter.
        :param _builtins.int size: The `Size` parameter is only required when the mode is CUSTOM_ROWS. The profile job is run on the specified number of rows. The maximum value for size is Long.MAX_VALUE.
               
               Long.MAX_VALUE = 9223372036854775807
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional['JobSampleMode']:
        """
        A value that determines whether the profile job is run on the entire dataset or a specified number of rows. This value must be one of the following:

        - FULL_DATASET - The profile job is run on the entire dataset.
        - CUSTOM_ROWS - The profile job is run on the number of rows specified in the `Size` parameter.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The `Size` parameter is only required when the mode is CUSTOM_ROWS. The profile job is run on the specified number of rows. The maximum value for size is Long.MAX_VALUE.

        Long.MAX_VALUE = 9223372036854775807
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class JobStatisticOverride(dict):
    def __init__(__self__, *,
                 parameters: Mapping[str, _builtins.str],
                 statistic: _builtins.str):
        """
        :param Mapping[str, _builtins.str] parameters: A map that includes overrides of an evaluations parameters.
        :param _builtins.str statistic: The name of an evaluation
        """
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "statistic", statistic)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Mapping[str, _builtins.str]:
        """
        A map that includes overrides of an evaluations parameters.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def statistic(self) -> _builtins.str:
        """
        The name of an evaluation
        """
        return pulumi.get(self, "statistic")


@pulumi.output_type
class JobStatisticsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedStatistics":
            suggest = "included_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobStatisticsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobStatisticsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobStatisticsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 included_statistics: Optional[Sequence[_builtins.str]] = None,
                 overrides: Optional[Sequence['outputs.JobStatisticOverride']] = None):
        """
        :param Sequence[_builtins.str] included_statistics: List of included evaluations. When the list is undefined, all supported evaluations will be included.
        :param Sequence['JobStatisticOverride'] overrides: List of overrides for evaluations.
        """
        if included_statistics is not None:
            pulumi.set(__self__, "included_statistics", included_statistics)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="includedStatistics")
    def included_statistics(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of included evaluations. When the list is undefined, all supported evaluations will be included.
        """
        return pulumi.get(self, "included_statistics")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.JobStatisticOverride']]:
        """
        List of overrides for evaluations.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class JobValidationConfiguration(dict):
    """
    Configuration to attach Rulesets to the job
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rulesetArn":
            suggest = "ruleset_arn"
        elif key == "validationMode":
            suggest = "validation_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobValidationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobValidationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobValidationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ruleset_arn: _builtins.str,
                 validation_mode: Optional['JobValidationMode'] = None):
        """
        Configuration to attach Rulesets to the job
        :param _builtins.str ruleset_arn: Arn of the Ruleset
        :param 'JobValidationMode' validation_mode: Mode of data quality validation. Default mode is "CHECK_ALL" which verifies all rules defined in the selected ruleset.
        """
        pulumi.set(__self__, "ruleset_arn", ruleset_arn)
        if validation_mode is not None:
            pulumi.set(__self__, "validation_mode", validation_mode)

    @_builtins.property
    @pulumi.getter(name="rulesetArn")
    def ruleset_arn(self) -> _builtins.str:
        """
        Arn of the Ruleset
        """
        return pulumi.get(self, "ruleset_arn")

    @_builtins.property
    @pulumi.getter(name="validationMode")
    def validation_mode(self) -> Optional['JobValidationMode']:
        """
        Mode of data quality validation. Default mode is "CHECK_ALL" which verifies all rules defined in the selected ruleset.
        """
        return pulumi.get(self, "validation_mode")


@pulumi.output_type
class ProjectSample(dict):
    def __init__(__self__, *,
                 type: 'ProjectSampleType',
                 size: Optional[_builtins.int] = None):
        """
        :param 'ProjectSampleType' type: Sample type
        :param _builtins.int size: Sample size
        """
        pulumi.set(__self__, "type", type)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'ProjectSampleType':
        """
        Sample type
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        Sample size
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class RecipeAction(dict):
    def __init__(__self__, *,
                 operation: _builtins.str,
                 parameters: Optional[Any] = None):
        """
        :param _builtins.str operation: Step action operation
        :param Union['RecipeParameters', Mapping[str, _builtins.str]] parameters: Contextual parameters for the transformation.
        """
        pulumi.set(__self__, "operation", operation)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        Step action operation
        """
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        """
        Contextual parameters for the transformation.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class RecipeConditionExpression(dict):
    """
    Condition expressions applied to the step action
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetColumn":
            suggest = "target_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecipeConditionExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecipeConditionExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecipeConditionExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: _builtins.str,
                 target_column: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        Condition expressions applied to the step action
        :param _builtins.str condition: Input condition to be applied to the target column
        :param _builtins.str target_column: Name of the target column
        :param _builtins.str value: Value of the condition
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "target_column", target_column)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        Input condition to be applied to the target column
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter(name="targetColumn")
    def target_column(self) -> _builtins.str:
        """
        Name of the target column
        """
        return pulumi.get(self, "target_column")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value of the condition
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RecipeDataCatalogInputDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogId":
            suggest = "catalog_id"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "tempDirectory":
            suggest = "temp_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecipeDataCatalogInputDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecipeDataCatalogInputDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecipeDataCatalogInputDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_id: Optional[_builtins.str] = None,
                 database_name: Optional[_builtins.str] = None,
                 table_name: Optional[_builtins.str] = None,
                 temp_directory: Optional['outputs.RecipeS3Location'] = None):
        """
        :param _builtins.str catalog_id: Catalog id
        :param _builtins.str database_name: Database name
        :param _builtins.str table_name: Table name
        """
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)
        if temp_directory is not None:
            pulumi.set(__self__, "temp_directory", temp_directory)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[_builtins.str]:
        """
        Catalog id
        """
        return pulumi.get(self, "catalog_id")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        Database name
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[_builtins.str]:
        """
        Table name
        """
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="tempDirectory")
    def temp_directory(self) -> Optional['outputs.RecipeS3Location']:
        return pulumi.get(self, "temp_directory")


@pulumi.output_type
class RecipeParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateFunction":
            suggest = "aggregate_function"
        elif key == "caseStatement":
            suggest = "case_statement"
        elif key == "categoryMap":
            suggest = "category_map"
        elif key == "charsToRemove":
            suggest = "chars_to_remove"
        elif key == "collapseConsecutiveWhitespace":
            suggest = "collapse_consecutive_whitespace"
        elif key == "columnDataType":
            suggest = "column_data_type"
        elif key == "columnRange":
            suggest = "column_range"
        elif key == "customCharacters":
            suggest = "custom_characters"
        elif key == "customStopWords":
            suggest = "custom_stop_words"
        elif key == "customValue":
            suggest = "custom_value"
        elif key == "datasetsColumns":
            suggest = "datasets_columns"
        elif key == "dateAddValue":
            suggest = "date_add_value"
        elif key == "dateTimeFormat":
            suggest = "date_time_format"
        elif key == "dateTimeParameters":
            suggest = "date_time_parameters"
        elif key == "deleteOtherRows":
            suggest = "delete_other_rows"
        elif key == "endPattern":
            suggest = "end_pattern"
        elif key == "endPosition":
            suggest = "end_position"
        elif key == "endValue":
            suggest = "end_value"
        elif key == "expandContractions":
            suggest = "expand_contractions"
        elif key == "falseString":
            suggest = "false_string"
        elif key == "groupByAggFunctionOptions":
            suggest = "group_by_agg_function_options"
        elif key == "groupByColumns":
            suggest = "group_by_columns"
        elif key == "hiddenColumns":
            suggest = "hidden_columns"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "includeInSplit":
            suggest = "include_in_split"
        elif key == "isText":
            suggest = "is_text"
        elif key == "joinKeys":
            suggest = "join_keys"
        elif key == "joinType":
            suggest = "join_type"
        elif key == "leftColumns":
            suggest = "left_columns"
        elif key == "lowerBound":
            suggest = "lower_bound"
        elif key == "mapType":
            suggest = "map_type"
        elif key == "modeType":
            suggest = "mode_type"
        elif key == "multiLine":
            suggest = "multi_line"
        elif key == "numRows":
            suggest = "num_rows"
        elif key == "numRowsAfter":
            suggest = "num_rows_after"
        elif key == "numRowsBefore":
            suggest = "num_rows_before"
        elif key == "orderByColumn":
            suggest = "order_by_column"
        elif key == "orderByColumns":
            suggest = "order_by_columns"
        elif key == "patternOption1":
            suggest = "pattern_option1"
        elif key == "patternOption2":
            suggest = "pattern_option2"
        elif key == "patternOptions":
            suggest = "pattern_options"
        elif key == "removeAllPunctuation":
            suggest = "remove_all_punctuation"
        elif key == "removeAllQuotes":
            suggest = "remove_all_quotes"
        elif key == "removeAllWhitespace":
            suggest = "remove_all_whitespace"
        elif key == "removeCustomCharacters":
            suggest = "remove_custom_characters"
        elif key == "removeCustomValue":
            suggest = "remove_custom_value"
        elif key == "removeLeadingAndTrailingPunctuation":
            suggest = "remove_leading_and_trailing_punctuation"
        elif key == "removeLeadingAndTrailingQuotes":
            suggest = "remove_leading_and_trailing_quotes"
        elif key == "removeLeadingAndTrailingWhitespace":
            suggest = "remove_leading_and_trailing_whitespace"
        elif key == "removeLetters":
            suggest = "remove_letters"
        elif key == "removeNumbers":
            suggest = "remove_numbers"
        elif key == "removeSourceColumn":
            suggest = "remove_source_column"
        elif key == "removeSpecialCharacters":
            suggest = "remove_special_characters"
        elif key == "rightColumns":
            suggest = "right_columns"
        elif key == "sampleSize":
            suggest = "sample_size"
        elif key == "sampleType":
            suggest = "sample_type"
        elif key == "secondInput":
            suggest = "second_input"
        elif key == "secondaryInputs":
            suggest = "secondary_inputs"
        elif key == "sheetIndexes":
            suggest = "sheet_indexes"
        elif key == "sheetNames":
            suggest = "sheet_names"
        elif key == "sourceColumn":
            suggest = "source_column"
        elif key == "sourceColumn1":
            suggest = "source_column1"
        elif key == "sourceColumn2":
            suggest = "source_column2"
        elif key == "sourceColumns":
            suggest = "source_columns"
        elif key == "startColumnIndex":
            suggest = "start_column_index"
        elif key == "startPattern":
            suggest = "start_pattern"
        elif key == "startPosition":
            suggest = "start_position"
        elif key == "startValue":
            suggest = "start_value"
        elif key == "stemmingMode":
            suggest = "stemming_mode"
        elif key == "stepCount":
            suggest = "step_count"
        elif key == "stepIndex":
            suggest = "step_index"
        elif key == "stopWordsMode":
            suggest = "stop_words_mode"
        elif key == "targetColumn":
            suggest = "target_column"
        elif key == "targetColumnNames":
            suggest = "target_column_names"
        elif key == "targetDateFormat":
            suggest = "target_date_format"
        elif key == "targetIndex":
            suggest = "target_index"
        elif key == "timeZone":
            suggest = "time_zone"
        elif key == "tokenizerPattern":
            suggest = "tokenizer_pattern"
        elif key == "trueString":
            suggest = "true_string"
        elif key == "udfLang":
            suggest = "udf_lang"
        elif key == "unpivotColumn":
            suggest = "unpivot_column"
        elif key == "upperBound":
            suggest = "upper_bound"
        elif key == "useNewDataFrame":
            suggest = "use_new_data_frame"
        elif key == "valueColumn":
            suggest = "value_column"
        elif key == "viewFrame":
            suggest = "view_frame"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecipeParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecipeParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecipeParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregate_function: Optional[_builtins.str] = None,
                 base: Optional[_builtins.str] = None,
                 case_statement: Optional[_builtins.str] = None,
                 category_map: Optional[_builtins.str] = None,
                 chars_to_remove: Optional[_builtins.str] = None,
                 collapse_consecutive_whitespace: Optional[_builtins.str] = None,
                 column_data_type: Optional[_builtins.str] = None,
                 column_range: Optional[_builtins.str] = None,
                 count: Optional[_builtins.str] = None,
                 custom_characters: Optional[_builtins.str] = None,
                 custom_stop_words: Optional[_builtins.str] = None,
                 custom_value: Optional[_builtins.str] = None,
                 datasets_columns: Optional[_builtins.str] = None,
                 date_add_value: Optional[_builtins.str] = None,
                 date_time_format: Optional[_builtins.str] = None,
                 date_time_parameters: Optional[_builtins.str] = None,
                 delete_other_rows: Optional[_builtins.str] = None,
                 delimiter: Optional[_builtins.str] = None,
                 end_pattern: Optional[_builtins.str] = None,
                 end_position: Optional[_builtins.str] = None,
                 end_value: Optional[_builtins.str] = None,
                 expand_contractions: Optional[_builtins.str] = None,
                 exponent: Optional[_builtins.str] = None,
                 false_string: Optional[_builtins.str] = None,
                 group_by_agg_function_options: Optional[_builtins.str] = None,
                 group_by_columns: Optional[_builtins.str] = None,
                 hidden_columns: Optional[_builtins.str] = None,
                 ignore_case: Optional[_builtins.str] = None,
                 include_in_split: Optional[_builtins.str] = None,
                 input: Optional['outputs.RecipeParametersInputProperties'] = None,
                 interval: Optional[_builtins.str] = None,
                 is_text: Optional[_builtins.str] = None,
                 join_keys: Optional[_builtins.str] = None,
                 join_type: Optional[_builtins.str] = None,
                 left_columns: Optional[_builtins.str] = None,
                 limit: Optional[_builtins.str] = None,
                 lower_bound: Optional[_builtins.str] = None,
                 map_type: Optional[_builtins.str] = None,
                 mode_type: Optional[_builtins.str] = None,
                 multi_line: Optional[_builtins.bool] = None,
                 num_rows: Optional[_builtins.str] = None,
                 num_rows_after: Optional[_builtins.str] = None,
                 num_rows_before: Optional[_builtins.str] = None,
                 order_by_column: Optional[_builtins.str] = None,
                 order_by_columns: Optional[_builtins.str] = None,
                 other: Optional[_builtins.str] = None,
                 pattern: Optional[_builtins.str] = None,
                 pattern_option1: Optional[_builtins.str] = None,
                 pattern_option2: Optional[_builtins.str] = None,
                 pattern_options: Optional[_builtins.str] = None,
                 period: Optional[_builtins.str] = None,
                 position: Optional[_builtins.str] = None,
                 remove_all_punctuation: Optional[_builtins.str] = None,
                 remove_all_quotes: Optional[_builtins.str] = None,
                 remove_all_whitespace: Optional[_builtins.str] = None,
                 remove_custom_characters: Optional[_builtins.str] = None,
                 remove_custom_value: Optional[_builtins.str] = None,
                 remove_leading_and_trailing_punctuation: Optional[_builtins.str] = None,
                 remove_leading_and_trailing_quotes: Optional[_builtins.str] = None,
                 remove_leading_and_trailing_whitespace: Optional[_builtins.str] = None,
                 remove_letters: Optional[_builtins.str] = None,
                 remove_numbers: Optional[_builtins.str] = None,
                 remove_source_column: Optional[_builtins.str] = None,
                 remove_special_characters: Optional[_builtins.str] = None,
                 right_columns: Optional[_builtins.str] = None,
                 sample_size: Optional[_builtins.str] = None,
                 sample_type: Optional[_builtins.str] = None,
                 second_input: Optional[_builtins.str] = None,
                 secondary_inputs: Optional[Sequence['outputs.RecipeSecondaryInput']] = None,
                 sheet_indexes: Optional[Sequence[_builtins.int]] = None,
                 sheet_names: Optional[Sequence[_builtins.str]] = None,
                 source_column: Optional[_builtins.str] = None,
                 source_column1: Optional[_builtins.str] = None,
                 source_column2: Optional[_builtins.str] = None,
                 source_columns: Optional[_builtins.str] = None,
                 start_column_index: Optional[_builtins.str] = None,
                 start_pattern: Optional[_builtins.str] = None,
                 start_position: Optional[_builtins.str] = None,
                 start_value: Optional[_builtins.str] = None,
                 stemming_mode: Optional[_builtins.str] = None,
                 step_count: Optional[_builtins.str] = None,
                 step_index: Optional[_builtins.str] = None,
                 stop_words_mode: Optional[_builtins.str] = None,
                 strategy: Optional[_builtins.str] = None,
                 target_column: Optional[_builtins.str] = None,
                 target_column_names: Optional[_builtins.str] = None,
                 target_date_format: Optional[_builtins.str] = None,
                 target_index: Optional[_builtins.str] = None,
                 time_zone: Optional[_builtins.str] = None,
                 tokenizer_pattern: Optional[_builtins.str] = None,
                 true_string: Optional[_builtins.str] = None,
                 udf_lang: Optional[_builtins.str] = None,
                 units: Optional[_builtins.str] = None,
                 unpivot_column: Optional[_builtins.str] = None,
                 upper_bound: Optional[_builtins.str] = None,
                 use_new_data_frame: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None,
                 value1: Optional[_builtins.str] = None,
                 value2: Optional[_builtins.str] = None,
                 value_column: Optional[_builtins.str] = None,
                 view_frame: Optional[_builtins.str] = None):
        """
        :param 'RecipeParametersInputProperties' input: Input
        """
        if aggregate_function is not None:
            pulumi.set(__self__, "aggregate_function", aggregate_function)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if case_statement is not None:
            pulumi.set(__self__, "case_statement", case_statement)
        if category_map is not None:
            pulumi.set(__self__, "category_map", category_map)
        if chars_to_remove is not None:
            pulumi.set(__self__, "chars_to_remove", chars_to_remove)
        if collapse_consecutive_whitespace is not None:
            pulumi.set(__self__, "collapse_consecutive_whitespace", collapse_consecutive_whitespace)
        if column_data_type is not None:
            pulumi.set(__self__, "column_data_type", column_data_type)
        if column_range is not None:
            pulumi.set(__self__, "column_range", column_range)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if custom_characters is not None:
            pulumi.set(__self__, "custom_characters", custom_characters)
        if custom_stop_words is not None:
            pulumi.set(__self__, "custom_stop_words", custom_stop_words)
        if custom_value is not None:
            pulumi.set(__self__, "custom_value", custom_value)
        if datasets_columns is not None:
            pulumi.set(__self__, "datasets_columns", datasets_columns)
        if date_add_value is not None:
            pulumi.set(__self__, "date_add_value", date_add_value)
        if date_time_format is not None:
            pulumi.set(__self__, "date_time_format", date_time_format)
        if date_time_parameters is not None:
            pulumi.set(__self__, "date_time_parameters", date_time_parameters)
        if delete_other_rows is not None:
            pulumi.set(__self__, "delete_other_rows", delete_other_rows)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if end_pattern is not None:
            pulumi.set(__self__, "end_pattern", end_pattern)
        if end_position is not None:
            pulumi.set(__self__, "end_position", end_position)
        if end_value is not None:
            pulumi.set(__self__, "end_value", end_value)
        if expand_contractions is not None:
            pulumi.set(__self__, "expand_contractions", expand_contractions)
        if exponent is not None:
            pulumi.set(__self__, "exponent", exponent)
        if false_string is not None:
            pulumi.set(__self__, "false_string", false_string)
        if group_by_agg_function_options is not None:
            pulumi.set(__self__, "group_by_agg_function_options", group_by_agg_function_options)
        if group_by_columns is not None:
            pulumi.set(__self__, "group_by_columns", group_by_columns)
        if hidden_columns is not None:
            pulumi.set(__self__, "hidden_columns", hidden_columns)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if include_in_split is not None:
            pulumi.set(__self__, "include_in_split", include_in_split)
        if input is not None:
            pulumi.set(__self__, "input", input)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if is_text is not None:
            pulumi.set(__self__, "is_text", is_text)
        if join_keys is not None:
            pulumi.set(__self__, "join_keys", join_keys)
        if join_type is not None:
            pulumi.set(__self__, "join_type", join_type)
        if left_columns is not None:
            pulumi.set(__self__, "left_columns", left_columns)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if lower_bound is not None:
            pulumi.set(__self__, "lower_bound", lower_bound)
        if map_type is not None:
            pulumi.set(__self__, "map_type", map_type)
        if mode_type is not None:
            pulumi.set(__self__, "mode_type", mode_type)
        if multi_line is not None:
            pulumi.set(__self__, "multi_line", multi_line)
        if num_rows is not None:
            pulumi.set(__self__, "num_rows", num_rows)
        if num_rows_after is not None:
            pulumi.set(__self__, "num_rows_after", num_rows_after)
        if num_rows_before is not None:
            pulumi.set(__self__, "num_rows_before", num_rows_before)
        if order_by_column is not None:
            pulumi.set(__self__, "order_by_column", order_by_column)
        if order_by_columns is not None:
            pulumi.set(__self__, "order_by_columns", order_by_columns)
        if other is not None:
            pulumi.set(__self__, "other", other)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if pattern_option1 is not None:
            pulumi.set(__self__, "pattern_option1", pattern_option1)
        if pattern_option2 is not None:
            pulumi.set(__self__, "pattern_option2", pattern_option2)
        if pattern_options is not None:
            pulumi.set(__self__, "pattern_options", pattern_options)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if position is not None:
            pulumi.set(__self__, "position", position)
        if remove_all_punctuation is not None:
            pulumi.set(__self__, "remove_all_punctuation", remove_all_punctuation)
        if remove_all_quotes is not None:
            pulumi.set(__self__, "remove_all_quotes", remove_all_quotes)
        if remove_all_whitespace is not None:
            pulumi.set(__self__, "remove_all_whitespace", remove_all_whitespace)
        if remove_custom_characters is not None:
            pulumi.set(__self__, "remove_custom_characters", remove_custom_characters)
        if remove_custom_value is not None:
            pulumi.set(__self__, "remove_custom_value", remove_custom_value)
        if remove_leading_and_trailing_punctuation is not None:
            pulumi.set(__self__, "remove_leading_and_trailing_punctuation", remove_leading_and_trailing_punctuation)
        if remove_leading_and_trailing_quotes is not None:
            pulumi.set(__self__, "remove_leading_and_trailing_quotes", remove_leading_and_trailing_quotes)
        if remove_leading_and_trailing_whitespace is not None:
            pulumi.set(__self__, "remove_leading_and_trailing_whitespace", remove_leading_and_trailing_whitespace)
        if remove_letters is not None:
            pulumi.set(__self__, "remove_letters", remove_letters)
        if remove_numbers is not None:
            pulumi.set(__self__, "remove_numbers", remove_numbers)
        if remove_source_column is not None:
            pulumi.set(__self__, "remove_source_column", remove_source_column)
        if remove_special_characters is not None:
            pulumi.set(__self__, "remove_special_characters", remove_special_characters)
        if right_columns is not None:
            pulumi.set(__self__, "right_columns", right_columns)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if sample_type is not None:
            pulumi.set(__self__, "sample_type", sample_type)
        if second_input is not None:
            pulumi.set(__self__, "second_input", second_input)
        if secondary_inputs is not None:
            pulumi.set(__self__, "secondary_inputs", secondary_inputs)
        if sheet_indexes is not None:
            pulumi.set(__self__, "sheet_indexes", sheet_indexes)
        if sheet_names is not None:
            pulumi.set(__self__, "sheet_names", sheet_names)
        if source_column is not None:
            pulumi.set(__self__, "source_column", source_column)
        if source_column1 is not None:
            pulumi.set(__self__, "source_column1", source_column1)
        if source_column2 is not None:
            pulumi.set(__self__, "source_column2", source_column2)
        if source_columns is not None:
            pulumi.set(__self__, "source_columns", source_columns)
        if start_column_index is not None:
            pulumi.set(__self__, "start_column_index", start_column_index)
        if start_pattern is not None:
            pulumi.set(__self__, "start_pattern", start_pattern)
        if start_position is not None:
            pulumi.set(__self__, "start_position", start_position)
        if start_value is not None:
            pulumi.set(__self__, "start_value", start_value)
        if stemming_mode is not None:
            pulumi.set(__self__, "stemming_mode", stemming_mode)
        if step_count is not None:
            pulumi.set(__self__, "step_count", step_count)
        if step_index is not None:
            pulumi.set(__self__, "step_index", step_index)
        if stop_words_mode is not None:
            pulumi.set(__self__, "stop_words_mode", stop_words_mode)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if target_column is not None:
            pulumi.set(__self__, "target_column", target_column)
        if target_column_names is not None:
            pulumi.set(__self__, "target_column_names", target_column_names)
        if target_date_format is not None:
            pulumi.set(__self__, "target_date_format", target_date_format)
        if target_index is not None:
            pulumi.set(__self__, "target_index", target_index)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if tokenizer_pattern is not None:
            pulumi.set(__self__, "tokenizer_pattern", tokenizer_pattern)
        if true_string is not None:
            pulumi.set(__self__, "true_string", true_string)
        if udf_lang is not None:
            pulumi.set(__self__, "udf_lang", udf_lang)
        if units is not None:
            pulumi.set(__self__, "units", units)
        if unpivot_column is not None:
            pulumi.set(__self__, "unpivot_column", unpivot_column)
        if upper_bound is not None:
            pulumi.set(__self__, "upper_bound", upper_bound)
        if use_new_data_frame is not None:
            pulumi.set(__self__, "use_new_data_frame", use_new_data_frame)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value1 is not None:
            pulumi.set(__self__, "value1", value1)
        if value2 is not None:
            pulumi.set(__self__, "value2", value2)
        if value_column is not None:
            pulumi.set(__self__, "value_column", value_column)
        if view_frame is not None:
            pulumi.set(__self__, "view_frame", view_frame)

    @_builtins.property
    @pulumi.getter(name="aggregateFunction")
    def aggregate_function(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aggregate_function")

    @_builtins.property
    @pulumi.getter
    def base(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "base")

    @_builtins.property
    @pulumi.getter(name="caseStatement")
    def case_statement(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "case_statement")

    @_builtins.property
    @pulumi.getter(name="categoryMap")
    def category_map(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "category_map")

    @_builtins.property
    @pulumi.getter(name="charsToRemove")
    def chars_to_remove(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "chars_to_remove")

    @_builtins.property
    @pulumi.getter(name="collapseConsecutiveWhitespace")
    def collapse_consecutive_whitespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "collapse_consecutive_whitespace")

    @_builtins.property
    @pulumi.getter(name="columnDataType")
    def column_data_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "column_data_type")

    @_builtins.property
    @pulumi.getter(name="columnRange")
    def column_range(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "column_range")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="customCharacters")
    def custom_characters(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_characters")

    @_builtins.property
    @pulumi.getter(name="customStopWords")
    def custom_stop_words(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_stop_words")

    @_builtins.property
    @pulumi.getter(name="customValue")
    def custom_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_value")

    @_builtins.property
    @pulumi.getter(name="datasetsColumns")
    def datasets_columns(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "datasets_columns")

    @_builtins.property
    @pulumi.getter(name="dateAddValue")
    def date_add_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "date_add_value")

    @_builtins.property
    @pulumi.getter(name="dateTimeFormat")
    def date_time_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "date_time_format")

    @_builtins.property
    @pulumi.getter(name="dateTimeParameters")
    def date_time_parameters(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "date_time_parameters")

    @_builtins.property
    @pulumi.getter(name="deleteOtherRows")
    def delete_other_rows(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "delete_other_rows")

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="endPattern")
    def end_pattern(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "end_pattern")

    @_builtins.property
    @pulumi.getter(name="endPosition")
    def end_position(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "end_position")

    @_builtins.property
    @pulumi.getter(name="endValue")
    def end_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "end_value")

    @_builtins.property
    @pulumi.getter(name="expandContractions")
    def expand_contractions(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "expand_contractions")

    @_builtins.property
    @pulumi.getter
    def exponent(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exponent")

    @_builtins.property
    @pulumi.getter(name="falseString")
    def false_string(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "false_string")

    @_builtins.property
    @pulumi.getter(name="groupByAggFunctionOptions")
    def group_by_agg_function_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group_by_agg_function_options")

    @_builtins.property
    @pulumi.getter(name="groupByColumns")
    def group_by_columns(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group_by_columns")

    @_builtins.property
    @pulumi.getter(name="hiddenColumns")
    def hidden_columns(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hidden_columns")

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ignore_case")

    @_builtins.property
    @pulumi.getter(name="includeInSplit")
    def include_in_split(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "include_in_split")

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.RecipeParametersInputProperties']:
        """
        Input
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="isText")
    def is_text(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "is_text")

    @_builtins.property
    @pulumi.getter(name="joinKeys")
    def join_keys(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "join_keys")

    @_builtins.property
    @pulumi.getter(name="joinType")
    def join_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "join_type")

    @_builtins.property
    @pulumi.getter(name="leftColumns")
    def left_columns(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "left_columns")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter(name="lowerBound")
    def lower_bound(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "lower_bound")

    @_builtins.property
    @pulumi.getter(name="mapType")
    def map_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "map_type")

    @_builtins.property
    @pulumi.getter(name="modeType")
    def mode_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode_type")

    @_builtins.property
    @pulumi.getter(name="multiLine")
    def multi_line(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "multi_line")

    @_builtins.property
    @pulumi.getter(name="numRows")
    def num_rows(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "num_rows")

    @_builtins.property
    @pulumi.getter(name="numRowsAfter")
    def num_rows_after(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "num_rows_after")

    @_builtins.property
    @pulumi.getter(name="numRowsBefore")
    def num_rows_before(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "num_rows_before")

    @_builtins.property
    @pulumi.getter(name="orderByColumn")
    def order_by_column(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "order_by_column")

    @_builtins.property
    @pulumi.getter(name="orderByColumns")
    def order_by_columns(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "order_by_columns")

    @_builtins.property
    @pulumi.getter
    def other(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "other")

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pattern")

    @_builtins.property
    @pulumi.getter(name="patternOption1")
    def pattern_option1(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pattern_option1")

    @_builtins.property
    @pulumi.getter(name="patternOption2")
    def pattern_option2(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pattern_option2")

    @_builtins.property
    @pulumi.getter(name="patternOptions")
    def pattern_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pattern_options")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "position")

    @_builtins.property
    @pulumi.getter(name="removeAllPunctuation")
    def remove_all_punctuation(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_all_punctuation")

    @_builtins.property
    @pulumi.getter(name="removeAllQuotes")
    def remove_all_quotes(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_all_quotes")

    @_builtins.property
    @pulumi.getter(name="removeAllWhitespace")
    def remove_all_whitespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_all_whitespace")

    @_builtins.property
    @pulumi.getter(name="removeCustomCharacters")
    def remove_custom_characters(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_custom_characters")

    @_builtins.property
    @pulumi.getter(name="removeCustomValue")
    def remove_custom_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_custom_value")

    @_builtins.property
    @pulumi.getter(name="removeLeadingAndTrailingPunctuation")
    def remove_leading_and_trailing_punctuation(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_leading_and_trailing_punctuation")

    @_builtins.property
    @pulumi.getter(name="removeLeadingAndTrailingQuotes")
    def remove_leading_and_trailing_quotes(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_leading_and_trailing_quotes")

    @_builtins.property
    @pulumi.getter(name="removeLeadingAndTrailingWhitespace")
    def remove_leading_and_trailing_whitespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_leading_and_trailing_whitespace")

    @_builtins.property
    @pulumi.getter(name="removeLetters")
    def remove_letters(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_letters")

    @_builtins.property
    @pulumi.getter(name="removeNumbers")
    def remove_numbers(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_numbers")

    @_builtins.property
    @pulumi.getter(name="removeSourceColumn")
    def remove_source_column(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_source_column")

    @_builtins.property
    @pulumi.getter(name="removeSpecialCharacters")
    def remove_special_characters(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remove_special_characters")

    @_builtins.property
    @pulumi.getter(name="rightColumns")
    def right_columns(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "right_columns")

    @_builtins.property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sample_size")

    @_builtins.property
    @pulumi.getter(name="sampleType")
    def sample_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sample_type")

    @_builtins.property
    @pulumi.getter(name="secondInput")
    def second_input(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "second_input")

    @_builtins.property
    @pulumi.getter(name="secondaryInputs")
    def secondary_inputs(self) -> Optional[Sequence['outputs.RecipeSecondaryInput']]:
        return pulumi.get(self, "secondary_inputs")

    @_builtins.property
    @pulumi.getter(name="sheetIndexes")
    def sheet_indexes(self) -> Optional[Sequence[_builtins.int]]:
        return pulumi.get(self, "sheet_indexes")

    @_builtins.property
    @pulumi.getter(name="sheetNames")
    def sheet_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "sheet_names")

    @_builtins.property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_column")

    @_builtins.property
    @pulumi.getter(name="sourceColumn1")
    def source_column1(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_column1")

    @_builtins.property
    @pulumi.getter(name="sourceColumn2")
    def source_column2(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_column2")

    @_builtins.property
    @pulumi.getter(name="sourceColumns")
    def source_columns(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_columns")

    @_builtins.property
    @pulumi.getter(name="startColumnIndex")
    def start_column_index(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "start_column_index")

    @_builtins.property
    @pulumi.getter(name="startPattern")
    def start_pattern(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "start_pattern")

    @_builtins.property
    @pulumi.getter(name="startPosition")
    def start_position(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "start_position")

    @_builtins.property
    @pulumi.getter(name="startValue")
    def start_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "start_value")

    @_builtins.property
    @pulumi.getter(name="stemmingMode")
    def stemming_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "stemming_mode")

    @_builtins.property
    @pulumi.getter(name="stepCount")
    def step_count(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "step_count")

    @_builtins.property
    @pulumi.getter(name="stepIndex")
    def step_index(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "step_index")

    @_builtins.property
    @pulumi.getter(name="stopWordsMode")
    def stop_words_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "stop_words_mode")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "strategy")

    @_builtins.property
    @pulumi.getter(name="targetColumn")
    def target_column(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_column")

    @_builtins.property
    @pulumi.getter(name="targetColumnNames")
    def target_column_names(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_column_names")

    @_builtins.property
    @pulumi.getter(name="targetDateFormat")
    def target_date_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_date_format")

    @_builtins.property
    @pulumi.getter(name="targetIndex")
    def target_index(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_index")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="tokenizerPattern")
    def tokenizer_pattern(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tokenizer_pattern")

    @_builtins.property
    @pulumi.getter(name="trueString")
    def true_string(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "true_string")

    @_builtins.property
    @pulumi.getter(name="udfLang")
    def udf_lang(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "udf_lang")

    @_builtins.property
    @pulumi.getter
    def units(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "units")

    @_builtins.property
    @pulumi.getter(name="unpivotColumn")
    def unpivot_column(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unpivot_column")

    @_builtins.property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "upper_bound")

    @_builtins.property
    @pulumi.getter(name="useNewDataFrame")
    def use_new_data_frame(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_new_data_frame")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def value1(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value1")

    @_builtins.property
    @pulumi.getter
    def value2(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value2")

    @_builtins.property
    @pulumi.getter(name="valueColumn")
    def value_column(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value_column")

    @_builtins.property
    @pulumi.getter(name="viewFrame")
    def view_frame(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "view_frame")


@pulumi.output_type
class RecipeParametersInputProperties(dict):
    """
    Input
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataCatalogInputDefinition":
            suggest = "data_catalog_input_definition"
        elif key == "s3InputDefinition":
            suggest = "s3_input_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecipeParametersInputProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecipeParametersInputProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecipeParametersInputProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_catalog_input_definition: Optional['outputs.RecipeDataCatalogInputDefinition'] = None,
                 s3_input_definition: Optional['outputs.RecipeS3Location'] = None):
        """
        Input
        """
        if data_catalog_input_definition is not None:
            pulumi.set(__self__, "data_catalog_input_definition", data_catalog_input_definition)
        if s3_input_definition is not None:
            pulumi.set(__self__, "s3_input_definition", s3_input_definition)

    @_builtins.property
    @pulumi.getter(name="dataCatalogInputDefinition")
    def data_catalog_input_definition(self) -> Optional['outputs.RecipeDataCatalogInputDefinition']:
        return pulumi.get(self, "data_catalog_input_definition")

    @_builtins.property
    @pulumi.getter(name="s3InputDefinition")
    def s3_input_definition(self) -> Optional['outputs.RecipeS3Location']:
        return pulumi.get(self, "s3_input_definition")


@pulumi.output_type
class RecipeS3Location(dict):
    """
    Input location
    """
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 key: Optional[_builtins.str] = None):
        """
        Input location
        """
        pulumi.set(__self__, "bucket", bucket)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class RecipeSecondaryInput(dict):
    """
    Secondary input
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataCatalogInputDefinition":
            suggest = "data_catalog_input_definition"
        elif key == "s3InputDefinition":
            suggest = "s3_input_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecipeSecondaryInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecipeSecondaryInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecipeSecondaryInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_catalog_input_definition: Optional['outputs.RecipeDataCatalogInputDefinition'] = None,
                 s3_input_definition: Optional['outputs.RecipeS3Location'] = None):
        """
        Secondary input
        """
        if data_catalog_input_definition is not None:
            pulumi.set(__self__, "data_catalog_input_definition", data_catalog_input_definition)
        if s3_input_definition is not None:
            pulumi.set(__self__, "s3_input_definition", s3_input_definition)

    @_builtins.property
    @pulumi.getter(name="dataCatalogInputDefinition")
    def data_catalog_input_definition(self) -> Optional['outputs.RecipeDataCatalogInputDefinition']:
        return pulumi.get(self, "data_catalog_input_definition")

    @_builtins.property
    @pulumi.getter(name="s3InputDefinition")
    def s3_input_definition(self) -> Optional['outputs.RecipeS3Location']:
        return pulumi.get(self, "s3_input_definition")


@pulumi.output_type
class RecipeStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionExpressions":
            suggest = "condition_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecipeStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecipeStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecipeStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.RecipeAction',
                 condition_expressions: Optional[Sequence['outputs.RecipeConditionExpression']] = None):
        """
        :param 'RecipeAction' action: The particular action to be performed in the recipe step.
        :param Sequence['RecipeConditionExpression'] condition_expressions: Condition expressions applied to the step action
        """
        pulumi.set(__self__, "action", action)
        if condition_expressions is not None:
            pulumi.set(__self__, "condition_expressions", condition_expressions)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'outputs.RecipeAction':
        """
        The particular action to be performed in the recipe step.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="conditionExpressions")
    def condition_expressions(self) -> Optional[Sequence['outputs.RecipeConditionExpression']]:
        """
        Condition expressions applied to the step action
        """
        return pulumi.get(self, "condition_expressions")


@pulumi.output_type
class RulesetColumnSelector(dict):
    """
    Selector of a column from a dataset for profile job configuration. One selector includes either a column name or a regular expression
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        Selector of a column from a dataset for profile job configuration. One selector includes either a column name or a regular expression
        :param _builtins.str name: The name of a column from a dataset
        :param _builtins.str regex: A regular expression for selecting a column from a dataset
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of a column from a dataset
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        A regular expression for selecting a column from a dataset
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class RulesetRule(dict):
    """
    Data quality rule for a target resource (dataset)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkExpression":
            suggest = "check_expression"
        elif key == "columnSelectors":
            suggest = "column_selectors"
        elif key == "substitutionMap":
            suggest = "substitution_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_expression: _builtins.str,
                 name: _builtins.str,
                 column_selectors: Optional[Sequence['outputs.RulesetColumnSelector']] = None,
                 disabled: Optional[_builtins.bool] = None,
                 substitution_map: Optional[Sequence['outputs.RulesetSubstitutionValue']] = None,
                 threshold: Optional['outputs.RulesetThreshold'] = None):
        """
        Data quality rule for a target resource (dataset)
        :param _builtins.str check_expression: The expression which includes column references, condition names followed by variable references, possibly grouped and combined with other conditions. For example, `(:col1 starts_with :prefix1 or :col1 starts_with :prefix2) and (:col1 ends_with :suffix1 or :col1 ends_with :suffix2)` . Column and value references are substitution variables that should start with the ':' symbol. Depending on the context, substitution variables' values can be either an actual value or a column name. These values are defined in the SubstitutionMap. If a CheckExpression starts with a column reference, then ColumnSelectors in the rule should be null. If ColumnSelectors has been defined, then there should be no columnn reference in the left side of a condition, for example, `is_between :val1 and :val2` .
        :param _builtins.str name: Name of the rule
        :param Sequence['RulesetColumnSelector'] column_selectors: List of column selectors. Selectors can be used to select columns using a name or regular expression from the dataset. Rule will be applied to selected columns.
        :param _builtins.bool disabled: A value that specifies whether the rule is disabled. Once a rule is disabled, a profile job will not validate it during a job run. Default value is false.
        :param Sequence['RulesetSubstitutionValue'] substitution_map: The map of substitution variable names to their values used in a check expression. Variable names should start with a ':' (colon). Variable values can either be actual values or column names. To differentiate between the two, column names should be enclosed in backticks, for example, `":col1": "`Column A`".`
        :param 'RulesetThreshold' threshold: The threshold used with a non-aggregate check expression. Non-aggregate check expressions will be applied to each row in a specific column, and the threshold will be used to determine whether the validation succeeds.
        """
        pulumi.set(__self__, "check_expression", check_expression)
        pulumi.set(__self__, "name", name)
        if column_selectors is not None:
            pulumi.set(__self__, "column_selectors", column_selectors)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if substitution_map is not None:
            pulumi.set(__self__, "substitution_map", substitution_map)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="checkExpression")
    def check_expression(self) -> _builtins.str:
        """
        The expression which includes column references, condition names followed by variable references, possibly grouped and combined with other conditions. For example, `(:col1 starts_with :prefix1 or :col1 starts_with :prefix2) and (:col1 ends_with :suffix1 or :col1 ends_with :suffix2)` . Column and value references are substitution variables that should start with the ':' symbol. Depending on the context, substitution variables' values can be either an actual value or a column name. These values are defined in the SubstitutionMap. If a CheckExpression starts with a column reference, then ColumnSelectors in the rule should be null. If ColumnSelectors has been defined, then there should be no columnn reference in the left side of a condition, for example, `is_between :val1 and :val2` .
        """
        return pulumi.get(self, "check_expression")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="columnSelectors")
    def column_selectors(self) -> Optional[Sequence['outputs.RulesetColumnSelector']]:
        """
        List of column selectors. Selectors can be used to select columns using a name or regular expression from the dataset. Rule will be applied to selected columns.
        """
        return pulumi.get(self, "column_selectors")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        A value that specifies whether the rule is disabled. Once a rule is disabled, a profile job will not validate it during a job run. Default value is false.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="substitutionMap")
    def substitution_map(self) -> Optional[Sequence['outputs.RulesetSubstitutionValue']]:
        """
        The map of substitution variable names to their values used in a check expression. Variable names should start with a ':' (colon). Variable values can either be actual values or column names. To differentiate between the two, column names should be enclosed in backticks, for example, `":col1": "`Column A`".`
        """
        return pulumi.get(self, "substitution_map")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.RulesetThreshold']:
        """
        The threshold used with a non-aggregate check expression. Non-aggregate check expressions will be applied to each row in a specific column, and the threshold will be used to determine whether the validation succeeds.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class RulesetSubstitutionValue(dict):
    """
    A key-value pair to associate expression's substitution variable names with their values
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueReference":
            suggest = "value_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetSubstitutionValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetSubstitutionValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetSubstitutionValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: _builtins.str,
                 value_reference: _builtins.str):
        """
        A key-value pair to associate expression's substitution variable names with their values
        :param _builtins.str value: Value or column name
        :param _builtins.str value_reference: Variable name
        """
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_reference", value_reference)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value or column name
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueReference")
    def value_reference(self) -> _builtins.str:
        """
        Variable name
        """
        return pulumi.get(self, "value_reference")


@pulumi.output_type
class RulesetThreshold(dict):
    def __init__(__self__, *,
                 value: _builtins.float,
                 type: Optional['RulesetThresholdType'] = None,
                 unit: Optional['RulesetThresholdUnit'] = None):
        """
        :param _builtins.float value: The value of a threshold.
        :param 'RulesetThresholdType' type: The type of a threshold. Used for comparison of an actual count of rows that satisfy the rule to the threshold value.
        :param 'RulesetThresholdUnit' unit: Unit of threshold value. Can be either a COUNT or PERCENTAGE of the full sample size used for validation.
        """
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        The value of a threshold.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['RulesetThresholdType']:
        """
        The type of a threshold. Used for comparison of an actual count of rows that satisfy the rule to the threshold value.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional['RulesetThresholdUnit']:
        """
        Unit of threshold value. Can be either a COUNT or PERCENTAGE of the full sample size used for validation.
        """
        return pulumi.get(self, "unit")


