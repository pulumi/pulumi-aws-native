# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ConfigurationSetDashboardOptionsArgs',
    'ConfigurationSetDashboardOptionsArgsDict',
    'ConfigurationSetDeliveryOptionsArgs',
    'ConfigurationSetDeliveryOptionsArgsDict',
    'ConfigurationSetEventDestinationCloudWatchDestinationArgs',
    'ConfigurationSetEventDestinationCloudWatchDestinationArgsDict',
    'ConfigurationSetEventDestinationDimensionConfigurationArgs',
    'ConfigurationSetEventDestinationDimensionConfigurationArgsDict',
    'ConfigurationSetEventDestinationEventBridgeDestinationArgs',
    'ConfigurationSetEventDestinationEventBridgeDestinationArgsDict',
    'ConfigurationSetEventDestinationEventDestinationArgs',
    'ConfigurationSetEventDestinationEventDestinationArgsDict',
    'ConfigurationSetEventDestinationKinesisFirehoseDestinationArgs',
    'ConfigurationSetEventDestinationKinesisFirehoseDestinationArgsDict',
    'ConfigurationSetEventDestinationSnsDestinationArgs',
    'ConfigurationSetEventDestinationSnsDestinationArgsDict',
    'ConfigurationSetGuardianOptionsArgs',
    'ConfigurationSetGuardianOptionsArgsDict',
    'ConfigurationSetReputationOptionsArgs',
    'ConfigurationSetReputationOptionsArgsDict',
    'ConfigurationSetSendingOptionsArgs',
    'ConfigurationSetSendingOptionsArgsDict',
    'ConfigurationSetSuppressionOptionsArgs',
    'ConfigurationSetSuppressionOptionsArgsDict',
    'ConfigurationSetTrackingOptionsArgs',
    'ConfigurationSetTrackingOptionsArgsDict',
    'ConfigurationSetVdmOptionsArgs',
    'ConfigurationSetVdmOptionsArgsDict',
    'ContactListTopicArgs',
    'ContactListTopicArgsDict',
    'EmailIdentityConfigurationSetAttributesArgs',
    'EmailIdentityConfigurationSetAttributesArgsDict',
    'EmailIdentityDkimAttributesArgs',
    'EmailIdentityDkimAttributesArgsDict',
    'EmailIdentityDkimSigningAttributesArgs',
    'EmailIdentityDkimSigningAttributesArgsDict',
    'EmailIdentityFeedbackAttributesArgs',
    'EmailIdentityFeedbackAttributesArgsDict',
    'EmailIdentityMailFromAttributesArgs',
    'EmailIdentityMailFromAttributesArgsDict',
    'MailManagerArchiveArchiveRetentionPropertiesArgs',
    'MailManagerArchiveArchiveRetentionPropertiesArgsDict',
    'MailManagerIngressPointIngressPointConfiguration0PropertiesArgs',
    'MailManagerIngressPointIngressPointConfiguration0PropertiesArgsDict',
    'MailManagerIngressPointIngressPointConfiguration1PropertiesArgs',
    'MailManagerIngressPointIngressPointConfiguration1PropertiesArgsDict',
    'MailManagerRelayNoAuthenticationArgs',
    'MailManagerRelayNoAuthenticationArgsDict',
    'MailManagerRelayRelayAuthentication0PropertiesArgs',
    'MailManagerRelayRelayAuthentication0PropertiesArgsDict',
    'MailManagerRelayRelayAuthentication1PropertiesArgs',
    'MailManagerRelayRelayAuthentication1PropertiesArgsDict',
    'MailManagerRuleSetAddHeaderActionArgs',
    'MailManagerRuleSetAddHeaderActionArgsDict',
    'MailManagerRuleSetAnalysisArgs',
    'MailManagerRuleSetAnalysisArgsDict',
    'MailManagerRuleSetArchiveActionArgs',
    'MailManagerRuleSetArchiveActionArgsDict',
    'MailManagerRuleSetDeliverToMailboxActionArgs',
    'MailManagerRuleSetDeliverToMailboxActionArgsDict',
    'MailManagerRuleSetDeliverToQBusinessActionArgs',
    'MailManagerRuleSetDeliverToQBusinessActionArgsDict',
    'MailManagerRuleSetDropActionArgs',
    'MailManagerRuleSetDropActionArgsDict',
    'MailManagerRuleSetRelayActionArgs',
    'MailManagerRuleSetRelayActionArgsDict',
    'MailManagerRuleSetReplaceRecipientActionArgs',
    'MailManagerRuleSetReplaceRecipientActionArgsDict',
    'MailManagerRuleSetRuleAction0PropertiesArgs',
    'MailManagerRuleSetRuleAction0PropertiesArgsDict',
    'MailManagerRuleSetRuleAction1PropertiesArgs',
    'MailManagerRuleSetRuleAction1PropertiesArgsDict',
    'MailManagerRuleSetRuleAction2PropertiesArgs',
    'MailManagerRuleSetRuleAction2PropertiesArgsDict',
    'MailManagerRuleSetRuleAction3PropertiesArgs',
    'MailManagerRuleSetRuleAction3PropertiesArgsDict',
    'MailManagerRuleSetRuleAction4PropertiesArgs',
    'MailManagerRuleSetRuleAction4PropertiesArgsDict',
    'MailManagerRuleSetRuleAction5PropertiesArgs',
    'MailManagerRuleSetRuleAction5PropertiesArgsDict',
    'MailManagerRuleSetRuleAction6PropertiesArgs',
    'MailManagerRuleSetRuleAction6PropertiesArgsDict',
    'MailManagerRuleSetRuleAction7PropertiesArgs',
    'MailManagerRuleSetRuleAction7PropertiesArgsDict',
    'MailManagerRuleSetRuleAction8PropertiesArgs',
    'MailManagerRuleSetRuleAction8PropertiesArgsDict',
    'MailManagerRuleSetRuleBooleanExpressionArgs',
    'MailManagerRuleSetRuleBooleanExpressionArgsDict',
    'MailManagerRuleSetRuleBooleanToEvaluatePropertiesArgs',
    'MailManagerRuleSetRuleBooleanToEvaluatePropertiesArgsDict',
    'MailManagerRuleSetRuleCondition0PropertiesArgs',
    'MailManagerRuleSetRuleCondition0PropertiesArgsDict',
    'MailManagerRuleSetRuleCondition1PropertiesArgs',
    'MailManagerRuleSetRuleCondition1PropertiesArgsDict',
    'MailManagerRuleSetRuleCondition2PropertiesArgs',
    'MailManagerRuleSetRuleCondition2PropertiesArgsDict',
    'MailManagerRuleSetRuleCondition3PropertiesArgs',
    'MailManagerRuleSetRuleCondition3PropertiesArgsDict',
    'MailManagerRuleSetRuleCondition4PropertiesArgs',
    'MailManagerRuleSetRuleCondition4PropertiesArgsDict',
    'MailManagerRuleSetRuleCondition5PropertiesArgs',
    'MailManagerRuleSetRuleCondition5PropertiesArgsDict',
    'MailManagerRuleSetRuleDmarcExpressionArgs',
    'MailManagerRuleSetRuleDmarcExpressionArgsDict',
    'MailManagerRuleSetRuleIpExpressionArgs',
    'MailManagerRuleSetRuleIpExpressionArgsDict',
    'MailManagerRuleSetRuleIpToEvaluatePropertiesArgs',
    'MailManagerRuleSetRuleIpToEvaluatePropertiesArgsDict',
    'MailManagerRuleSetRuleNumberExpressionArgs',
    'MailManagerRuleSetRuleNumberExpressionArgsDict',
    'MailManagerRuleSetRuleNumberToEvaluatePropertiesArgs',
    'MailManagerRuleSetRuleNumberToEvaluatePropertiesArgsDict',
    'MailManagerRuleSetRuleStringExpressionArgs',
    'MailManagerRuleSetRuleStringExpressionArgsDict',
    'MailManagerRuleSetRuleStringToEvaluate0PropertiesArgs',
    'MailManagerRuleSetRuleStringToEvaluate0PropertiesArgsDict',
    'MailManagerRuleSetRuleStringToEvaluate1PropertiesArgs',
    'MailManagerRuleSetRuleStringToEvaluate1PropertiesArgsDict',
    'MailManagerRuleSetRuleVerdictExpressionArgs',
    'MailManagerRuleSetRuleVerdictExpressionArgsDict',
    'MailManagerRuleSetRuleVerdictToEvaluate0PropertiesArgs',
    'MailManagerRuleSetRuleVerdictToEvaluate0PropertiesArgsDict',
    'MailManagerRuleSetRuleVerdictToEvaluate1PropertiesArgs',
    'MailManagerRuleSetRuleVerdictToEvaluate1PropertiesArgsDict',
    'MailManagerRuleSetRuleArgs',
    'MailManagerRuleSetRuleArgsDict',
    'MailManagerRuleSetS3ActionArgs',
    'MailManagerRuleSetS3ActionArgsDict',
    'MailManagerRuleSetSendActionArgs',
    'MailManagerRuleSetSendActionArgsDict',
    'MailManagerTrafficPolicyIngressAnalysisArgs',
    'MailManagerTrafficPolicyIngressAnalysisArgsDict',
    'MailManagerTrafficPolicyIngressBooleanExpressionArgs',
    'MailManagerTrafficPolicyIngressBooleanExpressionArgsDict',
    'MailManagerTrafficPolicyIngressBooleanToEvaluatePropertiesArgs',
    'MailManagerTrafficPolicyIngressBooleanToEvaluatePropertiesArgsDict',
    'MailManagerTrafficPolicyIngressIpToEvaluatePropertiesArgs',
    'MailManagerTrafficPolicyIngressIpToEvaluatePropertiesArgsDict',
    'MailManagerTrafficPolicyIngressIpv4ExpressionArgs',
    'MailManagerTrafficPolicyIngressIpv4ExpressionArgsDict',
    'MailManagerTrafficPolicyIngressStringExpressionArgs',
    'MailManagerTrafficPolicyIngressStringExpressionArgsDict',
    'MailManagerTrafficPolicyIngressStringToEvaluatePropertiesArgs',
    'MailManagerTrafficPolicyIngressStringToEvaluatePropertiesArgsDict',
    'MailManagerTrafficPolicyIngressTlsProtocolExpressionArgs',
    'MailManagerTrafficPolicyIngressTlsProtocolExpressionArgsDict',
    'MailManagerTrafficPolicyIngressTlsProtocolToEvaluatePropertiesArgs',
    'MailManagerTrafficPolicyIngressTlsProtocolToEvaluatePropertiesArgsDict',
    'MailManagerTrafficPolicyPolicyCondition0PropertiesArgs',
    'MailManagerTrafficPolicyPolicyCondition0PropertiesArgsDict',
    'MailManagerTrafficPolicyPolicyCondition1PropertiesArgs',
    'MailManagerTrafficPolicyPolicyCondition1PropertiesArgsDict',
    'MailManagerTrafficPolicyPolicyCondition2PropertiesArgs',
    'MailManagerTrafficPolicyPolicyCondition2PropertiesArgsDict',
    'MailManagerTrafficPolicyPolicyCondition3PropertiesArgs',
    'MailManagerTrafficPolicyPolicyCondition3PropertiesArgsDict',
    'MailManagerTrafficPolicyPolicyStatementArgs',
    'MailManagerTrafficPolicyPolicyStatementArgsDict',
    'TemplateArgs',
    'TemplateArgsDict',
    'VdmAttributesDashboardAttributesArgs',
    'VdmAttributesDashboardAttributesArgsDict',
    'VdmAttributesGuardianAttributesArgs',
    'VdmAttributesGuardianAttributesArgsDict',
]

MYPY = False

if not MYPY:
    class ConfigurationSetDashboardOptionsArgsDict(TypedDict):
        """
        Preferences regarding the Dashboard feature.
        """
        engagement_metrics: pulumi.Input[str]
        """
        Whether emails sent with this configuration set have engagement tracking enabled.
        """
elif False:
    ConfigurationSetDashboardOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetDashboardOptionsArgs:
    def __init__(__self__, *,
                 engagement_metrics: pulumi.Input[str]):
        """
        Preferences regarding the Dashboard feature.
        :param pulumi.Input[str] engagement_metrics: Whether emails sent with this configuration set have engagement tracking enabled.
        """
        pulumi.set(__self__, "engagement_metrics", engagement_metrics)

    @property
    @pulumi.getter(name="engagementMetrics")
    def engagement_metrics(self) -> pulumi.Input[str]:
        """
        Whether emails sent with this configuration set have engagement tracking enabled.
        """
        return pulumi.get(self, "engagement_metrics")

    @engagement_metrics.setter
    def engagement_metrics(self, value: pulumi.Input[str]):
        pulumi.set(self, "engagement_metrics", value)


if not MYPY:
    class ConfigurationSetDeliveryOptionsArgsDict(TypedDict):
        """
        An object that defines the dedicated IP pool that is used to send emails that you send using the configuration set.
        """
        max_delivery_seconds: NotRequired[pulumi.Input[float]]
        """
        Specifies the maximum time until which SES will retry sending emails
        """
        sending_pool_name: NotRequired[pulumi.Input[str]]
        """
        The name of the dedicated IP pool to associate with the configuration set.
        """
        tls_policy: NotRequired[pulumi.Input[str]]
        """
        Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). If the value is Require , messages are only delivered if a TLS connection can be established. If the value is Optional , messages can be delivered in plain text if a TLS connection can't be established.
        """
elif False:
    ConfigurationSetDeliveryOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetDeliveryOptionsArgs:
    def __init__(__self__, *,
                 max_delivery_seconds: Optional[pulumi.Input[float]] = None,
                 sending_pool_name: Optional[pulumi.Input[str]] = None,
                 tls_policy: Optional[pulumi.Input[str]] = None):
        """
        An object that defines the dedicated IP pool that is used to send emails that you send using the configuration set.
        :param pulumi.Input[float] max_delivery_seconds: Specifies the maximum time until which SES will retry sending emails
        :param pulumi.Input[str] sending_pool_name: The name of the dedicated IP pool to associate with the configuration set.
        :param pulumi.Input[str] tls_policy: Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). If the value is Require , messages are only delivered if a TLS connection can be established. If the value is Optional , messages can be delivered in plain text if a TLS connection can't be established.
        """
        if max_delivery_seconds is not None:
            pulumi.set(__self__, "max_delivery_seconds", max_delivery_seconds)
        if sending_pool_name is not None:
            pulumi.set(__self__, "sending_pool_name", sending_pool_name)
        if tls_policy is not None:
            pulumi.set(__self__, "tls_policy", tls_policy)

    @property
    @pulumi.getter(name="maxDeliverySeconds")
    def max_delivery_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the maximum time until which SES will retry sending emails
        """
        return pulumi.get(self, "max_delivery_seconds")

    @max_delivery_seconds.setter
    def max_delivery_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_delivery_seconds", value)

    @property
    @pulumi.getter(name="sendingPoolName")
    def sending_pool_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the dedicated IP pool to associate with the configuration set.
        """
        return pulumi.get(self, "sending_pool_name")

    @sending_pool_name.setter
    def sending_pool_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sending_pool_name", value)

    @property
    @pulumi.getter(name="tlsPolicy")
    def tls_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). If the value is Require , messages are only delivered if a TLS connection can be established. If the value is Optional , messages can be delivered in plain text if a TLS connection can't be established.
        """
        return pulumi.get(self, "tls_policy")

    @tls_policy.setter
    def tls_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_policy", value)


if not MYPY:
    class ConfigurationSetEventDestinationCloudWatchDestinationArgsDict(TypedDict):
        """
        An object that contains the names, default values, and sources of the dimensions associated with an Amazon CloudWatch event destination.
        """
        dimension_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigurationSetEventDestinationDimensionConfigurationArgsDict']]]]
        """
        A list of dimensions upon which to categorize your emails when you publish email sending events to Amazon CloudWatch.
        """
elif False:
    ConfigurationSetEventDestinationCloudWatchDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetEventDestinationCloudWatchDestinationArgs:
    def __init__(__self__, *,
                 dimension_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationSetEventDestinationDimensionConfigurationArgs']]]] = None):
        """
        An object that contains the names, default values, and sources of the dimensions associated with an Amazon CloudWatch event destination.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigurationSetEventDestinationDimensionConfigurationArgs']]] dimension_configurations: A list of dimensions upon which to categorize your emails when you publish email sending events to Amazon CloudWatch.
        """
        if dimension_configurations is not None:
            pulumi.set(__self__, "dimension_configurations", dimension_configurations)

    @property
    @pulumi.getter(name="dimensionConfigurations")
    def dimension_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationSetEventDestinationDimensionConfigurationArgs']]]]:
        """
        A list of dimensions upon which to categorize your emails when you publish email sending events to Amazon CloudWatch.
        """
        return pulumi.get(self, "dimension_configurations")

    @dimension_configurations.setter
    def dimension_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationSetEventDestinationDimensionConfigurationArgs']]]]):
        pulumi.set(self, "dimension_configurations", value)


if not MYPY:
    class ConfigurationSetEventDestinationDimensionConfigurationArgsDict(TypedDict):
        """
        A list of dimensions upon which to categorize your emails when you publish email sending events to Amazon CloudWatch.
        """
        default_dimension_value: pulumi.Input[str]
        """
        The default value of the dimension that is published to Amazon CloudWatch if you do not provide the value of the dimension when you send an email.
        """
        dimension_name: pulumi.Input[str]
        """
        The name of an Amazon CloudWatch dimension associated with an email sending metric.
        """
        dimension_value_source: pulumi.Input[str]
        """
        The place where Amazon SES finds the value of a dimension to publish to Amazon CloudWatch. To use the message tags that you specify using an X-SES-MESSAGE-TAGS header or a parameter to the SendEmail/SendRawEmail API, specify messageTag. To use your own email headers, specify emailHeader. To put a custom tag on any link included in your email, specify linkTag.
        """
elif False:
    ConfigurationSetEventDestinationDimensionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetEventDestinationDimensionConfigurationArgs:
    def __init__(__self__, *,
                 default_dimension_value: pulumi.Input[str],
                 dimension_name: pulumi.Input[str],
                 dimension_value_source: pulumi.Input[str]):
        """
        A list of dimensions upon which to categorize your emails when you publish email sending events to Amazon CloudWatch.
        :param pulumi.Input[str] default_dimension_value: The default value of the dimension that is published to Amazon CloudWatch if you do not provide the value of the dimension when you send an email.
        :param pulumi.Input[str] dimension_name: The name of an Amazon CloudWatch dimension associated with an email sending metric.
        :param pulumi.Input[str] dimension_value_source: The place where Amazon SES finds the value of a dimension to publish to Amazon CloudWatch. To use the message tags that you specify using an X-SES-MESSAGE-TAGS header or a parameter to the SendEmail/SendRawEmail API, specify messageTag. To use your own email headers, specify emailHeader. To put a custom tag on any link included in your email, specify linkTag.
        """
        pulumi.set(__self__, "default_dimension_value", default_dimension_value)
        pulumi.set(__self__, "dimension_name", dimension_name)
        pulumi.set(__self__, "dimension_value_source", dimension_value_source)

    @property
    @pulumi.getter(name="defaultDimensionValue")
    def default_dimension_value(self) -> pulumi.Input[str]:
        """
        The default value of the dimension that is published to Amazon CloudWatch if you do not provide the value of the dimension when you send an email.
        """
        return pulumi.get(self, "default_dimension_value")

    @default_dimension_value.setter
    def default_dimension_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_dimension_value", value)

    @property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> pulumi.Input[str]:
        """
        The name of an Amazon CloudWatch dimension associated with an email sending metric.
        """
        return pulumi.get(self, "dimension_name")

    @dimension_name.setter
    def dimension_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "dimension_name", value)

    @property
    @pulumi.getter(name="dimensionValueSource")
    def dimension_value_source(self) -> pulumi.Input[str]:
        """
        The place where Amazon SES finds the value of a dimension to publish to Amazon CloudWatch. To use the message tags that you specify using an X-SES-MESSAGE-TAGS header or a parameter to the SendEmail/SendRawEmail API, specify messageTag. To use your own email headers, specify emailHeader. To put a custom tag on any link included in your email, specify linkTag.
        """
        return pulumi.get(self, "dimension_value_source")

    @dimension_value_source.setter
    def dimension_value_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "dimension_value_source", value)


if not MYPY:
    class ConfigurationSetEventDestinationEventBridgeDestinationArgsDict(TypedDict):
        """
        An object that contains Event bus ARN associated with the event bridge destination.
        """
        event_bus_arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the Amazon EventBridge bus to publish email events to. Only the default bus is supported.
        """
elif False:
    ConfigurationSetEventDestinationEventBridgeDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetEventDestinationEventBridgeDestinationArgs:
    def __init__(__self__, *,
                 event_bus_arn: pulumi.Input[str]):
        """
        An object that contains Event bus ARN associated with the event bridge destination.
        :param pulumi.Input[str] event_bus_arn: The Amazon Resource Name (ARN) of the Amazon EventBridge bus to publish email events to. Only the default bus is supported.
        """
        pulumi.set(__self__, "event_bus_arn", event_bus_arn)

    @property
    @pulumi.getter(name="eventBusArn")
    def event_bus_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon EventBridge bus to publish email events to. Only the default bus is supported.
        """
        return pulumi.get(self, "event_bus_arn")

    @event_bus_arn.setter
    def event_bus_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_bus_arn", value)


if not MYPY:
    class ConfigurationSetEventDestinationEventDestinationArgsDict(TypedDict):
        matching_event_types: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The type of email sending events, send, reject, bounce, complaint, delivery, open, click, renderingFailure, deliveryDelay, and subscription.
        """
        cloud_watch_destination: NotRequired[pulumi.Input['ConfigurationSetEventDestinationCloudWatchDestinationArgsDict']]
        """
        An object that contains the names, default values, and sources of the dimensions associated with an Amazon CloudWatch event destination.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Sets whether Amazon SES publishes events to this destination when you send an email with the associated configuration set. Set to true to enable publishing to this destination; set to false to prevent publishing to this destination. The default value is false.   
        """
        event_bridge_destination: NotRequired[pulumi.Input['ConfigurationSetEventDestinationEventBridgeDestinationArgsDict']]
        """
        An object that contains Event bus ARN associated with the event bridge destination.
        """
        kinesis_firehose_destination: NotRequired[pulumi.Input['ConfigurationSetEventDestinationKinesisFirehoseDestinationArgsDict']]
        """
        An object that contains the delivery stream ARN and the IAM role ARN associated with an Amazon Kinesis Firehose event destination.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the event destination set.
        """
        sns_destination: NotRequired[pulumi.Input['ConfigurationSetEventDestinationSnsDestinationArgsDict']]
        """
        An object that contains SNS topic ARN associated event destination.
        """
elif False:
    ConfigurationSetEventDestinationEventDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetEventDestinationEventDestinationArgs:
    def __init__(__self__, *,
                 matching_event_types: pulumi.Input[Sequence[pulumi.Input[str]]],
                 cloud_watch_destination: Optional[pulumi.Input['ConfigurationSetEventDestinationCloudWatchDestinationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 event_bridge_destination: Optional[pulumi.Input['ConfigurationSetEventDestinationEventBridgeDestinationArgs']] = None,
                 kinesis_firehose_destination: Optional[pulumi.Input['ConfigurationSetEventDestinationKinesisFirehoseDestinationArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 sns_destination: Optional[pulumi.Input['ConfigurationSetEventDestinationSnsDestinationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] matching_event_types: The type of email sending events, send, reject, bounce, complaint, delivery, open, click, renderingFailure, deliveryDelay, and subscription.
        :param pulumi.Input['ConfigurationSetEventDestinationCloudWatchDestinationArgs'] cloud_watch_destination: An object that contains the names, default values, and sources of the dimensions associated with an Amazon CloudWatch event destination.
        :param pulumi.Input[bool] enabled: Sets whether Amazon SES publishes events to this destination when you send an email with the associated configuration set. Set to true to enable publishing to this destination; set to false to prevent publishing to this destination. The default value is false.   
        :param pulumi.Input['ConfigurationSetEventDestinationEventBridgeDestinationArgs'] event_bridge_destination: An object that contains Event bus ARN associated with the event bridge destination.
        :param pulumi.Input['ConfigurationSetEventDestinationKinesisFirehoseDestinationArgs'] kinesis_firehose_destination: An object that contains the delivery stream ARN and the IAM role ARN associated with an Amazon Kinesis Firehose event destination.
        :param pulumi.Input[str] name: The name of the event destination set.
        :param pulumi.Input['ConfigurationSetEventDestinationSnsDestinationArgs'] sns_destination: An object that contains SNS topic ARN associated event destination.
        """
        pulumi.set(__self__, "matching_event_types", matching_event_types)
        if cloud_watch_destination is not None:
            pulumi.set(__self__, "cloud_watch_destination", cloud_watch_destination)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if event_bridge_destination is not None:
            pulumi.set(__self__, "event_bridge_destination", event_bridge_destination)
        if kinesis_firehose_destination is not None:
            pulumi.set(__self__, "kinesis_firehose_destination", kinesis_firehose_destination)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sns_destination is not None:
            pulumi.set(__self__, "sns_destination", sns_destination)

    @property
    @pulumi.getter(name="matchingEventTypes")
    def matching_event_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The type of email sending events, send, reject, bounce, complaint, delivery, open, click, renderingFailure, deliveryDelay, and subscription.
        """
        return pulumi.get(self, "matching_event_types")

    @matching_event_types.setter
    def matching_event_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "matching_event_types", value)

    @property
    @pulumi.getter(name="cloudWatchDestination")
    def cloud_watch_destination(self) -> Optional[pulumi.Input['ConfigurationSetEventDestinationCloudWatchDestinationArgs']]:
        """
        An object that contains the names, default values, and sources of the dimensions associated with an Amazon CloudWatch event destination.
        """
        return pulumi.get(self, "cloud_watch_destination")

    @cloud_watch_destination.setter
    def cloud_watch_destination(self, value: Optional[pulumi.Input['ConfigurationSetEventDestinationCloudWatchDestinationArgs']]):
        pulumi.set(self, "cloud_watch_destination", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets whether Amazon SES publishes events to this destination when you send an email with the associated configuration set. Set to true to enable publishing to this destination; set to false to prevent publishing to this destination. The default value is false.   
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="eventBridgeDestination")
    def event_bridge_destination(self) -> Optional[pulumi.Input['ConfigurationSetEventDestinationEventBridgeDestinationArgs']]:
        """
        An object that contains Event bus ARN associated with the event bridge destination.
        """
        return pulumi.get(self, "event_bridge_destination")

    @event_bridge_destination.setter
    def event_bridge_destination(self, value: Optional[pulumi.Input['ConfigurationSetEventDestinationEventBridgeDestinationArgs']]):
        pulumi.set(self, "event_bridge_destination", value)

    @property
    @pulumi.getter(name="kinesisFirehoseDestination")
    def kinesis_firehose_destination(self) -> Optional[pulumi.Input['ConfigurationSetEventDestinationKinesisFirehoseDestinationArgs']]:
        """
        An object that contains the delivery stream ARN and the IAM role ARN associated with an Amazon Kinesis Firehose event destination.
        """
        return pulumi.get(self, "kinesis_firehose_destination")

    @kinesis_firehose_destination.setter
    def kinesis_firehose_destination(self, value: Optional[pulumi.Input['ConfigurationSetEventDestinationKinesisFirehoseDestinationArgs']]):
        pulumi.set(self, "kinesis_firehose_destination", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the event destination set.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="snsDestination")
    def sns_destination(self) -> Optional[pulumi.Input['ConfigurationSetEventDestinationSnsDestinationArgs']]:
        """
        An object that contains SNS topic ARN associated event destination.
        """
        return pulumi.get(self, "sns_destination")

    @sns_destination.setter
    def sns_destination(self, value: Optional[pulumi.Input['ConfigurationSetEventDestinationSnsDestinationArgs']]):
        pulumi.set(self, "sns_destination", value)


if not MYPY:
    class ConfigurationSetEventDestinationKinesisFirehoseDestinationArgsDict(TypedDict):
        """
        An object that contains the delivery stream ARN and the IAM role ARN associated with an Amazon Kinesis Firehose event destination.
        """
        delivery_stream_arn: pulumi.Input[str]
        """
        The ARN of the Amazon Kinesis Firehose stream that email sending events should be published to.
        """
        iam_role_arn: pulumi.Input[str]
        """
        The ARN of the IAM role under which Amazon SES publishes email sending events to the Amazon Kinesis Firehose stream.
        """
elif False:
    ConfigurationSetEventDestinationKinesisFirehoseDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetEventDestinationKinesisFirehoseDestinationArgs:
    def __init__(__self__, *,
                 delivery_stream_arn: pulumi.Input[str],
                 iam_role_arn: pulumi.Input[str]):
        """
        An object that contains the delivery stream ARN and the IAM role ARN associated with an Amazon Kinesis Firehose event destination.
        :param pulumi.Input[str] delivery_stream_arn: The ARN of the Amazon Kinesis Firehose stream that email sending events should be published to.
        :param pulumi.Input[str] iam_role_arn: The ARN of the IAM role under which Amazon SES publishes email sending events to the Amazon Kinesis Firehose stream.
        """
        pulumi.set(__self__, "delivery_stream_arn", delivery_stream_arn)
        pulumi.set(__self__, "iam_role_arn", iam_role_arn)

    @property
    @pulumi.getter(name="deliveryStreamArn")
    def delivery_stream_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the Amazon Kinesis Firehose stream that email sending events should be published to.
        """
        return pulumi.get(self, "delivery_stream_arn")

    @delivery_stream_arn.setter
    def delivery_stream_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "delivery_stream_arn", value)

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role under which Amazon SES publishes email sending events to the Amazon Kinesis Firehose stream.
        """
        return pulumi.get(self, "iam_role_arn")

    @iam_role_arn.setter
    def iam_role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "iam_role_arn", value)


if not MYPY:
    class ConfigurationSetEventDestinationSnsDestinationArgsDict(TypedDict):
        """
        An object that contains SNS topic ARN associated event destination.
        """
        topic_arn: pulumi.Input[str]
        """
        The ARN of the Amazon SNS topic for email sending events. You can find the ARN of a topic by using the [ListTopics](https://docs.aws.amazon.com/sns/latest/api/API_ListTopics.html) Amazon SNS operation.

        For more information about Amazon SNS topics, see the [Amazon SNS Developer Guide](https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html) .
        """
elif False:
    ConfigurationSetEventDestinationSnsDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetEventDestinationSnsDestinationArgs:
    def __init__(__self__, *,
                 topic_arn: pulumi.Input[str]):
        """
        An object that contains SNS topic ARN associated event destination.
        :param pulumi.Input[str] topic_arn: The ARN of the Amazon SNS topic for email sending events. You can find the ARN of a topic by using the [ListTopics](https://docs.aws.amazon.com/sns/latest/api/API_ListTopics.html) Amazon SNS operation.
               
               For more information about Amazon SNS topics, see the [Amazon SNS Developer Guide](https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html) .
        """
        pulumi.set(__self__, "topic_arn", topic_arn)

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the Amazon SNS topic for email sending events. You can find the ARN of a topic by using the [ListTopics](https://docs.aws.amazon.com/sns/latest/api/API_ListTopics.html) Amazon SNS operation.

        For more information about Amazon SNS topics, see the [Amazon SNS Developer Guide](https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html) .
        """
        return pulumi.get(self, "topic_arn")

    @topic_arn.setter
    def topic_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_arn", value)


if not MYPY:
    class ConfigurationSetGuardianOptionsArgsDict(TypedDict):
        """
        Preferences regarding the Guardian feature.
        """
        optimized_shared_delivery: pulumi.Input[str]
        """
        Whether emails sent with this configuration set have optimized delivery algorithm enabled.
        """
elif False:
    ConfigurationSetGuardianOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetGuardianOptionsArgs:
    def __init__(__self__, *,
                 optimized_shared_delivery: pulumi.Input[str]):
        """
        Preferences regarding the Guardian feature.
        :param pulumi.Input[str] optimized_shared_delivery: Whether emails sent with this configuration set have optimized delivery algorithm enabled.
        """
        pulumi.set(__self__, "optimized_shared_delivery", optimized_shared_delivery)

    @property
    @pulumi.getter(name="optimizedSharedDelivery")
    def optimized_shared_delivery(self) -> pulumi.Input[str]:
        """
        Whether emails sent with this configuration set have optimized delivery algorithm enabled.
        """
        return pulumi.get(self, "optimized_shared_delivery")

    @optimized_shared_delivery.setter
    def optimized_shared_delivery(self, value: pulumi.Input[str]):
        pulumi.set(self, "optimized_shared_delivery", value)


if not MYPY:
    class ConfigurationSetReputationOptionsArgsDict(TypedDict):
        """
        An object that defines whether or not Amazon SES collects reputation metrics for the emails that you send that use the configuration set.
        """
        reputation_metrics_enabled: NotRequired[pulumi.Input[bool]]
        """
        If true , tracking of reputation metrics is enabled for the configuration set. If false , tracking of reputation metrics is disabled for the configuration set.
        """
elif False:
    ConfigurationSetReputationOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetReputationOptionsArgs:
    def __init__(__self__, *,
                 reputation_metrics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        An object that defines whether or not Amazon SES collects reputation metrics for the emails that you send that use the configuration set.
        :param pulumi.Input[bool] reputation_metrics_enabled: If true , tracking of reputation metrics is enabled for the configuration set. If false , tracking of reputation metrics is disabled for the configuration set.
        """
        if reputation_metrics_enabled is not None:
            pulumi.set(__self__, "reputation_metrics_enabled", reputation_metrics_enabled)

    @property
    @pulumi.getter(name="reputationMetricsEnabled")
    def reputation_metrics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true , tracking of reputation metrics is enabled for the configuration set. If false , tracking of reputation metrics is disabled for the configuration set.
        """
        return pulumi.get(self, "reputation_metrics_enabled")

    @reputation_metrics_enabled.setter
    def reputation_metrics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reputation_metrics_enabled", value)


if not MYPY:
    class ConfigurationSetSendingOptionsArgsDict(TypedDict):
        """
        An object that defines whether or not Amazon SES can send email that you send using the configuration set.
        """
        sending_enabled: NotRequired[pulumi.Input[bool]]
        """
        If `true` , email sending is enabled for the configuration set. If `false` , email sending is disabled for the configuration set.
        """
elif False:
    ConfigurationSetSendingOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetSendingOptionsArgs:
    def __init__(__self__, *,
                 sending_enabled: Optional[pulumi.Input[bool]] = None):
        """
        An object that defines whether or not Amazon SES can send email that you send using the configuration set.
        :param pulumi.Input[bool] sending_enabled: If `true` , email sending is enabled for the configuration set. If `false` , email sending is disabled for the configuration set.
        """
        if sending_enabled is not None:
            pulumi.set(__self__, "sending_enabled", sending_enabled)

    @property
    @pulumi.getter(name="sendingEnabled")
    def sending_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` , email sending is enabled for the configuration set. If `false` , email sending is disabled for the configuration set.
        """
        return pulumi.get(self, "sending_enabled")

    @sending_enabled.setter
    def sending_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sending_enabled", value)


if not MYPY:
    class ConfigurationSetSuppressionOptionsArgsDict(TypedDict):
        """
        An object that contains information about the suppression list preferences for your account.
        """
        suppressed_reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list that contains the reasons that email addresses are automatically added to the suppression list for your account.
        """
elif False:
    ConfigurationSetSuppressionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetSuppressionOptionsArgs:
    def __init__(__self__, *,
                 suppressed_reasons: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        An object that contains information about the suppression list preferences for your account.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] suppressed_reasons: A list that contains the reasons that email addresses are automatically added to the suppression list for your account.
        """
        if suppressed_reasons is not None:
            pulumi.set(__self__, "suppressed_reasons", suppressed_reasons)

    @property
    @pulumi.getter(name="suppressedReasons")
    def suppressed_reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list that contains the reasons that email addresses are automatically added to the suppression list for your account.
        """
        return pulumi.get(self, "suppressed_reasons")

    @suppressed_reasons.setter
    def suppressed_reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "suppressed_reasons", value)


if not MYPY:
    class ConfigurationSetTrackingOptionsArgsDict(TypedDict):
        """
        An object that defines the open and click tracking options for emails that you send using the configuration set.
        """
        custom_redirect_domain: NotRequired[pulumi.Input[str]]
        """
        The domain to use for tracking open and click events.
        """
elif False:
    ConfigurationSetTrackingOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetTrackingOptionsArgs:
    def __init__(__self__, *,
                 custom_redirect_domain: Optional[pulumi.Input[str]] = None):
        """
        An object that defines the open and click tracking options for emails that you send using the configuration set.
        :param pulumi.Input[str] custom_redirect_domain: The domain to use for tracking open and click events.
        """
        if custom_redirect_domain is not None:
            pulumi.set(__self__, "custom_redirect_domain", custom_redirect_domain)

    @property
    @pulumi.getter(name="customRedirectDomain")
    def custom_redirect_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The domain to use for tracking open and click events.
        """
        return pulumi.get(self, "custom_redirect_domain")

    @custom_redirect_domain.setter
    def custom_redirect_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_redirect_domain", value)


if not MYPY:
    class ConfigurationSetVdmOptionsArgsDict(TypedDict):
        """
        An object that contains Virtual Deliverability Manager (VDM) settings for this configuration set.
        """
        dashboard_options: NotRequired[pulumi.Input['ConfigurationSetDashboardOptionsArgsDict']]
        """
        Specifies additional settings for your VDM configuration as applicable to the Dashboard.
        """
        guardian_options: NotRequired[pulumi.Input['ConfigurationSetGuardianOptionsArgsDict']]
        """
        Specifies additional settings for your VDM configuration as applicable to the Guardian.
        """
elif False:
    ConfigurationSetVdmOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationSetVdmOptionsArgs:
    def __init__(__self__, *,
                 dashboard_options: Optional[pulumi.Input['ConfigurationSetDashboardOptionsArgs']] = None,
                 guardian_options: Optional[pulumi.Input['ConfigurationSetGuardianOptionsArgs']] = None):
        """
        An object that contains Virtual Deliverability Manager (VDM) settings for this configuration set.
        :param pulumi.Input['ConfigurationSetDashboardOptionsArgs'] dashboard_options: Specifies additional settings for your VDM configuration as applicable to the Dashboard.
        :param pulumi.Input['ConfigurationSetGuardianOptionsArgs'] guardian_options: Specifies additional settings for your VDM configuration as applicable to the Guardian.
        """
        if dashboard_options is not None:
            pulumi.set(__self__, "dashboard_options", dashboard_options)
        if guardian_options is not None:
            pulumi.set(__self__, "guardian_options", guardian_options)

    @property
    @pulumi.getter(name="dashboardOptions")
    def dashboard_options(self) -> Optional[pulumi.Input['ConfigurationSetDashboardOptionsArgs']]:
        """
        Specifies additional settings for your VDM configuration as applicable to the Dashboard.
        """
        return pulumi.get(self, "dashboard_options")

    @dashboard_options.setter
    def dashboard_options(self, value: Optional[pulumi.Input['ConfigurationSetDashboardOptionsArgs']]):
        pulumi.set(self, "dashboard_options", value)

    @property
    @pulumi.getter(name="guardianOptions")
    def guardian_options(self) -> Optional[pulumi.Input['ConfigurationSetGuardianOptionsArgs']]:
        """
        Specifies additional settings for your VDM configuration as applicable to the Guardian.
        """
        return pulumi.get(self, "guardian_options")

    @guardian_options.setter
    def guardian_options(self, value: Optional[pulumi.Input['ConfigurationSetGuardianOptionsArgs']]):
        pulumi.set(self, "guardian_options", value)


if not MYPY:
    class ContactListTopicArgsDict(TypedDict):
        default_subscription_status: pulumi.Input[str]
        """
        The default subscription status to be applied to a contact if the contact has not noted their preference for subscribing to a topic.
        """
        display_name: pulumi.Input[str]
        """
        The display name of the topic.
        """
        topic_name: pulumi.Input[str]
        """
        The name of the topic.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the topic.
        """
elif False:
    ContactListTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactListTopicArgs:
    def __init__(__self__, *,
                 default_subscription_status: pulumi.Input[str],
                 display_name: pulumi.Input[str],
                 topic_name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default_subscription_status: The default subscription status to be applied to a contact if the contact has not noted their preference for subscribing to a topic.
        :param pulumi.Input[str] display_name: The display name of the topic.
        :param pulumi.Input[str] topic_name: The name of the topic.
        :param pulumi.Input[str] description: The description of the topic.
        """
        pulumi.set(__self__, "default_subscription_status", default_subscription_status)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "topic_name", topic_name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="defaultSubscriptionStatus")
    def default_subscription_status(self) -> pulumi.Input[str]:
        """
        The default subscription status to be applied to a contact if the contact has not noted their preference for subscribing to a topic.
        """
        return pulumi.get(self, "default_subscription_status")

    @default_subscription_status.setter
    def default_subscription_status(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_subscription_status", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        The display name of the topic.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[str]:
        """
        The name of the topic.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the topic.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class EmailIdentityConfigurationSetAttributesArgsDict(TypedDict):
        """
        Used to associate a configuration set with an email identity.
        """
        configuration_set_name: NotRequired[pulumi.Input[str]]
        """
        The configuration set to use by default when sending from this identity. Note that any configuration set defined in the email sending request takes precedence.
        """
elif False:
    EmailIdentityConfigurationSetAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailIdentityConfigurationSetAttributesArgs:
    def __init__(__self__, *,
                 configuration_set_name: Optional[pulumi.Input[str]] = None):
        """
        Used to associate a configuration set with an email identity.
        :param pulumi.Input[str] configuration_set_name: The configuration set to use by default when sending from this identity. Note that any configuration set defined in the email sending request takes precedence.
        """
        if configuration_set_name is not None:
            pulumi.set(__self__, "configuration_set_name", configuration_set_name)

    @property
    @pulumi.getter(name="configurationSetName")
    def configuration_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        The configuration set to use by default when sending from this identity. Note that any configuration set defined in the email sending request takes precedence.
        """
        return pulumi.get(self, "configuration_set_name")

    @configuration_set_name.setter
    def configuration_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "configuration_set_name", value)


if not MYPY:
    class EmailIdentityDkimAttributesArgsDict(TypedDict):
        """
        Used to enable or disable DKIM authentication for an email identity.
        """
        signing_enabled: NotRequired[pulumi.Input[bool]]
        """
        Sets the DKIM signing configuration for the identity. When you set this value true, then the messages that are sent from the identity are signed using DKIM. If you set this value to false, your messages are sent without DKIM signing.
        """
elif False:
    EmailIdentityDkimAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailIdentityDkimAttributesArgs:
    def __init__(__self__, *,
                 signing_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Used to enable or disable DKIM authentication for an email identity.
        :param pulumi.Input[bool] signing_enabled: Sets the DKIM signing configuration for the identity. When you set this value true, then the messages that are sent from the identity are signed using DKIM. If you set this value to false, your messages are sent without DKIM signing.
        """
        if signing_enabled is not None:
            pulumi.set(__self__, "signing_enabled", signing_enabled)

    @property
    @pulumi.getter(name="signingEnabled")
    def signing_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets the DKIM signing configuration for the identity. When you set this value true, then the messages that are sent from the identity are signed using DKIM. If you set this value to false, your messages are sent without DKIM signing.
        """
        return pulumi.get(self, "signing_enabled")

    @signing_enabled.setter
    def signing_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "signing_enabled", value)


if not MYPY:
    class EmailIdentityDkimSigningAttributesArgsDict(TypedDict):
        """
        If your request includes this object, Amazon SES configures the identity to use Bring Your Own DKIM (BYODKIM) for DKIM authentication purposes, or, configures the key length to be used for Easy DKIM.
        """
        domain_signing_private_key: NotRequired[pulumi.Input[str]]
        """
        [Bring Your Own DKIM] A private key that's used to generate a DKIM signature. The private key must use 1024 or 2048-bit RSA encryption, and must be encoded using base64 encoding.
        """
        domain_signing_selector: NotRequired[pulumi.Input[str]]
        """
        [Bring Your Own DKIM] A string that's used to identify a public key in the DNS configuration for a domain.
        """
        next_signing_key_length: NotRequired[pulumi.Input[str]]
        """
        [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day.
        """
elif False:
    EmailIdentityDkimSigningAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailIdentityDkimSigningAttributesArgs:
    def __init__(__self__, *,
                 domain_signing_private_key: Optional[pulumi.Input[str]] = None,
                 domain_signing_selector: Optional[pulumi.Input[str]] = None,
                 next_signing_key_length: Optional[pulumi.Input[str]] = None):
        """
        If your request includes this object, Amazon SES configures the identity to use Bring Your Own DKIM (BYODKIM) for DKIM authentication purposes, or, configures the key length to be used for Easy DKIM.
        :param pulumi.Input[str] domain_signing_private_key: [Bring Your Own DKIM] A private key that's used to generate a DKIM signature. The private key must use 1024 or 2048-bit RSA encryption, and must be encoded using base64 encoding.
        :param pulumi.Input[str] domain_signing_selector: [Bring Your Own DKIM] A string that's used to identify a public key in the DNS configuration for a domain.
        :param pulumi.Input[str] next_signing_key_length: [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day.
        """
        if domain_signing_private_key is not None:
            pulumi.set(__self__, "domain_signing_private_key", domain_signing_private_key)
        if domain_signing_selector is not None:
            pulumi.set(__self__, "domain_signing_selector", domain_signing_selector)
        if next_signing_key_length is not None:
            pulumi.set(__self__, "next_signing_key_length", next_signing_key_length)

    @property
    @pulumi.getter(name="domainSigningPrivateKey")
    def domain_signing_private_key(self) -> Optional[pulumi.Input[str]]:
        """
        [Bring Your Own DKIM] A private key that's used to generate a DKIM signature. The private key must use 1024 or 2048-bit RSA encryption, and must be encoded using base64 encoding.
        """
        return pulumi.get(self, "domain_signing_private_key")

    @domain_signing_private_key.setter
    def domain_signing_private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_signing_private_key", value)

    @property
    @pulumi.getter(name="domainSigningSelector")
    def domain_signing_selector(self) -> Optional[pulumi.Input[str]]:
        """
        [Bring Your Own DKIM] A string that's used to identify a public key in the DNS configuration for a domain.
        """
        return pulumi.get(self, "domain_signing_selector")

    @domain_signing_selector.setter
    def domain_signing_selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_signing_selector", value)

    @property
    @pulumi.getter(name="nextSigningKeyLength")
    def next_signing_key_length(self) -> Optional[pulumi.Input[str]]:
        """
        [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day.
        """
        return pulumi.get(self, "next_signing_key_length")

    @next_signing_key_length.setter
    def next_signing_key_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_signing_key_length", value)


if not MYPY:
    class EmailIdentityFeedbackAttributesArgsDict(TypedDict):
        """
        Used to enable or disable feedback forwarding for an identity.
        """
        email_forwarding_enabled: NotRequired[pulumi.Input[bool]]
        """
        If the value is true, you receive email notifications when bounce or complaint events occur
        """
elif False:
    EmailIdentityFeedbackAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailIdentityFeedbackAttributesArgs:
    def __init__(__self__, *,
                 email_forwarding_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Used to enable or disable feedback forwarding for an identity.
        :param pulumi.Input[bool] email_forwarding_enabled: If the value is true, you receive email notifications when bounce or complaint events occur
        """
        if email_forwarding_enabled is not None:
            pulumi.set(__self__, "email_forwarding_enabled", email_forwarding_enabled)

    @property
    @pulumi.getter(name="emailForwardingEnabled")
    def email_forwarding_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the value is true, you receive email notifications when bounce or complaint events occur
        """
        return pulumi.get(self, "email_forwarding_enabled")

    @email_forwarding_enabled.setter
    def email_forwarding_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "email_forwarding_enabled", value)


if not MYPY:
    class EmailIdentityMailFromAttributesArgsDict(TypedDict):
        """
        Used to enable or disable the custom Mail-From domain configuration for an email identity.
        """
        behavior_on_mx_failure: NotRequired[pulumi.Input[str]]
        """
        The action to take if the required MX record isn't found when you send an email. When you set this value to UseDefaultValue , the mail is sent using amazonses.com as the MAIL FROM domain. When you set this value to RejectMessage , the Amazon SES API v2 returns a MailFromDomainNotVerified error, and doesn't attempt to deliver the email.
        """
        mail_from_domain: NotRequired[pulumi.Input[str]]
        """
        The custom MAIL FROM domain that you want the verified identity to use
        """
elif False:
    EmailIdentityMailFromAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailIdentityMailFromAttributesArgs:
    def __init__(__self__, *,
                 behavior_on_mx_failure: Optional[pulumi.Input[str]] = None,
                 mail_from_domain: Optional[pulumi.Input[str]] = None):
        """
        Used to enable or disable the custom Mail-From domain configuration for an email identity.
        :param pulumi.Input[str] behavior_on_mx_failure: The action to take if the required MX record isn't found when you send an email. When you set this value to UseDefaultValue , the mail is sent using amazonses.com as the MAIL FROM domain. When you set this value to RejectMessage , the Amazon SES API v2 returns a MailFromDomainNotVerified error, and doesn't attempt to deliver the email.
        :param pulumi.Input[str] mail_from_domain: The custom MAIL FROM domain that you want the verified identity to use
        """
        if behavior_on_mx_failure is not None:
            pulumi.set(__self__, "behavior_on_mx_failure", behavior_on_mx_failure)
        if mail_from_domain is not None:
            pulumi.set(__self__, "mail_from_domain", mail_from_domain)

    @property
    @pulumi.getter(name="behaviorOnMxFailure")
    def behavior_on_mx_failure(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take if the required MX record isn't found when you send an email. When you set this value to UseDefaultValue , the mail is sent using amazonses.com as the MAIL FROM domain. When you set this value to RejectMessage , the Amazon SES API v2 returns a MailFromDomainNotVerified error, and doesn't attempt to deliver the email.
        """
        return pulumi.get(self, "behavior_on_mx_failure")

    @behavior_on_mx_failure.setter
    def behavior_on_mx_failure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "behavior_on_mx_failure", value)

    @property
    @pulumi.getter(name="mailFromDomain")
    def mail_from_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The custom MAIL FROM domain that you want the verified identity to use
        """
        return pulumi.get(self, "mail_from_domain")

    @mail_from_domain.setter
    def mail_from_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mail_from_domain", value)


if not MYPY:
    class MailManagerArchiveArchiveRetentionPropertiesArgsDict(TypedDict):
        retention_period: pulumi.Input['MailManagerArchiveRetentionPeriod']
elif False:
    MailManagerArchiveArchiveRetentionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerArchiveArchiveRetentionPropertiesArgs:
    def __init__(__self__, *,
                 retention_period: pulumi.Input['MailManagerArchiveRetentionPeriod']):
        pulumi.set(__self__, "retention_period", retention_period)

    @property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> pulumi.Input['MailManagerArchiveRetentionPeriod']:
        return pulumi.get(self, "retention_period")

    @retention_period.setter
    def retention_period(self, value: pulumi.Input['MailManagerArchiveRetentionPeriod']):
        pulumi.set(self, "retention_period", value)


if not MYPY:
    class MailManagerIngressPointIngressPointConfiguration0PropertiesArgsDict(TypedDict):
        smtp_password: pulumi.Input[str]
elif False:
    MailManagerIngressPointIngressPointConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerIngressPointIngressPointConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 smtp_password: pulumi.Input[str]):
        pulumi.set(__self__, "smtp_password", smtp_password)

    @property
    @pulumi.getter(name="smtpPassword")
    def smtp_password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "smtp_password")

    @smtp_password.setter
    def smtp_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "smtp_password", value)


if not MYPY:
    class MailManagerIngressPointIngressPointConfiguration1PropertiesArgsDict(TypedDict):
        secret_arn: pulumi.Input[str]
elif False:
    MailManagerIngressPointIngressPointConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerIngressPointIngressPointConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 secret_arn: pulumi.Input[str]):
        pulumi.set(__self__, "secret_arn", secret_arn)

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_arn", value)


if not MYPY:
    class MailManagerRelayNoAuthenticationArgsDict(TypedDict):
        pass
elif False:
    MailManagerRelayNoAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRelayNoAuthenticationArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class MailManagerRelayRelayAuthentication0PropertiesArgsDict(TypedDict):
        secret_arn: pulumi.Input[str]
elif False:
    MailManagerRelayRelayAuthentication0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRelayRelayAuthentication0PropertiesArgs:
    def __init__(__self__, *,
                 secret_arn: pulumi.Input[str]):
        pulumi.set(__self__, "secret_arn", secret_arn)

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_arn", value)


if not MYPY:
    class MailManagerRelayRelayAuthentication1PropertiesArgsDict(TypedDict):
        no_authentication: pulumi.Input['MailManagerRelayNoAuthenticationArgsDict']
elif False:
    MailManagerRelayRelayAuthentication1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRelayRelayAuthentication1PropertiesArgs:
    def __init__(__self__, *,
                 no_authentication: pulumi.Input['MailManagerRelayNoAuthenticationArgs']):
        pulumi.set(__self__, "no_authentication", no_authentication)

    @property
    @pulumi.getter(name="noAuthentication")
    def no_authentication(self) -> pulumi.Input['MailManagerRelayNoAuthenticationArgs']:
        return pulumi.get(self, "no_authentication")

    @no_authentication.setter
    def no_authentication(self, value: pulumi.Input['MailManagerRelayNoAuthenticationArgs']):
        pulumi.set(self, "no_authentication", value)


if not MYPY:
    class MailManagerRuleSetAddHeaderActionArgsDict(TypedDict):
        header_name: pulumi.Input[str]
        header_value: pulumi.Input[str]
elif False:
    MailManagerRuleSetAddHeaderActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetAddHeaderActionArgs:
    def __init__(__self__, *,
                 header_name: pulumi.Input[str],
                 header_value: pulumi.Input[str]):
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_value", value)


if not MYPY:
    class MailManagerRuleSetAnalysisArgsDict(TypedDict):
        analyzer: pulumi.Input[str]
        result_field: pulumi.Input[str]
elif False:
    MailManagerRuleSetAnalysisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetAnalysisArgs:
    def __init__(__self__, *,
                 analyzer: pulumi.Input[str],
                 result_field: pulumi.Input[str]):
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "result_field", result_field)

    @property
    @pulumi.getter
    def analyzer(self) -> pulumi.Input[str]:
        return pulumi.get(self, "analyzer")

    @analyzer.setter
    def analyzer(self, value: pulumi.Input[str]):
        pulumi.set(self, "analyzer", value)

    @property
    @pulumi.getter(name="resultField")
    def result_field(self) -> pulumi.Input[str]:
        return pulumi.get(self, "result_field")

    @result_field.setter
    def result_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "result_field", value)


if not MYPY:
    class MailManagerRuleSetArchiveActionArgsDict(TypedDict):
        target_archive: pulumi.Input[str]
        action_failure_policy: NotRequired[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]
elif False:
    MailManagerRuleSetArchiveActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetArchiveActionArgs:
    def __init__(__self__, *,
                 target_archive: pulumi.Input[str],
                 action_failure_policy: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']] = None):
        pulumi.set(__self__, "target_archive", target_archive)
        if action_failure_policy is not None:
            pulumi.set(__self__, "action_failure_policy", action_failure_policy)

    @property
    @pulumi.getter(name="targetArchive")
    def target_archive(self) -> pulumi.Input[str]:
        return pulumi.get(self, "target_archive")

    @target_archive.setter
    def target_archive(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_archive", value)

    @property
    @pulumi.getter(name="actionFailurePolicy")
    def action_failure_policy(self) -> Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]:
        return pulumi.get(self, "action_failure_policy")

    @action_failure_policy.setter
    def action_failure_policy(self, value: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]):
        pulumi.set(self, "action_failure_policy", value)


if not MYPY:
    class MailManagerRuleSetDeliverToMailboxActionArgsDict(TypedDict):
        mailbox_arn: pulumi.Input[str]
        role_arn: pulumi.Input[str]
        action_failure_policy: NotRequired[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]
elif False:
    MailManagerRuleSetDeliverToMailboxActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetDeliverToMailboxActionArgs:
    def __init__(__self__, *,
                 mailbox_arn: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 action_failure_policy: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']] = None):
        pulumi.set(__self__, "mailbox_arn", mailbox_arn)
        pulumi.set(__self__, "role_arn", role_arn)
        if action_failure_policy is not None:
            pulumi.set(__self__, "action_failure_policy", action_failure_policy)

    @property
    @pulumi.getter(name="mailboxArn")
    def mailbox_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mailbox_arn")

    @mailbox_arn.setter
    def mailbox_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "mailbox_arn", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="actionFailurePolicy")
    def action_failure_policy(self) -> Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]:
        return pulumi.get(self, "action_failure_policy")

    @action_failure_policy.setter
    def action_failure_policy(self, value: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]):
        pulumi.set(self, "action_failure_policy", value)


if not MYPY:
    class MailManagerRuleSetDeliverToQBusinessActionArgsDict(TypedDict):
        application_id: pulumi.Input[str]
        index_id: pulumi.Input[str]
        role_arn: pulumi.Input[str]
        action_failure_policy: NotRequired[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]
elif False:
    MailManagerRuleSetDeliverToQBusinessActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetDeliverToQBusinessActionArgs:
    def __init__(__self__, *,
                 application_id: pulumi.Input[str],
                 index_id: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 action_failure_policy: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']] = None):
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "index_id", index_id)
        pulumi.set(__self__, "role_arn", role_arn)
        if action_failure_policy is not None:
            pulumi.set(__self__, "action_failure_policy", action_failure_policy)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="indexId")
    def index_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index_id")

    @index_id.setter
    def index_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_id", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="actionFailurePolicy")
    def action_failure_policy(self) -> Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]:
        return pulumi.get(self, "action_failure_policy")

    @action_failure_policy.setter
    def action_failure_policy(self, value: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]):
        pulumi.set(self, "action_failure_policy", value)


if not MYPY:
    class MailManagerRuleSetDropActionArgsDict(TypedDict):
        pass
elif False:
    MailManagerRuleSetDropActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetDropActionArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class MailManagerRuleSetRelayActionArgsDict(TypedDict):
        relay: pulumi.Input[str]
        action_failure_policy: NotRequired[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]
        mail_from: NotRequired[pulumi.Input['MailManagerRuleSetMailFrom']]
elif False:
    MailManagerRuleSetRelayActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRelayActionArgs:
    def __init__(__self__, *,
                 relay: pulumi.Input[str],
                 action_failure_policy: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']] = None,
                 mail_from: Optional[pulumi.Input['MailManagerRuleSetMailFrom']] = None):
        pulumi.set(__self__, "relay", relay)
        if action_failure_policy is not None:
            pulumi.set(__self__, "action_failure_policy", action_failure_policy)
        if mail_from is not None:
            pulumi.set(__self__, "mail_from", mail_from)

    @property
    @pulumi.getter
    def relay(self) -> pulumi.Input[str]:
        return pulumi.get(self, "relay")

    @relay.setter
    def relay(self, value: pulumi.Input[str]):
        pulumi.set(self, "relay", value)

    @property
    @pulumi.getter(name="actionFailurePolicy")
    def action_failure_policy(self) -> Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]:
        return pulumi.get(self, "action_failure_policy")

    @action_failure_policy.setter
    def action_failure_policy(self, value: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]):
        pulumi.set(self, "action_failure_policy", value)

    @property
    @pulumi.getter(name="mailFrom")
    def mail_from(self) -> Optional[pulumi.Input['MailManagerRuleSetMailFrom']]:
        return pulumi.get(self, "mail_from")

    @mail_from.setter
    def mail_from(self, value: Optional[pulumi.Input['MailManagerRuleSetMailFrom']]):
        pulumi.set(self, "mail_from", value)


if not MYPY:
    class MailManagerRuleSetReplaceRecipientActionArgsDict(TypedDict):
        replace_with: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    MailManagerRuleSetReplaceRecipientActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetReplaceRecipientActionArgs:
    def __init__(__self__, *,
                 replace_with: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if replace_with is not None:
            pulumi.set(__self__, "replace_with", replace_with)

    @property
    @pulumi.getter(name="replaceWith")
    def replace_with(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "replace_with")

    @replace_with.setter
    def replace_with(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "replace_with", value)


if not MYPY:
    class MailManagerRuleSetRuleAction0PropertiesArgsDict(TypedDict):
        drop: pulumi.Input['MailManagerRuleSetDropActionArgsDict']
elif False:
    MailManagerRuleSetRuleAction0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleAction0PropertiesArgs:
    def __init__(__self__, *,
                 drop: pulumi.Input['MailManagerRuleSetDropActionArgs']):
        pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def drop(self) -> pulumi.Input['MailManagerRuleSetDropActionArgs']:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: pulumi.Input['MailManagerRuleSetDropActionArgs']):
        pulumi.set(self, "drop", value)


if not MYPY:
    class MailManagerRuleSetRuleAction1PropertiesArgsDict(TypedDict):
        relay: pulumi.Input['MailManagerRuleSetRelayActionArgsDict']
elif False:
    MailManagerRuleSetRuleAction1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleAction1PropertiesArgs:
    def __init__(__self__, *,
                 relay: pulumi.Input['MailManagerRuleSetRelayActionArgs']):
        pulumi.set(__self__, "relay", relay)

    @property
    @pulumi.getter
    def relay(self) -> pulumi.Input['MailManagerRuleSetRelayActionArgs']:
        return pulumi.get(self, "relay")

    @relay.setter
    def relay(self, value: pulumi.Input['MailManagerRuleSetRelayActionArgs']):
        pulumi.set(self, "relay", value)


if not MYPY:
    class MailManagerRuleSetRuleAction2PropertiesArgsDict(TypedDict):
        archive: pulumi.Input['MailManagerRuleSetArchiveActionArgsDict']
elif False:
    MailManagerRuleSetRuleAction2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleAction2PropertiesArgs:
    def __init__(__self__, *,
                 archive: pulumi.Input['MailManagerRuleSetArchiveActionArgs']):
        pulumi.set(__self__, "archive", archive)

    @property
    @pulumi.getter
    def archive(self) -> pulumi.Input['MailManagerRuleSetArchiveActionArgs']:
        return pulumi.get(self, "archive")

    @archive.setter
    def archive(self, value: pulumi.Input['MailManagerRuleSetArchiveActionArgs']):
        pulumi.set(self, "archive", value)


if not MYPY:
    class MailManagerRuleSetRuleAction3PropertiesArgsDict(TypedDict):
        write_to_s3: pulumi.Input['MailManagerRuleSetS3ActionArgsDict']
elif False:
    MailManagerRuleSetRuleAction3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleAction3PropertiesArgs:
    def __init__(__self__, *,
                 write_to_s3: pulumi.Input['MailManagerRuleSetS3ActionArgs']):
        pulumi.set(__self__, "write_to_s3", write_to_s3)

    @property
    @pulumi.getter(name="writeToS3")
    def write_to_s3(self) -> pulumi.Input['MailManagerRuleSetS3ActionArgs']:
        return pulumi.get(self, "write_to_s3")

    @write_to_s3.setter
    def write_to_s3(self, value: pulumi.Input['MailManagerRuleSetS3ActionArgs']):
        pulumi.set(self, "write_to_s3", value)


if not MYPY:
    class MailManagerRuleSetRuleAction4PropertiesArgsDict(TypedDict):
        send: pulumi.Input['MailManagerRuleSetSendActionArgsDict']
elif False:
    MailManagerRuleSetRuleAction4PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleAction4PropertiesArgs:
    def __init__(__self__, *,
                 send: pulumi.Input['MailManagerRuleSetSendActionArgs']):
        pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def send(self) -> pulumi.Input['MailManagerRuleSetSendActionArgs']:
        return pulumi.get(self, "send")

    @send.setter
    def send(self, value: pulumi.Input['MailManagerRuleSetSendActionArgs']):
        pulumi.set(self, "send", value)


if not MYPY:
    class MailManagerRuleSetRuleAction5PropertiesArgsDict(TypedDict):
        add_header: pulumi.Input['MailManagerRuleSetAddHeaderActionArgsDict']
elif False:
    MailManagerRuleSetRuleAction5PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleAction5PropertiesArgs:
    def __init__(__self__, *,
                 add_header: pulumi.Input['MailManagerRuleSetAddHeaderActionArgs']):
        pulumi.set(__self__, "add_header", add_header)

    @property
    @pulumi.getter(name="addHeader")
    def add_header(self) -> pulumi.Input['MailManagerRuleSetAddHeaderActionArgs']:
        return pulumi.get(self, "add_header")

    @add_header.setter
    def add_header(self, value: pulumi.Input['MailManagerRuleSetAddHeaderActionArgs']):
        pulumi.set(self, "add_header", value)


if not MYPY:
    class MailManagerRuleSetRuleAction6PropertiesArgsDict(TypedDict):
        replace_recipient: pulumi.Input['MailManagerRuleSetReplaceRecipientActionArgsDict']
elif False:
    MailManagerRuleSetRuleAction6PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleAction6PropertiesArgs:
    def __init__(__self__, *,
                 replace_recipient: pulumi.Input['MailManagerRuleSetReplaceRecipientActionArgs']):
        pulumi.set(__self__, "replace_recipient", replace_recipient)

    @property
    @pulumi.getter(name="replaceRecipient")
    def replace_recipient(self) -> pulumi.Input['MailManagerRuleSetReplaceRecipientActionArgs']:
        return pulumi.get(self, "replace_recipient")

    @replace_recipient.setter
    def replace_recipient(self, value: pulumi.Input['MailManagerRuleSetReplaceRecipientActionArgs']):
        pulumi.set(self, "replace_recipient", value)


if not MYPY:
    class MailManagerRuleSetRuleAction7PropertiesArgsDict(TypedDict):
        deliver_to_mailbox: pulumi.Input['MailManagerRuleSetDeliverToMailboxActionArgsDict']
elif False:
    MailManagerRuleSetRuleAction7PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleAction7PropertiesArgs:
    def __init__(__self__, *,
                 deliver_to_mailbox: pulumi.Input['MailManagerRuleSetDeliverToMailboxActionArgs']):
        pulumi.set(__self__, "deliver_to_mailbox", deliver_to_mailbox)

    @property
    @pulumi.getter(name="deliverToMailbox")
    def deliver_to_mailbox(self) -> pulumi.Input['MailManagerRuleSetDeliverToMailboxActionArgs']:
        return pulumi.get(self, "deliver_to_mailbox")

    @deliver_to_mailbox.setter
    def deliver_to_mailbox(self, value: pulumi.Input['MailManagerRuleSetDeliverToMailboxActionArgs']):
        pulumi.set(self, "deliver_to_mailbox", value)


if not MYPY:
    class MailManagerRuleSetRuleAction8PropertiesArgsDict(TypedDict):
        deliver_to_q_business: pulumi.Input['MailManagerRuleSetDeliverToQBusinessActionArgsDict']
elif False:
    MailManagerRuleSetRuleAction8PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleAction8PropertiesArgs:
    def __init__(__self__, *,
                 deliver_to_q_business: pulumi.Input['MailManagerRuleSetDeliverToQBusinessActionArgs']):
        pulumi.set(__self__, "deliver_to_q_business", deliver_to_q_business)

    @property
    @pulumi.getter(name="deliverToQBusiness")
    def deliver_to_q_business(self) -> pulumi.Input['MailManagerRuleSetDeliverToQBusinessActionArgs']:
        return pulumi.get(self, "deliver_to_q_business")

    @deliver_to_q_business.setter
    def deliver_to_q_business(self, value: pulumi.Input['MailManagerRuleSetDeliverToQBusinessActionArgs']):
        pulumi.set(self, "deliver_to_q_business", value)


if not MYPY:
    class MailManagerRuleSetRuleBooleanExpressionArgsDict(TypedDict):
        evaluate: pulumi.Input['MailManagerRuleSetRuleBooleanToEvaluatePropertiesArgsDict']
        operator: pulumi.Input['MailManagerRuleSetRuleBooleanOperator']
elif False:
    MailManagerRuleSetRuleBooleanExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleBooleanExpressionArgs:
    def __init__(__self__, *,
                 evaluate: pulumi.Input['MailManagerRuleSetRuleBooleanToEvaluatePropertiesArgs'],
                 operator: pulumi.Input['MailManagerRuleSetRuleBooleanOperator']):
        pulumi.set(__self__, "evaluate", evaluate)
        pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def evaluate(self) -> pulumi.Input['MailManagerRuleSetRuleBooleanToEvaluatePropertiesArgs']:
        return pulumi.get(self, "evaluate")

    @evaluate.setter
    def evaluate(self, value: pulumi.Input['MailManagerRuleSetRuleBooleanToEvaluatePropertiesArgs']):
        pulumi.set(self, "evaluate", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['MailManagerRuleSetRuleBooleanOperator']:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['MailManagerRuleSetRuleBooleanOperator']):
        pulumi.set(self, "operator", value)


if not MYPY:
    class MailManagerRuleSetRuleBooleanToEvaluatePropertiesArgsDict(TypedDict):
        attribute: pulumi.Input['MailManagerRuleSetRuleBooleanEmailAttribute']
elif False:
    MailManagerRuleSetRuleBooleanToEvaluatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleBooleanToEvaluatePropertiesArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input['MailManagerRuleSetRuleBooleanEmailAttribute']):
        pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def attribute(self) -> pulumi.Input['MailManagerRuleSetRuleBooleanEmailAttribute']:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input['MailManagerRuleSetRuleBooleanEmailAttribute']):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class MailManagerRuleSetRuleCondition0PropertiesArgsDict(TypedDict):
        boolean_expression: pulumi.Input['MailManagerRuleSetRuleBooleanExpressionArgsDict']
elif False:
    MailManagerRuleSetRuleCondition0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleCondition0PropertiesArgs:
    def __init__(__self__, *,
                 boolean_expression: pulumi.Input['MailManagerRuleSetRuleBooleanExpressionArgs']):
        pulumi.set(__self__, "boolean_expression", boolean_expression)

    @property
    @pulumi.getter(name="booleanExpression")
    def boolean_expression(self) -> pulumi.Input['MailManagerRuleSetRuleBooleanExpressionArgs']:
        return pulumi.get(self, "boolean_expression")

    @boolean_expression.setter
    def boolean_expression(self, value: pulumi.Input['MailManagerRuleSetRuleBooleanExpressionArgs']):
        pulumi.set(self, "boolean_expression", value)


if not MYPY:
    class MailManagerRuleSetRuleCondition1PropertiesArgsDict(TypedDict):
        string_expression: pulumi.Input['MailManagerRuleSetRuleStringExpressionArgsDict']
elif False:
    MailManagerRuleSetRuleCondition1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleCondition1PropertiesArgs:
    def __init__(__self__, *,
                 string_expression: pulumi.Input['MailManagerRuleSetRuleStringExpressionArgs']):
        pulumi.set(__self__, "string_expression", string_expression)

    @property
    @pulumi.getter(name="stringExpression")
    def string_expression(self) -> pulumi.Input['MailManagerRuleSetRuleStringExpressionArgs']:
        return pulumi.get(self, "string_expression")

    @string_expression.setter
    def string_expression(self, value: pulumi.Input['MailManagerRuleSetRuleStringExpressionArgs']):
        pulumi.set(self, "string_expression", value)


if not MYPY:
    class MailManagerRuleSetRuleCondition2PropertiesArgsDict(TypedDict):
        number_expression: pulumi.Input['MailManagerRuleSetRuleNumberExpressionArgsDict']
elif False:
    MailManagerRuleSetRuleCondition2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleCondition2PropertiesArgs:
    def __init__(__self__, *,
                 number_expression: pulumi.Input['MailManagerRuleSetRuleNumberExpressionArgs']):
        pulumi.set(__self__, "number_expression", number_expression)

    @property
    @pulumi.getter(name="numberExpression")
    def number_expression(self) -> pulumi.Input['MailManagerRuleSetRuleNumberExpressionArgs']:
        return pulumi.get(self, "number_expression")

    @number_expression.setter
    def number_expression(self, value: pulumi.Input['MailManagerRuleSetRuleNumberExpressionArgs']):
        pulumi.set(self, "number_expression", value)


if not MYPY:
    class MailManagerRuleSetRuleCondition3PropertiesArgsDict(TypedDict):
        ip_expression: pulumi.Input['MailManagerRuleSetRuleIpExpressionArgsDict']
elif False:
    MailManagerRuleSetRuleCondition3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleCondition3PropertiesArgs:
    def __init__(__self__, *,
                 ip_expression: pulumi.Input['MailManagerRuleSetRuleIpExpressionArgs']):
        pulumi.set(__self__, "ip_expression", ip_expression)

    @property
    @pulumi.getter(name="ipExpression")
    def ip_expression(self) -> pulumi.Input['MailManagerRuleSetRuleIpExpressionArgs']:
        return pulumi.get(self, "ip_expression")

    @ip_expression.setter
    def ip_expression(self, value: pulumi.Input['MailManagerRuleSetRuleIpExpressionArgs']):
        pulumi.set(self, "ip_expression", value)


if not MYPY:
    class MailManagerRuleSetRuleCondition4PropertiesArgsDict(TypedDict):
        verdict_expression: pulumi.Input['MailManagerRuleSetRuleVerdictExpressionArgsDict']
elif False:
    MailManagerRuleSetRuleCondition4PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleCondition4PropertiesArgs:
    def __init__(__self__, *,
                 verdict_expression: pulumi.Input['MailManagerRuleSetRuleVerdictExpressionArgs']):
        pulumi.set(__self__, "verdict_expression", verdict_expression)

    @property
    @pulumi.getter(name="verdictExpression")
    def verdict_expression(self) -> pulumi.Input['MailManagerRuleSetRuleVerdictExpressionArgs']:
        return pulumi.get(self, "verdict_expression")

    @verdict_expression.setter
    def verdict_expression(self, value: pulumi.Input['MailManagerRuleSetRuleVerdictExpressionArgs']):
        pulumi.set(self, "verdict_expression", value)


if not MYPY:
    class MailManagerRuleSetRuleCondition5PropertiesArgsDict(TypedDict):
        dmarc_expression: pulumi.Input['MailManagerRuleSetRuleDmarcExpressionArgsDict']
elif False:
    MailManagerRuleSetRuleCondition5PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleCondition5PropertiesArgs:
    def __init__(__self__, *,
                 dmarc_expression: pulumi.Input['MailManagerRuleSetRuleDmarcExpressionArgs']):
        pulumi.set(__self__, "dmarc_expression", dmarc_expression)

    @property
    @pulumi.getter(name="dmarcExpression")
    def dmarc_expression(self) -> pulumi.Input['MailManagerRuleSetRuleDmarcExpressionArgs']:
        return pulumi.get(self, "dmarc_expression")

    @dmarc_expression.setter
    def dmarc_expression(self, value: pulumi.Input['MailManagerRuleSetRuleDmarcExpressionArgs']):
        pulumi.set(self, "dmarc_expression", value)


if not MYPY:
    class MailManagerRuleSetRuleDmarcExpressionArgsDict(TypedDict):
        operator: pulumi.Input['MailManagerRuleSetRuleDmarcOperator']
        values: pulumi.Input[Sequence[pulumi.Input['MailManagerRuleSetRuleDmarcPolicy']]]
elif False:
    MailManagerRuleSetRuleDmarcExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleDmarcExpressionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input['MailManagerRuleSetRuleDmarcOperator'],
                 values: pulumi.Input[Sequence[pulumi.Input['MailManagerRuleSetRuleDmarcPolicy']]]):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['MailManagerRuleSetRuleDmarcOperator']:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['MailManagerRuleSetRuleDmarcOperator']):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input['MailManagerRuleSetRuleDmarcPolicy']]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input['MailManagerRuleSetRuleDmarcPolicy']]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MailManagerRuleSetRuleIpExpressionArgsDict(TypedDict):
        evaluate: pulumi.Input['MailManagerRuleSetRuleIpToEvaluatePropertiesArgsDict']
        operator: pulumi.Input['MailManagerRuleSetRuleIpOperator']
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    MailManagerRuleSetRuleIpExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleIpExpressionArgs:
    def __init__(__self__, *,
                 evaluate: pulumi.Input['MailManagerRuleSetRuleIpToEvaluatePropertiesArgs'],
                 operator: pulumi.Input['MailManagerRuleSetRuleIpOperator'],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "evaluate", evaluate)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def evaluate(self) -> pulumi.Input['MailManagerRuleSetRuleIpToEvaluatePropertiesArgs']:
        return pulumi.get(self, "evaluate")

    @evaluate.setter
    def evaluate(self, value: pulumi.Input['MailManagerRuleSetRuleIpToEvaluatePropertiesArgs']):
        pulumi.set(self, "evaluate", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['MailManagerRuleSetRuleIpOperator']:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['MailManagerRuleSetRuleIpOperator']):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MailManagerRuleSetRuleIpToEvaluatePropertiesArgsDict(TypedDict):
        attribute: pulumi.Input['MailManagerRuleSetRuleIpEmailAttribute']
elif False:
    MailManagerRuleSetRuleIpToEvaluatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleIpToEvaluatePropertiesArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input['MailManagerRuleSetRuleIpEmailAttribute']):
        pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def attribute(self) -> pulumi.Input['MailManagerRuleSetRuleIpEmailAttribute']:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input['MailManagerRuleSetRuleIpEmailAttribute']):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class MailManagerRuleSetRuleNumberExpressionArgsDict(TypedDict):
        evaluate: pulumi.Input['MailManagerRuleSetRuleNumberToEvaluatePropertiesArgsDict']
        operator: pulumi.Input['MailManagerRuleSetRuleNumberOperator']
        value: pulumi.Input[float]
elif False:
    MailManagerRuleSetRuleNumberExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleNumberExpressionArgs:
    def __init__(__self__, *,
                 evaluate: pulumi.Input['MailManagerRuleSetRuleNumberToEvaluatePropertiesArgs'],
                 operator: pulumi.Input['MailManagerRuleSetRuleNumberOperator'],
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "evaluate", evaluate)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def evaluate(self) -> pulumi.Input['MailManagerRuleSetRuleNumberToEvaluatePropertiesArgs']:
        return pulumi.get(self, "evaluate")

    @evaluate.setter
    def evaluate(self, value: pulumi.Input['MailManagerRuleSetRuleNumberToEvaluatePropertiesArgs']):
        pulumi.set(self, "evaluate", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['MailManagerRuleSetRuleNumberOperator']:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['MailManagerRuleSetRuleNumberOperator']):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MailManagerRuleSetRuleNumberToEvaluatePropertiesArgsDict(TypedDict):
        attribute: pulumi.Input['MailManagerRuleSetRuleNumberEmailAttribute']
elif False:
    MailManagerRuleSetRuleNumberToEvaluatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleNumberToEvaluatePropertiesArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input['MailManagerRuleSetRuleNumberEmailAttribute']):
        pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def attribute(self) -> pulumi.Input['MailManagerRuleSetRuleNumberEmailAttribute']:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input['MailManagerRuleSetRuleNumberEmailAttribute']):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class MailManagerRuleSetRuleStringExpressionArgsDict(TypedDict):
        evaluate: pulumi.Input[Union['MailManagerRuleSetRuleStringToEvaluate0PropertiesArgsDict', 'MailManagerRuleSetRuleStringToEvaluate1PropertiesArgsDict']]
        operator: pulumi.Input['MailManagerRuleSetRuleStringOperator']
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    MailManagerRuleSetRuleStringExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleStringExpressionArgs:
    def __init__(__self__, *,
                 evaluate: pulumi.Input[Union['MailManagerRuleSetRuleStringToEvaluate0PropertiesArgs', 'MailManagerRuleSetRuleStringToEvaluate1PropertiesArgs']],
                 operator: pulumi.Input['MailManagerRuleSetRuleStringOperator'],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "evaluate", evaluate)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def evaluate(self) -> pulumi.Input[Union['MailManagerRuleSetRuleStringToEvaluate0PropertiesArgs', 'MailManagerRuleSetRuleStringToEvaluate1PropertiesArgs']]:
        return pulumi.get(self, "evaluate")

    @evaluate.setter
    def evaluate(self, value: pulumi.Input[Union['MailManagerRuleSetRuleStringToEvaluate0PropertiesArgs', 'MailManagerRuleSetRuleStringToEvaluate1PropertiesArgs']]):
        pulumi.set(self, "evaluate", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['MailManagerRuleSetRuleStringOperator']:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['MailManagerRuleSetRuleStringOperator']):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MailManagerRuleSetRuleStringToEvaluate0PropertiesArgsDict(TypedDict):
        attribute: pulumi.Input['MailManagerRuleSetRuleStringEmailAttribute']
elif False:
    MailManagerRuleSetRuleStringToEvaluate0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleStringToEvaluate0PropertiesArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input['MailManagerRuleSetRuleStringEmailAttribute']):
        pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def attribute(self) -> pulumi.Input['MailManagerRuleSetRuleStringEmailAttribute']:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input['MailManagerRuleSetRuleStringEmailAttribute']):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class MailManagerRuleSetRuleStringToEvaluate1PropertiesArgsDict(TypedDict):
        mime_header_attribute: pulumi.Input[str]
elif False:
    MailManagerRuleSetRuleStringToEvaluate1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleStringToEvaluate1PropertiesArgs:
    def __init__(__self__, *,
                 mime_header_attribute: pulumi.Input[str]):
        pulumi.set(__self__, "mime_header_attribute", mime_header_attribute)

    @property
    @pulumi.getter(name="mimeHeaderAttribute")
    def mime_header_attribute(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mime_header_attribute")

    @mime_header_attribute.setter
    def mime_header_attribute(self, value: pulumi.Input[str]):
        pulumi.set(self, "mime_header_attribute", value)


if not MYPY:
    class MailManagerRuleSetRuleVerdictExpressionArgsDict(TypedDict):
        evaluate: pulumi.Input[Union['MailManagerRuleSetRuleVerdictToEvaluate0PropertiesArgsDict', 'MailManagerRuleSetRuleVerdictToEvaluate1PropertiesArgsDict']]
        operator: pulumi.Input['MailManagerRuleSetRuleVerdictOperator']
        values: pulumi.Input[Sequence[pulumi.Input['MailManagerRuleSetRuleVerdict']]]
elif False:
    MailManagerRuleSetRuleVerdictExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleVerdictExpressionArgs:
    def __init__(__self__, *,
                 evaluate: pulumi.Input[Union['MailManagerRuleSetRuleVerdictToEvaluate0PropertiesArgs', 'MailManagerRuleSetRuleVerdictToEvaluate1PropertiesArgs']],
                 operator: pulumi.Input['MailManagerRuleSetRuleVerdictOperator'],
                 values: pulumi.Input[Sequence[pulumi.Input['MailManagerRuleSetRuleVerdict']]]):
        pulumi.set(__self__, "evaluate", evaluate)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def evaluate(self) -> pulumi.Input[Union['MailManagerRuleSetRuleVerdictToEvaluate0PropertiesArgs', 'MailManagerRuleSetRuleVerdictToEvaluate1PropertiesArgs']]:
        return pulumi.get(self, "evaluate")

    @evaluate.setter
    def evaluate(self, value: pulumi.Input[Union['MailManagerRuleSetRuleVerdictToEvaluate0PropertiesArgs', 'MailManagerRuleSetRuleVerdictToEvaluate1PropertiesArgs']]):
        pulumi.set(self, "evaluate", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['MailManagerRuleSetRuleVerdictOperator']:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['MailManagerRuleSetRuleVerdictOperator']):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input['MailManagerRuleSetRuleVerdict']]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input['MailManagerRuleSetRuleVerdict']]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MailManagerRuleSetRuleVerdictToEvaluate0PropertiesArgsDict(TypedDict):
        attribute: pulumi.Input['MailManagerRuleSetRuleVerdictAttribute']
elif False:
    MailManagerRuleSetRuleVerdictToEvaluate0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleVerdictToEvaluate0PropertiesArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input['MailManagerRuleSetRuleVerdictAttribute']):
        pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def attribute(self) -> pulumi.Input['MailManagerRuleSetRuleVerdictAttribute']:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input['MailManagerRuleSetRuleVerdictAttribute']):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class MailManagerRuleSetRuleVerdictToEvaluate1PropertiesArgsDict(TypedDict):
        analysis: pulumi.Input['MailManagerRuleSetAnalysisArgsDict']
elif False:
    MailManagerRuleSetRuleVerdictToEvaluate1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleVerdictToEvaluate1PropertiesArgs:
    def __init__(__self__, *,
                 analysis: pulumi.Input['MailManagerRuleSetAnalysisArgs']):
        pulumi.set(__self__, "analysis", analysis)

    @property
    @pulumi.getter
    def analysis(self) -> pulumi.Input['MailManagerRuleSetAnalysisArgs']:
        return pulumi.get(self, "analysis")

    @analysis.setter
    def analysis(self, value: pulumi.Input['MailManagerRuleSetAnalysisArgs']):
        pulumi.set(self, "analysis", value)


if not MYPY:
    class MailManagerRuleSetRuleArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleAction0PropertiesArgsDict', 'MailManagerRuleSetRuleAction1PropertiesArgsDict', 'MailManagerRuleSetRuleAction2PropertiesArgsDict', 'MailManagerRuleSetRuleAction3PropertiesArgsDict', 'MailManagerRuleSetRuleAction4PropertiesArgsDict', 'MailManagerRuleSetRuleAction5PropertiesArgsDict', 'MailManagerRuleSetRuleAction6PropertiesArgsDict', 'MailManagerRuleSetRuleAction7PropertiesArgsDict', 'MailManagerRuleSetRuleAction8PropertiesArgsDict']]]]
        """
        The list of actions to execute when the conditions match the incoming email, and none of the "unless conditions" match.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleCondition0PropertiesArgsDict', 'MailManagerRuleSetRuleCondition1PropertiesArgsDict', 'MailManagerRuleSetRuleCondition2PropertiesArgsDict', 'MailManagerRuleSetRuleCondition3PropertiesArgsDict', 'MailManagerRuleSetRuleCondition4PropertiesArgsDict', 'MailManagerRuleSetRuleCondition5PropertiesArgsDict']]]]]
        """
        The conditions of this rule. All conditions must match the email for the actions to be executed. An empty list of conditions means that all emails match, but are still subject to any "unless conditions"
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The user-friendly name of the rule.
        """
        unless: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleCondition0PropertiesArgsDict', 'MailManagerRuleSetRuleCondition1PropertiesArgsDict', 'MailManagerRuleSetRuleCondition2PropertiesArgsDict', 'MailManagerRuleSetRuleCondition3PropertiesArgsDict', 'MailManagerRuleSetRuleCondition4PropertiesArgsDict', 'MailManagerRuleSetRuleCondition5PropertiesArgsDict']]]]]
        """
        The "unless conditions" of this rule. None of the conditions can match the email for the actions to be executed. If any of these conditions do match the email, then the actions are not executed.
        """
elif False:
    MailManagerRuleSetRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleAction0PropertiesArgs', 'MailManagerRuleSetRuleAction1PropertiesArgs', 'MailManagerRuleSetRuleAction2PropertiesArgs', 'MailManagerRuleSetRuleAction3PropertiesArgs', 'MailManagerRuleSetRuleAction4PropertiesArgs', 'MailManagerRuleSetRuleAction5PropertiesArgs', 'MailManagerRuleSetRuleAction6PropertiesArgs', 'MailManagerRuleSetRuleAction7PropertiesArgs', 'MailManagerRuleSetRuleAction8PropertiesArgs']]]],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleCondition0PropertiesArgs', 'MailManagerRuleSetRuleCondition1PropertiesArgs', 'MailManagerRuleSetRuleCondition2PropertiesArgs', 'MailManagerRuleSetRuleCondition3PropertiesArgs', 'MailManagerRuleSetRuleCondition4PropertiesArgs', 'MailManagerRuleSetRuleCondition5PropertiesArgs']]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 unless: Optional[pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleCondition0PropertiesArgs', 'MailManagerRuleSetRuleCondition1PropertiesArgs', 'MailManagerRuleSetRuleCondition2PropertiesArgs', 'MailManagerRuleSetRuleCondition3PropertiesArgs', 'MailManagerRuleSetRuleCondition4PropertiesArgs', 'MailManagerRuleSetRuleCondition5PropertiesArgs']]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleAction0PropertiesArgs', 'MailManagerRuleSetRuleAction1PropertiesArgs', 'MailManagerRuleSetRuleAction2PropertiesArgs', 'MailManagerRuleSetRuleAction3PropertiesArgs', 'MailManagerRuleSetRuleAction4PropertiesArgs', 'MailManagerRuleSetRuleAction5PropertiesArgs', 'MailManagerRuleSetRuleAction6PropertiesArgs', 'MailManagerRuleSetRuleAction7PropertiesArgs', 'MailManagerRuleSetRuleAction8PropertiesArgs']]]] actions: The list of actions to execute when the conditions match the incoming email, and none of the "unless conditions" match.
        :param pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleCondition0PropertiesArgs', 'MailManagerRuleSetRuleCondition1PropertiesArgs', 'MailManagerRuleSetRuleCondition2PropertiesArgs', 'MailManagerRuleSetRuleCondition3PropertiesArgs', 'MailManagerRuleSetRuleCondition4PropertiesArgs', 'MailManagerRuleSetRuleCondition5PropertiesArgs']]]] conditions: The conditions of this rule. All conditions must match the email for the actions to be executed. An empty list of conditions means that all emails match, but are still subject to any "unless conditions"
        :param pulumi.Input[str] name: The user-friendly name of the rule.
        :param pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleCondition0PropertiesArgs', 'MailManagerRuleSetRuleCondition1PropertiesArgs', 'MailManagerRuleSetRuleCondition2PropertiesArgs', 'MailManagerRuleSetRuleCondition3PropertiesArgs', 'MailManagerRuleSetRuleCondition4PropertiesArgs', 'MailManagerRuleSetRuleCondition5PropertiesArgs']]]] unless: The "unless conditions" of this rule. None of the conditions can match the email for the actions to be executed. If any of these conditions do match the email, then the actions are not executed.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unless is not None:
            pulumi.set(__self__, "unless", unless)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleAction0PropertiesArgs', 'MailManagerRuleSetRuleAction1PropertiesArgs', 'MailManagerRuleSetRuleAction2PropertiesArgs', 'MailManagerRuleSetRuleAction3PropertiesArgs', 'MailManagerRuleSetRuleAction4PropertiesArgs', 'MailManagerRuleSetRuleAction5PropertiesArgs', 'MailManagerRuleSetRuleAction6PropertiesArgs', 'MailManagerRuleSetRuleAction7PropertiesArgs', 'MailManagerRuleSetRuleAction8PropertiesArgs']]]]:
        """
        The list of actions to execute when the conditions match the incoming email, and none of the "unless conditions" match.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleAction0PropertiesArgs', 'MailManagerRuleSetRuleAction1PropertiesArgs', 'MailManagerRuleSetRuleAction2PropertiesArgs', 'MailManagerRuleSetRuleAction3PropertiesArgs', 'MailManagerRuleSetRuleAction4PropertiesArgs', 'MailManagerRuleSetRuleAction5PropertiesArgs', 'MailManagerRuleSetRuleAction6PropertiesArgs', 'MailManagerRuleSetRuleAction7PropertiesArgs', 'MailManagerRuleSetRuleAction8PropertiesArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleCondition0PropertiesArgs', 'MailManagerRuleSetRuleCondition1PropertiesArgs', 'MailManagerRuleSetRuleCondition2PropertiesArgs', 'MailManagerRuleSetRuleCondition3PropertiesArgs', 'MailManagerRuleSetRuleCondition4PropertiesArgs', 'MailManagerRuleSetRuleCondition5PropertiesArgs']]]]]:
        """
        The conditions of this rule. All conditions must match the email for the actions to be executed. An empty list of conditions means that all emails match, but are still subject to any "unless conditions"
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleCondition0PropertiesArgs', 'MailManagerRuleSetRuleCondition1PropertiesArgs', 'MailManagerRuleSetRuleCondition2PropertiesArgs', 'MailManagerRuleSetRuleCondition3PropertiesArgs', 'MailManagerRuleSetRuleCondition4PropertiesArgs', 'MailManagerRuleSetRuleCondition5PropertiesArgs']]]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The user-friendly name of the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def unless(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleCondition0PropertiesArgs', 'MailManagerRuleSetRuleCondition1PropertiesArgs', 'MailManagerRuleSetRuleCondition2PropertiesArgs', 'MailManagerRuleSetRuleCondition3PropertiesArgs', 'MailManagerRuleSetRuleCondition4PropertiesArgs', 'MailManagerRuleSetRuleCondition5PropertiesArgs']]]]]:
        """
        The "unless conditions" of this rule. None of the conditions can match the email for the actions to be executed. If any of these conditions do match the email, then the actions are not executed.
        """
        return pulumi.get(self, "unless")

    @unless.setter
    def unless(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['MailManagerRuleSetRuleCondition0PropertiesArgs', 'MailManagerRuleSetRuleCondition1PropertiesArgs', 'MailManagerRuleSetRuleCondition2PropertiesArgs', 'MailManagerRuleSetRuleCondition3PropertiesArgs', 'MailManagerRuleSetRuleCondition4PropertiesArgs', 'MailManagerRuleSetRuleCondition5PropertiesArgs']]]]]):
        pulumi.set(self, "unless", value)


if not MYPY:
    class MailManagerRuleSetS3ActionArgsDict(TypedDict):
        role_arn: pulumi.Input[str]
        s3_bucket: pulumi.Input[str]
        action_failure_policy: NotRequired[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]
        s3_prefix: NotRequired[pulumi.Input[str]]
        s3_sse_kms_key_id: NotRequired[pulumi.Input[str]]
elif False:
    MailManagerRuleSetS3ActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetS3ActionArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 s3_bucket: pulumi.Input[str],
                 action_failure_policy: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']] = None,
                 s3_prefix: Optional[pulumi.Input[str]] = None,
                 s3_sse_kms_key_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "s3_bucket", s3_bucket)
        if action_failure_policy is not None:
            pulumi.set(__self__, "action_failure_policy", action_failure_policy)
        if s3_prefix is not None:
            pulumi.set(__self__, "s3_prefix", s3_prefix)
        if s3_sse_kms_key_id is not None:
            pulumi.set(__self__, "s3_sse_kms_key_id", s3_sse_kms_key_id)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket", value)

    @property
    @pulumi.getter(name="actionFailurePolicy")
    def action_failure_policy(self) -> Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]:
        return pulumi.get(self, "action_failure_policy")

    @action_failure_policy.setter
    def action_failure_policy(self, value: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]):
        pulumi.set(self, "action_failure_policy", value)

    @property
    @pulumi.getter(name="s3Prefix")
    def s3_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "s3_prefix")

    @s3_prefix.setter
    def s3_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_prefix", value)

    @property
    @pulumi.getter(name="s3SseKmsKeyId")
    def s3_sse_kms_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "s3_sse_kms_key_id")

    @s3_sse_kms_key_id.setter
    def s3_sse_kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_sse_kms_key_id", value)


if not MYPY:
    class MailManagerRuleSetSendActionArgsDict(TypedDict):
        role_arn: pulumi.Input[str]
        action_failure_policy: NotRequired[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]
elif False:
    MailManagerRuleSetSendActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerRuleSetSendActionArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 action_failure_policy: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        if action_failure_policy is not None:
            pulumi.set(__self__, "action_failure_policy", action_failure_policy)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="actionFailurePolicy")
    def action_failure_policy(self) -> Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]:
        return pulumi.get(self, "action_failure_policy")

    @action_failure_policy.setter
    def action_failure_policy(self, value: Optional[pulumi.Input['MailManagerRuleSetActionFailurePolicy']]):
        pulumi.set(self, "action_failure_policy", value)


if not MYPY:
    class MailManagerTrafficPolicyIngressAnalysisArgsDict(TypedDict):
        analyzer: pulumi.Input[str]
        result_field: pulumi.Input[str]
elif False:
    MailManagerTrafficPolicyIngressAnalysisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyIngressAnalysisArgs:
    def __init__(__self__, *,
                 analyzer: pulumi.Input[str],
                 result_field: pulumi.Input[str]):
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "result_field", result_field)

    @property
    @pulumi.getter
    def analyzer(self) -> pulumi.Input[str]:
        return pulumi.get(self, "analyzer")

    @analyzer.setter
    def analyzer(self, value: pulumi.Input[str]):
        pulumi.set(self, "analyzer", value)

    @property
    @pulumi.getter(name="resultField")
    def result_field(self) -> pulumi.Input[str]:
        return pulumi.get(self, "result_field")

    @result_field.setter
    def result_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "result_field", value)


if not MYPY:
    class MailManagerTrafficPolicyIngressBooleanExpressionArgsDict(TypedDict):
        evaluate: pulumi.Input['MailManagerTrafficPolicyIngressBooleanToEvaluatePropertiesArgsDict']
        operator: pulumi.Input['MailManagerTrafficPolicyIngressBooleanOperator']
elif False:
    MailManagerTrafficPolicyIngressBooleanExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyIngressBooleanExpressionArgs:
    def __init__(__self__, *,
                 evaluate: pulumi.Input['MailManagerTrafficPolicyIngressBooleanToEvaluatePropertiesArgs'],
                 operator: pulumi.Input['MailManagerTrafficPolicyIngressBooleanOperator']):
        pulumi.set(__self__, "evaluate", evaluate)
        pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def evaluate(self) -> pulumi.Input['MailManagerTrafficPolicyIngressBooleanToEvaluatePropertiesArgs']:
        return pulumi.get(self, "evaluate")

    @evaluate.setter
    def evaluate(self, value: pulumi.Input['MailManagerTrafficPolicyIngressBooleanToEvaluatePropertiesArgs']):
        pulumi.set(self, "evaluate", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['MailManagerTrafficPolicyIngressBooleanOperator']:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['MailManagerTrafficPolicyIngressBooleanOperator']):
        pulumi.set(self, "operator", value)


if not MYPY:
    class MailManagerTrafficPolicyIngressBooleanToEvaluatePropertiesArgsDict(TypedDict):
        analysis: pulumi.Input['MailManagerTrafficPolicyIngressAnalysisArgsDict']
elif False:
    MailManagerTrafficPolicyIngressBooleanToEvaluatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyIngressBooleanToEvaluatePropertiesArgs:
    def __init__(__self__, *,
                 analysis: pulumi.Input['MailManagerTrafficPolicyIngressAnalysisArgs']):
        pulumi.set(__self__, "analysis", analysis)

    @property
    @pulumi.getter
    def analysis(self) -> pulumi.Input['MailManagerTrafficPolicyIngressAnalysisArgs']:
        return pulumi.get(self, "analysis")

    @analysis.setter
    def analysis(self, value: pulumi.Input['MailManagerTrafficPolicyIngressAnalysisArgs']):
        pulumi.set(self, "analysis", value)


if not MYPY:
    class MailManagerTrafficPolicyIngressIpToEvaluatePropertiesArgsDict(TypedDict):
        attribute: pulumi.Input['MailManagerTrafficPolicyIngressIpv4Attribute']
elif False:
    MailManagerTrafficPolicyIngressIpToEvaluatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyIngressIpToEvaluatePropertiesArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input['MailManagerTrafficPolicyIngressIpv4Attribute']):
        pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def attribute(self) -> pulumi.Input['MailManagerTrafficPolicyIngressIpv4Attribute']:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input['MailManagerTrafficPolicyIngressIpv4Attribute']):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class MailManagerTrafficPolicyIngressIpv4ExpressionArgsDict(TypedDict):
        evaluate: pulumi.Input['MailManagerTrafficPolicyIngressIpToEvaluatePropertiesArgsDict']
        operator: pulumi.Input['MailManagerTrafficPolicyIngressIpOperator']
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    MailManagerTrafficPolicyIngressIpv4ExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyIngressIpv4ExpressionArgs:
    def __init__(__self__, *,
                 evaluate: pulumi.Input['MailManagerTrafficPolicyIngressIpToEvaluatePropertiesArgs'],
                 operator: pulumi.Input['MailManagerTrafficPolicyIngressIpOperator'],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "evaluate", evaluate)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def evaluate(self) -> pulumi.Input['MailManagerTrafficPolicyIngressIpToEvaluatePropertiesArgs']:
        return pulumi.get(self, "evaluate")

    @evaluate.setter
    def evaluate(self, value: pulumi.Input['MailManagerTrafficPolicyIngressIpToEvaluatePropertiesArgs']):
        pulumi.set(self, "evaluate", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['MailManagerTrafficPolicyIngressIpOperator']:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['MailManagerTrafficPolicyIngressIpOperator']):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MailManagerTrafficPolicyIngressStringExpressionArgsDict(TypedDict):
        evaluate: pulumi.Input['MailManagerTrafficPolicyIngressStringToEvaluatePropertiesArgsDict']
        operator: pulumi.Input['MailManagerTrafficPolicyIngressStringOperator']
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    MailManagerTrafficPolicyIngressStringExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyIngressStringExpressionArgs:
    def __init__(__self__, *,
                 evaluate: pulumi.Input['MailManagerTrafficPolicyIngressStringToEvaluatePropertiesArgs'],
                 operator: pulumi.Input['MailManagerTrafficPolicyIngressStringOperator'],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "evaluate", evaluate)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def evaluate(self) -> pulumi.Input['MailManagerTrafficPolicyIngressStringToEvaluatePropertiesArgs']:
        return pulumi.get(self, "evaluate")

    @evaluate.setter
    def evaluate(self, value: pulumi.Input['MailManagerTrafficPolicyIngressStringToEvaluatePropertiesArgs']):
        pulumi.set(self, "evaluate", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['MailManagerTrafficPolicyIngressStringOperator']:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['MailManagerTrafficPolicyIngressStringOperator']):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MailManagerTrafficPolicyIngressStringToEvaluatePropertiesArgsDict(TypedDict):
        attribute: pulumi.Input['MailManagerTrafficPolicyIngressStringEmailAttribute']
elif False:
    MailManagerTrafficPolicyIngressStringToEvaluatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyIngressStringToEvaluatePropertiesArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input['MailManagerTrafficPolicyIngressStringEmailAttribute']):
        pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def attribute(self) -> pulumi.Input['MailManagerTrafficPolicyIngressStringEmailAttribute']:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input['MailManagerTrafficPolicyIngressStringEmailAttribute']):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class MailManagerTrafficPolicyIngressTlsProtocolExpressionArgsDict(TypedDict):
        evaluate: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolToEvaluatePropertiesArgsDict']
        operator: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolOperator']
        value: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolAttribute']
elif False:
    MailManagerTrafficPolicyIngressTlsProtocolExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyIngressTlsProtocolExpressionArgs:
    def __init__(__self__, *,
                 evaluate: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolToEvaluatePropertiesArgs'],
                 operator: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolOperator'],
                 value: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolAttribute']):
        pulumi.set(__self__, "evaluate", evaluate)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def evaluate(self) -> pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolToEvaluatePropertiesArgs']:
        return pulumi.get(self, "evaluate")

    @evaluate.setter
    def evaluate(self, value: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolToEvaluatePropertiesArgs']):
        pulumi.set(self, "evaluate", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolOperator']:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolOperator']):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolAttribute']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolAttribute']):
        pulumi.set(self, "value", value)


if not MYPY:
    class MailManagerTrafficPolicyIngressTlsProtocolToEvaluatePropertiesArgsDict(TypedDict):
        attribute: pulumi.Input['MailManagerTrafficPolicyIngressTlsAttribute']
elif False:
    MailManagerTrafficPolicyIngressTlsProtocolToEvaluatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyIngressTlsProtocolToEvaluatePropertiesArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input['MailManagerTrafficPolicyIngressTlsAttribute']):
        pulumi.set(__self__, "attribute", attribute)

    @property
    @pulumi.getter
    def attribute(self) -> pulumi.Input['MailManagerTrafficPolicyIngressTlsAttribute']:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input['MailManagerTrafficPolicyIngressTlsAttribute']):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class MailManagerTrafficPolicyPolicyCondition0PropertiesArgsDict(TypedDict):
        string_expression: pulumi.Input['MailManagerTrafficPolicyIngressStringExpressionArgsDict']
elif False:
    MailManagerTrafficPolicyPolicyCondition0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyPolicyCondition0PropertiesArgs:
    def __init__(__self__, *,
                 string_expression: pulumi.Input['MailManagerTrafficPolicyIngressStringExpressionArgs']):
        pulumi.set(__self__, "string_expression", string_expression)

    @property
    @pulumi.getter(name="stringExpression")
    def string_expression(self) -> pulumi.Input['MailManagerTrafficPolicyIngressStringExpressionArgs']:
        return pulumi.get(self, "string_expression")

    @string_expression.setter
    def string_expression(self, value: pulumi.Input['MailManagerTrafficPolicyIngressStringExpressionArgs']):
        pulumi.set(self, "string_expression", value)


if not MYPY:
    class MailManagerTrafficPolicyPolicyCondition1PropertiesArgsDict(TypedDict):
        ip_expression: pulumi.Input['MailManagerTrafficPolicyIngressIpv4ExpressionArgsDict']
elif False:
    MailManagerTrafficPolicyPolicyCondition1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyPolicyCondition1PropertiesArgs:
    def __init__(__self__, *,
                 ip_expression: pulumi.Input['MailManagerTrafficPolicyIngressIpv4ExpressionArgs']):
        pulumi.set(__self__, "ip_expression", ip_expression)

    @property
    @pulumi.getter(name="ipExpression")
    def ip_expression(self) -> pulumi.Input['MailManagerTrafficPolicyIngressIpv4ExpressionArgs']:
        return pulumi.get(self, "ip_expression")

    @ip_expression.setter
    def ip_expression(self, value: pulumi.Input['MailManagerTrafficPolicyIngressIpv4ExpressionArgs']):
        pulumi.set(self, "ip_expression", value)


if not MYPY:
    class MailManagerTrafficPolicyPolicyCondition2PropertiesArgsDict(TypedDict):
        tls_expression: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolExpressionArgsDict']
elif False:
    MailManagerTrafficPolicyPolicyCondition2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyPolicyCondition2PropertiesArgs:
    def __init__(__self__, *,
                 tls_expression: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolExpressionArgs']):
        pulumi.set(__self__, "tls_expression", tls_expression)

    @property
    @pulumi.getter(name="tlsExpression")
    def tls_expression(self) -> pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolExpressionArgs']:
        return pulumi.get(self, "tls_expression")

    @tls_expression.setter
    def tls_expression(self, value: pulumi.Input['MailManagerTrafficPolicyIngressTlsProtocolExpressionArgs']):
        pulumi.set(self, "tls_expression", value)


if not MYPY:
    class MailManagerTrafficPolicyPolicyCondition3PropertiesArgsDict(TypedDict):
        boolean_expression: pulumi.Input['MailManagerTrafficPolicyIngressBooleanExpressionArgsDict']
elif False:
    MailManagerTrafficPolicyPolicyCondition3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyPolicyCondition3PropertiesArgs:
    def __init__(__self__, *,
                 boolean_expression: pulumi.Input['MailManagerTrafficPolicyIngressBooleanExpressionArgs']):
        pulumi.set(__self__, "boolean_expression", boolean_expression)

    @property
    @pulumi.getter(name="booleanExpression")
    def boolean_expression(self) -> pulumi.Input['MailManagerTrafficPolicyIngressBooleanExpressionArgs']:
        return pulumi.get(self, "boolean_expression")

    @boolean_expression.setter
    def boolean_expression(self, value: pulumi.Input['MailManagerTrafficPolicyIngressBooleanExpressionArgs']):
        pulumi.set(self, "boolean_expression", value)


if not MYPY:
    class MailManagerTrafficPolicyPolicyStatementArgsDict(TypedDict):
        action: pulumi.Input['MailManagerTrafficPolicyAcceptAction']
        """
        The action that informs a traffic policy resource to either allow or block the email if it matches a condition in the policy statement.
        """
        conditions: pulumi.Input[Sequence[pulumi.Input[Union['MailManagerTrafficPolicyPolicyCondition0PropertiesArgsDict', 'MailManagerTrafficPolicyPolicyCondition1PropertiesArgsDict', 'MailManagerTrafficPolicyPolicyCondition2PropertiesArgsDict', 'MailManagerTrafficPolicyPolicyCondition3PropertiesArgsDict']]]]
        """
        The list of conditions to apply to incoming messages for filtering email traffic.
        """
elif False:
    MailManagerTrafficPolicyPolicyStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MailManagerTrafficPolicyPolicyStatementArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['MailManagerTrafficPolicyAcceptAction'],
                 conditions: pulumi.Input[Sequence[pulumi.Input[Union['MailManagerTrafficPolicyPolicyCondition0PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition1PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition2PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition3PropertiesArgs']]]]):
        """
        :param pulumi.Input['MailManagerTrafficPolicyAcceptAction'] action: The action that informs a traffic policy resource to either allow or block the email if it matches a condition in the policy statement.
        :param pulumi.Input[Sequence[pulumi.Input[Union['MailManagerTrafficPolicyPolicyCondition0PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition1PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition2PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition3PropertiesArgs']]]] conditions: The list of conditions to apply to incoming messages for filtering email traffic.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['MailManagerTrafficPolicyAcceptAction']:
        """
        The action that informs a traffic policy resource to either allow or block the email if it matches a condition in the policy statement.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['MailManagerTrafficPolicyAcceptAction']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input[Union['MailManagerTrafficPolicyPolicyCondition0PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition1PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition2PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition3PropertiesArgs']]]]:
        """
        The list of conditions to apply to incoming messages for filtering email traffic.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input[Union['MailManagerTrafficPolicyPolicyCondition0PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition1PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition2PropertiesArgs', 'MailManagerTrafficPolicyPolicyCondition3PropertiesArgs']]]]):
        pulumi.set(self, "conditions", value)


if not MYPY:
    class TemplateArgsDict(TypedDict):
        """
        The content of the email, composed of a subject line, an HTML part, and a text-only part
        """
        subject_part: pulumi.Input[str]
        """
        The subject line of the email.
        """
        html_part: NotRequired[pulumi.Input[str]]
        """
        The HTML body of the email.
        """
        template_name: NotRequired[pulumi.Input[str]]
        """
        The name of the template.
        """
        text_part: NotRequired[pulumi.Input[str]]
        """
        The email body that is visible to recipients whose email clients do not display HTML content.
        """
elif False:
    TemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateArgs:
    def __init__(__self__, *,
                 subject_part: pulumi.Input[str],
                 html_part: Optional[pulumi.Input[str]] = None,
                 template_name: Optional[pulumi.Input[str]] = None,
                 text_part: Optional[pulumi.Input[str]] = None):
        """
        The content of the email, composed of a subject line, an HTML part, and a text-only part
        :param pulumi.Input[str] subject_part: The subject line of the email.
        :param pulumi.Input[str] html_part: The HTML body of the email.
        :param pulumi.Input[str] template_name: The name of the template.
        :param pulumi.Input[str] text_part: The email body that is visible to recipients whose email clients do not display HTML content.
        """
        pulumi.set(__self__, "subject_part", subject_part)
        if html_part is not None:
            pulumi.set(__self__, "html_part", html_part)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)
        if text_part is not None:
            pulumi.set(__self__, "text_part", text_part)

    @property
    @pulumi.getter(name="subjectPart")
    def subject_part(self) -> pulumi.Input[str]:
        """
        The subject line of the email.
        """
        return pulumi.get(self, "subject_part")

    @subject_part.setter
    def subject_part(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject_part", value)

    @property
    @pulumi.getter(name="htmlPart")
    def html_part(self) -> Optional[pulumi.Input[str]]:
        """
        The HTML body of the email.
        """
        return pulumi.get(self, "html_part")

    @html_part.setter
    def html_part(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "html_part", value)

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the template.
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template_name", value)

    @property
    @pulumi.getter(name="textPart")
    def text_part(self) -> Optional[pulumi.Input[str]]:
        """
        The email body that is visible to recipients whose email clients do not display HTML content.
        """
        return pulumi.get(self, "text_part")

    @text_part.setter
    def text_part(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_part", value)


if not MYPY:
    class VdmAttributesDashboardAttributesArgsDict(TypedDict):
        """
        Preferences regarding the Dashboard feature.
        """
        engagement_metrics: NotRequired[pulumi.Input[str]]
        """
        Whether emails sent from this account have engagement tracking enabled.
        """
elif False:
    VdmAttributesDashboardAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VdmAttributesDashboardAttributesArgs:
    def __init__(__self__, *,
                 engagement_metrics: Optional[pulumi.Input[str]] = None):
        """
        Preferences regarding the Dashboard feature.
        :param pulumi.Input[str] engagement_metrics: Whether emails sent from this account have engagement tracking enabled.
        """
        if engagement_metrics is not None:
            pulumi.set(__self__, "engagement_metrics", engagement_metrics)

    @property
    @pulumi.getter(name="engagementMetrics")
    def engagement_metrics(self) -> Optional[pulumi.Input[str]]:
        """
        Whether emails sent from this account have engagement tracking enabled.
        """
        return pulumi.get(self, "engagement_metrics")

    @engagement_metrics.setter
    def engagement_metrics(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "engagement_metrics", value)


if not MYPY:
    class VdmAttributesGuardianAttributesArgsDict(TypedDict):
        """
        Preferences regarding the Guardian feature.
        """
        optimized_shared_delivery: NotRequired[pulumi.Input[str]]
        """
        Whether emails sent from this account have optimized delivery algorithm enabled.
        """
elif False:
    VdmAttributesGuardianAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VdmAttributesGuardianAttributesArgs:
    def __init__(__self__, *,
                 optimized_shared_delivery: Optional[pulumi.Input[str]] = None):
        """
        Preferences regarding the Guardian feature.
        :param pulumi.Input[str] optimized_shared_delivery: Whether emails sent from this account have optimized delivery algorithm enabled.
        """
        if optimized_shared_delivery is not None:
            pulumi.set(__self__, "optimized_shared_delivery", optimized_shared_delivery)

    @property
    @pulumi.getter(name="optimizedSharedDelivery")
    def optimized_shared_delivery(self) -> Optional[pulumi.Input[str]]:
        """
        Whether emails sent from this account have optimized delivery algorithm enabled.
        """
        return pulumi.get(self, "optimized_shared_delivery")

    @optimized_shared_delivery.setter
    def optimized_shared_delivery(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "optimized_shared_delivery", value)


