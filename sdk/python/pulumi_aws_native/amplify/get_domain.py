# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'GetDomainResult',
    'AwaitableGetDomainResult',
    'get_domain',
    'get_domain_output',
]

@pulumi.output_type
class GetDomainResult:
    def __init__(__self__, arn=None, auto_sub_domain_creation_patterns=None, auto_sub_domain_iam_role=None, certificate=None, certificate_record=None, certificate_settings=None, domain_status=None, enable_auto_sub_domain=None, status_reason=None, sub_domain_settings=None, update_status=None):
        if arn and not isinstance(arn, str):
            raise TypeError("Expected argument 'arn' to be a str")
        pulumi.set(__self__, "arn", arn)
        if auto_sub_domain_creation_patterns and not isinstance(auto_sub_domain_creation_patterns, list):
            raise TypeError("Expected argument 'auto_sub_domain_creation_patterns' to be a list")
        pulumi.set(__self__, "auto_sub_domain_creation_patterns", auto_sub_domain_creation_patterns)
        if auto_sub_domain_iam_role and not isinstance(auto_sub_domain_iam_role, str):
            raise TypeError("Expected argument 'auto_sub_domain_iam_role' to be a str")
        pulumi.set(__self__, "auto_sub_domain_iam_role", auto_sub_domain_iam_role)
        if certificate and not isinstance(certificate, dict):
            raise TypeError("Expected argument 'certificate' to be a dict")
        pulumi.set(__self__, "certificate", certificate)
        if certificate_record and not isinstance(certificate_record, str):
            raise TypeError("Expected argument 'certificate_record' to be a str")
        pulumi.set(__self__, "certificate_record", certificate_record)
        if certificate_settings and not isinstance(certificate_settings, dict):
            raise TypeError("Expected argument 'certificate_settings' to be a dict")
        pulumi.set(__self__, "certificate_settings", certificate_settings)
        if domain_status and not isinstance(domain_status, str):
            raise TypeError("Expected argument 'domain_status' to be a str")
        pulumi.set(__self__, "domain_status", domain_status)
        if enable_auto_sub_domain and not isinstance(enable_auto_sub_domain, bool):
            raise TypeError("Expected argument 'enable_auto_sub_domain' to be a bool")
        pulumi.set(__self__, "enable_auto_sub_domain", enable_auto_sub_domain)
        if status_reason and not isinstance(status_reason, str):
            raise TypeError("Expected argument 'status_reason' to be a str")
        pulumi.set(__self__, "status_reason", status_reason)
        if sub_domain_settings and not isinstance(sub_domain_settings, list):
            raise TypeError("Expected argument 'sub_domain_settings' to be a list")
        pulumi.set(__self__, "sub_domain_settings", sub_domain_settings)
        if update_status and not isinstance(update_status, str):
            raise TypeError("Expected argument 'update_status' to be a str")
        pulumi.set(__self__, "update_status", update_status)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="autoSubDomainCreationPatterns")
    def auto_sub_domain_creation_patterns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "auto_sub_domain_creation_patterns")

    @property
    @pulumi.getter(name="autoSubDomainIamRole")
    def auto_sub_domain_iam_role(self) -> Optional[str]:
        return pulumi.get(self, "auto_sub_domain_iam_role")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.DomainCertificate']:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="certificateRecord")
    def certificate_record(self) -> Optional[str]:
        return pulumi.get(self, "certificate_record")

    @property
    @pulumi.getter(name="certificateSettings")
    def certificate_settings(self) -> Optional['outputs.DomainCertificateSettings']:
        return pulumi.get(self, "certificate_settings")

    @property
    @pulumi.getter(name="domainStatus")
    def domain_status(self) -> Optional[str]:
        return pulumi.get(self, "domain_status")

    @property
    @pulumi.getter(name="enableAutoSubDomain")
    def enable_auto_sub_domain(self) -> Optional[bool]:
        return pulumi.get(self, "enable_auto_sub_domain")

    @property
    @pulumi.getter(name="statusReason")
    def status_reason(self) -> Optional[str]:
        return pulumi.get(self, "status_reason")

    @property
    @pulumi.getter(name="subDomainSettings")
    def sub_domain_settings(self) -> Optional[Sequence['outputs.DomainSubDomainSetting']]:
        return pulumi.get(self, "sub_domain_settings")

    @property
    @pulumi.getter(name="updateStatus")
    def update_status(self) -> Optional[str]:
        return pulumi.get(self, "update_status")


class AwaitableGetDomainResult(GetDomainResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetDomainResult(
            arn=self.arn,
            auto_sub_domain_creation_patterns=self.auto_sub_domain_creation_patterns,
            auto_sub_domain_iam_role=self.auto_sub_domain_iam_role,
            certificate=self.certificate,
            certificate_record=self.certificate_record,
            certificate_settings=self.certificate_settings,
            domain_status=self.domain_status,
            enable_auto_sub_domain=self.enable_auto_sub_domain,
            status_reason=self.status_reason,
            sub_domain_settings=self.sub_domain_settings,
            update_status=self.update_status)


def get_domain(arn: Optional[str] = None,
               opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetDomainResult:
    """
    The AWS::Amplify::Domain resource allows you to connect a custom domain to your app.
    """
    __args__ = dict()
    __args__['arn'] = arn
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('aws-native:amplify:getDomain', __args__, opts=opts, typ=GetDomainResult).value

    return AwaitableGetDomainResult(
        arn=pulumi.get(__ret__, 'arn'),
        auto_sub_domain_creation_patterns=pulumi.get(__ret__, 'auto_sub_domain_creation_patterns'),
        auto_sub_domain_iam_role=pulumi.get(__ret__, 'auto_sub_domain_iam_role'),
        certificate=pulumi.get(__ret__, 'certificate'),
        certificate_record=pulumi.get(__ret__, 'certificate_record'),
        certificate_settings=pulumi.get(__ret__, 'certificate_settings'),
        domain_status=pulumi.get(__ret__, 'domain_status'),
        enable_auto_sub_domain=pulumi.get(__ret__, 'enable_auto_sub_domain'),
        status_reason=pulumi.get(__ret__, 'status_reason'),
        sub_domain_settings=pulumi.get(__ret__, 'sub_domain_settings'),
        update_status=pulumi.get(__ret__, 'update_status'))


@_utilities.lift_output_func(get_domain)
def get_domain_output(arn: Optional[pulumi.Input[str]] = None,
                      opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetDomainResult]:
    """
    The AWS::Amplify::Domain resource allows you to connect a custom domain to your app.
    """
    ...
