# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'PlanArcRoutingControlConfigurationArgs',
    'PlanArcRoutingControlConfigurationArgsDict',
    'PlanAsgArgs',
    'PlanAsgArgsDict',
    'PlanAssociatedAlarmArgs',
    'PlanAssociatedAlarmArgsDict',
    'PlanCustomActionLambdaConfigurationArgs',
    'PlanCustomActionLambdaConfigurationArgsDict',
    'PlanEc2AsgCapacityIncreaseConfigurationArgs',
    'PlanEc2AsgCapacityIncreaseConfigurationArgsDict',
    'PlanEc2UngracefulArgs',
    'PlanEc2UngracefulArgsDict',
    'PlanEcsCapacityIncreaseConfigurationArgs',
    'PlanEcsCapacityIncreaseConfigurationArgsDict',
    'PlanEcsUngracefulArgs',
    'PlanEcsUngracefulArgsDict',
    'PlanEksClusterArgs',
    'PlanEksClusterArgsDict',
    'PlanEksResourceScalingConfigurationArgs',
    'PlanEksResourceScalingConfigurationArgsDict',
    'PlanEksResourceScalingUngracefulArgs',
    'PlanEksResourceScalingUngracefulArgsDict',
    'PlanExecutionApprovalConfigurationArgs',
    'PlanExecutionApprovalConfigurationArgsDict',
    'PlanExecutionBlockConfiguration0PropertiesArgs',
    'PlanExecutionBlockConfiguration0PropertiesArgsDict',
    'PlanExecutionBlockConfiguration1PropertiesArgs',
    'PlanExecutionBlockConfiguration1PropertiesArgsDict',
    'PlanExecutionBlockConfiguration2PropertiesArgs',
    'PlanExecutionBlockConfiguration2PropertiesArgsDict',
    'PlanExecutionBlockConfiguration3PropertiesArgs',
    'PlanExecutionBlockConfiguration3PropertiesArgsDict',
    'PlanExecutionBlockConfiguration4PropertiesArgs',
    'PlanExecutionBlockConfiguration4PropertiesArgsDict',
    'PlanExecutionBlockConfiguration5PropertiesArgs',
    'PlanExecutionBlockConfiguration5PropertiesArgsDict',
    'PlanExecutionBlockConfiguration6PropertiesArgs',
    'PlanExecutionBlockConfiguration6PropertiesArgsDict',
    'PlanExecutionBlockConfiguration7PropertiesArgs',
    'PlanExecutionBlockConfiguration7PropertiesArgsDict',
    'PlanExecutionBlockConfiguration8PropertiesArgs',
    'PlanExecutionBlockConfiguration8PropertiesArgsDict',
    'PlanExecutionBlockConfiguration9PropertiesArgs',
    'PlanExecutionBlockConfiguration9PropertiesArgsDict',
    'PlanGlobalAuroraConfigurationArgs',
    'PlanGlobalAuroraConfigurationArgsDict',
    'PlanGlobalAuroraUngracefulArgs',
    'PlanGlobalAuroraUngracefulArgsDict',
    'PlanKubernetesResourceTypeArgs',
    'PlanKubernetesResourceTypeArgsDict',
    'PlanLambdaUngracefulArgs',
    'PlanLambdaUngracefulArgsDict',
    'PlanLambdasArgs',
    'PlanLambdasArgsDict',
    'PlanParallelExecutionBlockConfigurationArgs',
    'PlanParallelExecutionBlockConfigurationArgsDict',
    'PlanRegionSwitchPlanConfigurationArgs',
    'PlanRegionSwitchPlanConfigurationArgsDict',
    'PlanRoute53HealthCheckConfigurationArgs',
    'PlanRoute53HealthCheckConfigurationArgsDict',
    'PlanRoute53ResourceRecordSetArgs',
    'PlanRoute53ResourceRecordSetArgsDict',
    'PlanServiceArgs',
    'PlanServiceArgsDict',
    'PlanStepArgs',
    'PlanStepArgsDict',
    'PlanTriggerConditionArgs',
    'PlanTriggerConditionArgsDict',
    'PlanTriggerArgs',
    'PlanTriggerArgsDict',
    'PlanWorkflowArgs',
    'PlanWorkflowArgsDict',
]

MYPY = False

if not MYPY:
    class PlanArcRoutingControlConfigurationArgsDict(TypedDict):
        region_and_routing_controls: pulumi.Input[Mapping[str, Any]]
        cross_account_role: NotRequired[pulumi.Input[builtins.str]]
        external_id: NotRequired[pulumi.Input[builtins.str]]
        timeout_minutes: NotRequired[pulumi.Input[builtins.float]]
elif False:
    PlanArcRoutingControlConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanArcRoutingControlConfigurationArgs:
    def __init__(__self__, *,
                 region_and_routing_controls: pulumi.Input[Mapping[str, Any]],
                 cross_account_role: Optional[pulumi.Input[builtins.str]] = None,
                 external_id: Optional[pulumi.Input[builtins.str]] = None,
                 timeout_minutes: Optional[pulumi.Input[builtins.float]] = None):
        pulumi.set(__self__, "region_and_routing_controls", region_and_routing_controls)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @property
    @pulumi.getter(name="regionAndRoutingControls")
    def region_and_routing_controls(self) -> pulumi.Input[Mapping[str, Any]]:
        return pulumi.get(self, "region_and_routing_controls")

    @region_and_routing_controls.setter
    def region_and_routing_controls(self, value: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(self, "region_and_routing_controls", value)

    @property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "timeout_minutes", value)


if not MYPY:
    class PlanAsgArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[builtins.str]]
        cross_account_role: NotRequired[pulumi.Input[builtins.str]]
        external_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    PlanAsgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanAsgArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[builtins.str]] = None,
                 cross_account_role: Optional[pulumi.Input[builtins.str]] = None,
                 external_id: Optional[pulumi.Input[builtins.str]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanAssociatedAlarmArgsDict(TypedDict):
        alarm_type: pulumi.Input['PlanAlarmType']
        """
        The alarm type for an associated alarm. An associated CloudWatch alarm can be an application health alarm or a trigger alarm.
        """
        resource_identifier: pulumi.Input[builtins.str]
        """
        The resource identifier for alarms that you associate with a plan.
        """
        cross_account_role: NotRequired[pulumi.Input[builtins.str]]
        """
        The cross account role for the configuration.
        """
        external_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The external ID (secret key) for the configuration.
        """
elif False:
    PlanAssociatedAlarmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanAssociatedAlarmArgs:
    def __init__(__self__, *,
                 alarm_type: pulumi.Input['PlanAlarmType'],
                 resource_identifier: pulumi.Input[builtins.str],
                 cross_account_role: Optional[pulumi.Input[builtins.str]] = None,
                 external_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['PlanAlarmType'] alarm_type: The alarm type for an associated alarm. An associated CloudWatch alarm can be an application health alarm or a trigger alarm.
        :param pulumi.Input[builtins.str] resource_identifier: The resource identifier for alarms that you associate with a plan.
        :param pulumi.Input[builtins.str] cross_account_role: The cross account role for the configuration.
        :param pulumi.Input[builtins.str] external_id: The external ID (secret key) for the configuration.
        """
        pulumi.set(__self__, "alarm_type", alarm_type)
        pulumi.set(__self__, "resource_identifier", resource_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter(name="alarmType")
    def alarm_type(self) -> pulumi.Input['PlanAlarmType']:
        """
        The alarm type for an associated alarm. An associated CloudWatch alarm can be an application health alarm or a trigger alarm.
        """
        return pulumi.get(self, "alarm_type")

    @alarm_type.setter
    def alarm_type(self, value: pulumi.Input['PlanAlarmType']):
        pulumi.set(self, "alarm_type", value)

    @property
    @pulumi.getter(name="resourceIdentifier")
    def resource_identifier(self) -> pulumi.Input[builtins.str]:
        """
        The resource identifier for alarms that you associate with a plan.
        """
        return pulumi.get(self, "resource_identifier")

    @resource_identifier.setter
    def resource_identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_identifier", value)

    @property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The cross account role for the configuration.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The external ID (secret key) for the configuration.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanCustomActionLambdaConfigurationArgsDict(TypedDict):
        lambdas: pulumi.Input[Sequence[pulumi.Input['PlanLambdasArgsDict']]]
        region_to_run: pulumi.Input['PlanRegionToRunIn']
        retry_interval_minutes: pulumi.Input[builtins.float]
        timeout_minutes: NotRequired[pulumi.Input[builtins.float]]
        ungraceful: NotRequired[pulumi.Input['PlanLambdaUngracefulArgsDict']]
elif False:
    PlanCustomActionLambdaConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanCustomActionLambdaConfigurationArgs:
    def __init__(__self__, *,
                 lambdas: pulumi.Input[Sequence[pulumi.Input['PlanLambdasArgs']]],
                 region_to_run: pulumi.Input['PlanRegionToRunIn'],
                 retry_interval_minutes: pulumi.Input[builtins.float],
                 timeout_minutes: Optional[pulumi.Input[builtins.float]] = None,
                 ungraceful: Optional[pulumi.Input['PlanLambdaUngracefulArgs']] = None):
        pulumi.set(__self__, "lambdas", lambdas)
        pulumi.set(__self__, "region_to_run", region_to_run)
        pulumi.set(__self__, "retry_interval_minutes", retry_interval_minutes)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @property
    @pulumi.getter
    def lambdas(self) -> pulumi.Input[Sequence[pulumi.Input['PlanLambdasArgs']]]:
        return pulumi.get(self, "lambdas")

    @lambdas.setter
    def lambdas(self, value: pulumi.Input[Sequence[pulumi.Input['PlanLambdasArgs']]]):
        pulumi.set(self, "lambdas", value)

    @property
    @pulumi.getter(name="regionToRun")
    def region_to_run(self) -> pulumi.Input['PlanRegionToRunIn']:
        return pulumi.get(self, "region_to_run")

    @region_to_run.setter
    def region_to_run(self, value: pulumi.Input['PlanRegionToRunIn']):
        pulumi.set(self, "region_to_run", value)

    @property
    @pulumi.getter(name="retryIntervalMinutes")
    def retry_interval_minutes(self) -> pulumi.Input[builtins.float]:
        return pulumi.get(self, "retry_interval_minutes")

    @retry_interval_minutes.setter
    def retry_interval_minutes(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "retry_interval_minutes", value)

    @property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "timeout_minutes", value)

    @property
    @pulumi.getter
    def ungraceful(self) -> Optional[pulumi.Input['PlanLambdaUngracefulArgs']]:
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: Optional[pulumi.Input['PlanLambdaUngracefulArgs']]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanEc2AsgCapacityIncreaseConfigurationArgsDict(TypedDict):
        asgs: pulumi.Input[Sequence[pulumi.Input['PlanAsgArgsDict']]]
        capacity_monitoring_approach: NotRequired[Any]
        target_percent: NotRequired[pulumi.Input[builtins.float]]
        timeout_minutes: NotRequired[pulumi.Input[builtins.float]]
        ungraceful: NotRequired[pulumi.Input['PlanEc2UngracefulArgsDict']]
elif False:
    PlanEc2AsgCapacityIncreaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanEc2AsgCapacityIncreaseConfigurationArgs:
    def __init__(__self__, *,
                 asgs: pulumi.Input[Sequence[pulumi.Input['PlanAsgArgs']]],
                 capacity_monitoring_approach: Optional[Any] = None,
                 target_percent: Optional[pulumi.Input[builtins.float]] = None,
                 timeout_minutes: Optional[pulumi.Input[builtins.float]] = None,
                 ungraceful: Optional[pulumi.Input['PlanEc2UngracefulArgs']] = None):
        pulumi.set(__self__, "asgs", asgs)
        if capacity_monitoring_approach is not None:
            pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @property
    @pulumi.getter
    def asgs(self) -> pulumi.Input[Sequence[pulumi.Input['PlanAsgArgs']]]:
        return pulumi.get(self, "asgs")

    @asgs.setter
    def asgs(self, value: pulumi.Input[Sequence[pulumi.Input['PlanAsgArgs']]]):
        pulumi.set(self, "asgs", value)

    @property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> Optional[Any]:
        return pulumi.get(self, "capacity_monitoring_approach")

    @capacity_monitoring_approach.setter
    def capacity_monitoring_approach(self, value: Optional[Any]):
        pulumi.set(self, "capacity_monitoring_approach", value)

    @property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "target_percent")

    @target_percent.setter
    def target_percent(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "target_percent", value)

    @property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "timeout_minutes", value)

    @property
    @pulumi.getter
    def ungraceful(self) -> Optional[pulumi.Input['PlanEc2UngracefulArgs']]:
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: Optional[pulumi.Input['PlanEc2UngracefulArgs']]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanEc2UngracefulArgsDict(TypedDict):
        minimum_success_percentage: pulumi.Input[builtins.float]
elif False:
    PlanEc2UngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanEc2UngracefulArgs:
    def __init__(__self__, *,
                 minimum_success_percentage: pulumi.Input[builtins.float]):
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> pulumi.Input[builtins.float]:
        return pulumi.get(self, "minimum_success_percentage")

    @minimum_success_percentage.setter
    def minimum_success_percentage(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "minimum_success_percentage", value)


if not MYPY:
    class PlanEcsCapacityIncreaseConfigurationArgsDict(TypedDict):
        services: pulumi.Input[Sequence[pulumi.Input['PlanServiceArgsDict']]]
        capacity_monitoring_approach: NotRequired[Any]
        target_percent: NotRequired[pulumi.Input[builtins.float]]
        timeout_minutes: NotRequired[pulumi.Input[builtins.float]]
        ungraceful: NotRequired[pulumi.Input['PlanEcsUngracefulArgsDict']]
elif False:
    PlanEcsCapacityIncreaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanEcsCapacityIncreaseConfigurationArgs:
    def __init__(__self__, *,
                 services: pulumi.Input[Sequence[pulumi.Input['PlanServiceArgs']]],
                 capacity_monitoring_approach: Optional[Any] = None,
                 target_percent: Optional[pulumi.Input[builtins.float]] = None,
                 timeout_minutes: Optional[pulumi.Input[builtins.float]] = None,
                 ungraceful: Optional[pulumi.Input['PlanEcsUngracefulArgs']] = None):
        pulumi.set(__self__, "services", services)
        if capacity_monitoring_approach is not None:
            pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @property
    @pulumi.getter
    def services(self) -> pulumi.Input[Sequence[pulumi.Input['PlanServiceArgs']]]:
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: pulumi.Input[Sequence[pulumi.Input['PlanServiceArgs']]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> Optional[Any]:
        return pulumi.get(self, "capacity_monitoring_approach")

    @capacity_monitoring_approach.setter
    def capacity_monitoring_approach(self, value: Optional[Any]):
        pulumi.set(self, "capacity_monitoring_approach", value)

    @property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "target_percent")

    @target_percent.setter
    def target_percent(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "target_percent", value)

    @property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "timeout_minutes", value)

    @property
    @pulumi.getter
    def ungraceful(self) -> Optional[pulumi.Input['PlanEcsUngracefulArgs']]:
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: Optional[pulumi.Input['PlanEcsUngracefulArgs']]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanEcsUngracefulArgsDict(TypedDict):
        minimum_success_percentage: pulumi.Input[builtins.float]
elif False:
    PlanEcsUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanEcsUngracefulArgs:
    def __init__(__self__, *,
                 minimum_success_percentage: pulumi.Input[builtins.float]):
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> pulumi.Input[builtins.float]:
        return pulumi.get(self, "minimum_success_percentage")

    @minimum_success_percentage.setter
    def minimum_success_percentage(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "minimum_success_percentage", value)


if not MYPY:
    class PlanEksClusterArgsDict(TypedDict):
        cluster_arn: pulumi.Input[builtins.str]
        cross_account_role: NotRequired[pulumi.Input[builtins.str]]
        external_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    PlanEksClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanEksClusterArgs:
    def __init__(__self__, *,
                 cluster_arn: pulumi.Input[builtins.str],
                 cross_account_role: Optional[pulumi.Input[builtins.str]] = None,
                 external_id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "cluster_arn")

    @cluster_arn.setter
    def cluster_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cluster_arn", value)

    @property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanEksResourceScalingConfigurationArgsDict(TypedDict):
        kubernetes_resource_type: pulumi.Input['PlanKubernetesResourceTypeArgsDict']
        capacity_monitoring_approach: NotRequired[Any]
        eks_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanEksClusterArgsDict']]]]
        scaling_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]
        target_percent: NotRequired[pulumi.Input[builtins.float]]
        timeout_minutes: NotRequired[pulumi.Input[builtins.float]]
        ungraceful: NotRequired[pulumi.Input['PlanEksResourceScalingUngracefulArgsDict']]
elif False:
    PlanEksResourceScalingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanEksResourceScalingConfigurationArgs:
    def __init__(__self__, *,
                 kubernetes_resource_type: pulumi.Input['PlanKubernetesResourceTypeArgs'],
                 capacity_monitoring_approach: Optional[Any] = None,
                 eks_clusters: Optional[pulumi.Input[Sequence[pulumi.Input['PlanEksClusterArgs']]]] = None,
                 scaling_resources: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None,
                 target_percent: Optional[pulumi.Input[builtins.float]] = None,
                 timeout_minutes: Optional[pulumi.Input[builtins.float]] = None,
                 ungraceful: Optional[pulumi.Input['PlanEksResourceScalingUngracefulArgs']] = None):
        pulumi.set(__self__, "kubernetes_resource_type", kubernetes_resource_type)
        if capacity_monitoring_approach is not None:
            pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if eks_clusters is not None:
            pulumi.set(__self__, "eks_clusters", eks_clusters)
        if scaling_resources is not None:
            pulumi.set(__self__, "scaling_resources", scaling_resources)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @property
    @pulumi.getter(name="kubernetesResourceType")
    def kubernetes_resource_type(self) -> pulumi.Input['PlanKubernetesResourceTypeArgs']:
        return pulumi.get(self, "kubernetes_resource_type")

    @kubernetes_resource_type.setter
    def kubernetes_resource_type(self, value: pulumi.Input['PlanKubernetesResourceTypeArgs']):
        pulumi.set(self, "kubernetes_resource_type", value)

    @property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> Optional[Any]:
        return pulumi.get(self, "capacity_monitoring_approach")

    @capacity_monitoring_approach.setter
    def capacity_monitoring_approach(self, value: Optional[Any]):
        pulumi.set(self, "capacity_monitoring_approach", value)

    @property
    @pulumi.getter(name="eksClusters")
    def eks_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanEksClusterArgs']]]]:
        return pulumi.get(self, "eks_clusters")

    @eks_clusters.setter
    def eks_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanEksClusterArgs']]]]):
        pulumi.set(self, "eks_clusters", value)

    @property
    @pulumi.getter(name="scalingResources")
    def scaling_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        return pulumi.get(self, "scaling_resources")

    @scaling_resources.setter
    def scaling_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "scaling_resources", value)

    @property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "target_percent")

    @target_percent.setter
    def target_percent(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "target_percent", value)

    @property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "timeout_minutes", value)

    @property
    @pulumi.getter
    def ungraceful(self) -> Optional[pulumi.Input['PlanEksResourceScalingUngracefulArgs']]:
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: Optional[pulumi.Input['PlanEksResourceScalingUngracefulArgs']]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanEksResourceScalingUngracefulArgsDict(TypedDict):
        minimum_success_percentage: pulumi.Input[builtins.float]
elif False:
    PlanEksResourceScalingUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanEksResourceScalingUngracefulArgs:
    def __init__(__self__, *,
                 minimum_success_percentage: pulumi.Input[builtins.float]):
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> pulumi.Input[builtins.float]:
        return pulumi.get(self, "minimum_success_percentage")

    @minimum_success_percentage.setter
    def minimum_success_percentage(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "minimum_success_percentage", value)


if not MYPY:
    class PlanExecutionApprovalConfigurationArgsDict(TypedDict):
        approval_role: pulumi.Input[builtins.str]
        timeout_minutes: NotRequired[pulumi.Input[builtins.float]]
elif False:
    PlanExecutionApprovalConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanExecutionApprovalConfigurationArgs:
    def __init__(__self__, *,
                 approval_role: pulumi.Input[builtins.str],
                 timeout_minutes: Optional[pulumi.Input[builtins.float]] = None):
        pulumi.set(__self__, "approval_role", approval_role)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @property
    @pulumi.getter(name="approvalRole")
    def approval_role(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "approval_role")

    @approval_role.setter
    def approval_role(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "approval_role", value)

    @property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "timeout_minutes", value)


if not MYPY:
    class PlanExecutionBlockConfiguration0PropertiesArgsDict(TypedDict):
        custom_action_lambda_config: pulumi.Input['PlanCustomActionLambdaConfigurationArgsDict']
elif False:
    PlanExecutionBlockConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanExecutionBlockConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 custom_action_lambda_config: pulumi.Input['PlanCustomActionLambdaConfigurationArgs']):
        pulumi.set(__self__, "custom_action_lambda_config", custom_action_lambda_config)

    @property
    @pulumi.getter(name="customActionLambdaConfig")
    def custom_action_lambda_config(self) -> pulumi.Input['PlanCustomActionLambdaConfigurationArgs']:
        return pulumi.get(self, "custom_action_lambda_config")

    @custom_action_lambda_config.setter
    def custom_action_lambda_config(self, value: pulumi.Input['PlanCustomActionLambdaConfigurationArgs']):
        pulumi.set(self, "custom_action_lambda_config", value)


if not MYPY:
    class PlanExecutionBlockConfiguration1PropertiesArgsDict(TypedDict):
        ec2_asg_capacity_increase_config: pulumi.Input['PlanEc2AsgCapacityIncreaseConfigurationArgsDict']
elif False:
    PlanExecutionBlockConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanExecutionBlockConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 ec2_asg_capacity_increase_config: pulumi.Input['PlanEc2AsgCapacityIncreaseConfigurationArgs']):
        pulumi.set(__self__, "ec2_asg_capacity_increase_config", ec2_asg_capacity_increase_config)

    @property
    @pulumi.getter(name="ec2AsgCapacityIncreaseConfig")
    def ec2_asg_capacity_increase_config(self) -> pulumi.Input['PlanEc2AsgCapacityIncreaseConfigurationArgs']:
        return pulumi.get(self, "ec2_asg_capacity_increase_config")

    @ec2_asg_capacity_increase_config.setter
    def ec2_asg_capacity_increase_config(self, value: pulumi.Input['PlanEc2AsgCapacityIncreaseConfigurationArgs']):
        pulumi.set(self, "ec2_asg_capacity_increase_config", value)


if not MYPY:
    class PlanExecutionBlockConfiguration2PropertiesArgsDict(TypedDict):
        execution_approval_config: pulumi.Input['PlanExecutionApprovalConfigurationArgsDict']
elif False:
    PlanExecutionBlockConfiguration2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanExecutionBlockConfiguration2PropertiesArgs:
    def __init__(__self__, *,
                 execution_approval_config: pulumi.Input['PlanExecutionApprovalConfigurationArgs']):
        pulumi.set(__self__, "execution_approval_config", execution_approval_config)

    @property
    @pulumi.getter(name="executionApprovalConfig")
    def execution_approval_config(self) -> pulumi.Input['PlanExecutionApprovalConfigurationArgs']:
        return pulumi.get(self, "execution_approval_config")

    @execution_approval_config.setter
    def execution_approval_config(self, value: pulumi.Input['PlanExecutionApprovalConfigurationArgs']):
        pulumi.set(self, "execution_approval_config", value)


if not MYPY:
    class PlanExecutionBlockConfiguration3PropertiesArgsDict(TypedDict):
        arc_routing_control_config: pulumi.Input['PlanArcRoutingControlConfigurationArgsDict']
elif False:
    PlanExecutionBlockConfiguration3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanExecutionBlockConfiguration3PropertiesArgs:
    def __init__(__self__, *,
                 arc_routing_control_config: pulumi.Input['PlanArcRoutingControlConfigurationArgs']):
        pulumi.set(__self__, "arc_routing_control_config", arc_routing_control_config)

    @property
    @pulumi.getter(name="arcRoutingControlConfig")
    def arc_routing_control_config(self) -> pulumi.Input['PlanArcRoutingControlConfigurationArgs']:
        return pulumi.get(self, "arc_routing_control_config")

    @arc_routing_control_config.setter
    def arc_routing_control_config(self, value: pulumi.Input['PlanArcRoutingControlConfigurationArgs']):
        pulumi.set(self, "arc_routing_control_config", value)


if not MYPY:
    class PlanExecutionBlockConfiguration4PropertiesArgsDict(TypedDict):
        global_aurora_config: pulumi.Input['PlanGlobalAuroraConfigurationArgsDict']
elif False:
    PlanExecutionBlockConfiguration4PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanExecutionBlockConfiguration4PropertiesArgs:
    def __init__(__self__, *,
                 global_aurora_config: pulumi.Input['PlanGlobalAuroraConfigurationArgs']):
        pulumi.set(__self__, "global_aurora_config", global_aurora_config)

    @property
    @pulumi.getter(name="globalAuroraConfig")
    def global_aurora_config(self) -> pulumi.Input['PlanGlobalAuroraConfigurationArgs']:
        return pulumi.get(self, "global_aurora_config")

    @global_aurora_config.setter
    def global_aurora_config(self, value: pulumi.Input['PlanGlobalAuroraConfigurationArgs']):
        pulumi.set(self, "global_aurora_config", value)


if not MYPY:
    class PlanExecutionBlockConfiguration5PropertiesArgsDict(TypedDict):
        parallel_config: pulumi.Input['PlanParallelExecutionBlockConfigurationArgsDict']
elif False:
    PlanExecutionBlockConfiguration5PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanExecutionBlockConfiguration5PropertiesArgs:
    def __init__(__self__, *,
                 parallel_config: pulumi.Input['PlanParallelExecutionBlockConfigurationArgs']):
        pulumi.set(__self__, "parallel_config", parallel_config)

    @property
    @pulumi.getter(name="parallelConfig")
    def parallel_config(self) -> pulumi.Input['PlanParallelExecutionBlockConfigurationArgs']:
        return pulumi.get(self, "parallel_config")

    @parallel_config.setter
    def parallel_config(self, value: pulumi.Input['PlanParallelExecutionBlockConfigurationArgs']):
        pulumi.set(self, "parallel_config", value)


if not MYPY:
    class PlanExecutionBlockConfiguration6PropertiesArgsDict(TypedDict):
        region_switch_plan_config: pulumi.Input['PlanRegionSwitchPlanConfigurationArgsDict']
elif False:
    PlanExecutionBlockConfiguration6PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanExecutionBlockConfiguration6PropertiesArgs:
    def __init__(__self__, *,
                 region_switch_plan_config: pulumi.Input['PlanRegionSwitchPlanConfigurationArgs']):
        pulumi.set(__self__, "region_switch_plan_config", region_switch_plan_config)

    @property
    @pulumi.getter(name="regionSwitchPlanConfig")
    def region_switch_plan_config(self) -> pulumi.Input['PlanRegionSwitchPlanConfigurationArgs']:
        return pulumi.get(self, "region_switch_plan_config")

    @region_switch_plan_config.setter
    def region_switch_plan_config(self, value: pulumi.Input['PlanRegionSwitchPlanConfigurationArgs']):
        pulumi.set(self, "region_switch_plan_config", value)


if not MYPY:
    class PlanExecutionBlockConfiguration7PropertiesArgsDict(TypedDict):
        ecs_capacity_increase_config: pulumi.Input['PlanEcsCapacityIncreaseConfigurationArgsDict']
elif False:
    PlanExecutionBlockConfiguration7PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanExecutionBlockConfiguration7PropertiesArgs:
    def __init__(__self__, *,
                 ecs_capacity_increase_config: pulumi.Input['PlanEcsCapacityIncreaseConfigurationArgs']):
        pulumi.set(__self__, "ecs_capacity_increase_config", ecs_capacity_increase_config)

    @property
    @pulumi.getter(name="ecsCapacityIncreaseConfig")
    def ecs_capacity_increase_config(self) -> pulumi.Input['PlanEcsCapacityIncreaseConfigurationArgs']:
        return pulumi.get(self, "ecs_capacity_increase_config")

    @ecs_capacity_increase_config.setter
    def ecs_capacity_increase_config(self, value: pulumi.Input['PlanEcsCapacityIncreaseConfigurationArgs']):
        pulumi.set(self, "ecs_capacity_increase_config", value)


if not MYPY:
    class PlanExecutionBlockConfiguration8PropertiesArgsDict(TypedDict):
        eks_resource_scaling_config: pulumi.Input['PlanEksResourceScalingConfigurationArgsDict']
elif False:
    PlanExecutionBlockConfiguration8PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanExecutionBlockConfiguration8PropertiesArgs:
    def __init__(__self__, *,
                 eks_resource_scaling_config: pulumi.Input['PlanEksResourceScalingConfigurationArgs']):
        pulumi.set(__self__, "eks_resource_scaling_config", eks_resource_scaling_config)

    @property
    @pulumi.getter(name="eksResourceScalingConfig")
    def eks_resource_scaling_config(self) -> pulumi.Input['PlanEksResourceScalingConfigurationArgs']:
        return pulumi.get(self, "eks_resource_scaling_config")

    @eks_resource_scaling_config.setter
    def eks_resource_scaling_config(self, value: pulumi.Input['PlanEksResourceScalingConfigurationArgs']):
        pulumi.set(self, "eks_resource_scaling_config", value)


if not MYPY:
    class PlanExecutionBlockConfiguration9PropertiesArgsDict(TypedDict):
        route53_health_check_config: pulumi.Input['PlanRoute53HealthCheckConfigurationArgsDict']
elif False:
    PlanExecutionBlockConfiguration9PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanExecutionBlockConfiguration9PropertiesArgs:
    def __init__(__self__, *,
                 route53_health_check_config: pulumi.Input['PlanRoute53HealthCheckConfigurationArgs']):
        pulumi.set(__self__, "route53_health_check_config", route53_health_check_config)

    @property
    @pulumi.getter(name="route53HealthCheckConfig")
    def route53_health_check_config(self) -> pulumi.Input['PlanRoute53HealthCheckConfigurationArgs']:
        return pulumi.get(self, "route53_health_check_config")

    @route53_health_check_config.setter
    def route53_health_check_config(self, value: pulumi.Input['PlanRoute53HealthCheckConfigurationArgs']):
        pulumi.set(self, "route53_health_check_config", value)


if not MYPY:
    class PlanGlobalAuroraConfigurationArgsDict(TypedDict):
        behavior: Any
        database_cluster_arns: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        global_cluster_identifier: pulumi.Input[builtins.str]
        cross_account_role: NotRequired[pulumi.Input[builtins.str]]
        external_id: NotRequired[pulumi.Input[builtins.str]]
        timeout_minutes: NotRequired[pulumi.Input[builtins.float]]
        ungraceful: NotRequired[pulumi.Input['PlanGlobalAuroraUngracefulArgsDict']]
elif False:
    PlanGlobalAuroraConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanGlobalAuroraConfigurationArgs:
    def __init__(__self__, *,
                 behavior: Any,
                 database_cluster_arns: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 global_cluster_identifier: pulumi.Input[builtins.str],
                 cross_account_role: Optional[pulumi.Input[builtins.str]] = None,
                 external_id: Optional[pulumi.Input[builtins.str]] = None,
                 timeout_minutes: Optional[pulumi.Input[builtins.float]] = None,
                 ungraceful: Optional[pulumi.Input['PlanGlobalAuroraUngracefulArgs']] = None):
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "database_cluster_arns", database_cluster_arns)
        pulumi.set(__self__, "global_cluster_identifier", global_cluster_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @property
    @pulumi.getter
    def behavior(self) -> Any:
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: Any):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter(name="databaseClusterArns")
    def database_cluster_arns(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "database_cluster_arns")

    @database_cluster_arns.setter
    def database_cluster_arns(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "database_cluster_arns", value)

    @property
    @pulumi.getter(name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "global_cluster_identifier")

    @global_cluster_identifier.setter
    def global_cluster_identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "global_cluster_identifier", value)

    @property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "timeout_minutes", value)

    @property
    @pulumi.getter
    def ungraceful(self) -> Optional[pulumi.Input['PlanGlobalAuroraUngracefulArgs']]:
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: Optional[pulumi.Input['PlanGlobalAuroraUngracefulArgs']]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanGlobalAuroraUngracefulArgsDict(TypedDict):
        ungraceful: NotRequired[pulumi.Input['PlanGlobalAuroraUngracefulBehavior']]
elif False:
    PlanGlobalAuroraUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanGlobalAuroraUngracefulArgs:
    def __init__(__self__, *,
                 ungraceful: Optional[pulumi.Input['PlanGlobalAuroraUngracefulBehavior']] = None):
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @property
    @pulumi.getter
    def ungraceful(self) -> Optional[pulumi.Input['PlanGlobalAuroraUngracefulBehavior']]:
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: Optional[pulumi.Input['PlanGlobalAuroraUngracefulBehavior']]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanKubernetesResourceTypeArgsDict(TypedDict):
        api_version: pulumi.Input[builtins.str]
        kind: pulumi.Input[builtins.str]
elif False:
    PlanKubernetesResourceTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanKubernetesResourceTypeArgs:
    def __init__(__self__, *,
                 api_version: pulumi.Input[builtins.str],
                 kind: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class PlanLambdaUngracefulArgsDict(TypedDict):
        behavior: NotRequired[Any]
elif False:
    PlanLambdaUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanLambdaUngracefulArgs:
    def __init__(__self__, *,
                 behavior: Optional[Any] = None):
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)

    @property
    @pulumi.getter
    def behavior(self) -> Optional[Any]:
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: Optional[Any]):
        pulumi.set(self, "behavior", value)


if not MYPY:
    class PlanLambdasArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[builtins.str]]
        cross_account_role: NotRequired[pulumi.Input[builtins.str]]
        external_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    PlanLambdasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanLambdasArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[builtins.str]] = None,
                 cross_account_role: Optional[pulumi.Input[builtins.str]] = None,
                 external_id: Optional[pulumi.Input[builtins.str]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanParallelExecutionBlockConfigurationArgsDict(TypedDict):
        steps: pulumi.Input[Sequence[pulumi.Input['PlanStepArgsDict']]]
elif False:
    PlanParallelExecutionBlockConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanParallelExecutionBlockConfigurationArgs:
    def __init__(__self__, *,
                 steps: pulumi.Input[Sequence[pulumi.Input['PlanStepArgs']]]):
        pulumi.set(__self__, "steps", steps)

    @property
    @pulumi.getter
    def steps(self) -> pulumi.Input[Sequence[pulumi.Input['PlanStepArgs']]]:
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: pulumi.Input[Sequence[pulumi.Input['PlanStepArgs']]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class PlanRegionSwitchPlanConfigurationArgsDict(TypedDict):
        arn: pulumi.Input[builtins.str]
        cross_account_role: NotRequired[pulumi.Input[builtins.str]]
        external_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    PlanRegionSwitchPlanConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanRegionSwitchPlanConfigurationArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[builtins.str],
                 cross_account_role: Optional[pulumi.Input[builtins.str]] = None,
                 external_id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanRoute53HealthCheckConfigurationArgsDict(TypedDict):
        hosted_zone_id: pulumi.Input[builtins.str]
        record_name: pulumi.Input[builtins.str]
        cross_account_role: NotRequired[pulumi.Input[builtins.str]]
        external_id: NotRequired[pulumi.Input[builtins.str]]
        record_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanRoute53ResourceRecordSetArgsDict']]]]
        timeout_minutes: NotRequired[pulumi.Input[builtins.float]]
elif False:
    PlanRoute53HealthCheckConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanRoute53HealthCheckConfigurationArgs:
    def __init__(__self__, *,
                 hosted_zone_id: pulumi.Input[builtins.str],
                 record_name: pulumi.Input[builtins.str],
                 cross_account_role: Optional[pulumi.Input[builtins.str]] = None,
                 external_id: Optional[pulumi.Input[builtins.str]] = None,
                 record_sets: Optional[pulumi.Input[Sequence[pulumi.Input['PlanRoute53ResourceRecordSetArgs']]]] = None,
                 timeout_minutes: Optional[pulumi.Input[builtins.float]] = None):
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        pulumi.set(__self__, "record_name", record_name)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if record_sets is not None:
            pulumi.set(__self__, "record_sets", record_sets)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "hosted_zone_id", value)

    @property
    @pulumi.getter(name="recordName")
    def record_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "record_name")

    @record_name.setter
    def record_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "record_name", value)

    @property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="recordSets")
    def record_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanRoute53ResourceRecordSetArgs']]]]:
        return pulumi.get(self, "record_sets")

    @record_sets.setter
    def record_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanRoute53ResourceRecordSetArgs']]]]):
        pulumi.set(self, "record_sets", value)

    @property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "timeout_minutes", value)


if not MYPY:
    class PlanRoute53ResourceRecordSetArgsDict(TypedDict):
        record_set_identifier: NotRequired[pulumi.Input[builtins.str]]
        region: NotRequired[pulumi.Input[builtins.str]]
elif False:
    PlanRoute53ResourceRecordSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanRoute53ResourceRecordSetArgs:
    def __init__(__self__, *,
                 record_set_identifier: Optional[pulumi.Input[builtins.str]] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None):
        if record_set_identifier is not None:
            pulumi.set(__self__, "record_set_identifier", record_set_identifier)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="recordSetIdentifier")
    def record_set_identifier(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "record_set_identifier")

    @record_set_identifier.setter
    def record_set_identifier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "record_set_identifier", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class PlanServiceArgsDict(TypedDict):
        cluster_arn: NotRequired[pulumi.Input[builtins.str]]
        cross_account_role: NotRequired[pulumi.Input[builtins.str]]
        external_id: NotRequired[pulumi.Input[builtins.str]]
        service_arn: NotRequired[pulumi.Input[builtins.str]]
elif False:
    PlanServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanServiceArgs:
    def __init__(__self__, *,
                 cluster_arn: Optional[pulumi.Input[builtins.str]] = None,
                 cross_account_role: Optional[pulumi.Input[builtins.str]] = None,
                 external_id: Optional[pulumi.Input[builtins.str]] = None,
                 service_arn: Optional[pulumi.Input[builtins.str]] = None):
        if cluster_arn is not None:
            pulumi.set(__self__, "cluster_arn", cluster_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if service_arn is not None:
            pulumi.set(__self__, "service_arn", service_arn)

    @property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cluster_arn")

    @cluster_arn.setter
    def cluster_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_arn", value)

    @property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="serviceArn")
    def service_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "service_arn")

    @service_arn.setter
    def service_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_arn", value)


if not MYPY:
    class PlanStepArgsDict(TypedDict):
        execution_block_configuration: pulumi.Input[Union['PlanExecutionBlockConfiguration0PropertiesArgsDict', 'PlanExecutionBlockConfiguration1PropertiesArgsDict', 'PlanExecutionBlockConfiguration2PropertiesArgsDict', 'PlanExecutionBlockConfiguration3PropertiesArgsDict', 'PlanExecutionBlockConfiguration4PropertiesArgsDict', 'PlanExecutionBlockConfiguration5PropertiesArgsDict', 'PlanExecutionBlockConfiguration6PropertiesArgsDict', 'PlanExecutionBlockConfiguration7PropertiesArgsDict', 'PlanExecutionBlockConfiguration8PropertiesArgsDict', 'PlanExecutionBlockConfiguration9PropertiesArgsDict']]
        """
        The configuration for an execution block in a workflow.
        """
        execution_block_type: pulumi.Input['PlanExecutionBlockType']
        """
        The type of an execution block in a workflow.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of a step in a workflow.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of a step in a workflow.
        """
elif False:
    PlanStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanStepArgs:
    def __init__(__self__, *,
                 execution_block_configuration: pulumi.Input[Union['PlanExecutionBlockConfiguration0PropertiesArgs', 'PlanExecutionBlockConfiguration1PropertiesArgs', 'PlanExecutionBlockConfiguration2PropertiesArgs', 'PlanExecutionBlockConfiguration3PropertiesArgs', 'PlanExecutionBlockConfiguration4PropertiesArgs', 'PlanExecutionBlockConfiguration5PropertiesArgs', 'PlanExecutionBlockConfiguration6PropertiesArgs', 'PlanExecutionBlockConfiguration7PropertiesArgs', 'PlanExecutionBlockConfiguration8PropertiesArgs', 'PlanExecutionBlockConfiguration9PropertiesArgs']],
                 execution_block_type: pulumi.Input['PlanExecutionBlockType'],
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Union['PlanExecutionBlockConfiguration0PropertiesArgs', 'PlanExecutionBlockConfiguration1PropertiesArgs', 'PlanExecutionBlockConfiguration2PropertiesArgs', 'PlanExecutionBlockConfiguration3PropertiesArgs', 'PlanExecutionBlockConfiguration4PropertiesArgs', 'PlanExecutionBlockConfiguration5PropertiesArgs', 'PlanExecutionBlockConfiguration6PropertiesArgs', 'PlanExecutionBlockConfiguration7PropertiesArgs', 'PlanExecutionBlockConfiguration8PropertiesArgs', 'PlanExecutionBlockConfiguration9PropertiesArgs']] execution_block_configuration: The configuration for an execution block in a workflow.
        :param pulumi.Input['PlanExecutionBlockType'] execution_block_type: The type of an execution block in a workflow.
        :param pulumi.Input[builtins.str] name: The name of a step in a workflow.
        :param pulumi.Input[builtins.str] description: The description of a step in a workflow.
        """
        pulumi.set(__self__, "execution_block_configuration", execution_block_configuration)
        pulumi.set(__self__, "execution_block_type", execution_block_type)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="executionBlockConfiguration")
    def execution_block_configuration(self) -> pulumi.Input[Union['PlanExecutionBlockConfiguration0PropertiesArgs', 'PlanExecutionBlockConfiguration1PropertiesArgs', 'PlanExecutionBlockConfiguration2PropertiesArgs', 'PlanExecutionBlockConfiguration3PropertiesArgs', 'PlanExecutionBlockConfiguration4PropertiesArgs', 'PlanExecutionBlockConfiguration5PropertiesArgs', 'PlanExecutionBlockConfiguration6PropertiesArgs', 'PlanExecutionBlockConfiguration7PropertiesArgs', 'PlanExecutionBlockConfiguration8PropertiesArgs', 'PlanExecutionBlockConfiguration9PropertiesArgs']]:
        """
        The configuration for an execution block in a workflow.
        """
        return pulumi.get(self, "execution_block_configuration")

    @execution_block_configuration.setter
    def execution_block_configuration(self, value: pulumi.Input[Union['PlanExecutionBlockConfiguration0PropertiesArgs', 'PlanExecutionBlockConfiguration1PropertiesArgs', 'PlanExecutionBlockConfiguration2PropertiesArgs', 'PlanExecutionBlockConfiguration3PropertiesArgs', 'PlanExecutionBlockConfiguration4PropertiesArgs', 'PlanExecutionBlockConfiguration5PropertiesArgs', 'PlanExecutionBlockConfiguration6PropertiesArgs', 'PlanExecutionBlockConfiguration7PropertiesArgs', 'PlanExecutionBlockConfiguration8PropertiesArgs', 'PlanExecutionBlockConfiguration9PropertiesArgs']]):
        pulumi.set(self, "execution_block_configuration", value)

    @property
    @pulumi.getter(name="executionBlockType")
    def execution_block_type(self) -> pulumi.Input['PlanExecutionBlockType']:
        """
        The type of an execution block in a workflow.
        """
        return pulumi.get(self, "execution_block_type")

    @execution_block_type.setter
    def execution_block_type(self, value: pulumi.Input['PlanExecutionBlockType']):
        pulumi.set(self, "execution_block_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of a step in a workflow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of a step in a workflow.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class PlanTriggerConditionArgsDict(TypedDict):
        associated_alarm_name: pulumi.Input[builtins.str]
        """
        The name of the CloudWatch alarm associated with the condition.
        """
        condition: pulumi.Input['PlanAlarmCondition']
        """
        The condition that must be met. Valid values include ALARM and OK.
        """
elif False:
    PlanTriggerConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanTriggerConditionArgs:
    def __init__(__self__, *,
                 associated_alarm_name: pulumi.Input[builtins.str],
                 condition: pulumi.Input['PlanAlarmCondition']):
        """
        :param pulumi.Input[builtins.str] associated_alarm_name: The name of the CloudWatch alarm associated with the condition.
        :param pulumi.Input['PlanAlarmCondition'] condition: The condition that must be met. Valid values include ALARM and OK.
        """
        pulumi.set(__self__, "associated_alarm_name", associated_alarm_name)
        pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter(name="associatedAlarmName")
    def associated_alarm_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the CloudWatch alarm associated with the condition.
        """
        return pulumi.get(self, "associated_alarm_name")

    @associated_alarm_name.setter
    def associated_alarm_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "associated_alarm_name", value)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input['PlanAlarmCondition']:
        """
        The condition that must be met. Valid values include ALARM and OK.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['PlanAlarmCondition']):
        pulumi.set(self, "condition", value)


if not MYPY:
    class PlanTriggerArgsDict(TypedDict):
        action: pulumi.Input['PlanWorkflowTargetAction']
        """
        The action to perform when the trigger fires. Valid values include ACTIVATE and DEACTIVATE.
        """
        conditions: pulumi.Input[Sequence[pulumi.Input['PlanTriggerConditionArgsDict']]]
        """
        The conditions that must be met for the trigger to fire.
        """
        min_delay_minutes_between_executions: pulumi.Input[builtins.float]
        """
        The minimum time, in minutes, that must elapse between automatic executions of the plan.
        """
        target_region: pulumi.Input[builtins.str]
        """
        The AWS Region for a trigger.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description for a trigger.
        """
elif False:
    PlanTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanTriggerArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['PlanWorkflowTargetAction'],
                 conditions: pulumi.Input[Sequence[pulumi.Input['PlanTriggerConditionArgs']]],
                 min_delay_minutes_between_executions: pulumi.Input[builtins.float],
                 target_region: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['PlanWorkflowTargetAction'] action: The action to perform when the trigger fires. Valid values include ACTIVATE and DEACTIVATE.
        :param pulumi.Input[Sequence[pulumi.Input['PlanTriggerConditionArgs']]] conditions: The conditions that must be met for the trigger to fire.
        :param pulumi.Input[builtins.float] min_delay_minutes_between_executions: The minimum time, in minutes, that must elapse between automatic executions of the plan.
        :param pulumi.Input[builtins.str] target_region: The AWS Region for a trigger.
        :param pulumi.Input[builtins.str] description: The description for a trigger.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "min_delay_minutes_between_executions", min_delay_minutes_between_executions)
        pulumi.set(__self__, "target_region", target_region)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['PlanWorkflowTargetAction']:
        """
        The action to perform when the trigger fires. Valid values include ACTIVATE and DEACTIVATE.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['PlanWorkflowTargetAction']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['PlanTriggerConditionArgs']]]:
        """
        The conditions that must be met for the trigger to fire.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['PlanTriggerConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="minDelayMinutesBetweenExecutions")
    def min_delay_minutes_between_executions(self) -> pulumi.Input[builtins.float]:
        """
        The minimum time, in minutes, that must elapse between automatic executions of the plan.
        """
        return pulumi.get(self, "min_delay_minutes_between_executions")

    @min_delay_minutes_between_executions.setter
    def min_delay_minutes_between_executions(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "min_delay_minutes_between_executions", value)

    @property
    @pulumi.getter(name="targetRegion")
    def target_region(self) -> pulumi.Input[builtins.str]:
        """
        The AWS Region for a trigger.
        """
        return pulumi.get(self, "target_region")

    @target_region.setter
    def target_region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target_region", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description for a trigger.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class PlanWorkflowArgsDict(TypedDict):
        workflow_target_action: pulumi.Input['PlanWorkflowTargetAction']
        """
        The action that the workflow performs. Valid values include ACTIVATE and DEACTIVATE.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanStepArgsDict']]]]
        """
        The steps that make up the workflow.
        """
        workflow_description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the workflow.
        """
        workflow_target_region: NotRequired[pulumi.Input[builtins.str]]
        """
        The AWS Region that the workflow targets.
        """
elif False:
    PlanWorkflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowArgs:
    def __init__(__self__, *,
                 workflow_target_action: pulumi.Input['PlanWorkflowTargetAction'],
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['PlanStepArgs']]]] = None,
                 workflow_description: Optional[pulumi.Input[builtins.str]] = None,
                 workflow_target_region: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['PlanWorkflowTargetAction'] workflow_target_action: The action that the workflow performs. Valid values include ACTIVATE and DEACTIVATE.
        :param pulumi.Input[Sequence[pulumi.Input['PlanStepArgs']]] steps: The steps that make up the workflow.
        :param pulumi.Input[builtins.str] workflow_description: The description of the workflow.
        :param pulumi.Input[builtins.str] workflow_target_region: The AWS Region that the workflow targets.
        """
        pulumi.set(__self__, "workflow_target_action", workflow_target_action)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)
        if workflow_description is not None:
            pulumi.set(__self__, "workflow_description", workflow_description)
        if workflow_target_region is not None:
            pulumi.set(__self__, "workflow_target_region", workflow_target_region)

    @property
    @pulumi.getter(name="workflowTargetAction")
    def workflow_target_action(self) -> pulumi.Input['PlanWorkflowTargetAction']:
        """
        The action that the workflow performs. Valid values include ACTIVATE and DEACTIVATE.
        """
        return pulumi.get(self, "workflow_target_action")

    @workflow_target_action.setter
    def workflow_target_action(self, value: pulumi.Input['PlanWorkflowTargetAction']):
        pulumi.set(self, "workflow_target_action", value)

    @property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanStepArgs']]]]:
        """
        The steps that make up the workflow.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanStepArgs']]]]):
        pulumi.set(self, "steps", value)

    @property
    @pulumi.getter(name="workflowDescription")
    def workflow_description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the workflow.
        """
        return pulumi.get(self, "workflow_description")

    @workflow_description.setter
    def workflow_description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "workflow_description", value)

    @property
    @pulumi.getter(name="workflowTargetRegion")
    def workflow_target_region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The AWS Region that the workflow targets.
        """
        return pulumi.get(self, "workflow_target_region")

    @workflow_target_region.setter
    def workflow_target_region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "workflow_target_region", value)


