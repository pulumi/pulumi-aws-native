# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'PlanArcRoutingControlConfiguration',
    'PlanAsg',
    'PlanAssociatedAlarm',
    'PlanCustomActionLambdaConfiguration',
    'PlanEc2AsgCapacityIncreaseConfiguration',
    'PlanEc2Ungraceful',
    'PlanEcsCapacityIncreaseConfiguration',
    'PlanEcsUngraceful',
    'PlanEksCluster',
    'PlanEksResourceScalingConfiguration',
    'PlanEksResourceScalingUngraceful',
    'PlanExecutionApprovalConfiguration',
    'PlanExecutionBlockConfiguration0Properties',
    'PlanExecutionBlockConfiguration1Properties',
    'PlanExecutionBlockConfiguration2Properties',
    'PlanExecutionBlockConfiguration3Properties',
    'PlanExecutionBlockConfiguration4Properties',
    'PlanExecutionBlockConfiguration5Properties',
    'PlanExecutionBlockConfiguration6Properties',
    'PlanExecutionBlockConfiguration7Properties',
    'PlanExecutionBlockConfiguration8Properties',
    'PlanExecutionBlockConfiguration9Properties',
    'PlanGlobalAuroraConfiguration',
    'PlanGlobalAuroraUngraceful',
    'PlanHealthCheckState',
    'PlanKubernetesResourceType',
    'PlanLambdaUngraceful',
    'PlanLambdas',
    'PlanParallelExecutionBlockConfiguration',
    'PlanRegionSwitchPlanConfiguration',
    'PlanRoute53HealthCheckConfiguration',
    'PlanRoute53ResourceRecordSet',
    'PlanService',
    'PlanStep',
    'PlanTrigger',
    'PlanTriggerCondition',
    'PlanWorkflow',
    'Route53HealthChecksProperties',
]

@pulumi.output_type
class PlanArcRoutingControlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionAndRoutingControls":
            suggest = "region_and_routing_controls"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanArcRoutingControlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanArcRoutingControlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanArcRoutingControlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_and_routing_controls: Mapping[str, Any],
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 timeout_minutes: Optional[_builtins.float] = None):
        pulumi.set(__self__, "region_and_routing_controls", region_and_routing_controls)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="regionAndRoutingControls")
    def region_and_routing_controls(self) -> Mapping[str, Any]:
        return pulumi.get(self, "region_and_routing_controls")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "timeout_minutes")


@pulumi.output_type
class PlanAsg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanAsg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanAsg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanAsg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanAssociatedAlarm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmType":
            suggest = "alarm_type"
        elif key == "resourceIdentifier":
            suggest = "resource_identifier"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanAssociatedAlarm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanAssociatedAlarm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanAssociatedAlarm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_type: 'PlanAlarmType',
                 resource_identifier: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param 'PlanAlarmType' alarm_type: The alarm type for an associated alarm. An associated CloudWatch alarm can be an application health alarm or a trigger alarm.
        :param _builtins.str resource_identifier: The resource identifier for alarms that you associate with a plan.
        :param _builtins.str cross_account_role: The cross account role for the configuration.
        :param _builtins.str external_id: The external ID (secret key) for the configuration.
        """
        pulumi.set(__self__, "alarm_type", alarm_type)
        pulumi.set(__self__, "resource_identifier", resource_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="alarmType")
    def alarm_type(self) -> 'PlanAlarmType':
        """
        The alarm type for an associated alarm. An associated CloudWatch alarm can be an application health alarm or a trigger alarm.
        """
        return pulumi.get(self, "alarm_type")

    @_builtins.property
    @pulumi.getter(name="resourceIdentifier")
    def resource_identifier(self) -> _builtins.str:
        """
        The resource identifier for alarms that you associate with a plan.
        """
        return pulumi.get(self, "resource_identifier")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        The cross account role for the configuration.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        The external ID (secret key) for the configuration.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanCustomActionLambdaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionToRun":
            suggest = "region_to_run"
        elif key == "retryIntervalMinutes":
            suggest = "retry_interval_minutes"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanCustomActionLambdaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanCustomActionLambdaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanCustomActionLambdaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambdas: Sequence['outputs.PlanLambdas'],
                 region_to_run: 'PlanRegionToRunIn',
                 retry_interval_minutes: _builtins.float,
                 timeout_minutes: Optional[_builtins.float] = None,
                 ungraceful: Optional['outputs.PlanLambdaUngraceful'] = None):
        pulumi.set(__self__, "lambdas", lambdas)
        pulumi.set(__self__, "region_to_run", region_to_run)
        pulumi.set(__self__, "retry_interval_minutes", retry_interval_minutes)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def lambdas(self) -> Sequence['outputs.PlanLambdas']:
        return pulumi.get(self, "lambdas")

    @_builtins.property
    @pulumi.getter(name="regionToRun")
    def region_to_run(self) -> 'PlanRegionToRunIn':
        return pulumi.get(self, "region_to_run")

    @_builtins.property
    @pulumi.getter(name="retryIntervalMinutes")
    def retry_interval_minutes(self) -> _builtins.float:
        return pulumi.get(self, "retry_interval_minutes")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional['outputs.PlanLambdaUngraceful']:
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanEc2AsgCapacityIncreaseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityMonitoringApproach":
            suggest = "capacity_monitoring_approach"
        elif key == "targetPercent":
            suggest = "target_percent"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanEc2AsgCapacityIncreaseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanEc2AsgCapacityIncreaseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanEc2AsgCapacityIncreaseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asgs: Sequence['outputs.PlanAsg'],
                 capacity_monitoring_approach: Optional[Any] = None,
                 target_percent: Optional[_builtins.float] = None,
                 timeout_minutes: Optional[_builtins.float] = None,
                 ungraceful: Optional['outputs.PlanEc2Ungraceful'] = None):
        pulumi.set(__self__, "asgs", asgs)
        if capacity_monitoring_approach is not None:
            pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def asgs(self) -> Sequence['outputs.PlanAsg']:
        return pulumi.get(self, "asgs")

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> Optional[Any]:
        return pulumi.get(self, "capacity_monitoring_approach")

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "target_percent")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional['outputs.PlanEc2Ungraceful']:
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanEc2Ungraceful(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumSuccessPercentage":
            suggest = "minimum_success_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanEc2Ungraceful. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanEc2Ungraceful.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanEc2Ungraceful.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_success_percentage: _builtins.float):
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> _builtins.float:
        return pulumi.get(self, "minimum_success_percentage")


@pulumi.output_type
class PlanEcsCapacityIncreaseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityMonitoringApproach":
            suggest = "capacity_monitoring_approach"
        elif key == "targetPercent":
            suggest = "target_percent"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanEcsCapacityIncreaseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanEcsCapacityIncreaseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanEcsCapacityIncreaseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 services: Sequence['outputs.PlanService'],
                 capacity_monitoring_approach: Optional[Any] = None,
                 target_percent: Optional[_builtins.float] = None,
                 timeout_minutes: Optional[_builtins.float] = None,
                 ungraceful: Optional['outputs.PlanEcsUngraceful'] = None):
        pulumi.set(__self__, "services", services)
        if capacity_monitoring_approach is not None:
            pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Sequence['outputs.PlanService']:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> Optional[Any]:
        return pulumi.get(self, "capacity_monitoring_approach")

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "target_percent")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional['outputs.PlanEcsUngraceful']:
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanEcsUngraceful(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumSuccessPercentage":
            suggest = "minimum_success_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanEcsUngraceful. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanEcsUngraceful.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanEcsUngraceful.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_success_percentage: _builtins.float):
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> _builtins.float:
        return pulumi.get(self, "minimum_success_percentage")


@pulumi.output_type
class PlanEksCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterArn":
            suggest = "cluster_arn"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanEksCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanEksCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanEksCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> _builtins.str:
        return pulumi.get(self, "cluster_arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanEksResourceScalingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubernetesResourceType":
            suggest = "kubernetes_resource_type"
        elif key == "capacityMonitoringApproach":
            suggest = "capacity_monitoring_approach"
        elif key == "eksClusters":
            suggest = "eks_clusters"
        elif key == "scalingResources":
            suggest = "scaling_resources"
        elif key == "targetPercent":
            suggest = "target_percent"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanEksResourceScalingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanEksResourceScalingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanEksResourceScalingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kubernetes_resource_type: 'outputs.PlanKubernetesResourceType',
                 capacity_monitoring_approach: Optional[Any] = None,
                 eks_clusters: Optional[Sequence['outputs.PlanEksCluster']] = None,
                 scaling_resources: Optional[Sequence[Mapping[str, Any]]] = None,
                 target_percent: Optional[_builtins.float] = None,
                 timeout_minutes: Optional[_builtins.float] = None,
                 ungraceful: Optional['outputs.PlanEksResourceScalingUngraceful'] = None):
        pulumi.set(__self__, "kubernetes_resource_type", kubernetes_resource_type)
        if capacity_monitoring_approach is not None:
            pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if eks_clusters is not None:
            pulumi.set(__self__, "eks_clusters", eks_clusters)
        if scaling_resources is not None:
            pulumi.set(__self__, "scaling_resources", scaling_resources)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter(name="kubernetesResourceType")
    def kubernetes_resource_type(self) -> 'outputs.PlanKubernetesResourceType':
        return pulumi.get(self, "kubernetes_resource_type")

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> Optional[Any]:
        return pulumi.get(self, "capacity_monitoring_approach")

    @_builtins.property
    @pulumi.getter(name="eksClusters")
    def eks_clusters(self) -> Optional[Sequence['outputs.PlanEksCluster']]:
        return pulumi.get(self, "eks_clusters")

    @_builtins.property
    @pulumi.getter(name="scalingResources")
    def scaling_resources(self) -> Optional[Sequence[Mapping[str, Any]]]:
        return pulumi.get(self, "scaling_resources")

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "target_percent")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional['outputs.PlanEksResourceScalingUngraceful']:
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanEksResourceScalingUngraceful(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumSuccessPercentage":
            suggest = "minimum_success_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanEksResourceScalingUngraceful. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanEksResourceScalingUngraceful.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanEksResourceScalingUngraceful.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_success_percentage: _builtins.float):
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> _builtins.float:
        return pulumi.get(self, "minimum_success_percentage")


@pulumi.output_type
class PlanExecutionApprovalConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvalRole":
            suggest = "approval_role"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanExecutionApprovalConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanExecutionApprovalConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanExecutionApprovalConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approval_role: _builtins.str,
                 timeout_minutes: Optional[_builtins.float] = None):
        pulumi.set(__self__, "approval_role", approval_role)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="approvalRole")
    def approval_role(self) -> _builtins.str:
        return pulumi.get(self, "approval_role")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "timeout_minutes")


@pulumi.output_type
class PlanExecutionBlockConfiguration0Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionLambdaConfig":
            suggest = "custom_action_lambda_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanExecutionBlockConfiguration0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanExecutionBlockConfiguration0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanExecutionBlockConfiguration0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_lambda_config: 'outputs.PlanCustomActionLambdaConfiguration'):
        pulumi.set(__self__, "custom_action_lambda_config", custom_action_lambda_config)

    @_builtins.property
    @pulumi.getter(name="customActionLambdaConfig")
    def custom_action_lambda_config(self) -> 'outputs.PlanCustomActionLambdaConfiguration':
        return pulumi.get(self, "custom_action_lambda_config")


@pulumi.output_type
class PlanExecutionBlockConfiguration1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ec2AsgCapacityIncreaseConfig":
            suggest = "ec2_asg_capacity_increase_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanExecutionBlockConfiguration1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanExecutionBlockConfiguration1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanExecutionBlockConfiguration1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ec2_asg_capacity_increase_config: 'outputs.PlanEc2AsgCapacityIncreaseConfiguration'):
        pulumi.set(__self__, "ec2_asg_capacity_increase_config", ec2_asg_capacity_increase_config)

    @_builtins.property
    @pulumi.getter(name="ec2AsgCapacityIncreaseConfig")
    def ec2_asg_capacity_increase_config(self) -> 'outputs.PlanEc2AsgCapacityIncreaseConfiguration':
        return pulumi.get(self, "ec2_asg_capacity_increase_config")


@pulumi.output_type
class PlanExecutionBlockConfiguration2Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionApprovalConfig":
            suggest = "execution_approval_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanExecutionBlockConfiguration2Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanExecutionBlockConfiguration2Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanExecutionBlockConfiguration2Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_approval_config: 'outputs.PlanExecutionApprovalConfiguration'):
        pulumi.set(__self__, "execution_approval_config", execution_approval_config)

    @_builtins.property
    @pulumi.getter(name="executionApprovalConfig")
    def execution_approval_config(self) -> 'outputs.PlanExecutionApprovalConfiguration':
        return pulumi.get(self, "execution_approval_config")


@pulumi.output_type
class PlanExecutionBlockConfiguration3Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arcRoutingControlConfig":
            suggest = "arc_routing_control_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanExecutionBlockConfiguration3Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanExecutionBlockConfiguration3Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanExecutionBlockConfiguration3Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arc_routing_control_config: 'outputs.PlanArcRoutingControlConfiguration'):
        pulumi.set(__self__, "arc_routing_control_config", arc_routing_control_config)

    @_builtins.property
    @pulumi.getter(name="arcRoutingControlConfig")
    def arc_routing_control_config(self) -> 'outputs.PlanArcRoutingControlConfiguration':
        return pulumi.get(self, "arc_routing_control_config")


@pulumi.output_type
class PlanExecutionBlockConfiguration4Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "globalAuroraConfig":
            suggest = "global_aurora_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanExecutionBlockConfiguration4Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanExecutionBlockConfiguration4Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanExecutionBlockConfiguration4Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_aurora_config: 'outputs.PlanGlobalAuroraConfiguration'):
        pulumi.set(__self__, "global_aurora_config", global_aurora_config)

    @_builtins.property
    @pulumi.getter(name="globalAuroraConfig")
    def global_aurora_config(self) -> 'outputs.PlanGlobalAuroraConfiguration':
        return pulumi.get(self, "global_aurora_config")


@pulumi.output_type
class PlanExecutionBlockConfiguration5Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parallelConfig":
            suggest = "parallel_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanExecutionBlockConfiguration5Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanExecutionBlockConfiguration5Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanExecutionBlockConfiguration5Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parallel_config: 'outputs.PlanParallelExecutionBlockConfiguration'):
        pulumi.set(__self__, "parallel_config", parallel_config)

    @_builtins.property
    @pulumi.getter(name="parallelConfig")
    def parallel_config(self) -> 'outputs.PlanParallelExecutionBlockConfiguration':
        return pulumi.get(self, "parallel_config")


@pulumi.output_type
class PlanExecutionBlockConfiguration6Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionSwitchPlanConfig":
            suggest = "region_switch_plan_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanExecutionBlockConfiguration6Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanExecutionBlockConfiguration6Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanExecutionBlockConfiguration6Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_switch_plan_config: 'outputs.PlanRegionSwitchPlanConfiguration'):
        pulumi.set(__self__, "region_switch_plan_config", region_switch_plan_config)

    @_builtins.property
    @pulumi.getter(name="regionSwitchPlanConfig")
    def region_switch_plan_config(self) -> 'outputs.PlanRegionSwitchPlanConfiguration':
        return pulumi.get(self, "region_switch_plan_config")


@pulumi.output_type
class PlanExecutionBlockConfiguration7Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ecsCapacityIncreaseConfig":
            suggest = "ecs_capacity_increase_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanExecutionBlockConfiguration7Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanExecutionBlockConfiguration7Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanExecutionBlockConfiguration7Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ecs_capacity_increase_config: 'outputs.PlanEcsCapacityIncreaseConfiguration'):
        pulumi.set(__self__, "ecs_capacity_increase_config", ecs_capacity_increase_config)

    @_builtins.property
    @pulumi.getter(name="ecsCapacityIncreaseConfig")
    def ecs_capacity_increase_config(self) -> 'outputs.PlanEcsCapacityIncreaseConfiguration':
        return pulumi.get(self, "ecs_capacity_increase_config")


@pulumi.output_type
class PlanExecutionBlockConfiguration8Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eksResourceScalingConfig":
            suggest = "eks_resource_scaling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanExecutionBlockConfiguration8Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanExecutionBlockConfiguration8Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanExecutionBlockConfiguration8Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 eks_resource_scaling_config: 'outputs.PlanEksResourceScalingConfiguration'):
        pulumi.set(__self__, "eks_resource_scaling_config", eks_resource_scaling_config)

    @_builtins.property
    @pulumi.getter(name="eksResourceScalingConfig")
    def eks_resource_scaling_config(self) -> 'outputs.PlanEksResourceScalingConfiguration':
        return pulumi.get(self, "eks_resource_scaling_config")


@pulumi.output_type
class PlanExecutionBlockConfiguration9Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "route53HealthCheckConfig":
            suggest = "route53_health_check_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanExecutionBlockConfiguration9Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanExecutionBlockConfiguration9Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanExecutionBlockConfiguration9Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 route53_health_check_config: 'outputs.PlanRoute53HealthCheckConfiguration'):
        pulumi.set(__self__, "route53_health_check_config", route53_health_check_config)

    @_builtins.property
    @pulumi.getter(name="route53HealthCheckConfig")
    def route53_health_check_config(self) -> 'outputs.PlanRoute53HealthCheckConfiguration':
        return pulumi.get(self, "route53_health_check_config")


@pulumi.output_type
class PlanGlobalAuroraConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseClusterArns":
            suggest = "database_cluster_arns"
        elif key == "globalClusterIdentifier":
            suggest = "global_cluster_identifier"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanGlobalAuroraConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanGlobalAuroraConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanGlobalAuroraConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 behavior: Any,
                 database_cluster_arns: Sequence[_builtins.str],
                 global_cluster_identifier: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 timeout_minutes: Optional[_builtins.float] = None,
                 ungraceful: Optional['outputs.PlanGlobalAuroraUngraceful'] = None):
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "database_cluster_arns", database_cluster_arns)
        pulumi.set(__self__, "global_cluster_identifier", global_cluster_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Any:
        return pulumi.get(self, "behavior")

    @_builtins.property
    @pulumi.getter(name="databaseClusterArns")
    def database_cluster_arns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "database_cluster_arns")

    @_builtins.property
    @pulumi.getter(name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> _builtins.str:
        return pulumi.get(self, "global_cluster_identifier")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional['outputs.PlanGlobalAuroraUngraceful']:
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanGlobalAuroraUngraceful(dict):
    def __init__(__self__, *,
                 ungraceful: Optional['PlanGlobalAuroraUngracefulBehavior'] = None):
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional['PlanGlobalAuroraUngracefulBehavior']:
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanHealthCheckState(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckId":
            suggest = "health_check_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanHealthCheckState. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanHealthCheckState.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanHealthCheckState.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        if health_check_id is not None:
            pulumi.set(__self__, "health_check_id", health_check_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="healthCheckId")
    def health_check_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "health_check_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class PlanKubernetesResourceType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanKubernetesResourceType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanKubernetesResourceType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanKubernetesResourceType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: _builtins.str,
                 kind: _builtins.str):
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> _builtins.str:
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        return pulumi.get(self, "kind")


@pulumi.output_type
class PlanLambdaUngraceful(dict):
    def __init__(__self__, *,
                 behavior: Optional[Any] = None):
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional[Any]:
        return pulumi.get(self, "behavior")


@pulumi.output_type
class PlanLambdas(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanLambdas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanLambdas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanLambdas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanParallelExecutionBlockConfiguration(dict):
    def __init__(__self__, *,
                 steps: Sequence['outputs.PlanStep']):
        pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Sequence['outputs.PlanStep']:
        return pulumi.get(self, "steps")


@pulumi.output_type
class PlanRegionSwitchPlanConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanRegionSwitchPlanConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanRegionSwitchPlanConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanRegionSwitchPlanConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanRoute53HealthCheckConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostedZoneId":
            suggest = "hosted_zone_id"
        elif key == "recordName":
            suggest = "record_name"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "recordSets":
            suggest = "record_sets"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanRoute53HealthCheckConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanRoute53HealthCheckConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanRoute53HealthCheckConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosted_zone_id: _builtins.str,
                 record_name: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 record_sets: Optional[Sequence['outputs.PlanRoute53ResourceRecordSet']] = None,
                 timeout_minutes: Optional[_builtins.float] = None):
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        pulumi.set(__self__, "record_name", record_name)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if record_sets is not None:
            pulumi.set(__self__, "record_sets", record_sets)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> _builtins.str:
        return pulumi.get(self, "hosted_zone_id")

    @_builtins.property
    @pulumi.getter(name="recordName")
    def record_name(self) -> _builtins.str:
        return pulumi.get(self, "record_name")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="recordSets")
    def record_sets(self) -> Optional[Sequence['outputs.PlanRoute53ResourceRecordSet']]:
        return pulumi.get(self, "record_sets")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "timeout_minutes")


@pulumi.output_type
class PlanRoute53ResourceRecordSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordSetIdentifier":
            suggest = "record_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanRoute53ResourceRecordSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanRoute53ResourceRecordSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanRoute53ResourceRecordSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_set_identifier: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        if record_set_identifier is not None:
            pulumi.set(__self__, "record_set_identifier", record_set_identifier)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="recordSetIdentifier")
    def record_set_identifier(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "record_set_identifier")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class PlanService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterArn":
            suggest = "cluster_arn"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "serviceArn":
            suggest = "service_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_arn: Optional[_builtins.str] = None,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 service_arn: Optional[_builtins.str] = None):
        if cluster_arn is not None:
            pulumi.set(__self__, "cluster_arn", cluster_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if service_arn is not None:
            pulumi.set(__self__, "service_arn", service_arn)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="serviceArn")
    def service_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_arn")


@pulumi.output_type
class PlanStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionBlockConfiguration":
            suggest = "execution_block_configuration"
        elif key == "executionBlockType":
            suggest = "execution_block_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_block_configuration: Any,
                 execution_block_type: 'PlanExecutionBlockType',
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param Union['PlanExecutionBlockConfiguration0Properties', 'PlanExecutionBlockConfiguration1Properties', 'PlanExecutionBlockConfiguration2Properties', 'PlanExecutionBlockConfiguration3Properties', 'PlanExecutionBlockConfiguration4Properties', 'PlanExecutionBlockConfiguration5Properties', 'PlanExecutionBlockConfiguration6Properties', 'PlanExecutionBlockConfiguration7Properties', 'PlanExecutionBlockConfiguration8Properties', 'PlanExecutionBlockConfiguration9Properties'] execution_block_configuration: The configuration for an execution block in a workflow.
        :param 'PlanExecutionBlockType' execution_block_type: The type of an execution block in a workflow.
        :param _builtins.str name: The name of a step in a workflow.
        :param _builtins.str description: The description of a step in a workflow.
        """
        pulumi.set(__self__, "execution_block_configuration", execution_block_configuration)
        pulumi.set(__self__, "execution_block_type", execution_block_type)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="executionBlockConfiguration")
    def execution_block_configuration(self) -> Any:
        """
        The configuration for an execution block in a workflow.
        """
        return pulumi.get(self, "execution_block_configuration")

    @_builtins.property
    @pulumi.getter(name="executionBlockType")
    def execution_block_type(self) -> 'PlanExecutionBlockType':
        """
        The type of an execution block in a workflow.
        """
        return pulumi.get(self, "execution_block_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of a step in a workflow.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of a step in a workflow.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class PlanTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minDelayMinutesBetweenExecutions":
            suggest = "min_delay_minutes_between_executions"
        elif key == "targetRegion":
            suggest = "target_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'PlanWorkflowTargetAction',
                 conditions: Sequence['outputs.PlanTriggerCondition'],
                 min_delay_minutes_between_executions: _builtins.float,
                 target_region: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param 'PlanWorkflowTargetAction' action: The action to perform when the trigger fires. Valid values include ACTIVATE and DEACTIVATE.
        :param Sequence['PlanTriggerCondition'] conditions: The conditions that must be met for the trigger to fire.
        :param _builtins.float min_delay_minutes_between_executions: The minimum time, in minutes, that must elapse between automatic executions of the plan.
        :param _builtins.str target_region: The AWS Region for a trigger.
        :param _builtins.str description: The description for a trigger.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "min_delay_minutes_between_executions", min_delay_minutes_between_executions)
        pulumi.set(__self__, "target_region", target_region)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'PlanWorkflowTargetAction':
        """
        The action to perform when the trigger fires. Valid values include ACTIVATE and DEACTIVATE.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.PlanTriggerCondition']:
        """
        The conditions that must be met for the trigger to fire.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter(name="minDelayMinutesBetweenExecutions")
    def min_delay_minutes_between_executions(self) -> _builtins.float:
        """
        The minimum time, in minutes, that must elapse between automatic executions of the plan.
        """
        return pulumi.get(self, "min_delay_minutes_between_executions")

    @_builtins.property
    @pulumi.getter(name="targetRegion")
    def target_region(self) -> _builtins.str:
        """
        The AWS Region for a trigger.
        """
        return pulumi.get(self, "target_region")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description for a trigger.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class PlanTriggerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedAlarmName":
            suggest = "associated_alarm_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanTriggerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanTriggerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanTriggerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_alarm_name: _builtins.str,
                 condition: 'PlanAlarmCondition'):
        """
        :param _builtins.str associated_alarm_name: The name of the CloudWatch alarm associated with the condition.
        :param 'PlanAlarmCondition' condition: The condition that must be met. Valid values include ALARM and OK.
        """
        pulumi.set(__self__, "associated_alarm_name", associated_alarm_name)
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter(name="associatedAlarmName")
    def associated_alarm_name(self) -> _builtins.str:
        """
        The name of the CloudWatch alarm associated with the condition.
        """
        return pulumi.get(self, "associated_alarm_name")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'PlanAlarmCondition':
        """
        The condition that must be met. Valid values include ALARM and OK.
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class PlanWorkflow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workflowTargetAction":
            suggest = "workflow_target_action"
        elif key == "workflowDescription":
            suggest = "workflow_description"
        elif key == "workflowTargetRegion":
            suggest = "workflow_target_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workflow_target_action: 'PlanWorkflowTargetAction',
                 steps: Optional[Sequence['outputs.PlanStep']] = None,
                 workflow_description: Optional[_builtins.str] = None,
                 workflow_target_region: Optional[_builtins.str] = None):
        """
        :param 'PlanWorkflowTargetAction' workflow_target_action: The action that the workflow performs. Valid values include ACTIVATE and DEACTIVATE.
        :param Sequence['PlanStep'] steps: The steps that make up the workflow.
        :param _builtins.str workflow_description: The description of the workflow.
        :param _builtins.str workflow_target_region: The AWS Region that the workflow targets.
        """
        pulumi.set(__self__, "workflow_target_action", workflow_target_action)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)
        if workflow_description is not None:
            pulumi.set(__self__, "workflow_description", workflow_description)
        if workflow_target_region is not None:
            pulumi.set(__self__, "workflow_target_region", workflow_target_region)

    @_builtins.property
    @pulumi.getter(name="workflowTargetAction")
    def workflow_target_action(self) -> 'PlanWorkflowTargetAction':
        """
        The action that the workflow performs. Valid values include ACTIVATE and DEACTIVATE.
        """
        return pulumi.get(self, "workflow_target_action")

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[Sequence['outputs.PlanStep']]:
        """
        The steps that make up the workflow.
        """
        return pulumi.get(self, "steps")

    @_builtins.property
    @pulumi.getter(name="workflowDescription")
    def workflow_description(self) -> Optional[_builtins.str]:
        """
        The description of the workflow.
        """
        return pulumi.get(self, "workflow_description")

    @_builtins.property
    @pulumi.getter(name="workflowTargetRegion")
    def workflow_target_region(self) -> Optional[_builtins.str]:
        """
        The AWS Region that the workflow targets.
        """
        return pulumi.get(self, "workflow_target_region")


@pulumi.output_type
class Route53HealthChecksProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckIds":
            suggest = "health_check_ids"
        elif key == "hostedZoneIds":
            suggest = "hosted_zone_ids"
        elif key == "recordNames":
            suggest = "record_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Route53HealthChecksProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Route53HealthChecksProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Route53HealthChecksProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check_ids: Optional[Sequence[_builtins.str]] = None,
                 hosted_zone_ids: Optional[Sequence[_builtins.str]] = None,
                 record_names: Optional[Sequence[_builtins.str]] = None,
                 regions: Optional[Sequence[_builtins.str]] = None):
        if health_check_ids is not None:
            pulumi.set(__self__, "health_check_ids", health_check_ids)
        if hosted_zone_ids is not None:
            pulumi.set(__self__, "hosted_zone_ids", hosted_zone_ids)
        if record_names is not None:
            pulumi.set(__self__, "record_names", record_names)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)

    @_builtins.property
    @pulumi.getter(name="healthCheckIds")
    def health_check_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "health_check_ids")

    @_builtins.property
    @pulumi.getter(name="hostedZoneIds")
    def hosted_zone_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "hosted_zone_ids")

    @_builtins.property
    @pulumi.getter(name="recordNames")
    def record_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "record_names")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "regions")


