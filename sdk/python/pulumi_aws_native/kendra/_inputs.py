# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'DataSourceAccessControlListConfigurationArgs',
    'DataSourceAclConfigurationArgs',
    'DataSourceColumnConfigurationArgs',
    'DataSourceConfigurationArgs',
    'DataSourceConfluenceAttachmentConfigurationArgs',
    'DataSourceConfluenceAttachmentToIndexFieldMappingArgs',
    'DataSourceConfluenceBlogConfigurationArgs',
    'DataSourceConfluenceBlogToIndexFieldMappingArgs',
    'DataSourceConfluenceConfigurationArgs',
    'DataSourceConfluencePageConfigurationArgs',
    'DataSourceConfluencePageToIndexFieldMappingArgs',
    'DataSourceConfluenceSpaceConfigurationArgs',
    'DataSourceConfluenceSpaceToIndexFieldMappingArgs',
    'DataSourceConnectionConfigurationArgs',
    'DataSourceCustomDocumentEnrichmentConfigurationArgs',
    'DataSourceDatabaseConfigurationArgs',
    'DataSourceDocumentAttributeConditionArgs',
    'DataSourceDocumentAttributeTargetArgs',
    'DataSourceDocumentAttributeValueArgs',
    'DataSourceDocumentsMetadataConfigurationArgs',
    'DataSourceGoogleDriveConfigurationArgs',
    'DataSourceHookConfigurationArgs',
    'DataSourceInlineCustomDocumentEnrichmentConfigurationArgs',
    'DataSourceOneDriveConfigurationArgs',
    'DataSourceOneDriveUsersArgs',
    'DataSourceProxyConfigurationArgs',
    'DataSourceS3DataSourceConfigurationArgs',
    'DataSourceS3PathArgs',
    'DataSourceSalesforceChatterFeedConfigurationArgs',
    'DataSourceSalesforceConfigurationArgs',
    'DataSourceSalesforceCustomKnowledgeArticleTypeConfigurationArgs',
    'DataSourceSalesforceKnowledgeArticleConfigurationArgs',
    'DataSourceSalesforceStandardKnowledgeArticleTypeConfigurationArgs',
    'DataSourceSalesforceStandardObjectAttachmentConfigurationArgs',
    'DataSourceSalesforceStandardObjectConfigurationArgs',
    'DataSourceServiceNowConfigurationArgs',
    'DataSourceServiceNowKnowledgeArticleConfigurationArgs',
    'DataSourceServiceNowServiceCatalogConfigurationArgs',
    'DataSourceSharePointConfigurationArgs',
    'DataSourceSqlConfigurationArgs',
    'DataSourceToIndexFieldMappingArgs',
    'DataSourceVpcConfigurationArgs',
    'DataSourceWebCrawlerAuthenticationConfigurationArgs',
    'DataSourceWebCrawlerBasicAuthenticationArgs',
    'DataSourceWebCrawlerConfigurationArgs',
    'DataSourceWebCrawlerSeedUrlConfigurationArgs',
    'DataSourceWebCrawlerSiteMapsConfigurationArgs',
    'DataSourceWebCrawlerUrlsArgs',
    'DataSourceWorkDocsConfigurationArgs',
    'FaqS3PathArgs',
    'IndexCapacityUnitsConfigurationArgs',
    'IndexDocumentMetadataConfigurationArgs',
    'IndexJsonTokenTypeConfigurationArgs',
    'IndexJwtTokenTypeConfigurationArgs',
    'IndexRelevanceArgs',
    'IndexSearchArgs',
    'IndexServerSideEncryptionConfigurationArgs',
    'IndexUserTokenConfigurationArgs',
    'IndexValueImportanceItemArgs',
]

@pulumi.input_type
class DataSourceAccessControlListConfigurationArgs:
    def __init__(__self__, *,
                 key_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_path: Path to the AWS S3 bucket that contains the access control list files.
        """
        if key_path is not None:
            pulumi.set(__self__, "key_path", key_path)

    @property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the AWS S3 bucket that contains the access control list files.
        """
        return pulumi.get(self, "key_path")

    @key_path.setter
    def key_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_path", value)


@pulumi.input_type
class DataSourceAclConfigurationArgs:
    def __init__(__self__, *,
                 allowed_groups_column_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] allowed_groups_column_name: A list of groups, separated by semi-colons, that filters a query response based on user context. The document is only returned to users that are in one of the groups specified in the `UserContext` field of the [Query](https://docs.aws.amazon.com/kendra/latest/dg/API_Query.html) operation.
        """
        pulumi.set(__self__, "allowed_groups_column_name", allowed_groups_column_name)

    @property
    @pulumi.getter(name="allowedGroupsColumnName")
    def allowed_groups_column_name(self) -> pulumi.Input[str]:
        """
        A list of groups, separated by semi-colons, that filters a query response based on user context. The document is only returned to users that are in one of the groups specified in the `UserContext` field of the [Query](https://docs.aws.amazon.com/kendra/latest/dg/API_Query.html) operation.
        """
        return pulumi.get(self, "allowed_groups_column_name")

    @allowed_groups_column_name.setter
    def allowed_groups_column_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "allowed_groups_column_name", value)


@pulumi.input_type
class DataSourceColumnConfigurationArgs:
    def __init__(__self__, *,
                 change_detecting_columns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 document_data_column_name: pulumi.Input[str],
                 document_id_column_name: pulumi.Input[str],
                 document_title_column_name: Optional[pulumi.Input[str]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] change_detecting_columns: One to five columns that indicate when a document in the database has changed.
        :param pulumi.Input[str] document_data_column_name: The column that contains the contents of the document.
        :param pulumi.Input[str] document_id_column_name: The column that provides the document's identifier.
        :param pulumi.Input[str] document_title_column_name: The column that contains the title of the document.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]] field_mappings: An array of objects that map database column names to the corresponding fields in an index. You must first create the fields in the index using the [UpdateIndex](https://docs.aws.amazon.com/kendra/latest/dg/API_UpdateIndex.html) operation.
        """
        pulumi.set(__self__, "change_detecting_columns", change_detecting_columns)
        pulumi.set(__self__, "document_data_column_name", document_data_column_name)
        pulumi.set(__self__, "document_id_column_name", document_id_column_name)
        if document_title_column_name is not None:
            pulumi.set(__self__, "document_title_column_name", document_title_column_name)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)

    @property
    @pulumi.getter(name="changeDetectingColumns")
    def change_detecting_columns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        One to five columns that indicate when a document in the database has changed.
        """
        return pulumi.get(self, "change_detecting_columns")

    @change_detecting_columns.setter
    def change_detecting_columns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "change_detecting_columns", value)

    @property
    @pulumi.getter(name="documentDataColumnName")
    def document_data_column_name(self) -> pulumi.Input[str]:
        """
        The column that contains the contents of the document.
        """
        return pulumi.get(self, "document_data_column_name")

    @document_data_column_name.setter
    def document_data_column_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "document_data_column_name", value)

    @property
    @pulumi.getter(name="documentIdColumnName")
    def document_id_column_name(self) -> pulumi.Input[str]:
        """
        The column that provides the document's identifier.
        """
        return pulumi.get(self, "document_id_column_name")

    @document_id_column_name.setter
    def document_id_column_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "document_id_column_name", value)

    @property
    @pulumi.getter(name="documentTitleColumnName")
    def document_title_column_name(self) -> Optional[pulumi.Input[str]]:
        """
        The column that contains the title of the document.
        """
        return pulumi.get(self, "document_title_column_name")

    @document_title_column_name.setter
    def document_title_column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_title_column_name", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        """
        An array of objects that map database column names to the corresponding fields in an index. You must first create the fields in the index using the [UpdateIndex](https://docs.aws.amazon.com/kendra/latest/dg/API_UpdateIndex.html) operation.
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)


@pulumi.input_type
class DataSourceConfigurationArgs:
    def __init__(__self__, *,
                 confluence_configuration: Optional[pulumi.Input['DataSourceConfluenceConfigurationArgs']] = None,
                 database_configuration: Optional[pulumi.Input['DataSourceDatabaseConfigurationArgs']] = None,
                 google_drive_configuration: Optional[pulumi.Input['DataSourceGoogleDriveConfigurationArgs']] = None,
                 one_drive_configuration: Optional[pulumi.Input['DataSourceOneDriveConfigurationArgs']] = None,
                 s3_configuration: Optional[pulumi.Input['DataSourceS3DataSourceConfigurationArgs']] = None,
                 salesforce_configuration: Optional[pulumi.Input['DataSourceSalesforceConfigurationArgs']] = None,
                 service_now_configuration: Optional[pulumi.Input['DataSourceServiceNowConfigurationArgs']] = None,
                 share_point_configuration: Optional[pulumi.Input['DataSourceSharePointConfigurationArgs']] = None,
                 web_crawler_configuration: Optional[pulumi.Input['DataSourceWebCrawlerConfigurationArgs']] = None,
                 work_docs_configuration: Optional[pulumi.Input['DataSourceWorkDocsConfigurationArgs']] = None):
        """
        :param pulumi.Input['DataSourceConfluenceConfigurationArgs'] confluence_configuration: Provides the configuration information to connect to Confluence as your data source.
        :param pulumi.Input['DataSourceDatabaseConfigurationArgs'] database_configuration: Provides the configuration information to connect to a database as your data source.
        :param pulumi.Input['DataSourceGoogleDriveConfigurationArgs'] google_drive_configuration: Provides the configuration information to connect to Google Drive as your data source.
        :param pulumi.Input['DataSourceOneDriveConfigurationArgs'] one_drive_configuration: Provides the configuration information to connect to Microsoft OneDrive as your data source.
        :param pulumi.Input['DataSourceS3DataSourceConfigurationArgs'] s3_configuration: Provides the configuration information to connect to an Amazon S3 bucket as your data source.
               
               > Amazon Kendra now supports an upgraded Amazon S3 connector.
               > 
               > You must now use the [TemplateConfiguration](https://docs.aws.amazon.com/kendra/latest/APIReference/API_TemplateConfiguration.html) object instead of the `S3DataSourceConfiguration` object to configure your connector.
               > 
               > Connectors configured using the older console and API architecture will continue to function as configured. However, you won't be able to edit or update them. If you want to edit or update your connector configuration, you must create a new connector.
               > 
               > We recommended migrating your connector workflow to the upgraded version. Support for connectors configured using the older architecture is scheduled to end by June 2024.
        :param pulumi.Input['DataSourceSalesforceConfigurationArgs'] salesforce_configuration: Provides the configuration information to connect to Salesforce as your data source.
        :param pulumi.Input['DataSourceServiceNowConfigurationArgs'] service_now_configuration: Provides the configuration information to connect to ServiceNow as your data source.
        :param pulumi.Input['DataSourceSharePointConfigurationArgs'] share_point_configuration: Provides the configuration information to connect to Microsoft SharePoint as your data source.
        :param pulumi.Input['DataSourceWebCrawlerConfigurationArgs'] web_crawler_configuration: Provides the configuration information required for Amazon Kendra Web Crawler.
        :param pulumi.Input['DataSourceWorkDocsConfigurationArgs'] work_docs_configuration: Provides the configuration information to connect to Amazon WorkDocs as your data source.
        """
        if confluence_configuration is not None:
            pulumi.set(__self__, "confluence_configuration", confluence_configuration)
        if database_configuration is not None:
            pulumi.set(__self__, "database_configuration", database_configuration)
        if google_drive_configuration is not None:
            pulumi.set(__self__, "google_drive_configuration", google_drive_configuration)
        if one_drive_configuration is not None:
            pulumi.set(__self__, "one_drive_configuration", one_drive_configuration)
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)
        if salesforce_configuration is not None:
            pulumi.set(__self__, "salesforce_configuration", salesforce_configuration)
        if service_now_configuration is not None:
            pulumi.set(__self__, "service_now_configuration", service_now_configuration)
        if share_point_configuration is not None:
            pulumi.set(__self__, "share_point_configuration", share_point_configuration)
        if web_crawler_configuration is not None:
            pulumi.set(__self__, "web_crawler_configuration", web_crawler_configuration)
        if work_docs_configuration is not None:
            pulumi.set(__self__, "work_docs_configuration", work_docs_configuration)

    @property
    @pulumi.getter(name="confluenceConfiguration")
    def confluence_configuration(self) -> Optional[pulumi.Input['DataSourceConfluenceConfigurationArgs']]:
        """
        Provides the configuration information to connect to Confluence as your data source.
        """
        return pulumi.get(self, "confluence_configuration")

    @confluence_configuration.setter
    def confluence_configuration(self, value: Optional[pulumi.Input['DataSourceConfluenceConfigurationArgs']]):
        pulumi.set(self, "confluence_configuration", value)

    @property
    @pulumi.getter(name="databaseConfiguration")
    def database_configuration(self) -> Optional[pulumi.Input['DataSourceDatabaseConfigurationArgs']]:
        """
        Provides the configuration information to connect to a database as your data source.
        """
        return pulumi.get(self, "database_configuration")

    @database_configuration.setter
    def database_configuration(self, value: Optional[pulumi.Input['DataSourceDatabaseConfigurationArgs']]):
        pulumi.set(self, "database_configuration", value)

    @property
    @pulumi.getter(name="googleDriveConfiguration")
    def google_drive_configuration(self) -> Optional[pulumi.Input['DataSourceGoogleDriveConfigurationArgs']]:
        """
        Provides the configuration information to connect to Google Drive as your data source.
        """
        return pulumi.get(self, "google_drive_configuration")

    @google_drive_configuration.setter
    def google_drive_configuration(self, value: Optional[pulumi.Input['DataSourceGoogleDriveConfigurationArgs']]):
        pulumi.set(self, "google_drive_configuration", value)

    @property
    @pulumi.getter(name="oneDriveConfiguration")
    def one_drive_configuration(self) -> Optional[pulumi.Input['DataSourceOneDriveConfigurationArgs']]:
        """
        Provides the configuration information to connect to Microsoft OneDrive as your data source.
        """
        return pulumi.get(self, "one_drive_configuration")

    @one_drive_configuration.setter
    def one_drive_configuration(self, value: Optional[pulumi.Input['DataSourceOneDriveConfigurationArgs']]):
        pulumi.set(self, "one_drive_configuration", value)

    @property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional[pulumi.Input['DataSourceS3DataSourceConfigurationArgs']]:
        """
        Provides the configuration information to connect to an Amazon S3 bucket as your data source.

        > Amazon Kendra now supports an upgraded Amazon S3 connector.
        > 
        > You must now use the [TemplateConfiguration](https://docs.aws.amazon.com/kendra/latest/APIReference/API_TemplateConfiguration.html) object instead of the `S3DataSourceConfiguration` object to configure your connector.
        > 
        > Connectors configured using the older console and API architecture will continue to function as configured. However, you won't be able to edit or update them. If you want to edit or update your connector configuration, you must create a new connector.
        > 
        > We recommended migrating your connector workflow to the upgraded version. Support for connectors configured using the older architecture is scheduled to end by June 2024.
        """
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: Optional[pulumi.Input['DataSourceS3DataSourceConfigurationArgs']]):
        pulumi.set(self, "s3_configuration", value)

    @property
    @pulumi.getter(name="salesforceConfiguration")
    def salesforce_configuration(self) -> Optional[pulumi.Input['DataSourceSalesforceConfigurationArgs']]:
        """
        Provides the configuration information to connect to Salesforce as your data source.
        """
        return pulumi.get(self, "salesforce_configuration")

    @salesforce_configuration.setter
    def salesforce_configuration(self, value: Optional[pulumi.Input['DataSourceSalesforceConfigurationArgs']]):
        pulumi.set(self, "salesforce_configuration", value)

    @property
    @pulumi.getter(name="serviceNowConfiguration")
    def service_now_configuration(self) -> Optional[pulumi.Input['DataSourceServiceNowConfigurationArgs']]:
        """
        Provides the configuration information to connect to ServiceNow as your data source.
        """
        return pulumi.get(self, "service_now_configuration")

    @service_now_configuration.setter
    def service_now_configuration(self, value: Optional[pulumi.Input['DataSourceServiceNowConfigurationArgs']]):
        pulumi.set(self, "service_now_configuration", value)

    @property
    @pulumi.getter(name="sharePointConfiguration")
    def share_point_configuration(self) -> Optional[pulumi.Input['DataSourceSharePointConfigurationArgs']]:
        """
        Provides the configuration information to connect to Microsoft SharePoint as your data source.
        """
        return pulumi.get(self, "share_point_configuration")

    @share_point_configuration.setter
    def share_point_configuration(self, value: Optional[pulumi.Input['DataSourceSharePointConfigurationArgs']]):
        pulumi.set(self, "share_point_configuration", value)

    @property
    @pulumi.getter(name="webCrawlerConfiguration")
    def web_crawler_configuration(self) -> Optional[pulumi.Input['DataSourceWebCrawlerConfigurationArgs']]:
        """
        Provides the configuration information required for Amazon Kendra Web Crawler.
        """
        return pulumi.get(self, "web_crawler_configuration")

    @web_crawler_configuration.setter
    def web_crawler_configuration(self, value: Optional[pulumi.Input['DataSourceWebCrawlerConfigurationArgs']]):
        pulumi.set(self, "web_crawler_configuration", value)

    @property
    @pulumi.getter(name="workDocsConfiguration")
    def work_docs_configuration(self) -> Optional[pulumi.Input['DataSourceWorkDocsConfigurationArgs']]:
        """
        Provides the configuration information to connect to Amazon WorkDocs as your data source.
        """
        return pulumi.get(self, "work_docs_configuration")

    @work_docs_configuration.setter
    def work_docs_configuration(self, value: Optional[pulumi.Input['DataSourceWorkDocsConfigurationArgs']]):
        pulumi.set(self, "work_docs_configuration", value)


@pulumi.input_type
class DataSourceConfluenceAttachmentConfigurationArgs:
    def __init__(__self__, *,
                 attachment_field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceAttachmentToIndexFieldMappingArgs']]]] = None,
                 crawl_attachments: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceAttachmentToIndexFieldMappingArgs']]] attachment_field_mappings: Maps attributes or field names of Confluence attachments to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Confluence fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Confluence data source field names must exist in your Confluence custom metadata.
               
               If you specify the `AttachentFieldMappings` parameter, you must specify at least one field mapping.
        :param pulumi.Input[bool] crawl_attachments: `TRUE` to index attachments of pages and blogs in Confluence.
        """
        if attachment_field_mappings is not None:
            pulumi.set(__self__, "attachment_field_mappings", attachment_field_mappings)
        if crawl_attachments is not None:
            pulumi.set(__self__, "crawl_attachments", crawl_attachments)

    @property
    @pulumi.getter(name="attachmentFieldMappings")
    def attachment_field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceAttachmentToIndexFieldMappingArgs']]]]:
        """
        Maps attributes or field names of Confluence attachments to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Confluence fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Confluence data source field names must exist in your Confluence custom metadata.

        If you specify the `AttachentFieldMappings` parameter, you must specify at least one field mapping.
        """
        return pulumi.get(self, "attachment_field_mappings")

    @attachment_field_mappings.setter
    def attachment_field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceAttachmentToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "attachment_field_mappings", value)

    @property
    @pulumi.getter(name="crawlAttachments")
    def crawl_attachments(self) -> Optional[pulumi.Input[bool]]:
        """
        `TRUE` to index attachments of pages and blogs in Confluence.
        """
        return pulumi.get(self, "crawl_attachments")

    @crawl_attachments.setter
    def crawl_attachments(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "crawl_attachments", value)


@pulumi.input_type
class DataSourceConfluenceAttachmentToIndexFieldMappingArgs:
    def __init__(__self__, *,
                 data_source_field_name: pulumi.Input['DataSourceConfluenceAttachmentFieldName'],
                 index_field_name: pulumi.Input[str],
                 date_field_format: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "data_source_field_name", data_source_field_name)
        pulumi.set(__self__, "index_field_name", index_field_name)
        if date_field_format is not None:
            pulumi.set(__self__, "date_field_format", date_field_format)

    @property
    @pulumi.getter(name="dataSourceFieldName")
    def data_source_field_name(self) -> pulumi.Input['DataSourceConfluenceAttachmentFieldName']:
        return pulumi.get(self, "data_source_field_name")

    @data_source_field_name.setter
    def data_source_field_name(self, value: pulumi.Input['DataSourceConfluenceAttachmentFieldName']):
        pulumi.set(self, "data_source_field_name", value)

    @property
    @pulumi.getter(name="indexFieldName")
    def index_field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index_field_name")

    @index_field_name.setter
    def index_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_field_name", value)

    @property
    @pulumi.getter(name="dateFieldFormat")
    def date_field_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_field_format")

    @date_field_format.setter
    def date_field_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_field_format", value)


@pulumi.input_type
class DataSourceConfluenceBlogConfigurationArgs:
    def __init__(__self__, *,
                 blog_field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceBlogToIndexFieldMappingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceBlogToIndexFieldMappingArgs']]] blog_field_mappings: Maps attributes or field names of Confluence blogs to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Confluence fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Confluence data source field names must exist in your Confluence custom metadata.
               
               If you specify the `BlogFieldMappings` parameter, you must specify at least one field mapping.
        """
        if blog_field_mappings is not None:
            pulumi.set(__self__, "blog_field_mappings", blog_field_mappings)

    @property
    @pulumi.getter(name="blogFieldMappings")
    def blog_field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceBlogToIndexFieldMappingArgs']]]]:
        """
        Maps attributes or field names of Confluence blogs to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Confluence fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Confluence data source field names must exist in your Confluence custom metadata.

        If you specify the `BlogFieldMappings` parameter, you must specify at least one field mapping.
        """
        return pulumi.get(self, "blog_field_mappings")

    @blog_field_mappings.setter
    def blog_field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceBlogToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "blog_field_mappings", value)


@pulumi.input_type
class DataSourceConfluenceBlogToIndexFieldMappingArgs:
    def __init__(__self__, *,
                 data_source_field_name: pulumi.Input['DataSourceConfluenceBlogFieldName'],
                 index_field_name: pulumi.Input[str],
                 date_field_format: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "data_source_field_name", data_source_field_name)
        pulumi.set(__self__, "index_field_name", index_field_name)
        if date_field_format is not None:
            pulumi.set(__self__, "date_field_format", date_field_format)

    @property
    @pulumi.getter(name="dataSourceFieldName")
    def data_source_field_name(self) -> pulumi.Input['DataSourceConfluenceBlogFieldName']:
        return pulumi.get(self, "data_source_field_name")

    @data_source_field_name.setter
    def data_source_field_name(self, value: pulumi.Input['DataSourceConfluenceBlogFieldName']):
        pulumi.set(self, "data_source_field_name", value)

    @property
    @pulumi.getter(name="indexFieldName")
    def index_field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index_field_name")

    @index_field_name.setter
    def index_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_field_name", value)

    @property
    @pulumi.getter(name="dateFieldFormat")
    def date_field_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_field_format")

    @date_field_format.setter
    def date_field_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_field_format", value)


@pulumi.input_type
class DataSourceConfluenceConfigurationArgs:
    def __init__(__self__, *,
                 secret_arn: pulumi.Input[str],
                 server_url: pulumi.Input[str],
                 version: pulumi.Input['DataSourceConfluenceVersion'],
                 attachment_configuration: Optional[pulumi.Input['DataSourceConfluenceAttachmentConfigurationArgs']] = None,
                 blog_configuration: Optional[pulumi.Input['DataSourceConfluenceBlogConfigurationArgs']] = None,
                 exclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 inclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 page_configuration: Optional[pulumi.Input['DataSourceConfluencePageConfigurationArgs']] = None,
                 space_configuration: Optional[pulumi.Input['DataSourceConfluenceSpaceConfigurationArgs']] = None,
                 vpc_configuration: Optional[pulumi.Input['DataSourceVpcConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] secret_arn: The Amazon Resource Name (ARN) of an AWS Secrets Manager secret that contains the user name and password required to connect to the Confluence instance. If you use Confluence Cloud, you use a generated API token as the password.
               
               You can also provide authentication credentials in the form of a personal access token. For more information, see [Using a Confluence data source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-confluence.html) .
        :param pulumi.Input[str] server_url: The URL of your Confluence instance. Use the full URL of the server. For example, *https://server.example.com:port/* . You can also use an IP address, for example, *https://192.168.1.113/* .
        :param pulumi.Input['DataSourceConfluenceVersion'] version: The version or the type of Confluence installation to connect to.
        :param pulumi.Input['DataSourceConfluenceAttachmentConfigurationArgs'] attachment_configuration: Configuration information for indexing attachments to Confluence blogs and pages.
        :param pulumi.Input['DataSourceConfluenceBlogConfigurationArgs'] blog_configuration: Configuration information for indexing Confluence blogs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclusion_patterns: A list of regular expression patterns to exclude certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are excluded from the index. Content that doesn't match the patterns is included in the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_patterns: A list of regular expression patterns to include certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are included in the index. Content that doesn't match the patterns is excluded from the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.
        :param pulumi.Input['DataSourceConfluencePageConfigurationArgs'] page_configuration: Configuration information for indexing Confluence pages.
        :param pulumi.Input['DataSourceConfluenceSpaceConfigurationArgs'] space_configuration: Configuration information for indexing Confluence spaces.
        :param pulumi.Input['DataSourceVpcConfigurationArgs'] vpc_configuration: Configuration information for an Amazon Virtual Private Cloud to connect to your Confluence. For more information, see [Configuring a VPC](https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html) .
        """
        pulumi.set(__self__, "secret_arn", secret_arn)
        pulumi.set(__self__, "server_url", server_url)
        pulumi.set(__self__, "version", version)
        if attachment_configuration is not None:
            pulumi.set(__self__, "attachment_configuration", attachment_configuration)
        if blog_configuration is not None:
            pulumi.set(__self__, "blog_configuration", blog_configuration)
        if exclusion_patterns is not None:
            pulumi.set(__self__, "exclusion_patterns", exclusion_patterns)
        if inclusion_patterns is not None:
            pulumi.set(__self__, "inclusion_patterns", inclusion_patterns)
        if page_configuration is not None:
            pulumi.set(__self__, "page_configuration", page_configuration)
        if space_configuration is not None:
            pulumi.set(__self__, "space_configuration", space_configuration)
        if vpc_configuration is not None:
            pulumi.set(__self__, "vpc_configuration", vpc_configuration)

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of an AWS Secrets Manager secret that contains the user name and password required to connect to the Confluence instance. If you use Confluence Cloud, you use a generated API token as the password.

        You can also provide authentication credentials in the form of a personal access token. For more information, see [Using a Confluence data source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-confluence.html) .
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_arn", value)

    @property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> pulumi.Input[str]:
        """
        The URL of your Confluence instance. Use the full URL of the server. For example, *https://server.example.com:port/* . You can also use an IP address, for example, *https://192.168.1.113/* .
        """
        return pulumi.get(self, "server_url")

    @server_url.setter
    def server_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_url", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input['DataSourceConfluenceVersion']:
        """
        The version or the type of Confluence installation to connect to.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input['DataSourceConfluenceVersion']):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="attachmentConfiguration")
    def attachment_configuration(self) -> Optional[pulumi.Input['DataSourceConfluenceAttachmentConfigurationArgs']]:
        """
        Configuration information for indexing attachments to Confluence blogs and pages.
        """
        return pulumi.get(self, "attachment_configuration")

    @attachment_configuration.setter
    def attachment_configuration(self, value: Optional[pulumi.Input['DataSourceConfluenceAttachmentConfigurationArgs']]):
        pulumi.set(self, "attachment_configuration", value)

    @property
    @pulumi.getter(name="blogConfiguration")
    def blog_configuration(self) -> Optional[pulumi.Input['DataSourceConfluenceBlogConfigurationArgs']]:
        """
        Configuration information for indexing Confluence blogs.
        """
        return pulumi.get(self, "blog_configuration")

    @blog_configuration.setter
    def blog_configuration(self, value: Optional[pulumi.Input['DataSourceConfluenceBlogConfigurationArgs']]):
        pulumi.set(self, "blog_configuration", value)

    @property
    @pulumi.getter(name="exclusionPatterns")
    def exclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to exclude certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are excluded from the index. Content that doesn't match the patterns is included in the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.
        """
        return pulumi.get(self, "exclusion_patterns")

    @exclusion_patterns.setter
    def exclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_patterns", value)

    @property
    @pulumi.getter(name="inclusionPatterns")
    def inclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to include certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are included in the index. Content that doesn't match the patterns is excluded from the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.
        """
        return pulumi.get(self, "inclusion_patterns")

    @inclusion_patterns.setter
    def inclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_patterns", value)

    @property
    @pulumi.getter(name="pageConfiguration")
    def page_configuration(self) -> Optional[pulumi.Input['DataSourceConfluencePageConfigurationArgs']]:
        """
        Configuration information for indexing Confluence pages.
        """
        return pulumi.get(self, "page_configuration")

    @page_configuration.setter
    def page_configuration(self, value: Optional[pulumi.Input['DataSourceConfluencePageConfigurationArgs']]):
        pulumi.set(self, "page_configuration", value)

    @property
    @pulumi.getter(name="spaceConfiguration")
    def space_configuration(self) -> Optional[pulumi.Input['DataSourceConfluenceSpaceConfigurationArgs']]:
        """
        Configuration information for indexing Confluence spaces.
        """
        return pulumi.get(self, "space_configuration")

    @space_configuration.setter
    def space_configuration(self, value: Optional[pulumi.Input['DataSourceConfluenceSpaceConfigurationArgs']]):
        pulumi.set(self, "space_configuration", value)

    @property
    @pulumi.getter(name="vpcConfiguration")
    def vpc_configuration(self) -> Optional[pulumi.Input['DataSourceVpcConfigurationArgs']]:
        """
        Configuration information for an Amazon Virtual Private Cloud to connect to your Confluence. For more information, see [Configuring a VPC](https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html) .
        """
        return pulumi.get(self, "vpc_configuration")

    @vpc_configuration.setter
    def vpc_configuration(self, value: Optional[pulumi.Input['DataSourceVpcConfigurationArgs']]):
        pulumi.set(self, "vpc_configuration", value)


@pulumi.input_type
class DataSourceConfluencePageConfigurationArgs:
    def __init__(__self__, *,
                 page_field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluencePageToIndexFieldMappingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceConfluencePageToIndexFieldMappingArgs']]] page_field_mappings: Maps attributes or field names of Confluence pages to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Confluence fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Confluence data source field names must exist in your Confluence custom metadata.
               
               If you specify the `PageFieldMappings` parameter, you must specify at least one field mapping.
        """
        if page_field_mappings is not None:
            pulumi.set(__self__, "page_field_mappings", page_field_mappings)

    @property
    @pulumi.getter(name="pageFieldMappings")
    def page_field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluencePageToIndexFieldMappingArgs']]]]:
        """
        Maps attributes or field names of Confluence pages to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Confluence fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Confluence data source field names must exist in your Confluence custom metadata.

        If you specify the `PageFieldMappings` parameter, you must specify at least one field mapping.
        """
        return pulumi.get(self, "page_field_mappings")

    @page_field_mappings.setter
    def page_field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluencePageToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "page_field_mappings", value)


@pulumi.input_type
class DataSourceConfluencePageToIndexFieldMappingArgs:
    def __init__(__self__, *,
                 data_source_field_name: pulumi.Input['DataSourceConfluencePageFieldName'],
                 index_field_name: pulumi.Input[str],
                 date_field_format: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "data_source_field_name", data_source_field_name)
        pulumi.set(__self__, "index_field_name", index_field_name)
        if date_field_format is not None:
            pulumi.set(__self__, "date_field_format", date_field_format)

    @property
    @pulumi.getter(name="dataSourceFieldName")
    def data_source_field_name(self) -> pulumi.Input['DataSourceConfluencePageFieldName']:
        return pulumi.get(self, "data_source_field_name")

    @data_source_field_name.setter
    def data_source_field_name(self, value: pulumi.Input['DataSourceConfluencePageFieldName']):
        pulumi.set(self, "data_source_field_name", value)

    @property
    @pulumi.getter(name="indexFieldName")
    def index_field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index_field_name")

    @index_field_name.setter
    def index_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_field_name", value)

    @property
    @pulumi.getter(name="dateFieldFormat")
    def date_field_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_field_format")

    @date_field_format.setter
    def date_field_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_field_format", value)


@pulumi.input_type
class DataSourceConfluenceSpaceConfigurationArgs:
    def __init__(__self__, *,
                 crawl_archived_spaces: Optional[pulumi.Input[bool]] = None,
                 crawl_personal_spaces: Optional[pulumi.Input[bool]] = None,
                 exclude_spaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_spaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 space_field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceSpaceToIndexFieldMappingArgs']]]] = None):
        """
        :param pulumi.Input[bool] crawl_archived_spaces: `TRUE` to index archived spaces.
        :param pulumi.Input[bool] crawl_personal_spaces: `TRUE` to index personal spaces. You can add restrictions to items in personal spaces. If personal spaces are indexed, queries without user context information may return restricted items from a personal space in their results. For more information, see [Filtering on user context](https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html) .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_spaces: A list of space keys of Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are not indexed. If a space is in both the `ExcludeSpaces` and the `IncludeSpaces` list, the space is excluded.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_spaces: A list of space keys for Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are indexed. Spaces that aren't in the list aren't indexed. A space in the list must exist. Otherwise, Amazon Kendra logs an error when the data source is synchronized. If a space is in both the `IncludeSpaces` and the `ExcludeSpaces` list, the space is excluded.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceSpaceToIndexFieldMappingArgs']]] space_field_mappings: Maps attributes or field names of Confluence spaces to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Confluence fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Confluence data source field names must exist in your Confluence custom metadata.
               
               If you specify the `SpaceFieldMappings` parameter, you must specify at least one field mapping.
        """
        if crawl_archived_spaces is not None:
            pulumi.set(__self__, "crawl_archived_spaces", crawl_archived_spaces)
        if crawl_personal_spaces is not None:
            pulumi.set(__self__, "crawl_personal_spaces", crawl_personal_spaces)
        if exclude_spaces is not None:
            pulumi.set(__self__, "exclude_spaces", exclude_spaces)
        if include_spaces is not None:
            pulumi.set(__self__, "include_spaces", include_spaces)
        if space_field_mappings is not None:
            pulumi.set(__self__, "space_field_mappings", space_field_mappings)

    @property
    @pulumi.getter(name="crawlArchivedSpaces")
    def crawl_archived_spaces(self) -> Optional[pulumi.Input[bool]]:
        """
        `TRUE` to index archived spaces.
        """
        return pulumi.get(self, "crawl_archived_spaces")

    @crawl_archived_spaces.setter
    def crawl_archived_spaces(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "crawl_archived_spaces", value)

    @property
    @pulumi.getter(name="crawlPersonalSpaces")
    def crawl_personal_spaces(self) -> Optional[pulumi.Input[bool]]:
        """
        `TRUE` to index personal spaces. You can add restrictions to items in personal spaces. If personal spaces are indexed, queries without user context information may return restricted items from a personal space in their results. For more information, see [Filtering on user context](https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html) .
        """
        return pulumi.get(self, "crawl_personal_spaces")

    @crawl_personal_spaces.setter
    def crawl_personal_spaces(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "crawl_personal_spaces", value)

    @property
    @pulumi.getter(name="excludeSpaces")
    def exclude_spaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of space keys of Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are not indexed. If a space is in both the `ExcludeSpaces` and the `IncludeSpaces` list, the space is excluded.
        """
        return pulumi.get(self, "exclude_spaces")

    @exclude_spaces.setter
    def exclude_spaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_spaces", value)

    @property
    @pulumi.getter(name="includeSpaces")
    def include_spaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of space keys for Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are indexed. Spaces that aren't in the list aren't indexed. A space in the list must exist. Otherwise, Amazon Kendra logs an error when the data source is synchronized. If a space is in both the `IncludeSpaces` and the `ExcludeSpaces` list, the space is excluded.
        """
        return pulumi.get(self, "include_spaces")

    @include_spaces.setter
    def include_spaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_spaces", value)

    @property
    @pulumi.getter(name="spaceFieldMappings")
    def space_field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceSpaceToIndexFieldMappingArgs']]]]:
        """
        Maps attributes or field names of Confluence spaces to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Confluence fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Confluence data source field names must exist in your Confluence custom metadata.

        If you specify the `SpaceFieldMappings` parameter, you must specify at least one field mapping.
        """
        return pulumi.get(self, "space_field_mappings")

    @space_field_mappings.setter
    def space_field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceConfluenceSpaceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "space_field_mappings", value)


@pulumi.input_type
class DataSourceConfluenceSpaceToIndexFieldMappingArgs:
    def __init__(__self__, *,
                 data_source_field_name: pulumi.Input['DataSourceConfluenceSpaceFieldName'],
                 index_field_name: pulumi.Input[str],
                 date_field_format: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "data_source_field_name", data_source_field_name)
        pulumi.set(__self__, "index_field_name", index_field_name)
        if date_field_format is not None:
            pulumi.set(__self__, "date_field_format", date_field_format)

    @property
    @pulumi.getter(name="dataSourceFieldName")
    def data_source_field_name(self) -> pulumi.Input['DataSourceConfluenceSpaceFieldName']:
        return pulumi.get(self, "data_source_field_name")

    @data_source_field_name.setter
    def data_source_field_name(self, value: pulumi.Input['DataSourceConfluenceSpaceFieldName']):
        pulumi.set(self, "data_source_field_name", value)

    @property
    @pulumi.getter(name="indexFieldName")
    def index_field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index_field_name")

    @index_field_name.setter
    def index_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_field_name", value)

    @property
    @pulumi.getter(name="dateFieldFormat")
    def date_field_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_field_format")

    @date_field_format.setter
    def date_field_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_field_format", value)


@pulumi.input_type
class DataSourceConnectionConfigurationArgs:
    def __init__(__self__, *,
                 database_host: pulumi.Input[str],
                 database_name: pulumi.Input[str],
                 database_port: pulumi.Input[int],
                 secret_arn: pulumi.Input[str],
                 table_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database_host: The name of the host for the database. Can be either a string (host.subdomain.domain.tld) or an IPv4 or IPv6 address.
        :param pulumi.Input[str] database_name: The name of the database containing the document data.
        :param pulumi.Input[int] database_port: The port that the database uses for connections.
        :param pulumi.Input[str] secret_arn: The Amazon Resource Name (ARN) of an AWS Secrets Manager secret that stores the credentials. The credentials should be a user-password pair. For more information, see [Using a Database Data Source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-database.html) . For more information about AWS Secrets Manager , see [What Is AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html) in the *AWS Secrets Manager* user guide.
        :param pulumi.Input[str] table_name: The name of the table that contains the document data.
        """
        pulumi.set(__self__, "database_host", database_host)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "database_port", database_port)
        pulumi.set(__self__, "secret_arn", secret_arn)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="databaseHost")
    def database_host(self) -> pulumi.Input[str]:
        """
        The name of the host for the database. Can be either a string (host.subdomain.domain.tld) or an IPv4 or IPv6 address.
        """
        return pulumi.get(self, "database_host")

    @database_host.setter
    def database_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_host", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database containing the document data.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="databasePort")
    def database_port(self) -> pulumi.Input[int]:
        """
        The port that the database uses for connections.
        """
        return pulumi.get(self, "database_port")

    @database_port.setter
    def database_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "database_port", value)

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of an AWS Secrets Manager secret that stores the credentials. The credentials should be a user-password pair. For more information, see [Using a Database Data Source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-database.html) . For more information about AWS Secrets Manager , see [What Is AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html) in the *AWS Secrets Manager* user guide.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_arn", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the table that contains the document data.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class DataSourceCustomDocumentEnrichmentConfigurationArgs:
    def __init__(__self__, *,
                 inline_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceInlineCustomDocumentEnrichmentConfigurationArgs']]]] = None,
                 post_extraction_hook_configuration: Optional[pulumi.Input['DataSourceHookConfigurationArgs']] = None,
                 pre_extraction_hook_configuration: Optional[pulumi.Input['DataSourceHookConfigurationArgs']] = None,
                 role_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceInlineCustomDocumentEnrichmentConfigurationArgs']]] inline_configurations: Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra.
        :param pulumi.Input['DataSourceHookConfigurationArgs'] post_extraction_hook_configuration: Configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Advanced data manipulation](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation) .
        :param pulumi.Input['DataSourceHookConfigurationArgs'] pre_extraction_hook_configuration: Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Advanced data manipulation](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation) .
        :param pulumi.Input[str] role_arn: The Amazon Resource Name (ARN) of an IAM role with permission to run `PreExtractionHookConfiguration` and `PostExtractionHookConfiguration` for altering document metadata and content during the document ingestion process. For more information, see [an IAM roles for Amazon Kendra](https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html) .
        """
        if inline_configurations is not None:
            pulumi.set(__self__, "inline_configurations", inline_configurations)
        if post_extraction_hook_configuration is not None:
            pulumi.set(__self__, "post_extraction_hook_configuration", post_extraction_hook_configuration)
        if pre_extraction_hook_configuration is not None:
            pulumi.set(__self__, "pre_extraction_hook_configuration", pre_extraction_hook_configuration)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="inlineConfigurations")
    def inline_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceInlineCustomDocumentEnrichmentConfigurationArgs']]]]:
        """
        Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra.
        """
        return pulumi.get(self, "inline_configurations")

    @inline_configurations.setter
    def inline_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceInlineCustomDocumentEnrichmentConfigurationArgs']]]]):
        pulumi.set(self, "inline_configurations", value)

    @property
    @pulumi.getter(name="postExtractionHookConfiguration")
    def post_extraction_hook_configuration(self) -> Optional[pulumi.Input['DataSourceHookConfigurationArgs']]:
        """
        Configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Advanced data manipulation](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation) .
        """
        return pulumi.get(self, "post_extraction_hook_configuration")

    @post_extraction_hook_configuration.setter
    def post_extraction_hook_configuration(self, value: Optional[pulumi.Input['DataSourceHookConfigurationArgs']]):
        pulumi.set(self, "post_extraction_hook_configuration", value)

    @property
    @pulumi.getter(name="preExtractionHookConfiguration")
    def pre_extraction_hook_configuration(self) -> Optional[pulumi.Input['DataSourceHookConfigurationArgs']]:
        """
        Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Advanced data manipulation](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation) .
        """
        return pulumi.get(self, "pre_extraction_hook_configuration")

    @pre_extraction_hook_configuration.setter
    def pre_extraction_hook_configuration(self, value: Optional[pulumi.Input['DataSourceHookConfigurationArgs']]):
        pulumi.set(self, "pre_extraction_hook_configuration", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of an IAM role with permission to run `PreExtractionHookConfiguration` and `PostExtractionHookConfiguration` for altering document metadata and content during the document ingestion process. For more information, see [an IAM roles for Amazon Kendra](https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html) .
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)


@pulumi.input_type
class DataSourceDatabaseConfigurationArgs:
    def __init__(__self__, *,
                 column_configuration: pulumi.Input['DataSourceColumnConfigurationArgs'],
                 connection_configuration: pulumi.Input['DataSourceConnectionConfigurationArgs'],
                 database_engine_type: pulumi.Input['DataSourceDatabaseEngineType'],
                 acl_configuration: Optional[pulumi.Input['DataSourceAclConfigurationArgs']] = None,
                 sql_configuration: Optional[pulumi.Input['DataSourceSqlConfigurationArgs']] = None,
                 vpc_configuration: Optional[pulumi.Input['DataSourceVpcConfigurationArgs']] = None):
        """
        :param pulumi.Input['DataSourceColumnConfigurationArgs'] column_configuration: Information about where the index should get the document information from the database.
        :param pulumi.Input['DataSourceConnectionConfigurationArgs'] connection_configuration: Configuration information that's required to connect to a database.
        :param pulumi.Input['DataSourceDatabaseEngineType'] database_engine_type: The type of database engine that runs the database.
        :param pulumi.Input['DataSourceAclConfigurationArgs'] acl_configuration: Information about the database column that provides information for user context filtering.
        :param pulumi.Input['DataSourceSqlConfigurationArgs'] sql_configuration: Provides information about how Amazon Kendra uses quote marks around SQL identifiers when querying a database data source.
        :param pulumi.Input['DataSourceVpcConfigurationArgs'] vpc_configuration: Provides information for connecting to an Amazon VPC.
        """
        pulumi.set(__self__, "column_configuration", column_configuration)
        pulumi.set(__self__, "connection_configuration", connection_configuration)
        pulumi.set(__self__, "database_engine_type", database_engine_type)
        if acl_configuration is not None:
            pulumi.set(__self__, "acl_configuration", acl_configuration)
        if sql_configuration is not None:
            pulumi.set(__self__, "sql_configuration", sql_configuration)
        if vpc_configuration is not None:
            pulumi.set(__self__, "vpc_configuration", vpc_configuration)

    @property
    @pulumi.getter(name="columnConfiguration")
    def column_configuration(self) -> pulumi.Input['DataSourceColumnConfigurationArgs']:
        """
        Information about where the index should get the document information from the database.
        """
        return pulumi.get(self, "column_configuration")

    @column_configuration.setter
    def column_configuration(self, value: pulumi.Input['DataSourceColumnConfigurationArgs']):
        pulumi.set(self, "column_configuration", value)

    @property
    @pulumi.getter(name="connectionConfiguration")
    def connection_configuration(self) -> pulumi.Input['DataSourceConnectionConfigurationArgs']:
        """
        Configuration information that's required to connect to a database.
        """
        return pulumi.get(self, "connection_configuration")

    @connection_configuration.setter
    def connection_configuration(self, value: pulumi.Input['DataSourceConnectionConfigurationArgs']):
        pulumi.set(self, "connection_configuration", value)

    @property
    @pulumi.getter(name="databaseEngineType")
    def database_engine_type(self) -> pulumi.Input['DataSourceDatabaseEngineType']:
        """
        The type of database engine that runs the database.
        """
        return pulumi.get(self, "database_engine_type")

    @database_engine_type.setter
    def database_engine_type(self, value: pulumi.Input['DataSourceDatabaseEngineType']):
        pulumi.set(self, "database_engine_type", value)

    @property
    @pulumi.getter(name="aclConfiguration")
    def acl_configuration(self) -> Optional[pulumi.Input['DataSourceAclConfigurationArgs']]:
        """
        Information about the database column that provides information for user context filtering.
        """
        return pulumi.get(self, "acl_configuration")

    @acl_configuration.setter
    def acl_configuration(self, value: Optional[pulumi.Input['DataSourceAclConfigurationArgs']]):
        pulumi.set(self, "acl_configuration", value)

    @property
    @pulumi.getter(name="sqlConfiguration")
    def sql_configuration(self) -> Optional[pulumi.Input['DataSourceSqlConfigurationArgs']]:
        """
        Provides information about how Amazon Kendra uses quote marks around SQL identifiers when querying a database data source.
        """
        return pulumi.get(self, "sql_configuration")

    @sql_configuration.setter
    def sql_configuration(self, value: Optional[pulumi.Input['DataSourceSqlConfigurationArgs']]):
        pulumi.set(self, "sql_configuration", value)

    @property
    @pulumi.getter(name="vpcConfiguration")
    def vpc_configuration(self) -> Optional[pulumi.Input['DataSourceVpcConfigurationArgs']]:
        """
        Provides information for connecting to an Amazon VPC.
        """
        return pulumi.get(self, "vpc_configuration")

    @vpc_configuration.setter
    def vpc_configuration(self, value: Optional[pulumi.Input['DataSourceVpcConfigurationArgs']]):
        pulumi.set(self, "vpc_configuration", value)


@pulumi.input_type
class DataSourceDocumentAttributeConditionArgs:
    def __init__(__self__, *,
                 condition_document_attribute_key: pulumi.Input[str],
                 operator: pulumi.Input['DataSourceConditionOperator'],
                 condition_on_value: Optional[pulumi.Input['DataSourceDocumentAttributeValueArgs']] = None):
        """
        :param pulumi.Input[str] condition_document_attribute_key: The identifier of the document attribute used for the condition.
               
               For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.
               
               Amazon Kendra currently does not support `_document_body` as an attribute key used for the condition.
        :param pulumi.Input['DataSourceConditionOperator'] operator: The condition operator.
               
               For example, you can use 'Contains' to partially match a string.
        :param pulumi.Input['DataSourceDocumentAttributeValueArgs'] condition_on_value: The value used by the operator.
               
               For example, you can specify the value 'financial' for strings in the 'Source_URI' field that partially match or contain this value.
        """
        pulumi.set(__self__, "condition_document_attribute_key", condition_document_attribute_key)
        pulumi.set(__self__, "operator", operator)
        if condition_on_value is not None:
            pulumi.set(__self__, "condition_on_value", condition_on_value)

    @property
    @pulumi.getter(name="conditionDocumentAttributeKey")
    def condition_document_attribute_key(self) -> pulumi.Input[str]:
        """
        The identifier of the document attribute used for the condition.

        For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.

        Amazon Kendra currently does not support `_document_body` as an attribute key used for the condition.
        """
        return pulumi.get(self, "condition_document_attribute_key")

    @condition_document_attribute_key.setter
    def condition_document_attribute_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_document_attribute_key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['DataSourceConditionOperator']:
        """
        The condition operator.

        For example, you can use 'Contains' to partially match a string.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['DataSourceConditionOperator']):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="conditionOnValue")
    def condition_on_value(self) -> Optional[pulumi.Input['DataSourceDocumentAttributeValueArgs']]:
        """
        The value used by the operator.

        For example, you can specify the value 'financial' for strings in the 'Source_URI' field that partially match or contain this value.
        """
        return pulumi.get(self, "condition_on_value")

    @condition_on_value.setter
    def condition_on_value(self, value: Optional[pulumi.Input['DataSourceDocumentAttributeValueArgs']]):
        pulumi.set(self, "condition_on_value", value)


@pulumi.input_type
class DataSourceDocumentAttributeTargetArgs:
    def __init__(__self__, *,
                 target_document_attribute_key: pulumi.Input[str],
                 target_document_attribute_value: Optional[pulumi.Input['DataSourceDocumentAttributeValueArgs']] = None,
                 target_document_attribute_value_deletion: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "target_document_attribute_key", target_document_attribute_key)
        if target_document_attribute_value is not None:
            pulumi.set(__self__, "target_document_attribute_value", target_document_attribute_value)
        if target_document_attribute_value_deletion is not None:
            pulumi.set(__self__, "target_document_attribute_value_deletion", target_document_attribute_value_deletion)

    @property
    @pulumi.getter(name="targetDocumentAttributeKey")
    def target_document_attribute_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "target_document_attribute_key")

    @target_document_attribute_key.setter
    def target_document_attribute_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_document_attribute_key", value)

    @property
    @pulumi.getter(name="targetDocumentAttributeValue")
    def target_document_attribute_value(self) -> Optional[pulumi.Input['DataSourceDocumentAttributeValueArgs']]:
        return pulumi.get(self, "target_document_attribute_value")

    @target_document_attribute_value.setter
    def target_document_attribute_value(self, value: Optional[pulumi.Input['DataSourceDocumentAttributeValueArgs']]):
        pulumi.set(self, "target_document_attribute_value", value)

    @property
    @pulumi.getter(name="targetDocumentAttributeValueDeletion")
    def target_document_attribute_value_deletion(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "target_document_attribute_value_deletion")

    @target_document_attribute_value_deletion.setter
    def target_document_attribute_value_deletion(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "target_document_attribute_value_deletion", value)


@pulumi.input_type
class DataSourceDocumentAttributeValueArgs:
    def __init__(__self__, *,
                 date_value: Optional[pulumi.Input[str]] = None,
                 long_value: Optional[pulumi.Input[int]] = None,
                 string_list_value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 string_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] date_value: A date expressed as an ISO 8601 string.
               
               It is important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.
        :param pulumi.Input[int] long_value: A long integer value.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] string_list_value: A list of strings. The default maximum length or number of strings is 10.
        :param pulumi.Input[str] string_value: A string, such as "department".
        """
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if long_value is not None:
            pulumi.set(__self__, "long_value", long_value)
        if string_list_value is not None:
            pulumi.set(__self__, "string_list_value", string_list_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input[str]]:
        """
        A date expressed as an ISO 8601 string.

        It is important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="longValue")
    def long_value(self) -> Optional[pulumi.Input[int]]:
        """
        A long integer value.
        """
        return pulumi.get(self, "long_value")

    @long_value.setter
    def long_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "long_value", value)

    @property
    @pulumi.getter(name="stringListValue")
    def string_list_value(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of strings. The default maximum length or number of strings is 10.
        """
        return pulumi.get(self, "string_list_value")

    @string_list_value.setter
    def string_list_value(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_list_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string, such as "department".
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)


@pulumi.input_type
class DataSourceDocumentsMetadataConfigurationArgs:
    def __init__(__self__, *,
                 s3_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] s3_prefix: A prefix used to filter metadata configuration files in the AWS S3 bucket. The S3 bucket might contain multiple metadata files. Use `S3Prefix` to include only the desired metadata files.
        """
        if s3_prefix is not None:
            pulumi.set(__self__, "s3_prefix", s3_prefix)

    @property
    @pulumi.getter(name="s3Prefix")
    def s3_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        A prefix used to filter metadata configuration files in the AWS S3 bucket. The S3 bucket might contain multiple metadata files. Use `S3Prefix` to include only the desired metadata files.
        """
        return pulumi.get(self, "s3_prefix")

    @s3_prefix.setter
    def s3_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_prefix", value)


@pulumi.input_type
class DataSourceGoogleDriveConfigurationArgs:
    def __init__(__self__, *,
                 secret_arn: pulumi.Input[str],
                 exclude_mime_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_shared_drives: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_user_accounts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None,
                 inclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] secret_arn: The Amazon Resource Name (ARN) of a AWS Secrets Manager secret that contains the credentials required to connect to Google Drive. For more information, see [Using a Google Workspace Drive data source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html) .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_mime_types: A list of MIME types to exclude from the index. All documents matching the specified MIME type are excluded.
               
               For a list of MIME types, see [Using a Google Workspace Drive data source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html) .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_shared_drives: A list of identifiers or shared drives to exclude from the index. All files and folders stored on the shared drive are excluded.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_user_accounts: A list of email addresses of the users. Documents owned by these users are excluded from the index. Documents shared with excluded users are indexed unless they are excluded in another way.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclusion_patterns: A list of regular expression patterns to exclude certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]] field_mappings: Maps Google Drive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Google Drive fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Google Drive data source field names must exist in your Google Drive custom metadata.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_patterns: A list of regular expression patterns to include certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.
        """
        pulumi.set(__self__, "secret_arn", secret_arn)
        if exclude_mime_types is not None:
            pulumi.set(__self__, "exclude_mime_types", exclude_mime_types)
        if exclude_shared_drives is not None:
            pulumi.set(__self__, "exclude_shared_drives", exclude_shared_drives)
        if exclude_user_accounts is not None:
            pulumi.set(__self__, "exclude_user_accounts", exclude_user_accounts)
        if exclusion_patterns is not None:
            pulumi.set(__self__, "exclusion_patterns", exclusion_patterns)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)
        if inclusion_patterns is not None:
            pulumi.set(__self__, "inclusion_patterns", inclusion_patterns)

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of a AWS Secrets Manager secret that contains the credentials required to connect to Google Drive. For more information, see [Using a Google Workspace Drive data source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html) .
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_arn", value)

    @property
    @pulumi.getter(name="excludeMimeTypes")
    def exclude_mime_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of MIME types to exclude from the index. All documents matching the specified MIME type are excluded.

        For a list of MIME types, see [Using a Google Workspace Drive data source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html) .
        """
        return pulumi.get(self, "exclude_mime_types")

    @exclude_mime_types.setter
    def exclude_mime_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_mime_types", value)

    @property
    @pulumi.getter(name="excludeSharedDrives")
    def exclude_shared_drives(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of identifiers or shared drives to exclude from the index. All files and folders stored on the shared drive are excluded.
        """
        return pulumi.get(self, "exclude_shared_drives")

    @exclude_shared_drives.setter
    def exclude_shared_drives(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_shared_drives", value)

    @property
    @pulumi.getter(name="excludeUserAccounts")
    def exclude_user_accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of email addresses of the users. Documents owned by these users are excluded from the index. Documents shared with excluded users are indexed unless they are excluded in another way.
        """
        return pulumi.get(self, "exclude_user_accounts")

    @exclude_user_accounts.setter
    def exclude_user_accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_user_accounts", value)

    @property
    @pulumi.getter(name="exclusionPatterns")
    def exclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to exclude certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.
        """
        return pulumi.get(self, "exclusion_patterns")

    @exclusion_patterns.setter
    def exclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_patterns", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        """
        Maps Google Drive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Google Drive fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Google Drive data source field names must exist in your Google Drive custom metadata.
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)

    @property
    @pulumi.getter(name="inclusionPatterns")
    def inclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to include certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.
        """
        return pulumi.get(self, "inclusion_patterns")

    @inclusion_patterns.setter
    def inclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_patterns", value)


@pulumi.input_type
class DataSourceHookConfigurationArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[str],
                 s3_bucket: pulumi.Input[str],
                 invocation_condition: Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']] = None):
        """
        :param pulumi.Input[str] lambda_arn: The Amazon Resource Name (ARN) of an IAM role with permission to run a Lambda function during ingestion. For more information, see [an IAM roles for Amazon Kendra](https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html) .
        :param pulumi.Input[str] s3_bucket: Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see [Data contracts for Lambda functions](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#cde-data-contracts-lambda) .
        :param pulumi.Input['DataSourceDocumentAttributeConditionArgs'] invocation_condition: The condition used for when a Lambda function should be invoked.
               
               For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        pulumi.set(__self__, "s3_bucket", s3_bucket)
        if invocation_condition is not None:
            pulumi.set(__self__, "invocation_condition", invocation_condition)

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of an IAM role with permission to run a Lambda function during ingestion. For more information, see [an IAM roles for Amazon Kendra](https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html) .
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "lambda_arn", value)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input[str]:
        """
        Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see [Data contracts for Lambda functions](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#cde-data-contracts-lambda) .
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket", value)

    @property
    @pulumi.getter(name="invocationCondition")
    def invocation_condition(self) -> Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']]:
        """
        The condition used for when a Lambda function should be invoked.

        For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time.
        """
        return pulumi.get(self, "invocation_condition")

    @invocation_condition.setter
    def invocation_condition(self, value: Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']]):
        pulumi.set(self, "invocation_condition", value)


@pulumi.input_type
class DataSourceInlineCustomDocumentEnrichmentConfigurationArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']] = None,
                 document_content_deletion: Optional[pulumi.Input[bool]] = None,
                 target: Optional[pulumi.Input['DataSourceDocumentAttributeTargetArgs']] = None):
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if document_content_deletion is not None:
            pulumi.set(__self__, "document_content_deletion", document_content_deletion)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="documentContentDeletion")
    def document_content_deletion(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "document_content_deletion")

    @document_content_deletion.setter
    def document_content_deletion(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "document_content_deletion", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['DataSourceDocumentAttributeTargetArgs']]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['DataSourceDocumentAttributeTargetArgs']]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class DataSourceOneDriveConfigurationArgs:
    def __init__(__self__, *,
                 one_drive_users: pulumi.Input['DataSourceOneDriveUsersArgs'],
                 secret_arn: pulumi.Input[str],
                 tenant_domain: pulumi.Input[str],
                 disable_local_groups: Optional[pulumi.Input[bool]] = None,
                 exclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None,
                 inclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['DataSourceOneDriveUsersArgs'] one_drive_users: A list of user accounts whose documents should be indexed.
        :param pulumi.Input[str] secret_arn: The Amazon Resource Name (ARN) of an AWS Secrets Manager secret that contains the user name and password to connect to OneDrive. The user name should be the application ID for the OneDrive application, and the password is the application key for the OneDrive application.
        :param pulumi.Input[str] tenant_domain: The Azure Active Directory domain of the organization.
        :param pulumi.Input[bool] disable_local_groups: `TRUE` to disable local groups information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclusion_patterns: A list of regular expression patterns to exclude certain documents in your OneDrive. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.
               
               The pattern is applied to the file name.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]] field_mappings: A list of `DataSourceToIndexFieldMapping` objects that map OneDrive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to OneDrive fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The OneDrive data source field names must exist in your OneDrive custom metadata.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_patterns: A list of regular expression patterns to include certain documents in your OneDrive. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.
               
               The pattern is applied to the file name.
        """
        pulumi.set(__self__, "one_drive_users", one_drive_users)
        pulumi.set(__self__, "secret_arn", secret_arn)
        pulumi.set(__self__, "tenant_domain", tenant_domain)
        if disable_local_groups is not None:
            pulumi.set(__self__, "disable_local_groups", disable_local_groups)
        if exclusion_patterns is not None:
            pulumi.set(__self__, "exclusion_patterns", exclusion_patterns)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)
        if inclusion_patterns is not None:
            pulumi.set(__self__, "inclusion_patterns", inclusion_patterns)

    @property
    @pulumi.getter(name="oneDriveUsers")
    def one_drive_users(self) -> pulumi.Input['DataSourceOneDriveUsersArgs']:
        """
        A list of user accounts whose documents should be indexed.
        """
        return pulumi.get(self, "one_drive_users")

    @one_drive_users.setter
    def one_drive_users(self, value: pulumi.Input['DataSourceOneDriveUsersArgs']):
        pulumi.set(self, "one_drive_users", value)

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of an AWS Secrets Manager secret that contains the user name and password to connect to OneDrive. The user name should be the application ID for the OneDrive application, and the password is the application key for the OneDrive application.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_arn", value)

    @property
    @pulumi.getter(name="tenantDomain")
    def tenant_domain(self) -> pulumi.Input[str]:
        """
        The Azure Active Directory domain of the organization.
        """
        return pulumi.get(self, "tenant_domain")

    @tenant_domain.setter
    def tenant_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_domain", value)

    @property
    @pulumi.getter(name="disableLocalGroups")
    def disable_local_groups(self) -> Optional[pulumi.Input[bool]]:
        """
        `TRUE` to disable local groups information.
        """
        return pulumi.get(self, "disable_local_groups")

    @disable_local_groups.setter
    def disable_local_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_groups", value)

    @property
    @pulumi.getter(name="exclusionPatterns")
    def exclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to exclude certain documents in your OneDrive. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.

        The pattern is applied to the file name.
        """
        return pulumi.get(self, "exclusion_patterns")

    @exclusion_patterns.setter
    def exclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_patterns", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        """
        A list of `DataSourceToIndexFieldMapping` objects that map OneDrive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to OneDrive fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The OneDrive data source field names must exist in your OneDrive custom metadata.
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)

    @property
    @pulumi.getter(name="inclusionPatterns")
    def inclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to include certain documents in your OneDrive. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.

        The pattern is applied to the file name.
        """
        return pulumi.get(self, "inclusion_patterns")

    @inclusion_patterns.setter
    def inclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_patterns", value)


@pulumi.input_type
class DataSourceOneDriveUsersArgs:
    def __init__(__self__, *,
                 one_drive_user_list: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 one_drive_user_s3_path: Optional[pulumi.Input['DataSourceS3PathArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] one_drive_user_list: A list of users whose documents should be indexed. Specify the user names in email format, for example, `username@tenantdomain` . If you need to index the documents of more than 10 users, use the `OneDriveUserS3Path` field to specify the location of a file containing a list of users.
        :param pulumi.Input['DataSourceS3PathArgs'] one_drive_user_s3_path: The S3 bucket location of a file containing a list of users whose documents should be indexed.
        """
        if one_drive_user_list is not None:
            pulumi.set(__self__, "one_drive_user_list", one_drive_user_list)
        if one_drive_user_s3_path is not None:
            pulumi.set(__self__, "one_drive_user_s3_path", one_drive_user_s3_path)

    @property
    @pulumi.getter(name="oneDriveUserList")
    def one_drive_user_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of users whose documents should be indexed. Specify the user names in email format, for example, `username@tenantdomain` . If you need to index the documents of more than 10 users, use the `OneDriveUserS3Path` field to specify the location of a file containing a list of users.
        """
        return pulumi.get(self, "one_drive_user_list")

    @one_drive_user_list.setter
    def one_drive_user_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "one_drive_user_list", value)

    @property
    @pulumi.getter(name="oneDriveUserS3Path")
    def one_drive_user_s3_path(self) -> Optional[pulumi.Input['DataSourceS3PathArgs']]:
        """
        The S3 bucket location of a file containing a list of users whose documents should be indexed.
        """
        return pulumi.get(self, "one_drive_user_s3_path")

    @one_drive_user_s3_path.setter
    def one_drive_user_s3_path(self, value: Optional[pulumi.Input['DataSourceS3PathArgs']]):
        pulumi.set(self, "one_drive_user_s3_path", value)


@pulumi.input_type
class DataSourceProxyConfigurationArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 port: pulumi.Input[int],
                 credentials: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The name of the website host you want to connect to via a web proxy server.
               
               For example, the host name of https://a.example.com/page1.html is "a.example.com".
        :param pulumi.Input[int] port: The port number of the website host you want to connect to via a web proxy server.
               
               For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.
        :param pulumi.Input[str] credentials: The Amazon Resource Name (ARN) of an AWS Secrets Manager secret. You create a secret to store your credentials in [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html)
               
               The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The name of the website host you want to connect to via a web proxy server.

        For example, the host name of https://a.example.com/page1.html is "a.example.com".
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port number of the website host you want to connect to via a web proxy server.

        For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of an AWS Secrets Manager secret. You create a secret to store your credentials in [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html)

        The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class DataSourceS3DataSourceConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 access_control_list_configuration: Optional[pulumi.Input['DataSourceAccessControlListConfigurationArgs']] = None,
                 documents_metadata_configuration: Optional[pulumi.Input['DataSourceDocumentsMetadataConfigurationArgs']] = None,
                 exclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 inclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 inclusion_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        S3 data source configuration
        :param pulumi.Input[str] bucket_name: The name of the bucket that contains the documents.
        :param pulumi.Input['DataSourceAccessControlListConfigurationArgs'] access_control_list_configuration: Provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see [Access control for S3 data sources](https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html) .
        :param pulumi.Input['DataSourceDocumentsMetadataConfigurationArgs'] documents_metadata_configuration: Specifies document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclusion_patterns: A list of glob patterns (patterns that can expand a wildcard pattern into a list of path names that match the given pattern) for certain file names and file types to exclude from your index. If a document matches both an inclusion and exclusion prefix or pattern, the exclusion prefix takes precendence and the document is not indexed. Examples of glob patterns include:
               
               - */myapp/config/** —All files inside config directory.
               - ***/*.png* —All .png files in all directories.
               - ***/*.{png, ico, md}* —All .png, .ico or .md files in all directories.
               - */myapp/src/**/*.ts* —All .ts files inside src directory (and all its subdirectories).
               - ***/!(*.module).ts* —All .ts files but not .module.ts
               - **.png , *.jpg* —All PNG and JPEG image files in a directory (files with the extensions .png and .jpg).
               - **internal** —All files in a directory that contain 'internal' in the file name, such as 'internal', 'internal_only', 'company_internal'.
               - ***/*internal** —All internal-related files in a directory and its subdirectories.
               
               For more examples, see [Use of Exclude and Include Filters](https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters) in the AWS CLI Command Reference.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_patterns: A list of glob patterns (patterns that can expand a wildcard pattern into a list of path names that match the given pattern) for certain file names and file types to include in your index. If a document matches both an inclusion and exclusion prefix or pattern, the exclusion prefix takes precendence and the document is not indexed. Examples of glob patterns include:
               
               - */myapp/config/** —All files inside config directory.
               - ***/*.png* —All .png files in all directories.
               - ***/*.{png, ico, md}* —All .png, .ico or .md files in all directories.
               - */myapp/src/**/*.ts* —All .ts files inside src directory (and all its subdirectories).
               - ***/!(*.module).ts* —All .ts files but not .module.ts
               - **.png , *.jpg* —All PNG and JPEG image files in a directory (files with the extensions .png and .jpg).
               - **internal** —All files in a directory that contain 'internal' in the file name, such as 'internal', 'internal_only', 'company_internal'.
               - ***/*internal** —All internal-related files in a directory and its subdirectories.
               
               For more examples, see [Use of Exclude and Include Filters](https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters) in the AWS CLI Command Reference.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_prefixes: A list of S3 prefixes for the documents that should be included in the index.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if access_control_list_configuration is not None:
            pulumi.set(__self__, "access_control_list_configuration", access_control_list_configuration)
        if documents_metadata_configuration is not None:
            pulumi.set(__self__, "documents_metadata_configuration", documents_metadata_configuration)
        if exclusion_patterns is not None:
            pulumi.set(__self__, "exclusion_patterns", exclusion_patterns)
        if inclusion_patterns is not None:
            pulumi.set(__self__, "inclusion_patterns", inclusion_patterns)
        if inclusion_prefixes is not None:
            pulumi.set(__self__, "inclusion_prefixes", inclusion_prefixes)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the bucket that contains the documents.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="accessControlListConfiguration")
    def access_control_list_configuration(self) -> Optional[pulumi.Input['DataSourceAccessControlListConfigurationArgs']]:
        """
        Provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see [Access control for S3 data sources](https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html) .
        """
        return pulumi.get(self, "access_control_list_configuration")

    @access_control_list_configuration.setter
    def access_control_list_configuration(self, value: Optional[pulumi.Input['DataSourceAccessControlListConfigurationArgs']]):
        pulumi.set(self, "access_control_list_configuration", value)

    @property
    @pulumi.getter(name="documentsMetadataConfiguration")
    def documents_metadata_configuration(self) -> Optional[pulumi.Input['DataSourceDocumentsMetadataConfigurationArgs']]:
        """
        Specifies document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document.
        """
        return pulumi.get(self, "documents_metadata_configuration")

    @documents_metadata_configuration.setter
    def documents_metadata_configuration(self, value: Optional[pulumi.Input['DataSourceDocumentsMetadataConfigurationArgs']]):
        pulumi.set(self, "documents_metadata_configuration", value)

    @property
    @pulumi.getter(name="exclusionPatterns")
    def exclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of glob patterns (patterns that can expand a wildcard pattern into a list of path names that match the given pattern) for certain file names and file types to exclude from your index. If a document matches both an inclusion and exclusion prefix or pattern, the exclusion prefix takes precendence and the document is not indexed. Examples of glob patterns include:

        - */myapp/config/** —All files inside config directory.
        - ***/*.png* —All .png files in all directories.
        - ***/*.{png, ico, md}* —All .png, .ico or .md files in all directories.
        - */myapp/src/**/*.ts* —All .ts files inside src directory (and all its subdirectories).
        - ***/!(*.module).ts* —All .ts files but not .module.ts
        - **.png , *.jpg* —All PNG and JPEG image files in a directory (files with the extensions .png and .jpg).
        - **internal** —All files in a directory that contain 'internal' in the file name, such as 'internal', 'internal_only', 'company_internal'.
        - ***/*internal** —All internal-related files in a directory and its subdirectories.

        For more examples, see [Use of Exclude and Include Filters](https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters) in the AWS CLI Command Reference.
        """
        return pulumi.get(self, "exclusion_patterns")

    @exclusion_patterns.setter
    def exclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_patterns", value)

    @property
    @pulumi.getter(name="inclusionPatterns")
    def inclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of glob patterns (patterns that can expand a wildcard pattern into a list of path names that match the given pattern) for certain file names and file types to include in your index. If a document matches both an inclusion and exclusion prefix or pattern, the exclusion prefix takes precendence and the document is not indexed. Examples of glob patterns include:

        - */myapp/config/** —All files inside config directory.
        - ***/*.png* —All .png files in all directories.
        - ***/*.{png, ico, md}* —All .png, .ico or .md files in all directories.
        - */myapp/src/**/*.ts* —All .ts files inside src directory (and all its subdirectories).
        - ***/!(*.module).ts* —All .ts files but not .module.ts
        - **.png , *.jpg* —All PNG and JPEG image files in a directory (files with the extensions .png and .jpg).
        - **internal** —All files in a directory that contain 'internal' in the file name, such as 'internal', 'internal_only', 'company_internal'.
        - ***/*internal** —All internal-related files in a directory and its subdirectories.

        For more examples, see [Use of Exclude and Include Filters](https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters) in the AWS CLI Command Reference.
        """
        return pulumi.get(self, "inclusion_patterns")

    @inclusion_patterns.setter
    def inclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_patterns", value)

    @property
    @pulumi.getter(name="inclusionPrefixes")
    def inclusion_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of S3 prefixes for the documents that should be included in the index.
        """
        return pulumi.get(self, "inclusion_prefixes")

    @inclusion_prefixes.setter
    def inclusion_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_prefixes", value)


@pulumi.input_type
class DataSourceS3PathArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: The name of the S3 bucket that contains the file.
        :param pulumi.Input[str] key: The name of the file.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the S3 bucket that contains the file.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the file.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class DataSourceSalesforceChatterFeedConfigurationArgs:
    def __init__(__self__, *,
                 document_data_field_name: pulumi.Input[str],
                 document_title_field_name: Optional[pulumi.Input[str]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None,
                 include_filter_types: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceChatterFeedIncludeFilterType']]]] = None):
        """
        :param pulumi.Input[str] document_data_field_name: The name of the column in the Salesforce FeedItem table that contains the content to index. Typically this is the `Body` column.
        :param pulumi.Input[str] document_title_field_name: The name of the column in the Salesforce FeedItem table that contains the title of the document. This is typically the `Title` column.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]] field_mappings: Maps fields from a Salesforce chatter feed into Amazon Kendra index fields.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceChatterFeedIncludeFilterType']]] include_filter_types: Filters the documents in the feed based on status of the user. When you specify `ACTIVE_USERS` only documents from users who have an active account are indexed. When you specify `STANDARD_USER` only documents for Salesforce standard users are documented. You can specify both.
        """
        pulumi.set(__self__, "document_data_field_name", document_data_field_name)
        if document_title_field_name is not None:
            pulumi.set(__self__, "document_title_field_name", document_title_field_name)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)
        if include_filter_types is not None:
            pulumi.set(__self__, "include_filter_types", include_filter_types)

    @property
    @pulumi.getter(name="documentDataFieldName")
    def document_data_field_name(self) -> pulumi.Input[str]:
        """
        The name of the column in the Salesforce FeedItem table that contains the content to index. Typically this is the `Body` column.
        """
        return pulumi.get(self, "document_data_field_name")

    @document_data_field_name.setter
    def document_data_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "document_data_field_name", value)

    @property
    @pulumi.getter(name="documentTitleFieldName")
    def document_title_field_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the column in the Salesforce FeedItem table that contains the title of the document. This is typically the `Title` column.
        """
        return pulumi.get(self, "document_title_field_name")

    @document_title_field_name.setter
    def document_title_field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_title_field_name", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        """
        Maps fields from a Salesforce chatter feed into Amazon Kendra index fields.
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)

    @property
    @pulumi.getter(name="includeFilterTypes")
    def include_filter_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceChatterFeedIncludeFilterType']]]]:
        """
        Filters the documents in the feed based on status of the user. When you specify `ACTIVE_USERS` only documents from users who have an active account are indexed. When you specify `STANDARD_USER` only documents for Salesforce standard users are documented. You can specify both.
        """
        return pulumi.get(self, "include_filter_types")

    @include_filter_types.setter
    def include_filter_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceChatterFeedIncludeFilterType']]]]):
        pulumi.set(self, "include_filter_types", value)


@pulumi.input_type
class DataSourceSalesforceConfigurationArgs:
    def __init__(__self__, *,
                 secret_arn: pulumi.Input[str],
                 server_url: pulumi.Input[str],
                 chatter_feed_configuration: Optional[pulumi.Input['DataSourceSalesforceChatterFeedConfigurationArgs']] = None,
                 crawl_attachments: Optional[pulumi.Input[bool]] = None,
                 exclude_attachment_file_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_attachment_file_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 knowledge_article_configuration: Optional[pulumi.Input['DataSourceSalesforceKnowledgeArticleConfigurationArgs']] = None,
                 standard_object_attachment_configuration: Optional[pulumi.Input['DataSourceSalesforceStandardObjectAttachmentConfigurationArgs']] = None,
                 standard_object_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceStandardObjectConfigurationArgs']]]] = None):
        """
        :param pulumi.Input[str] secret_arn: The Amazon Resource Name (ARN) of an AWS Secrets Manager secret that contains the key/value pairs required to connect to your Salesforce instance. The secret must contain a JSON structure with the following keys:
               
               - authenticationUrl - The OAUTH endpoint that Amazon Kendra connects to get an OAUTH token.
               - consumerKey - The application public key generated when you created your Salesforce application.
               - consumerSecret - The application private key generated when you created your Salesforce application.
               - password - The password associated with the user logging in to the Salesforce instance.
               - securityToken - The token associated with the user logging in to the Salesforce instance.
               - username - The user name of the user logging in to the Salesforce instance.
        :param pulumi.Input[str] server_url: The instance URL for the Salesforce site that you want to index.
        :param pulumi.Input['DataSourceSalesforceChatterFeedConfigurationArgs'] chatter_feed_configuration: Configuration information for Salesforce chatter feeds.
        :param pulumi.Input[bool] crawl_attachments: Indicates whether Amazon Kendra should index attachments to Salesforce objects.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_attachment_file_patterns: A list of regular expression patterns to exclude certain documents in your Salesforce. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.
               
               The pattern is applied to the name of the attached file.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_attachment_file_patterns: A list of regular expression patterns to include certain documents in your Salesforce. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.
               
               The pattern is applied to the name of the attached file.
        :param pulumi.Input['DataSourceSalesforceKnowledgeArticleConfigurationArgs'] knowledge_article_configuration: Configuration information for the knowledge article types that Amazon Kendra indexes. Amazon Kendra indexes standard knowledge articles and the standard fields of knowledge articles, or the custom fields of custom knowledge articles, but not both.
        :param pulumi.Input['DataSourceSalesforceStandardObjectAttachmentConfigurationArgs'] standard_object_attachment_configuration: Configuration information for processing attachments to Salesforce standard objects.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceStandardObjectConfigurationArgs']]] standard_object_configurations: Configuration of the Salesforce standard objects that Amazon Kendra indexes.
        """
        pulumi.set(__self__, "secret_arn", secret_arn)
        pulumi.set(__self__, "server_url", server_url)
        if chatter_feed_configuration is not None:
            pulumi.set(__self__, "chatter_feed_configuration", chatter_feed_configuration)
        if crawl_attachments is not None:
            pulumi.set(__self__, "crawl_attachments", crawl_attachments)
        if exclude_attachment_file_patterns is not None:
            pulumi.set(__self__, "exclude_attachment_file_patterns", exclude_attachment_file_patterns)
        if include_attachment_file_patterns is not None:
            pulumi.set(__self__, "include_attachment_file_patterns", include_attachment_file_patterns)
        if knowledge_article_configuration is not None:
            pulumi.set(__self__, "knowledge_article_configuration", knowledge_article_configuration)
        if standard_object_attachment_configuration is not None:
            pulumi.set(__self__, "standard_object_attachment_configuration", standard_object_attachment_configuration)
        if standard_object_configurations is not None:
            pulumi.set(__self__, "standard_object_configurations", standard_object_configurations)

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of an AWS Secrets Manager secret that contains the key/value pairs required to connect to your Salesforce instance. The secret must contain a JSON structure with the following keys:

        - authenticationUrl - The OAUTH endpoint that Amazon Kendra connects to get an OAUTH token.
        - consumerKey - The application public key generated when you created your Salesforce application.
        - consumerSecret - The application private key generated when you created your Salesforce application.
        - password - The password associated with the user logging in to the Salesforce instance.
        - securityToken - The token associated with the user logging in to the Salesforce instance.
        - username - The user name of the user logging in to the Salesforce instance.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_arn", value)

    @property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> pulumi.Input[str]:
        """
        The instance URL for the Salesforce site that you want to index.
        """
        return pulumi.get(self, "server_url")

    @server_url.setter
    def server_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_url", value)

    @property
    @pulumi.getter(name="chatterFeedConfiguration")
    def chatter_feed_configuration(self) -> Optional[pulumi.Input['DataSourceSalesforceChatterFeedConfigurationArgs']]:
        """
        Configuration information for Salesforce chatter feeds.
        """
        return pulumi.get(self, "chatter_feed_configuration")

    @chatter_feed_configuration.setter
    def chatter_feed_configuration(self, value: Optional[pulumi.Input['DataSourceSalesforceChatterFeedConfigurationArgs']]):
        pulumi.set(self, "chatter_feed_configuration", value)

    @property
    @pulumi.getter(name="crawlAttachments")
    def crawl_attachments(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether Amazon Kendra should index attachments to Salesforce objects.
        """
        return pulumi.get(self, "crawl_attachments")

    @crawl_attachments.setter
    def crawl_attachments(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "crawl_attachments", value)

    @property
    @pulumi.getter(name="excludeAttachmentFilePatterns")
    def exclude_attachment_file_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to exclude certain documents in your Salesforce. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.

        The pattern is applied to the name of the attached file.
        """
        return pulumi.get(self, "exclude_attachment_file_patterns")

    @exclude_attachment_file_patterns.setter
    def exclude_attachment_file_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_attachment_file_patterns", value)

    @property
    @pulumi.getter(name="includeAttachmentFilePatterns")
    def include_attachment_file_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to include certain documents in your Salesforce. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.

        The pattern is applied to the name of the attached file.
        """
        return pulumi.get(self, "include_attachment_file_patterns")

    @include_attachment_file_patterns.setter
    def include_attachment_file_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_attachment_file_patterns", value)

    @property
    @pulumi.getter(name="knowledgeArticleConfiguration")
    def knowledge_article_configuration(self) -> Optional[pulumi.Input['DataSourceSalesforceKnowledgeArticleConfigurationArgs']]:
        """
        Configuration information for the knowledge article types that Amazon Kendra indexes. Amazon Kendra indexes standard knowledge articles and the standard fields of knowledge articles, or the custom fields of custom knowledge articles, but not both.
        """
        return pulumi.get(self, "knowledge_article_configuration")

    @knowledge_article_configuration.setter
    def knowledge_article_configuration(self, value: Optional[pulumi.Input['DataSourceSalesforceKnowledgeArticleConfigurationArgs']]):
        pulumi.set(self, "knowledge_article_configuration", value)

    @property
    @pulumi.getter(name="standardObjectAttachmentConfiguration")
    def standard_object_attachment_configuration(self) -> Optional[pulumi.Input['DataSourceSalesforceStandardObjectAttachmentConfigurationArgs']]:
        """
        Configuration information for processing attachments to Salesforce standard objects.
        """
        return pulumi.get(self, "standard_object_attachment_configuration")

    @standard_object_attachment_configuration.setter
    def standard_object_attachment_configuration(self, value: Optional[pulumi.Input['DataSourceSalesforceStandardObjectAttachmentConfigurationArgs']]):
        pulumi.set(self, "standard_object_attachment_configuration", value)

    @property
    @pulumi.getter(name="standardObjectConfigurations")
    def standard_object_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceStandardObjectConfigurationArgs']]]]:
        """
        Configuration of the Salesforce standard objects that Amazon Kendra indexes.
        """
        return pulumi.get(self, "standard_object_configurations")

    @standard_object_configurations.setter
    def standard_object_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceStandardObjectConfigurationArgs']]]]):
        pulumi.set(self, "standard_object_configurations", value)


@pulumi.input_type
class DataSourceSalesforceCustomKnowledgeArticleTypeConfigurationArgs:
    def __init__(__self__, *,
                 document_data_field_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 document_title_field_name: Optional[pulumi.Input[str]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None):
        pulumi.set(__self__, "document_data_field_name", document_data_field_name)
        pulumi.set(__self__, "name", name)
        if document_title_field_name is not None:
            pulumi.set(__self__, "document_title_field_name", document_title_field_name)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)

    @property
    @pulumi.getter(name="documentDataFieldName")
    def document_data_field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "document_data_field_name")

    @document_data_field_name.setter
    def document_data_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "document_data_field_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="documentTitleFieldName")
    def document_title_field_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "document_title_field_name")

    @document_title_field_name.setter
    def document_title_field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_title_field_name", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)


@pulumi.input_type
class DataSourceSalesforceKnowledgeArticleConfigurationArgs:
    def __init__(__self__, *,
                 included_states: pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceKnowledgeArticleState']]],
                 custom_knowledge_article_type_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceCustomKnowledgeArticleTypeConfigurationArgs']]]] = None,
                 standard_knowledge_article_type_configuration: Optional[pulumi.Input['DataSourceSalesforceStandardKnowledgeArticleTypeConfigurationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceKnowledgeArticleState']]] included_states: Specifies the document states that should be included when Amazon Kendra indexes knowledge articles. You must specify at least one state.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceCustomKnowledgeArticleTypeConfigurationArgs']]] custom_knowledge_article_type_configurations: Configuration information for custom Salesforce knowledge articles.
        :param pulumi.Input['DataSourceSalesforceStandardKnowledgeArticleTypeConfigurationArgs'] standard_knowledge_article_type_configuration: Configuration information for standard Salesforce knowledge articles.
        """
        pulumi.set(__self__, "included_states", included_states)
        if custom_knowledge_article_type_configurations is not None:
            pulumi.set(__self__, "custom_knowledge_article_type_configurations", custom_knowledge_article_type_configurations)
        if standard_knowledge_article_type_configuration is not None:
            pulumi.set(__self__, "standard_knowledge_article_type_configuration", standard_knowledge_article_type_configuration)

    @property
    @pulumi.getter(name="includedStates")
    def included_states(self) -> pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceKnowledgeArticleState']]]:
        """
        Specifies the document states that should be included when Amazon Kendra indexes knowledge articles. You must specify at least one state.
        """
        return pulumi.get(self, "included_states")

    @included_states.setter
    def included_states(self, value: pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceKnowledgeArticleState']]]):
        pulumi.set(self, "included_states", value)

    @property
    @pulumi.getter(name="customKnowledgeArticleTypeConfigurations")
    def custom_knowledge_article_type_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceCustomKnowledgeArticleTypeConfigurationArgs']]]]:
        """
        Configuration information for custom Salesforce knowledge articles.
        """
        return pulumi.get(self, "custom_knowledge_article_type_configurations")

    @custom_knowledge_article_type_configurations.setter
    def custom_knowledge_article_type_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceSalesforceCustomKnowledgeArticleTypeConfigurationArgs']]]]):
        pulumi.set(self, "custom_knowledge_article_type_configurations", value)

    @property
    @pulumi.getter(name="standardKnowledgeArticleTypeConfiguration")
    def standard_knowledge_article_type_configuration(self) -> Optional[pulumi.Input['DataSourceSalesforceStandardKnowledgeArticleTypeConfigurationArgs']]:
        """
        Configuration information for standard Salesforce knowledge articles.
        """
        return pulumi.get(self, "standard_knowledge_article_type_configuration")

    @standard_knowledge_article_type_configuration.setter
    def standard_knowledge_article_type_configuration(self, value: Optional[pulumi.Input['DataSourceSalesforceStandardKnowledgeArticleTypeConfigurationArgs']]):
        pulumi.set(self, "standard_knowledge_article_type_configuration", value)


@pulumi.input_type
class DataSourceSalesforceStandardKnowledgeArticleTypeConfigurationArgs:
    def __init__(__self__, *,
                 document_data_field_name: pulumi.Input[str],
                 document_title_field_name: Optional[pulumi.Input[str]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None):
        """
        :param pulumi.Input[str] document_data_field_name: The name of the field that contains the document data to index.
        :param pulumi.Input[str] document_title_field_name: The name of the field that contains the document title.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]] field_mappings: Maps attributes or field names of the knowledge article to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Salesforce fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Salesforce data source field names must exist in your Salesforce custom metadata.
        """
        pulumi.set(__self__, "document_data_field_name", document_data_field_name)
        if document_title_field_name is not None:
            pulumi.set(__self__, "document_title_field_name", document_title_field_name)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)

    @property
    @pulumi.getter(name="documentDataFieldName")
    def document_data_field_name(self) -> pulumi.Input[str]:
        """
        The name of the field that contains the document data to index.
        """
        return pulumi.get(self, "document_data_field_name")

    @document_data_field_name.setter
    def document_data_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "document_data_field_name", value)

    @property
    @pulumi.getter(name="documentTitleFieldName")
    def document_title_field_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the field that contains the document title.
        """
        return pulumi.get(self, "document_title_field_name")

    @document_title_field_name.setter
    def document_title_field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_title_field_name", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        """
        Maps attributes or field names of the knowledge article to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Salesforce fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Salesforce data source field names must exist in your Salesforce custom metadata.
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)


@pulumi.input_type
class DataSourceSalesforceStandardObjectAttachmentConfigurationArgs:
    def __init__(__self__, *,
                 document_title_field_name: Optional[pulumi.Input[str]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None):
        """
        :param pulumi.Input[str] document_title_field_name: The name of the field used for the document title.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]] field_mappings: One or more objects that map fields in attachments to Amazon Kendra index fields.
        """
        if document_title_field_name is not None:
            pulumi.set(__self__, "document_title_field_name", document_title_field_name)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)

    @property
    @pulumi.getter(name="documentTitleFieldName")
    def document_title_field_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the field used for the document title.
        """
        return pulumi.get(self, "document_title_field_name")

    @document_title_field_name.setter
    def document_title_field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_title_field_name", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        """
        One or more objects that map fields in attachments to Amazon Kendra index fields.
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)


@pulumi.input_type
class DataSourceSalesforceStandardObjectConfigurationArgs:
    def __init__(__self__, *,
                 document_data_field_name: pulumi.Input[str],
                 name: pulumi.Input['DataSourceSalesforceStandardObjectName'],
                 document_title_field_name: Optional[pulumi.Input[str]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None):
        pulumi.set(__self__, "document_data_field_name", document_data_field_name)
        pulumi.set(__self__, "name", name)
        if document_title_field_name is not None:
            pulumi.set(__self__, "document_title_field_name", document_title_field_name)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)

    @property
    @pulumi.getter(name="documentDataFieldName")
    def document_data_field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "document_data_field_name")

    @document_data_field_name.setter
    def document_data_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "document_data_field_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input['DataSourceSalesforceStandardObjectName']:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input['DataSourceSalesforceStandardObjectName']):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="documentTitleFieldName")
    def document_title_field_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "document_title_field_name")

    @document_title_field_name.setter
    def document_title_field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_title_field_name", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)


@pulumi.input_type
class DataSourceServiceNowConfigurationArgs:
    def __init__(__self__, *,
                 host_url: pulumi.Input[str],
                 secret_arn: pulumi.Input[str],
                 service_now_build_version: pulumi.Input['DataSourceServiceNowBuildVersionType'],
                 authentication_type: Optional[pulumi.Input['DataSourceServiceNowAuthenticationType']] = None,
                 knowledge_article_configuration: Optional[pulumi.Input['DataSourceServiceNowKnowledgeArticleConfigurationArgs']] = None,
                 service_catalog_configuration: Optional[pulumi.Input['DataSourceServiceNowServiceCatalogConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] host_url: The ServiceNow instance that the data source connects to. The host endpoint should look like the following: *{instance}.service-now.com.*
        :param pulumi.Input[str] secret_arn: The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the user name and password required to connect to the ServiceNow instance. You can also provide OAuth authentication credentials of user name, password, client ID, and client secret. For more information, see [Using a ServiceNow data source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html) .
        :param pulumi.Input['DataSourceServiceNowBuildVersionType'] service_now_build_version: The identifier of the release that the ServiceNow host is running. If the host is not running the `LONDON` release, use `OTHERS` .
        :param pulumi.Input['DataSourceServiceNowAuthenticationType'] authentication_type: The type of authentication used to connect to the ServiceNow instance. If you choose `HTTP_BASIC` , Amazon Kendra is authenticated using the user name and password provided in the AWS Secrets Manager secret in the `SecretArn` field. If you choose `OAUTH2` , Amazon Kendra is authenticated using the credentials of client ID, client secret, user name and password.
               
               When you use `OAUTH2` authentication, you must generate a token and a client secret using the ServiceNow console. For more information, see [Using a ServiceNow data source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html) .
        :param pulumi.Input['DataSourceServiceNowKnowledgeArticleConfigurationArgs'] knowledge_article_configuration: Configuration information for crawling knowledge articles in the ServiceNow site.
        :param pulumi.Input['DataSourceServiceNowServiceCatalogConfigurationArgs'] service_catalog_configuration: Configuration information for crawling service catalogs in the ServiceNow site.
        """
        pulumi.set(__self__, "host_url", host_url)
        pulumi.set(__self__, "secret_arn", secret_arn)
        pulumi.set(__self__, "service_now_build_version", service_now_build_version)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if knowledge_article_configuration is not None:
            pulumi.set(__self__, "knowledge_article_configuration", knowledge_article_configuration)
        if service_catalog_configuration is not None:
            pulumi.set(__self__, "service_catalog_configuration", service_catalog_configuration)

    @property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> pulumi.Input[str]:
        """
        The ServiceNow instance that the data source connects to. The host endpoint should look like the following: *{instance}.service-now.com.*
        """
        return pulumi.get(self, "host_url")

    @host_url.setter
    def host_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_url", value)

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the user name and password required to connect to the ServiceNow instance. You can also provide OAuth authentication credentials of user name, password, client ID, and client secret. For more information, see [Using a ServiceNow data source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html) .
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_arn", value)

    @property
    @pulumi.getter(name="serviceNowBuildVersion")
    def service_now_build_version(self) -> pulumi.Input['DataSourceServiceNowBuildVersionType']:
        """
        The identifier of the release that the ServiceNow host is running. If the host is not running the `LONDON` release, use `OTHERS` .
        """
        return pulumi.get(self, "service_now_build_version")

    @service_now_build_version.setter
    def service_now_build_version(self, value: pulumi.Input['DataSourceServiceNowBuildVersionType']):
        pulumi.set(self, "service_now_build_version", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input['DataSourceServiceNowAuthenticationType']]:
        """
        The type of authentication used to connect to the ServiceNow instance. If you choose `HTTP_BASIC` , Amazon Kendra is authenticated using the user name and password provided in the AWS Secrets Manager secret in the `SecretArn` field. If you choose `OAUTH2` , Amazon Kendra is authenticated using the credentials of client ID, client secret, user name and password.

        When you use `OAUTH2` authentication, you must generate a token and a client secret using the ServiceNow console. For more information, see [Using a ServiceNow data source](https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html) .
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input['DataSourceServiceNowAuthenticationType']]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="knowledgeArticleConfiguration")
    def knowledge_article_configuration(self) -> Optional[pulumi.Input['DataSourceServiceNowKnowledgeArticleConfigurationArgs']]:
        """
        Configuration information for crawling knowledge articles in the ServiceNow site.
        """
        return pulumi.get(self, "knowledge_article_configuration")

    @knowledge_article_configuration.setter
    def knowledge_article_configuration(self, value: Optional[pulumi.Input['DataSourceServiceNowKnowledgeArticleConfigurationArgs']]):
        pulumi.set(self, "knowledge_article_configuration", value)

    @property
    @pulumi.getter(name="serviceCatalogConfiguration")
    def service_catalog_configuration(self) -> Optional[pulumi.Input['DataSourceServiceNowServiceCatalogConfigurationArgs']]:
        """
        Configuration information for crawling service catalogs in the ServiceNow site.
        """
        return pulumi.get(self, "service_catalog_configuration")

    @service_catalog_configuration.setter
    def service_catalog_configuration(self, value: Optional[pulumi.Input['DataSourceServiceNowServiceCatalogConfigurationArgs']]):
        pulumi.set(self, "service_catalog_configuration", value)


@pulumi.input_type
class DataSourceServiceNowKnowledgeArticleConfigurationArgs:
    def __init__(__self__, *,
                 document_data_field_name: pulumi.Input[str],
                 crawl_attachments: Optional[pulumi.Input[bool]] = None,
                 document_title_field_name: Optional[pulumi.Input[str]] = None,
                 exclude_attachment_file_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None,
                 filter_query: Optional[pulumi.Input[str]] = None,
                 include_attachment_file_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] document_data_field_name: The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.
        :param pulumi.Input[bool] crawl_attachments: `TRUE` to index attachments to knowledge articles.
        :param pulumi.Input[str] document_title_field_name: The name of the ServiceNow field that is mapped to the index document title field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_attachment_file_patterns: A list of regular expression patterns applied to exclude certain knowledge article attachments. Attachments that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]] field_mappings: Maps attributes or field names of knoweldge articles to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to ServiceNow fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The ServiceNow data source field names must exist in your ServiceNow custom metadata.
        :param pulumi.Input[str] filter_query: A query that selects the knowledge articles to index. The query can return articles from multiple knowledge bases, and the knowledge bases can be public or private.
               
               The query string must be one generated by the ServiceNow console. For more information, see [Specifying documents to index with a query](https://docs.aws.amazon.com/kendra/latest/dg/servicenow-query.html) .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_attachment_file_patterns: A list of regular expression patterns applied to include knowledge article attachments. Attachments that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.
        """
        pulumi.set(__self__, "document_data_field_name", document_data_field_name)
        if crawl_attachments is not None:
            pulumi.set(__self__, "crawl_attachments", crawl_attachments)
        if document_title_field_name is not None:
            pulumi.set(__self__, "document_title_field_name", document_title_field_name)
        if exclude_attachment_file_patterns is not None:
            pulumi.set(__self__, "exclude_attachment_file_patterns", exclude_attachment_file_patterns)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)
        if filter_query is not None:
            pulumi.set(__self__, "filter_query", filter_query)
        if include_attachment_file_patterns is not None:
            pulumi.set(__self__, "include_attachment_file_patterns", include_attachment_file_patterns)

    @property
    @pulumi.getter(name="documentDataFieldName")
    def document_data_field_name(self) -> pulumi.Input[str]:
        """
        The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.
        """
        return pulumi.get(self, "document_data_field_name")

    @document_data_field_name.setter
    def document_data_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "document_data_field_name", value)

    @property
    @pulumi.getter(name="crawlAttachments")
    def crawl_attachments(self) -> Optional[pulumi.Input[bool]]:
        """
        `TRUE` to index attachments to knowledge articles.
        """
        return pulumi.get(self, "crawl_attachments")

    @crawl_attachments.setter
    def crawl_attachments(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "crawl_attachments", value)

    @property
    @pulumi.getter(name="documentTitleFieldName")
    def document_title_field_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the ServiceNow field that is mapped to the index document title field.
        """
        return pulumi.get(self, "document_title_field_name")

    @document_title_field_name.setter
    def document_title_field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_title_field_name", value)

    @property
    @pulumi.getter(name="excludeAttachmentFilePatterns")
    def exclude_attachment_file_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns applied to exclude certain knowledge article attachments. Attachments that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.
        """
        return pulumi.get(self, "exclude_attachment_file_patterns")

    @exclude_attachment_file_patterns.setter
    def exclude_attachment_file_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_attachment_file_patterns", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        """
        Maps attributes or field names of knoweldge articles to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to ServiceNow fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The ServiceNow data source field names must exist in your ServiceNow custom metadata.
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)

    @property
    @pulumi.getter(name="filterQuery")
    def filter_query(self) -> Optional[pulumi.Input[str]]:
        """
        A query that selects the knowledge articles to index. The query can return articles from multiple knowledge bases, and the knowledge bases can be public or private.

        The query string must be one generated by the ServiceNow console. For more information, see [Specifying documents to index with a query](https://docs.aws.amazon.com/kendra/latest/dg/servicenow-query.html) .
        """
        return pulumi.get(self, "filter_query")

    @filter_query.setter
    def filter_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_query", value)

    @property
    @pulumi.getter(name="includeAttachmentFilePatterns")
    def include_attachment_file_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns applied to include knowledge article attachments. Attachments that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.
        """
        return pulumi.get(self, "include_attachment_file_patterns")

    @include_attachment_file_patterns.setter
    def include_attachment_file_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_attachment_file_patterns", value)


@pulumi.input_type
class DataSourceServiceNowServiceCatalogConfigurationArgs:
    def __init__(__self__, *,
                 document_data_field_name: pulumi.Input[str],
                 crawl_attachments: Optional[pulumi.Input[bool]] = None,
                 document_title_field_name: Optional[pulumi.Input[str]] = None,
                 exclude_attachment_file_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None,
                 include_attachment_file_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] document_data_field_name: The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.
        :param pulumi.Input[bool] crawl_attachments: `TRUE` to index attachments to service catalog items.
        :param pulumi.Input[str] document_title_field_name: The name of the ServiceNow field that is mapped to the index document title field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_attachment_file_patterns: A list of regular expression patterns to exclude certain attachments of catalogs in your ServiceNow. Item that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.
               
               The regex is applied to the file name of the attachment.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]] field_mappings: Maps attributes or field names of catalogs to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to ServiceNow fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The ServiceNow data source field names must exist in your ServiceNow custom metadata.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_attachment_file_patterns: A list of regular expression patterns to include certain attachments of catalogs in your ServiceNow. Item that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.
               
               The regex is applied to the file name of the attachment.
        """
        pulumi.set(__self__, "document_data_field_name", document_data_field_name)
        if crawl_attachments is not None:
            pulumi.set(__self__, "crawl_attachments", crawl_attachments)
        if document_title_field_name is not None:
            pulumi.set(__self__, "document_title_field_name", document_title_field_name)
        if exclude_attachment_file_patterns is not None:
            pulumi.set(__self__, "exclude_attachment_file_patterns", exclude_attachment_file_patterns)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)
        if include_attachment_file_patterns is not None:
            pulumi.set(__self__, "include_attachment_file_patterns", include_attachment_file_patterns)

    @property
    @pulumi.getter(name="documentDataFieldName")
    def document_data_field_name(self) -> pulumi.Input[str]:
        """
        The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.
        """
        return pulumi.get(self, "document_data_field_name")

    @document_data_field_name.setter
    def document_data_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "document_data_field_name", value)

    @property
    @pulumi.getter(name="crawlAttachments")
    def crawl_attachments(self) -> Optional[pulumi.Input[bool]]:
        """
        `TRUE` to index attachments to service catalog items.
        """
        return pulumi.get(self, "crawl_attachments")

    @crawl_attachments.setter
    def crawl_attachments(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "crawl_attachments", value)

    @property
    @pulumi.getter(name="documentTitleFieldName")
    def document_title_field_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the ServiceNow field that is mapped to the index document title field.
        """
        return pulumi.get(self, "document_title_field_name")

    @document_title_field_name.setter
    def document_title_field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_title_field_name", value)

    @property
    @pulumi.getter(name="excludeAttachmentFilePatterns")
    def exclude_attachment_file_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to exclude certain attachments of catalogs in your ServiceNow. Item that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.

        The regex is applied to the file name of the attachment.
        """
        return pulumi.get(self, "exclude_attachment_file_patterns")

    @exclude_attachment_file_patterns.setter
    def exclude_attachment_file_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_attachment_file_patterns", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        """
        Maps attributes or field names of catalogs to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to ServiceNow fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The ServiceNow data source field names must exist in your ServiceNow custom metadata.
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)

    @property
    @pulumi.getter(name="includeAttachmentFilePatterns")
    def include_attachment_file_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to include certain attachments of catalogs in your ServiceNow. Item that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.

        The regex is applied to the file name of the attachment.
        """
        return pulumi.get(self, "include_attachment_file_patterns")

    @include_attachment_file_patterns.setter
    def include_attachment_file_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_attachment_file_patterns", value)


@pulumi.input_type
class DataSourceSharePointConfigurationArgs:
    def __init__(__self__, *,
                 secret_arn: pulumi.Input[str],
                 share_point_version: pulumi.Input['DataSourceSharePointConfigurationSharePointVersion'],
                 urls: pulumi.Input[Sequence[pulumi.Input[str]]],
                 crawl_attachments: Optional[pulumi.Input[bool]] = None,
                 disable_local_groups: Optional[pulumi.Input[bool]] = None,
                 document_title_field_name: Optional[pulumi.Input[str]] = None,
                 exclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None,
                 inclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssl_certificate_s3_path: Optional[pulumi.Input['DataSourceS3PathArgs']] = None,
                 use_change_log: Optional[pulumi.Input[bool]] = None,
                 vpc_configuration: Optional[pulumi.Input['DataSourceVpcConfigurationArgs']] = None):
        """
        SharePoint configuration
        :param pulumi.Input[str] secret_arn: The Amazon Resource Name (ARN) of an AWS Secrets Manager secret that contains the user name and password required to connect to the SharePoint instance. For more information, see [Microsoft SharePoint](https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html) .
        :param pulumi.Input['DataSourceSharePointConfigurationSharePointVersion'] share_point_version: The version of Microsoft SharePoint that you use.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] urls: The Microsoft SharePoint site URLs for the documents you want to index.
        :param pulumi.Input[bool] crawl_attachments: `TRUE` to index document attachments.
        :param pulumi.Input[bool] disable_local_groups: `TRUE` to disable local groups information.
        :param pulumi.Input[str] document_title_field_name: The Microsoft SharePoint attribute field that contains the title of the document.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclusion_patterns: A list of regular expression patterns. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an exclusion pattern and an inclusion pattern, the document is not included in the index.
               
               The regex is applied to the display URL of the SharePoint document.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]] field_mappings: A list of `DataSourceToIndexFieldMapping` objects that map Microsoft SharePoint attributes or fields to Amazon Kendra index fields. You must first create the index fields using the [UpdateIndex](https://docs.aws.amazon.com/kendra/latest/dg/API_UpdateIndex.html) operation before you map SharePoint attributes. For more information, see [Mapping Data Source Fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_patterns: A list of regular expression patterns to include certain documents in your SharePoint. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.
               
               The regex applies to the display URL of the SharePoint document.
        :param pulumi.Input['DataSourceS3PathArgs'] ssl_certificate_s3_path: Information required to find a specific file in an Amazon S3 bucket.
        :param pulumi.Input[bool] use_change_log: `TRUE` to use the SharePoint change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in SharePoint.
        :param pulumi.Input['DataSourceVpcConfigurationArgs'] vpc_configuration: Provides information for connecting to an Amazon VPC.
        """
        pulumi.set(__self__, "secret_arn", secret_arn)
        pulumi.set(__self__, "share_point_version", share_point_version)
        pulumi.set(__self__, "urls", urls)
        if crawl_attachments is not None:
            pulumi.set(__self__, "crawl_attachments", crawl_attachments)
        if disable_local_groups is not None:
            pulumi.set(__self__, "disable_local_groups", disable_local_groups)
        if document_title_field_name is not None:
            pulumi.set(__self__, "document_title_field_name", document_title_field_name)
        if exclusion_patterns is not None:
            pulumi.set(__self__, "exclusion_patterns", exclusion_patterns)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)
        if inclusion_patterns is not None:
            pulumi.set(__self__, "inclusion_patterns", inclusion_patterns)
        if ssl_certificate_s3_path is not None:
            pulumi.set(__self__, "ssl_certificate_s3_path", ssl_certificate_s3_path)
        if use_change_log is not None:
            pulumi.set(__self__, "use_change_log", use_change_log)
        if vpc_configuration is not None:
            pulumi.set(__self__, "vpc_configuration", vpc_configuration)

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of an AWS Secrets Manager secret that contains the user name and password required to connect to the SharePoint instance. For more information, see [Microsoft SharePoint](https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html) .
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_arn", value)

    @property
    @pulumi.getter(name="sharePointVersion")
    def share_point_version(self) -> pulumi.Input['DataSourceSharePointConfigurationSharePointVersion']:
        """
        The version of Microsoft SharePoint that you use.
        """
        return pulumi.get(self, "share_point_version")

    @share_point_version.setter
    def share_point_version(self, value: pulumi.Input['DataSourceSharePointConfigurationSharePointVersion']):
        pulumi.set(self, "share_point_version", value)

    @property
    @pulumi.getter
    def urls(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The Microsoft SharePoint site URLs for the documents you want to index.
        """
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "urls", value)

    @property
    @pulumi.getter(name="crawlAttachments")
    def crawl_attachments(self) -> Optional[pulumi.Input[bool]]:
        """
        `TRUE` to index document attachments.
        """
        return pulumi.get(self, "crawl_attachments")

    @crawl_attachments.setter
    def crawl_attachments(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "crawl_attachments", value)

    @property
    @pulumi.getter(name="disableLocalGroups")
    def disable_local_groups(self) -> Optional[pulumi.Input[bool]]:
        """
        `TRUE` to disable local groups information.
        """
        return pulumi.get(self, "disable_local_groups")

    @disable_local_groups.setter
    def disable_local_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_groups", value)

    @property
    @pulumi.getter(name="documentTitleFieldName")
    def document_title_field_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Microsoft SharePoint attribute field that contains the title of the document.
        """
        return pulumi.get(self, "document_title_field_name")

    @document_title_field_name.setter
    def document_title_field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_title_field_name", value)

    @property
    @pulumi.getter(name="exclusionPatterns")
    def exclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an exclusion pattern and an inclusion pattern, the document is not included in the index.

        The regex is applied to the display URL of the SharePoint document.
        """
        return pulumi.get(self, "exclusion_patterns")

    @exclusion_patterns.setter
    def exclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_patterns", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        """
        A list of `DataSourceToIndexFieldMapping` objects that map Microsoft SharePoint attributes or fields to Amazon Kendra index fields. You must first create the index fields using the [UpdateIndex](https://docs.aws.amazon.com/kendra/latest/dg/API_UpdateIndex.html) operation before you map SharePoint attributes. For more information, see [Mapping Data Source Fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) .
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)

    @property
    @pulumi.getter(name="inclusionPatterns")
    def inclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to include certain documents in your SharePoint. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.

        The regex applies to the display URL of the SharePoint document.
        """
        return pulumi.get(self, "inclusion_patterns")

    @inclusion_patterns.setter
    def inclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_patterns", value)

    @property
    @pulumi.getter(name="sslCertificateS3Path")
    def ssl_certificate_s3_path(self) -> Optional[pulumi.Input['DataSourceS3PathArgs']]:
        """
        Information required to find a specific file in an Amazon S3 bucket.
        """
        return pulumi.get(self, "ssl_certificate_s3_path")

    @ssl_certificate_s3_path.setter
    def ssl_certificate_s3_path(self, value: Optional[pulumi.Input['DataSourceS3PathArgs']]):
        pulumi.set(self, "ssl_certificate_s3_path", value)

    @property
    @pulumi.getter(name="useChangeLog")
    def use_change_log(self) -> Optional[pulumi.Input[bool]]:
        """
        `TRUE` to use the SharePoint change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in SharePoint.
        """
        return pulumi.get(self, "use_change_log")

    @use_change_log.setter
    def use_change_log(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_change_log", value)

    @property
    @pulumi.getter(name="vpcConfiguration")
    def vpc_configuration(self) -> Optional[pulumi.Input['DataSourceVpcConfigurationArgs']]:
        """
        Provides information for connecting to an Amazon VPC.
        """
        return pulumi.get(self, "vpc_configuration")

    @vpc_configuration.setter
    def vpc_configuration(self, value: Optional[pulumi.Input['DataSourceVpcConfigurationArgs']]):
        pulumi.set(self, "vpc_configuration", value)


@pulumi.input_type
class DataSourceSqlConfigurationArgs:
    def __init__(__self__, *,
                 query_identifiers_enclosing_option: Optional[pulumi.Input['DataSourceQueryIdentifiersEnclosingOption']] = None):
        """
        :param pulumi.Input['DataSourceQueryIdentifiersEnclosingOption'] query_identifiers_enclosing_option: Determines whether Amazon Kendra encloses SQL identifiers for tables and column names in double quotes (") when making a database query. You can set the value to `DOUBLE_QUOTES` or `NONE` .
               
               By default, Amazon Kendra passes SQL identifiers the way that they are entered into the data source configuration. It does not change the case of identifiers or enclose them in quotes.
               
               PostgreSQL internally converts uppercase characters to lower case characters in identifiers unless they are quoted. Choosing this option encloses identifiers in quotes so that PostgreSQL does not convert the character's case.
               
               For MySQL databases, you must enable the ansi_quotes option when you set this field to `DOUBLE_QUOTES` .
        """
        if query_identifiers_enclosing_option is not None:
            pulumi.set(__self__, "query_identifiers_enclosing_option", query_identifiers_enclosing_option)

    @property
    @pulumi.getter(name="queryIdentifiersEnclosingOption")
    def query_identifiers_enclosing_option(self) -> Optional[pulumi.Input['DataSourceQueryIdentifiersEnclosingOption']]:
        """
        Determines whether Amazon Kendra encloses SQL identifiers for tables and column names in double quotes (") when making a database query. You can set the value to `DOUBLE_QUOTES` or `NONE` .

        By default, Amazon Kendra passes SQL identifiers the way that they are entered into the data source configuration. It does not change the case of identifiers or enclose them in quotes.

        PostgreSQL internally converts uppercase characters to lower case characters in identifiers unless they are quoted. Choosing this option encloses identifiers in quotes so that PostgreSQL does not convert the character's case.

        For MySQL databases, you must enable the ansi_quotes option when you set this field to `DOUBLE_QUOTES` .
        """
        return pulumi.get(self, "query_identifiers_enclosing_option")

    @query_identifiers_enclosing_option.setter
    def query_identifiers_enclosing_option(self, value: Optional[pulumi.Input['DataSourceQueryIdentifiersEnclosingOption']]):
        pulumi.set(self, "query_identifiers_enclosing_option", value)


@pulumi.input_type
class DataSourceToIndexFieldMappingArgs:
    def __init__(__self__, *,
                 data_source_field_name: pulumi.Input[str],
                 index_field_name: pulumi.Input[str],
                 date_field_format: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "data_source_field_name", data_source_field_name)
        pulumi.set(__self__, "index_field_name", index_field_name)
        if date_field_format is not None:
            pulumi.set(__self__, "date_field_format", date_field_format)

    @property
    @pulumi.getter(name="dataSourceFieldName")
    def data_source_field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "data_source_field_name")

    @data_source_field_name.setter
    def data_source_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source_field_name", value)

    @property
    @pulumi.getter(name="indexFieldName")
    def index_field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index_field_name")

    @index_field_name.setter
    def index_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_field_name", value)

    @property
    @pulumi.getter(name="dateFieldFormat")
    def date_field_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_field_format")

    @date_field_format.setter
    def date_field_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_field_format", value)


@pulumi.input_type
class DataSourceVpcConfigurationArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Kendra to connect to the data source.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Kendra to connect to the data source.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)


@pulumi.input_type
class DataSourceWebCrawlerAuthenticationConfigurationArgs:
    def __init__(__self__, *,
                 basic_authentication: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceWebCrawlerBasicAuthenticationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceWebCrawlerBasicAuthenticationArgs']]] basic_authentication: The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials.
               
               The list includes the name and port number of the website host.
        """
        if basic_authentication is not None:
            pulumi.set(__self__, "basic_authentication", basic_authentication)

    @property
    @pulumi.getter(name="basicAuthentication")
    def basic_authentication(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceWebCrawlerBasicAuthenticationArgs']]]]:
        """
        The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials.

        The list includes the name and port number of the website host.
        """
        return pulumi.get(self, "basic_authentication")

    @basic_authentication.setter
    def basic_authentication(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceWebCrawlerBasicAuthenticationArgs']]]]):
        pulumi.set(self, "basic_authentication", value)


@pulumi.input_type
class DataSourceWebCrawlerBasicAuthenticationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[str],
                 host: pulumi.Input[str],
                 port: pulumi.Input[int]):
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[str]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class DataSourceWebCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 urls: pulumi.Input['DataSourceWebCrawlerUrlsArgs'],
                 authentication_configuration: Optional[pulumi.Input['DataSourceWebCrawlerAuthenticationConfigurationArgs']] = None,
                 crawl_depth: Optional[pulumi.Input[int]] = None,
                 max_content_size_per_page_in_mega_bytes: Optional[pulumi.Input[float]] = None,
                 max_links_per_page: Optional[pulumi.Input[int]] = None,
                 max_urls_per_minute_crawl_rate: Optional[pulumi.Input[int]] = None,
                 proxy_configuration: Optional[pulumi.Input['DataSourceProxyConfigurationArgs']] = None,
                 url_exclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 url_inclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['DataSourceWebCrawlerUrlsArgs'] urls: Specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl.
               
               You can include website subdomains. You can list up to 100 seed URLs and up to three sitemap URLs.
               
               You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling.
               
               *When selecting websites to index, you must adhere to the [Amazon Acceptable Use Policy](https://docs.aws.amazon.com/aup/) and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index.*
        :param pulumi.Input['DataSourceWebCrawlerAuthenticationConfigurationArgs'] authentication_configuration: Configuration information required to connect to websites using authentication.
               
               You can connect to websites using basic authentication of user name and password. You use a secret in [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html) to store your authentication credentials.
               
               You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.
        :param pulumi.Input[int] crawl_depth: The 'depth' or number of levels from the seed level to crawl. For example, the seed URL page is depth 1 and any hyperlinks on this page that are also crawled are depth 2.
        :param pulumi.Input[float] max_content_size_per_page_in_mega_bytes: The maximum size (in MB) of a web page or attachment to crawl.
               
               Files larger than this size (in MB) are skipped/not crawled.
               
               The default maximum size of a web page or attachment is set to 50 MB.
        :param pulumi.Input[int] max_links_per_page: The maximum number of URLs on a web page to include when crawling a website. This number is per web page.
               
               As a website’s web pages are crawled, any URLs the web pages link to are also crawled. URLs on a web page are crawled in order of appearance.
               
               The default maximum links per page is 100.
        :param pulumi.Input[int] max_urls_per_minute_crawl_rate: The maximum number of URLs crawled per website host per minute.
               
               A minimum of one URL is required.
               
               The default maximum number of URLs crawled per website host per minute is 300.
        :param pulumi.Input['DataSourceProxyConfigurationArgs'] proxy_configuration: Configuration information required to connect to your internal websites via a web proxy.
               
               You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.
               
               Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html) .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] url_exclusion_patterns: A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] url_inclusion_patterns: A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.
        """
        pulumi.set(__self__, "urls", urls)
        if authentication_configuration is not None:
            pulumi.set(__self__, "authentication_configuration", authentication_configuration)
        if crawl_depth is not None:
            pulumi.set(__self__, "crawl_depth", crawl_depth)
        if max_content_size_per_page_in_mega_bytes is not None:
            pulumi.set(__self__, "max_content_size_per_page_in_mega_bytes", max_content_size_per_page_in_mega_bytes)
        if max_links_per_page is not None:
            pulumi.set(__self__, "max_links_per_page", max_links_per_page)
        if max_urls_per_minute_crawl_rate is not None:
            pulumi.set(__self__, "max_urls_per_minute_crawl_rate", max_urls_per_minute_crawl_rate)
        if proxy_configuration is not None:
            pulumi.set(__self__, "proxy_configuration", proxy_configuration)
        if url_exclusion_patterns is not None:
            pulumi.set(__self__, "url_exclusion_patterns", url_exclusion_patterns)
        if url_inclusion_patterns is not None:
            pulumi.set(__self__, "url_inclusion_patterns", url_inclusion_patterns)

    @property
    @pulumi.getter
    def urls(self) -> pulumi.Input['DataSourceWebCrawlerUrlsArgs']:
        """
        Specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl.

        You can include website subdomains. You can list up to 100 seed URLs and up to three sitemap URLs.

        You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling.

        *When selecting websites to index, you must adhere to the [Amazon Acceptable Use Policy](https://docs.aws.amazon.com/aup/) and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index.*
        """
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: pulumi.Input['DataSourceWebCrawlerUrlsArgs']):
        pulumi.set(self, "urls", value)

    @property
    @pulumi.getter(name="authenticationConfiguration")
    def authentication_configuration(self) -> Optional[pulumi.Input['DataSourceWebCrawlerAuthenticationConfigurationArgs']]:
        """
        Configuration information required to connect to websites using authentication.

        You can connect to websites using basic authentication of user name and password. You use a secret in [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html) to store your authentication credentials.

        You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.
        """
        return pulumi.get(self, "authentication_configuration")

    @authentication_configuration.setter
    def authentication_configuration(self, value: Optional[pulumi.Input['DataSourceWebCrawlerAuthenticationConfigurationArgs']]):
        pulumi.set(self, "authentication_configuration", value)

    @property
    @pulumi.getter(name="crawlDepth")
    def crawl_depth(self) -> Optional[pulumi.Input[int]]:
        """
        The 'depth' or number of levels from the seed level to crawl. For example, the seed URL page is depth 1 and any hyperlinks on this page that are also crawled are depth 2.
        """
        return pulumi.get(self, "crawl_depth")

    @crawl_depth.setter
    def crawl_depth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "crawl_depth", value)

    @property
    @pulumi.getter(name="maxContentSizePerPageInMegaBytes")
    def max_content_size_per_page_in_mega_bytes(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum size (in MB) of a web page or attachment to crawl.

        Files larger than this size (in MB) are skipped/not crawled.

        The default maximum size of a web page or attachment is set to 50 MB.
        """
        return pulumi.get(self, "max_content_size_per_page_in_mega_bytes")

    @max_content_size_per_page_in_mega_bytes.setter
    def max_content_size_per_page_in_mega_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_content_size_per_page_in_mega_bytes", value)

    @property
    @pulumi.getter(name="maxLinksPerPage")
    def max_links_per_page(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of URLs on a web page to include when crawling a website. This number is per web page.

        As a website’s web pages are crawled, any URLs the web pages link to are also crawled. URLs on a web page are crawled in order of appearance.

        The default maximum links per page is 100.
        """
        return pulumi.get(self, "max_links_per_page")

    @max_links_per_page.setter
    def max_links_per_page(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_links_per_page", value)

    @property
    @pulumi.getter(name="maxUrlsPerMinuteCrawlRate")
    def max_urls_per_minute_crawl_rate(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of URLs crawled per website host per minute.

        A minimum of one URL is required.

        The default maximum number of URLs crawled per website host per minute is 300.
        """
        return pulumi.get(self, "max_urls_per_minute_crawl_rate")

    @max_urls_per_minute_crawl_rate.setter
    def max_urls_per_minute_crawl_rate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_urls_per_minute_crawl_rate", value)

    @property
    @pulumi.getter(name="proxyConfiguration")
    def proxy_configuration(self) -> Optional[pulumi.Input['DataSourceProxyConfigurationArgs']]:
        """
        Configuration information required to connect to your internal websites via a web proxy.

        You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.

        Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html) .
        """
        return pulumi.get(self, "proxy_configuration")

    @proxy_configuration.setter
    def proxy_configuration(self, value: Optional[pulumi.Input['DataSourceProxyConfigurationArgs']]):
        pulumi.set(self, "proxy_configuration", value)

    @property
    @pulumi.getter(name="urlExclusionPatterns")
    def url_exclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.
        """
        return pulumi.get(self, "url_exclusion_patterns")

    @url_exclusion_patterns.setter
    def url_exclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "url_exclusion_patterns", value)

    @property
    @pulumi.getter(name="urlInclusionPatterns")
    def url_inclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.
        """
        return pulumi.get(self, "url_inclusion_patterns")

    @url_inclusion_patterns.setter
    def url_inclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "url_inclusion_patterns", value)


@pulumi.input_type
class DataSourceWebCrawlerSeedUrlConfigurationArgs:
    def __init__(__self__, *,
                 seed_urls: pulumi.Input[Sequence[pulumi.Input[str]]],
                 web_crawler_mode: Optional[pulumi.Input['DataSourceWebCrawlerSeedUrlConfigurationWebCrawlerMode']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] seed_urls: The list of seed or starting point URLs of the websites you want to crawl.
               
               The list can include a maximum of 100 seed URLs.
        :param pulumi.Input['DataSourceWebCrawlerSeedUrlConfigurationWebCrawlerMode'] web_crawler_mode: You can choose one of the following modes:
               
               - `HOST_ONLY` —crawl only the website host names. For example, if the seed URL is "abc.example.com", then only URLs with host name "abc.example.com" are crawled.
               - `SUBDOMAINS` —crawl the website host names with subdomains. For example, if the seed URL is "abc.example.com", then "a.abc.example.com" and "b.abc.example.com" are also crawled.
               - `EVERYTHING` —crawl the website host names with subdomains and other domains that the web pages link to.
               
               The default mode is set to `HOST_ONLY` .
        """
        pulumi.set(__self__, "seed_urls", seed_urls)
        if web_crawler_mode is not None:
            pulumi.set(__self__, "web_crawler_mode", web_crawler_mode)

    @property
    @pulumi.getter(name="seedUrls")
    def seed_urls(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of seed or starting point URLs of the websites you want to crawl.

        The list can include a maximum of 100 seed URLs.
        """
        return pulumi.get(self, "seed_urls")

    @seed_urls.setter
    def seed_urls(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "seed_urls", value)

    @property
    @pulumi.getter(name="webCrawlerMode")
    def web_crawler_mode(self) -> Optional[pulumi.Input['DataSourceWebCrawlerSeedUrlConfigurationWebCrawlerMode']]:
        """
        You can choose one of the following modes:

        - `HOST_ONLY` —crawl only the website host names. For example, if the seed URL is "abc.example.com", then only URLs with host name "abc.example.com" are crawled.
        - `SUBDOMAINS` —crawl the website host names with subdomains. For example, if the seed URL is "abc.example.com", then "a.abc.example.com" and "b.abc.example.com" are also crawled.
        - `EVERYTHING` —crawl the website host names with subdomains and other domains that the web pages link to.

        The default mode is set to `HOST_ONLY` .
        """
        return pulumi.get(self, "web_crawler_mode")

    @web_crawler_mode.setter
    def web_crawler_mode(self, value: Optional[pulumi.Input['DataSourceWebCrawlerSeedUrlConfigurationWebCrawlerMode']]):
        pulumi.set(self, "web_crawler_mode", value)


@pulumi.input_type
class DataSourceWebCrawlerSiteMapsConfigurationArgs:
    def __init__(__self__, *,
                 site_maps: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] site_maps: The list of sitemap URLs of the websites you want to crawl.
               
               The list can include a maximum of three sitemap URLs.
        """
        pulumi.set(__self__, "site_maps", site_maps)

    @property
    @pulumi.getter(name="siteMaps")
    def site_maps(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of sitemap URLs of the websites you want to crawl.

        The list can include a maximum of three sitemap URLs.
        """
        return pulumi.get(self, "site_maps")

    @site_maps.setter
    def site_maps(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "site_maps", value)


@pulumi.input_type
class DataSourceWebCrawlerUrlsArgs:
    def __init__(__self__, *,
                 seed_url_configuration: Optional[pulumi.Input['DataSourceWebCrawlerSeedUrlConfigurationArgs']] = None,
                 site_maps_configuration: Optional[pulumi.Input['DataSourceWebCrawlerSiteMapsConfigurationArgs']] = None):
        """
        :param pulumi.Input['DataSourceWebCrawlerSeedUrlConfigurationArgs'] seed_url_configuration: Configuration of the seed or starting point URLs of the websites you want to crawl.
               
               You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the web pages link to.
               
               You can list up to 100 seed URLs.
        :param pulumi.Input['DataSourceWebCrawlerSiteMapsConfigurationArgs'] site_maps_configuration: Configuration of the sitemap URLs of the websites you want to crawl.
               
               Only URLs belonging to the same website host names are crawled. You can list up to three sitemap URLs.
        """
        if seed_url_configuration is not None:
            pulumi.set(__self__, "seed_url_configuration", seed_url_configuration)
        if site_maps_configuration is not None:
            pulumi.set(__self__, "site_maps_configuration", site_maps_configuration)

    @property
    @pulumi.getter(name="seedUrlConfiguration")
    def seed_url_configuration(self) -> Optional[pulumi.Input['DataSourceWebCrawlerSeedUrlConfigurationArgs']]:
        """
        Configuration of the seed or starting point URLs of the websites you want to crawl.

        You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the web pages link to.

        You can list up to 100 seed URLs.
        """
        return pulumi.get(self, "seed_url_configuration")

    @seed_url_configuration.setter
    def seed_url_configuration(self, value: Optional[pulumi.Input['DataSourceWebCrawlerSeedUrlConfigurationArgs']]):
        pulumi.set(self, "seed_url_configuration", value)

    @property
    @pulumi.getter(name="siteMapsConfiguration")
    def site_maps_configuration(self) -> Optional[pulumi.Input['DataSourceWebCrawlerSiteMapsConfigurationArgs']]:
        """
        Configuration of the sitemap URLs of the websites you want to crawl.

        Only URLs belonging to the same website host names are crawled. You can list up to three sitemap URLs.
        """
        return pulumi.get(self, "site_maps_configuration")

    @site_maps_configuration.setter
    def site_maps_configuration(self, value: Optional[pulumi.Input['DataSourceWebCrawlerSiteMapsConfigurationArgs']]):
        pulumi.set(self, "site_maps_configuration", value)


@pulumi.input_type
class DataSourceWorkDocsConfigurationArgs:
    def __init__(__self__, *,
                 organization_id: pulumi.Input[str],
                 crawl_comments: Optional[pulumi.Input[bool]] = None,
                 exclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]] = None,
                 inclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_change_log: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] organization_id: The identifier of the directory corresponding to your Amazon WorkDocs site repository.
               
               You can find the organization ID in the [AWS Directory Service](https://docs.aws.amazon.com/directoryservicev2/) by going to *Active Directory* , then *Directories* . Your Amazon WorkDocs site directory has an ID, which is the organization ID. You can also set up a new Amazon WorkDocs directory in the AWS Directory Service console and enable a Amazon WorkDocs site for the directory in the Amazon WorkDocs console.
        :param pulumi.Input[bool] crawl_comments: `TRUE` to include comments on documents in your index. Including comments in your index means each comment is a document that can be searched on.
               
               The default is set to `FALSE` .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclusion_patterns: A list of regular expression patterns to exclude certain files in your Amazon WorkDocs site repository. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]] field_mappings: A list of `DataSourceToIndexFieldMapping` objects that map Amazon WorkDocs data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Amazon WorkDocs fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Amazon WorkDocs data source field names must exist in your Amazon WorkDocs custom metadata.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_patterns: A list of regular expression patterns to include certain files in your Amazon WorkDocs site repository. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.
        :param pulumi.Input[bool] use_change_log: `TRUE` to use the Amazon WorkDocs change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Amazon WorkDocs.
        """
        pulumi.set(__self__, "organization_id", organization_id)
        if crawl_comments is not None:
            pulumi.set(__self__, "crawl_comments", crawl_comments)
        if exclusion_patterns is not None:
            pulumi.set(__self__, "exclusion_patterns", exclusion_patterns)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)
        if inclusion_patterns is not None:
            pulumi.set(__self__, "inclusion_patterns", inclusion_patterns)
        if use_change_log is not None:
            pulumi.set(__self__, "use_change_log", use_change_log)

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> pulumi.Input[str]:
        """
        The identifier of the directory corresponding to your Amazon WorkDocs site repository.

        You can find the organization ID in the [AWS Directory Service](https://docs.aws.amazon.com/directoryservicev2/) by going to *Active Directory* , then *Directories* . Your Amazon WorkDocs site directory has an ID, which is the organization ID. You can also set up a new Amazon WorkDocs directory in the AWS Directory Service console and enable a Amazon WorkDocs site for the directory in the Amazon WorkDocs console.
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "organization_id", value)

    @property
    @pulumi.getter(name="crawlComments")
    def crawl_comments(self) -> Optional[pulumi.Input[bool]]:
        """
        `TRUE` to include comments on documents in your index. Including comments in your index means each comment is a document that can be searched on.

        The default is set to `FALSE` .
        """
        return pulumi.get(self, "crawl_comments")

    @crawl_comments.setter
    def crawl_comments(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "crawl_comments", value)

    @property
    @pulumi.getter(name="exclusionPatterns")
    def exclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to exclude certain files in your Amazon WorkDocs site repository. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.
        """
        return pulumi.get(self, "exclusion_patterns")

    @exclusion_patterns.setter
    def exclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_patterns", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]:
        """
        A list of `DataSourceToIndexFieldMapping` objects that map Amazon WorkDocs data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the `UpdateIndex` API before you map to Amazon WorkDocs fields. For more information, see [Mapping data source fields](https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html) . The Amazon WorkDocs data source field names must exist in your Amazon WorkDocs custom metadata.
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceToIndexFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)

    @property
    @pulumi.getter(name="inclusionPatterns")
    def inclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expression patterns to include certain files in your Amazon WorkDocs site repository. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.
        """
        return pulumi.get(self, "inclusion_patterns")

    @inclusion_patterns.setter
    def inclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_patterns", value)

    @property
    @pulumi.getter(name="useChangeLog")
    def use_change_log(self) -> Optional[pulumi.Input[bool]]:
        """
        `TRUE` to use the Amazon WorkDocs change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Amazon WorkDocs.
        """
        return pulumi.get(self, "use_change_log")

    @use_change_log.setter
    def use_change_log(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_change_log", value)


@pulumi.input_type
class FaqS3PathArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: The name of the S3 bucket that contains the file.
        :param pulumi.Input[str] key: The name of the file.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the S3 bucket that contains the file.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the file.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class IndexCapacityUnitsConfigurationArgs:
    def __init__(__self__, *,
                 query_capacity_units: pulumi.Input[int],
                 storage_capacity_units: pulumi.Input[int]):
        """
        :param pulumi.Input[int] query_capacity_units: The amount of extra query capacity for an index and [GetQuerySuggestions](https://docs.aws.amazon.com/kendra/latest/dg/API_GetQuerySuggestions.html) capacity.
               
               A single extra capacity unit for an index provides 0.1 queries per second or approximately 8,000 queries per day. You can add up to 100 extra capacity units.
               
               `GetQuerySuggestions` capacity is five times the provisioned query capacity for an index, or the base capacity of 2.5 calls per second, whichever is higher. For example, the base capacity for an index is 0.1 queries per second, and `GetQuerySuggestions` capacity has a base of 2.5 calls per second. If you add another 0.1 queries per second to total 0.2 queries per second for an index, the `GetQuerySuggestions` capacity is 2.5 calls per second (higher than five times 0.2 queries per second).
        :param pulumi.Input[int] storage_capacity_units: The amount of extra storage capacity for an index. A single capacity unit provides 30 GB of storage space or 100,000 documents, whichever is reached first. You can add up to 100 extra capacity units.
        """
        pulumi.set(__self__, "query_capacity_units", query_capacity_units)
        pulumi.set(__self__, "storage_capacity_units", storage_capacity_units)

    @property
    @pulumi.getter(name="queryCapacityUnits")
    def query_capacity_units(self) -> pulumi.Input[int]:
        """
        The amount of extra query capacity for an index and [GetQuerySuggestions](https://docs.aws.amazon.com/kendra/latest/dg/API_GetQuerySuggestions.html) capacity.

        A single extra capacity unit for an index provides 0.1 queries per second or approximately 8,000 queries per day. You can add up to 100 extra capacity units.

        `GetQuerySuggestions` capacity is five times the provisioned query capacity for an index, or the base capacity of 2.5 calls per second, whichever is higher. For example, the base capacity for an index is 0.1 queries per second, and `GetQuerySuggestions` capacity has a base of 2.5 calls per second. If you add another 0.1 queries per second to total 0.2 queries per second for an index, the `GetQuerySuggestions` capacity is 2.5 calls per second (higher than five times 0.2 queries per second).
        """
        return pulumi.get(self, "query_capacity_units")

    @query_capacity_units.setter
    def query_capacity_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "query_capacity_units", value)

    @property
    @pulumi.getter(name="storageCapacityUnits")
    def storage_capacity_units(self) -> pulumi.Input[int]:
        """
        The amount of extra storage capacity for an index. A single capacity unit provides 30 GB of storage space or 100,000 documents, whichever is reached first. You can add up to 100 extra capacity units.
        """
        return pulumi.get(self, "storage_capacity_units")

    @storage_capacity_units.setter
    def storage_capacity_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "storage_capacity_units", value)


@pulumi.input_type
class IndexDocumentMetadataConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input['IndexDocumentAttributeValueType'],
                 relevance: Optional[pulumi.Input['IndexRelevanceArgs']] = None,
                 search: Optional[pulumi.Input['IndexSearchArgs']] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if relevance is not None:
            pulumi.set(__self__, "relevance", relevance)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['IndexDocumentAttributeValueType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['IndexDocumentAttributeValueType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def relevance(self) -> Optional[pulumi.Input['IndexRelevanceArgs']]:
        return pulumi.get(self, "relevance")

    @relevance.setter
    def relevance(self, value: Optional[pulumi.Input['IndexRelevanceArgs']]):
        pulumi.set(self, "relevance", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['IndexSearchArgs']]:
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['IndexSearchArgs']]):
        pulumi.set(self, "search", value)


@pulumi.input_type
class IndexJsonTokenTypeConfigurationArgs:
    def __init__(__self__, *,
                 group_attribute_field: pulumi.Input[str],
                 user_name_attribute_field: pulumi.Input[str]):
        pulumi.set(__self__, "group_attribute_field", group_attribute_field)
        pulumi.set(__self__, "user_name_attribute_field", user_name_attribute_field)

    @property
    @pulumi.getter(name="groupAttributeField")
    def group_attribute_field(self) -> pulumi.Input[str]:
        return pulumi.get(self, "group_attribute_field")

    @group_attribute_field.setter
    def group_attribute_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_attribute_field", value)

    @property
    @pulumi.getter(name="userNameAttributeField")
    def user_name_attribute_field(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user_name_attribute_field")

    @user_name_attribute_field.setter
    def user_name_attribute_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name_attribute_field", value)


@pulumi.input_type
class IndexJwtTokenTypeConfigurationArgs:
    def __init__(__self__, *,
                 key_location: pulumi.Input['IndexKeyLocation'],
                 claim_regex: Optional[pulumi.Input[str]] = None,
                 group_attribute_field: Optional[pulumi.Input[str]] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 secret_manager_arn: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 user_name_attribute_field: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "key_location", key_location)
        if claim_regex is not None:
            pulumi.set(__self__, "claim_regex", claim_regex)
        if group_attribute_field is not None:
            pulumi.set(__self__, "group_attribute_field", group_attribute_field)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if secret_manager_arn is not None:
            pulumi.set(__self__, "secret_manager_arn", secret_manager_arn)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if user_name_attribute_field is not None:
            pulumi.set(__self__, "user_name_attribute_field", user_name_attribute_field)

    @property
    @pulumi.getter(name="keyLocation")
    def key_location(self) -> pulumi.Input['IndexKeyLocation']:
        return pulumi.get(self, "key_location")

    @key_location.setter
    def key_location(self, value: pulumi.Input['IndexKeyLocation']):
        pulumi.set(self, "key_location", value)

    @property
    @pulumi.getter(name="claimRegex")
    def claim_regex(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "claim_regex")

    @claim_regex.setter
    def claim_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "claim_regex", value)

    @property
    @pulumi.getter(name="groupAttributeField")
    def group_attribute_field(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "group_attribute_field")

    @group_attribute_field.setter
    def group_attribute_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_attribute_field", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="secretManagerArn")
    def secret_manager_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret_manager_arn")

    @secret_manager_arn.setter
    def secret_manager_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_manager_arn", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="userNameAttributeField")
    def user_name_attribute_field(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user_name_attribute_field")

    @user_name_attribute_field.setter
    def user_name_attribute_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name_attribute_field", value)


@pulumi.input_type
class IndexRelevanceArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[str]] = None,
                 freshness: Optional[pulumi.Input[bool]] = None,
                 importance: Optional[pulumi.Input[int]] = None,
                 rank_order: Optional[pulumi.Input['IndexOrder']] = None,
                 value_importance_items: Optional[pulumi.Input[Sequence[pulumi.Input['IndexValueImportanceItemArgs']]]] = None):
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if freshness is not None:
            pulumi.set(__self__, "freshness", freshness)
        if importance is not None:
            pulumi.set(__self__, "importance", importance)
        if rank_order is not None:
            pulumi.set(__self__, "rank_order", rank_order)
        if value_importance_items is not None:
            pulumi.set(__self__, "value_importance_items", value_importance_items)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def freshness(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "freshness")

    @freshness.setter
    def freshness(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "freshness", value)

    @property
    @pulumi.getter
    def importance(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "importance")

    @importance.setter
    def importance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "importance", value)

    @property
    @pulumi.getter(name="rankOrder")
    def rank_order(self) -> Optional[pulumi.Input['IndexOrder']]:
        return pulumi.get(self, "rank_order")

    @rank_order.setter
    def rank_order(self, value: Optional[pulumi.Input['IndexOrder']]):
        pulumi.set(self, "rank_order", value)

    @property
    @pulumi.getter(name="valueImportanceItems")
    def value_importance_items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexValueImportanceItemArgs']]]]:
        return pulumi.get(self, "value_importance_items")

    @value_importance_items.setter
    def value_importance_items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexValueImportanceItemArgs']]]]):
        pulumi.set(self, "value_importance_items", value)


@pulumi.input_type
class IndexSearchArgs:
    def __init__(__self__, *,
                 displayable: Optional[pulumi.Input[bool]] = None,
                 facetable: Optional[pulumi.Input[bool]] = None,
                 searchable: Optional[pulumi.Input[bool]] = None,
                 sortable: Optional[pulumi.Input[bool]] = None):
        if displayable is not None:
            pulumi.set(__self__, "displayable", displayable)
        if facetable is not None:
            pulumi.set(__self__, "facetable", facetable)
        if searchable is not None:
            pulumi.set(__self__, "searchable", searchable)
        if sortable is not None:
            pulumi.set(__self__, "sortable", sortable)

    @property
    @pulumi.getter
    def displayable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "displayable")

    @displayable.setter
    def displayable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "displayable", value)

    @property
    @pulumi.getter
    def facetable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "facetable")

    @facetable.setter
    def facetable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "facetable", value)

    @property
    @pulumi.getter
    def searchable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "searchable")

    @searchable.setter
    def searchable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "searchable", value)

    @property
    @pulumi.getter
    def sortable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sortable")

    @sortable.setter
    def sortable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sortable", value)


@pulumi.input_type
class IndexServerSideEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_id: The identifier of the AWS KMS key . Amazon Kendra doesn't support asymmetric keys.
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier of the AWS KMS key . Amazon Kendra doesn't support asymmetric keys.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class IndexUserTokenConfigurationArgs:
    def __init__(__self__, *,
                 json_token_type_configuration: Optional[pulumi.Input['IndexJsonTokenTypeConfigurationArgs']] = None,
                 jwt_token_type_configuration: Optional[pulumi.Input['IndexJwtTokenTypeConfigurationArgs']] = None):
        if json_token_type_configuration is not None:
            pulumi.set(__self__, "json_token_type_configuration", json_token_type_configuration)
        if jwt_token_type_configuration is not None:
            pulumi.set(__self__, "jwt_token_type_configuration", jwt_token_type_configuration)

    @property
    @pulumi.getter(name="jsonTokenTypeConfiguration")
    def json_token_type_configuration(self) -> Optional[pulumi.Input['IndexJsonTokenTypeConfigurationArgs']]:
        return pulumi.get(self, "json_token_type_configuration")

    @json_token_type_configuration.setter
    def json_token_type_configuration(self, value: Optional[pulumi.Input['IndexJsonTokenTypeConfigurationArgs']]):
        pulumi.set(self, "json_token_type_configuration", value)

    @property
    @pulumi.getter(name="jwtTokenTypeConfiguration")
    def jwt_token_type_configuration(self) -> Optional[pulumi.Input['IndexJwtTokenTypeConfigurationArgs']]:
        return pulumi.get(self, "jwt_token_type_configuration")

    @jwt_token_type_configuration.setter
    def jwt_token_type_configuration(self, value: Optional[pulumi.Input['IndexJwtTokenTypeConfigurationArgs']]):
        pulumi.set(self, "jwt_token_type_configuration", value)


@pulumi.input_type
class IndexValueImportanceItemArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


