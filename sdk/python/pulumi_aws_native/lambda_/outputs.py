# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AliasProvisionedConcurrencyConfiguration',
    'AliasRoutingConfiguration',
    'AliasVersionWeight',
    'CodeSigningConfigAllowedPublishers',
    'CodeSigningConfigCodeSigningPolicies',
    'EventInvokeConfigDestinationConfig',
    'EventInvokeConfigOnFailure',
    'EventInvokeConfigOnSuccess',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfig',
    'EventSourceMappingDestinationConfig',
    'EventSourceMappingDocumentDBEventSourceConfig',
    'EventSourceMappingEndpoints',
    'EventSourceMappingFilter',
    'EventSourceMappingFilterCriteria',
    'EventSourceMappingOnFailure',
    'EventSourceMappingScalingConfig',
    'EventSourceMappingSelfManagedEventSource',
    'EventSourceMappingSelfManagedKafkaEventSourceConfig',
    'EventSourceMappingSourceAccessConfiguration',
    'FunctionCode',
    'FunctionDeadLetterConfig',
    'FunctionEnvironment',
    'FunctionEphemeralStorage',
    'FunctionFileSystemConfig',
    'FunctionImageConfig',
    'FunctionRuntimeManagementConfig',
    'FunctionSnapStart',
    'FunctionSnapStartResponse',
    'FunctionTag',
    'FunctionTracingConfig',
    'FunctionVpcConfig',
    'LayerVersionContent',
    'UrlCors',
    'VersionProvisionedConcurrencyConfiguration',
]

@pulumi.output_type
class AliasProvisionedConcurrencyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisionedConcurrentExecutions":
            suggest = "provisioned_concurrent_executions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AliasProvisionedConcurrencyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AliasProvisionedConcurrencyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AliasProvisionedConcurrencyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioned_concurrent_executions: int):
        pulumi.set(__self__, "provisioned_concurrent_executions", provisioned_concurrent_executions)

    @property
    @pulumi.getter(name="provisionedConcurrentExecutions")
    def provisioned_concurrent_executions(self) -> int:
        return pulumi.get(self, "provisioned_concurrent_executions")


@pulumi.output_type
class AliasRoutingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalVersionWeights":
            suggest = "additional_version_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AliasRoutingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AliasRoutingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AliasRoutingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_version_weights: Sequence['outputs.AliasVersionWeight']):
        pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Sequence['outputs.AliasVersionWeight']:
        return pulumi.get(self, "additional_version_weights")


@pulumi.output_type
class AliasVersionWeight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionVersion":
            suggest = "function_version"
        elif key == "functionWeight":
            suggest = "function_weight"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AliasVersionWeight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AliasVersionWeight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AliasVersionWeight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function_version: str,
                 function_weight: float):
        pulumi.set(__self__, "function_version", function_version)
        pulumi.set(__self__, "function_weight", function_weight)

    @property
    @pulumi.getter(name="functionVersion")
    def function_version(self) -> str:
        return pulumi.get(self, "function_version")

    @property
    @pulumi.getter(name="functionWeight")
    def function_weight(self) -> float:
        return pulumi.get(self, "function_weight")


@pulumi.output_type
class CodeSigningConfigAllowedPublishers(dict):
    """
    When the CodeSigningConfig is later on attached to a function, the function code will be expected to be signed by profiles from this list
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "signingProfileVersionArns":
            suggest = "signing_profile_version_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeSigningConfigAllowedPublishers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeSigningConfigAllowedPublishers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeSigningConfigAllowedPublishers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 signing_profile_version_arns: Sequence[str]):
        """
        When the CodeSigningConfig is later on attached to a function, the function code will be expected to be signed by profiles from this list
        :param Sequence[str] signing_profile_version_arns: List of Signing profile version Arns
        """
        pulumi.set(__self__, "signing_profile_version_arns", signing_profile_version_arns)

    @property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> Sequence[str]:
        """
        List of Signing profile version Arns
        """
        return pulumi.get(self, "signing_profile_version_arns")


@pulumi.output_type
class CodeSigningConfigCodeSigningPolicies(dict):
    """
    Policies to control how to act if a signature is invalid
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "untrustedArtifactOnDeployment":
            suggest = "untrusted_artifact_on_deployment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeSigningConfigCodeSigningPolicies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeSigningConfigCodeSigningPolicies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeSigningConfigCodeSigningPolicies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: 'CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment'):
        """
        Policies to control how to act if a signature is invalid
        :param 'CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment' untrusted_artifact_on_deployment: Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
        """
        pulumi.set(__self__, "untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> 'CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment':
        """
        Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
        """
        return pulumi.get(self, "untrusted_artifact_on_deployment")


@pulumi.output_type
class EventInvokeConfigDestinationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onFailure":
            suggest = "on_failure"
        elif key == "onSuccess":
            suggest = "on_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventInvokeConfigDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventInvokeConfigDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventInvokeConfigDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_failure: Optional['outputs.EventInvokeConfigOnFailure'] = None,
                 on_success: Optional['outputs.EventInvokeConfigOnSuccess'] = None):
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.EventInvokeConfigOnFailure']:
        return pulumi.get(self, "on_failure")

    @property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional['outputs.EventInvokeConfigOnSuccess']:
        return pulumi.get(self, "on_success")


@pulumi.output_type
class EventInvokeConfigOnFailure(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class EventInvokeConfigOnSuccess(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfig(dict):
    """
    Specific configuration settings for an MSK event source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerGroupId":
            suggest = "consumer_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingAmazonManagedKafkaEventSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingAmazonManagedKafkaEventSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingAmazonManagedKafkaEventSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_group_id: Optional[str] = None):
        """
        Specific configuration settings for an MSK event source.
        :param str consumer_group_id: The identifier for the Kafka Consumer Group to join.
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[str]:
        """
        The identifier for the Kafka Consumer Group to join.
        """
        return pulumi.get(self, "consumer_group_id")


@pulumi.output_type
class EventSourceMappingDestinationConfig(dict):
    """
    (Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onFailure":
            suggest = "on_failure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_failure: Optional['outputs.EventSourceMappingOnFailure'] = None):
        """
        (Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
        :param 'EventSourceMappingOnFailure' on_failure: The destination configuration for failed invocations.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.EventSourceMappingOnFailure']:
        """
        The destination configuration for failed invocations.
        """
        return pulumi.get(self, "on_failure")


@pulumi.output_type
class EventSourceMappingDocumentDBEventSourceConfig(dict):
    """
    Document db event source config.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionName":
            suggest = "collection_name"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "fullDocument":
            suggest = "full_document"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingDocumentDBEventSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingDocumentDBEventSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingDocumentDBEventSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_name: Optional[str] = None,
                 database_name: Optional[str] = None,
                 full_document: Optional['EventSourceMappingDocumentDBEventSourceConfigFullDocument'] = None):
        """
        Document db event source config.
        :param str collection_name: The collection name to connect to.
        :param str database_name: The database name to connect to.
        :param 'EventSourceMappingDocumentDBEventSourceConfigFullDocument' full_document: Include full document in change stream response. The default option will only send the changes made to documents to Lambda. If you want the complete document sent to Lambda, set this to UpdateLookup.
        """
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if full_document is not None:
            pulumi.set(__self__, "full_document", full_document)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        """
        The collection name to connect to.
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The database name to connect to.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="fullDocument")
    def full_document(self) -> Optional['EventSourceMappingDocumentDBEventSourceConfigFullDocument']:
        """
        Include full document in change stream response. The default option will only send the changes made to documents to Lambda. If you want the complete document sent to Lambda, set this to UpdateLookup.
        """
        return pulumi.get(self, "full_document")


@pulumi.output_type
class EventSourceMappingEndpoints(dict):
    """
    The endpoints used by AWS Lambda to access a self-managed event source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaBootstrapServers":
            suggest = "kafka_bootstrap_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingEndpoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingEndpoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingEndpoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_bootstrap_servers: Optional[Sequence[str]] = None):
        """
        The endpoints used by AWS Lambda to access a self-managed event source.
        :param Sequence[str] kafka_bootstrap_servers: A list of Kafka server endpoints.
        """
        if kafka_bootstrap_servers is not None:
            pulumi.set(__self__, "kafka_bootstrap_servers", kafka_bootstrap_servers)

    @property
    @pulumi.getter(name="kafkaBootstrapServers")
    def kafka_bootstrap_servers(self) -> Optional[Sequence[str]]:
        """
        A list of Kafka server endpoints.
        """
        return pulumi.get(self, "kafka_bootstrap_servers")


@pulumi.output_type
class EventSourceMappingFilter(dict):
    """
    The filter object that defines parameters for ESM filtering.
    """
    def __init__(__self__, *,
                 pattern: Optional[str] = None):
        """
        The filter object that defines parameters for ESM filtering.
        :param str pattern: The filter pattern that defines which events should be passed for invocations.
        """
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        The filter pattern that defines which events should be passed for invocations.
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class EventSourceMappingFilterCriteria(dict):
    """
    The filter criteria to control event filtering.
    """
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.EventSourceMappingFilter']] = None):
        """
        The filter criteria to control event filtering.
        :param Sequence['EventSourceMappingFilter'] filters: List of filters of this FilterCriteria
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.EventSourceMappingFilter']]:
        """
        List of filters of this FilterCriteria
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class EventSourceMappingOnFailure(dict):
    """
    A destination for events that failed processing.
    """
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        """
        A destination for events that failed processing.
        :param str destination: The Amazon Resource Name (ARN) of the destination resource.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the destination resource.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class EventSourceMappingScalingConfig(dict):
    """
    The scaling configuration for the event source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumConcurrency":
            suggest = "maximum_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_concurrency: Optional[int] = None):
        """
        The scaling configuration for the event source.
        :param int maximum_concurrency: The maximum number of concurrent functions that the event source can invoke.
        """
        if maximum_concurrency is not None:
            pulumi.set(__self__, "maximum_concurrency", maximum_concurrency)

    @property
    @pulumi.getter(name="maximumConcurrency")
    def maximum_concurrency(self) -> Optional[int]:
        """
        The maximum number of concurrent functions that the event source can invoke.
        """
        return pulumi.get(self, "maximum_concurrency")


@pulumi.output_type
class EventSourceMappingSelfManagedEventSource(dict):
    """
    The configuration used by AWS Lambda to access a self-managed event source.
    """
    def __init__(__self__, *,
                 endpoints: Optional['outputs.EventSourceMappingEndpoints'] = None):
        """
        The configuration used by AWS Lambda to access a self-managed event source.
        :param 'EventSourceMappingEndpoints' endpoints: The endpoints for a self-managed event source.
        """
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional['outputs.EventSourceMappingEndpoints']:
        """
        The endpoints for a self-managed event source.
        """
        return pulumi.get(self, "endpoints")


@pulumi.output_type
class EventSourceMappingSelfManagedKafkaEventSourceConfig(dict):
    """
    Specific configuration settings for a Self-Managed Apache Kafka event source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerGroupId":
            suggest = "consumer_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingSelfManagedKafkaEventSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingSelfManagedKafkaEventSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingSelfManagedKafkaEventSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_group_id: Optional[str] = None):
        """
        Specific configuration settings for a Self-Managed Apache Kafka event source.
        :param str consumer_group_id: The identifier for the Kafka Consumer Group to join.
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[str]:
        """
        The identifier for the Kafka Consumer Group to join.
        """
        return pulumi.get(self, "consumer_group_id")


@pulumi.output_type
class EventSourceMappingSourceAccessConfiguration(dict):
    """
    The configuration used by AWS Lambda to access event source
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "uRI":
            suggest = "u_ri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingSourceAccessConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingSourceAccessConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingSourceAccessConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional['EventSourceMappingSourceAccessConfigurationType'] = None,
                 u_ri: Optional[str] = None):
        """
        The configuration used by AWS Lambda to access event source
        :param 'EventSourceMappingSourceAccessConfigurationType' type: The type of source access configuration.
        :param str u_ri: The URI for the source access configuration resource.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if u_ri is not None:
            pulumi.set(__self__, "u_ri", u_ri)

    @property
    @pulumi.getter
    def type(self) -> Optional['EventSourceMappingSourceAccessConfigurationType']:
        """
        The type of source access configuration.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="uRI")
    def u_ri(self) -> Optional[str]:
        """
        The URI for the source access configuration resource.
        """
        return pulumi.get(self, "u_ri")


@pulumi.output_type
class FunctionCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUri":
            suggest = "image_uri"
        elif key == "s3Bucket":
            suggest = "s3_bucket"
        elif key == "s3Key":
            suggest = "s3_key"
        elif key == "s3ObjectVersion":
            suggest = "s3_object_version"
        elif key == "zipFile":
            suggest = "zip_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_uri: Optional[str] = None,
                 s3_bucket: Optional[str] = None,
                 s3_key: Optional[str] = None,
                 s3_object_version: Optional[str] = None,
                 zip_file: Optional[str] = None):
        """
        :param str image_uri: ImageUri.
        :param str s3_bucket: An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
        :param str s3_key: The Amazon S3 key of the deployment package.
        :param str s3_object_version: For versioned objects, the version of the deployment package object to use.
        :param str zip_file: The source code of your Lambda function. If you include your function source inline with this parameter, AWS CloudFormation places it in a file named index and zips it to create a deployment package..
        """
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)
        if s3_bucket is not None:
            pulumi.set(__self__, "s3_bucket", s3_bucket)
        if s3_key is not None:
            pulumi.set(__self__, "s3_key", s3_key)
        if s3_object_version is not None:
            pulumi.set(__self__, "s3_object_version", s3_object_version)
        if zip_file is not None:
            pulumi.set(__self__, "zip_file", zip_file)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[str]:
        """
        ImageUri.
        """
        return pulumi.get(self, "image_uri")

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> Optional[str]:
        """
        An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
        """
        return pulumi.get(self, "s3_bucket")

    @property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> Optional[str]:
        """
        The Amazon S3 key of the deployment package.
        """
        return pulumi.get(self, "s3_key")

    @property
    @pulumi.getter(name="s3ObjectVersion")
    def s3_object_version(self) -> Optional[str]:
        """
        For versioned objects, the version of the deployment package object to use.
        """
        return pulumi.get(self, "s3_object_version")

    @property
    @pulumi.getter(name="zipFile")
    def zip_file(self) -> Optional[str]:
        """
        The source code of your Lambda function. If you include your function source inline with this parameter, AWS CloudFormation places it in a file named index and zips it to create a deployment package..
        """
        return pulumi.get(self, "zip_file")


@pulumi.output_type
class FunctionDeadLetterConfig(dict):
    """
    The dead-letter queue for failed asynchronous invocations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetArn":
            suggest = "target_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionDeadLetterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionDeadLetterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionDeadLetterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_arn: Optional[str] = None):
        """
        The dead-letter queue for failed asynchronous invocations.
        :param str target_arn: The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        """
        if target_arn is not None:
            pulumi.set(__self__, "target_arn", target_arn)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        """
        return pulumi.get(self, "target_arn")


@pulumi.output_type
class FunctionEnvironment(dict):
    """
    A function's environment variable settings.
    """
    def __init__(__self__, *,
                 variables: Optional[Any] = None):
        """
        A function's environment variable settings.
        :param Any variables: Environment variable key-value pairs.
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def variables(self) -> Optional[Any]:
        """
        Environment variable key-value pairs.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class FunctionEphemeralStorage(dict):
    """
    A function's ephemeral storage settings.
    """
    def __init__(__self__, *,
                 size: int):
        """
        A function's ephemeral storage settings.
        :param int size: The amount of ephemeral storage that your function has access to.
        """
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The amount of ephemeral storage that your function has access to.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class FunctionFileSystemConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localMountPath":
            suggest = "local_mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionFileSystemConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionFileSystemConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionFileSystemConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 local_mount_path: str):
        """
        :param str arn: The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        :param str local_mount_path: The path where the function can access the file system, starting with /mnt/.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "local_mount_path", local_mount_path)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> str:
        """
        The path where the function can access the file system, starting with /mnt/.
        """
        return pulumi.get(self, "local_mount_path")


@pulumi.output_type
class FunctionImageConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPoint":
            suggest = "entry_point"
        elif key == "workingDirectory":
            suggest = "working_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionImageConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionImageConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionImageConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: Optional[Sequence[str]] = None,
                 entry_point: Optional[Sequence[str]] = None,
                 working_directory: Optional[str] = None):
        """
        :param Sequence[str] command: Command.
        :param Sequence[str] entry_point: EntryPoint.
        :param str working_directory: WorkingDirectory.
        """
        if command is not None:
            pulumi.set(__self__, "command", command)
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @property
    @pulumi.getter
    def command(self) -> Optional[Sequence[str]]:
        """
        Command.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[Sequence[str]]:
        """
        EntryPoint.
        """
        return pulumi.get(self, "entry_point")

    @property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[str]:
        """
        WorkingDirectory.
        """
        return pulumi.get(self, "working_directory")


@pulumi.output_type
class FunctionRuntimeManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateRuntimeOn":
            suggest = "update_runtime_on"
        elif key == "runtimeVersionArn":
            suggest = "runtime_version_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionRuntimeManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionRuntimeManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionRuntimeManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 update_runtime_on: 'FunctionRuntimeManagementConfigUpdateRuntimeOn',
                 runtime_version_arn: Optional[str] = None):
        """
        :param 'FunctionRuntimeManagementConfigUpdateRuntimeOn' update_runtime_on: Trigger for runtime update
        :param str runtime_version_arn: Unique identifier for a runtime version arn
        """
        pulumi.set(__self__, "update_runtime_on", update_runtime_on)
        if runtime_version_arn is not None:
            pulumi.set(__self__, "runtime_version_arn", runtime_version_arn)

    @property
    @pulumi.getter(name="updateRuntimeOn")
    def update_runtime_on(self) -> 'FunctionRuntimeManagementConfigUpdateRuntimeOn':
        """
        Trigger for runtime update
        """
        return pulumi.get(self, "update_runtime_on")

    @property
    @pulumi.getter(name="runtimeVersionArn")
    def runtime_version_arn(self) -> Optional[str]:
        """
        Unique identifier for a runtime version arn
        """
        return pulumi.get(self, "runtime_version_arn")


@pulumi.output_type
class FunctionSnapStart(dict):
    """
    The function's SnapStart setting. When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyOn":
            suggest = "apply_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionSnapStart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionSnapStart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionSnapStart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_on: 'FunctionSnapStartApplyOn'):
        """
        The function's SnapStart setting. When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
        :param 'FunctionSnapStartApplyOn' apply_on: Applying SnapStart setting on function resource type.
        """
        pulumi.set(__self__, "apply_on", apply_on)

    @property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> 'FunctionSnapStartApplyOn':
        """
        Applying SnapStart setting on function resource type.
        """
        return pulumi.get(self, "apply_on")


@pulumi.output_type
class FunctionSnapStartResponse(dict):
    """
    The function's SnapStart Response. When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyOn":
            suggest = "apply_on"
        elif key == "optimizationStatus":
            suggest = "optimization_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionSnapStartResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionSnapStartResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionSnapStartResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_on: Optional['FunctionSnapStartResponseApplyOn'] = None,
                 optimization_status: Optional['FunctionSnapStartResponseOptimizationStatus'] = None):
        """
        The function's SnapStart Response. When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
        :param 'FunctionSnapStartResponseApplyOn' apply_on: Applying SnapStart setting on function resource type.
        :param 'FunctionSnapStartResponseOptimizationStatus' optimization_status: Indicates whether SnapStart is activated for the specified function version.
        """
        if apply_on is not None:
            pulumi.set(__self__, "apply_on", apply_on)
        if optimization_status is not None:
            pulumi.set(__self__, "optimization_status", optimization_status)

    @property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> Optional['FunctionSnapStartResponseApplyOn']:
        """
        Applying SnapStart setting on function resource type.
        """
        return pulumi.get(self, "apply_on")

    @property
    @pulumi.getter(name="optimizationStatus")
    def optimization_status(self) -> Optional['FunctionSnapStartResponseOptimizationStatus']:
        """
        Indicates whether SnapStart is activated for the specified function version.
        """
        return pulumi.get(self, "optimization_status")


@pulumi.output_type
class FunctionTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FunctionTracingConfig(dict):
    """
    The function's AWS X-Ray tracing configuration. To sample and record incoming requests, set Mode to Active.
    """
    def __init__(__self__, *,
                 mode: Optional['FunctionTracingConfigMode'] = None):
        """
        The function's AWS X-Ray tracing configuration. To sample and record incoming requests, set Mode to Active.
        :param 'FunctionTracingConfigMode' mode: The tracing mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional['FunctionTracingConfigMode']:
        """
        The tracing mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class FunctionVpcConfig(dict):
    """
    The VPC security groups and subnets that are attached to a Lambda function. When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Optional[Sequence[str]] = None,
                 subnet_ids: Optional[Sequence[str]] = None):
        """
        The VPC security groups and subnets that are attached to a Lambda function. When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC.
        :param Sequence[str] security_group_ids: A list of VPC security groups IDs.
        :param Sequence[str] subnet_ids: A list of VPC subnet IDs.
        """
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of VPC security groups IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        """
        A list of VPC subnet IDs.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class LayerVersionContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Bucket":
            suggest = "s3_bucket"
        elif key == "s3Key":
            suggest = "s3_key"
        elif key == "s3ObjectVersion":
            suggest = "s3_object_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LayerVersionContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LayerVersionContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LayerVersionContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_bucket: str,
                 s3_key: str,
                 s3_object_version: Optional[str] = None):
        """
        :param str s3_bucket: The Amazon S3 bucket of the layer archive.
        :param str s3_key: The Amazon S3 key of the layer archive.
        :param str s3_object_version: For versioned objects, the version of the layer archive object to use.
        """
        pulumi.set(__self__, "s3_bucket", s3_bucket)
        pulumi.set(__self__, "s3_key", s3_key)
        if s3_object_version is not None:
            pulumi.set(__self__, "s3_object_version", s3_object_version)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> str:
        """
        The Amazon S3 bucket of the layer archive.
        """
        return pulumi.get(self, "s3_bucket")

    @property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> str:
        """
        The Amazon S3 key of the layer archive.
        """
        return pulumi.get(self, "s3_key")

    @property
    @pulumi.getter(name="s3ObjectVersion")
    def s3_object_version(self) -> Optional[str]:
        """
        For versioned objects, the version of the layer archive object to use.
        """
        return pulumi.get(self, "s3_object_version")


@pulumi.output_type
class UrlCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[bool] = None,
                 allow_headers: Optional[Sequence[str]] = None,
                 allow_methods: Optional[Sequence['UrlAllowMethodsItem']] = None,
                 allow_origins: Optional[Sequence[str]] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age: Optional[int] = None):
        """
        :param bool allow_credentials: Specifies whether credentials are included in the CORS request.
        :param Sequence[str] allow_headers: Represents a collection of allowed headers.
        :param Sequence['UrlAllowMethodsItem'] allow_methods: Represents a collection of allowed HTTP methods.
        :param Sequence[str] allow_origins: Represents a collection of allowed origins.
        :param Sequence[str] expose_headers: Represents a collection of exposed headers.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        Specifies whether credentials are included in the CORS request.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[str]]:
        """
        Represents a collection of allowed headers.
        """
        return pulumi.get(self, "allow_headers")

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence['UrlAllowMethodsItem']]:
        """
        Represents a collection of allowed HTTP methods.
        """
        return pulumi.get(self, "allow_methods")

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[str]]:
        """
        Represents a collection of allowed origins.
        """
        return pulumi.get(self, "allow_origins")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        Represents a collection of exposed headers.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        return pulumi.get(self, "max_age")


@pulumi.output_type
class VersionProvisionedConcurrencyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisionedConcurrentExecutions":
            suggest = "provisioned_concurrent_executions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VersionProvisionedConcurrencyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VersionProvisionedConcurrencyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VersionProvisionedConcurrencyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioned_concurrent_executions: int):
        pulumi.set(__self__, "provisioned_concurrent_executions", provisioned_concurrent_executions)

    @property
    @pulumi.getter(name="provisionedConcurrentExecutions")
    def provisioned_concurrent_executions(self) -> int:
        return pulumi.get(self, "provisioned_concurrent_executions")


