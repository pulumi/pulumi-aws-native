# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'AliasProvisionedConcurrencyConfigurationArgs',
    'AliasRoutingConfigurationArgs',
    'AliasVersionWeightArgs',
    'CodeSigningConfigAllowedPublishersArgs',
    'CodeSigningConfigCodeSigningPoliciesArgs',
    'EventInvokeConfigDestinationConfigArgs',
    'EventInvokeConfigOnFailureArgs',
    'EventInvokeConfigOnSuccessArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingDestinationConfigArgs',
    'EventSourceMappingDocumentDbEventSourceConfigArgs',
    'EventSourceMappingEndpointsArgs',
    'EventSourceMappingFilterCriteriaArgs',
    'EventSourceMappingFilterArgs',
    'EventSourceMappingOnFailureArgs',
    'EventSourceMappingScalingConfigArgs',
    'EventSourceMappingSelfManagedEventSourceArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingSourceAccessConfigurationArgs',
    'FunctionCodeArgs',
    'FunctionDeadLetterConfigArgs',
    'FunctionEnvironmentArgs',
    'FunctionEphemeralStorageArgs',
    'FunctionFileSystemConfigArgs',
    'FunctionImageConfigArgs',
    'FunctionRuntimeManagementConfigArgs',
    'FunctionSnapStartArgs',
    'FunctionTagArgs',
    'FunctionTracingConfigArgs',
    'FunctionVpcConfigArgs',
    'LayerVersionContentArgs',
    'UrlCorsArgs',
    'VersionProvisionedConcurrencyConfigurationArgs',
    'VersionRuntimePolicyArgs',
]

@pulumi.input_type
class AliasProvisionedConcurrencyConfigurationArgs:
    def __init__(__self__, *,
                 provisioned_concurrent_executions: pulumi.Input[int]):
        AliasProvisionedConcurrencyConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioned_concurrent_executions=provisioned_concurrent_executions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioned_concurrent_executions: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("provisioned_concurrent_executions", provisioned_concurrent_executions)

    @property
    @pulumi.getter(name="provisionedConcurrentExecutions")
    def provisioned_concurrent_executions(self) -> pulumi.Input[int]:
        return pulumi.get(self, "provisioned_concurrent_executions")

    @provisioned_concurrent_executions.setter
    def provisioned_concurrent_executions(self, value: pulumi.Input[int]):
        pulumi.set(self, "provisioned_concurrent_executions", value)


@pulumi.input_type
class AliasRoutingConfigurationArgs:
    def __init__(__self__, *,
                 additional_version_weights: pulumi.Input[Sequence[pulumi.Input['AliasVersionWeightArgs']]]):
        AliasRoutingConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_version_weights=additional_version_weights,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_version_weights: pulumi.Input[Sequence[pulumi.Input['AliasVersionWeightArgs']]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("additional_version_weights", additional_version_weights)

    @property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> pulumi.Input[Sequence[pulumi.Input['AliasVersionWeightArgs']]]:
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: pulumi.Input[Sequence[pulumi.Input['AliasVersionWeightArgs']]]):
        pulumi.set(self, "additional_version_weights", value)


@pulumi.input_type
class AliasVersionWeightArgs:
    def __init__(__self__, *,
                 function_version: pulumi.Input[str],
                 function_weight: pulumi.Input[float]):
        AliasVersionWeightArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            function_version=function_version,
            function_weight=function_weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             function_version: pulumi.Input[str],
             function_weight: pulumi.Input[float],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("function_version", function_version)
        _setter("function_weight", function_weight)

    @property
    @pulumi.getter(name="functionVersion")
    def function_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "function_version")

    @function_version.setter
    def function_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_version", value)

    @property
    @pulumi.getter(name="functionWeight")
    def function_weight(self) -> pulumi.Input[float]:
        return pulumi.get(self, "function_weight")

    @function_weight.setter
    def function_weight(self, value: pulumi.Input[float]):
        pulumi.set(self, "function_weight", value)


@pulumi.input_type
class CodeSigningConfigAllowedPublishersArgs:
    def __init__(__self__, *,
                 signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        When the CodeSigningConfig is later on attached to a function, the function code will be expected to be signed by profiles from this list
        :param pulumi.Input[Sequence[pulumi.Input[str]]] signing_profile_version_arns: List of Signing profile version Arns
        """
        CodeSigningConfigAllowedPublishersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            signing_profile_version_arns=signing_profile_version_arns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("signing_profile_version_arns", signing_profile_version_arns)

    @property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of Signing profile version Arns
        """
        return pulumi.get(self, "signing_profile_version_arns")

    @signing_profile_version_arns.setter
    def signing_profile_version_arns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "signing_profile_version_arns", value)


@pulumi.input_type
class CodeSigningConfigCodeSigningPoliciesArgs:
    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: pulumi.Input['CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment']):
        """
        Policies to control how to act if a signature is invalid
        :param pulumi.Input['CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment'] untrusted_artifact_on_deployment: Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
        """
        CodeSigningConfigCodeSigningPoliciesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            untrusted_artifact_on_deployment=untrusted_artifact_on_deployment,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             untrusted_artifact_on_deployment: pulumi.Input['CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> pulumi.Input['CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment']:
        """
        Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
        """
        return pulumi.get(self, "untrusted_artifact_on_deployment")

    @untrusted_artifact_on_deployment.setter
    def untrusted_artifact_on_deployment(self, value: pulumi.Input['CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment']):
        pulumi.set(self, "untrusted_artifact_on_deployment", value)


@pulumi.input_type
class EventInvokeConfigDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['EventInvokeConfigOnFailureArgs']] = None,
                 on_success: Optional[pulumi.Input['EventInvokeConfigOnSuccessArgs']] = None):
        EventInvokeConfigDestinationConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            on_failure=on_failure,
            on_success=on_success,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             on_failure: Optional[pulumi.Input['EventInvokeConfigOnFailureArgs']] = None,
             on_success: Optional[pulumi.Input['EventInvokeConfigOnSuccessArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if on_failure is not None:
            _setter("on_failure", on_failure)
        if on_success is not None:
            _setter("on_success", on_success)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['EventInvokeConfigOnFailureArgs']]:
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['EventInvokeConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['EventInvokeConfigOnSuccessArgs']]:
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['EventInvokeConfigOnSuccessArgs']]):
        pulumi.set(self, "on_success", value)


@pulumi.input_type
class EventInvokeConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        EventInvokeConfigOnFailureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class EventInvokeConfigOnSuccessArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        EventInvokeConfigOnSuccessArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[str]] = None):
        """
        Specific configuration settings for an MSK event source.
        :param pulumi.Input[str] consumer_group_id: The identifier for the Kafka Consumer Group to join.
        """
        EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_group_id=consumer_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_group_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if consumer_group_id is not None:
            _setter("consumer_group_id", consumer_group_id)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the Kafka Consumer Group to join.
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group_id", value)


@pulumi.input_type
class EventSourceMappingDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['EventSourceMappingOnFailureArgs']] = None):
        """
        (Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
        :param pulumi.Input['EventSourceMappingOnFailureArgs'] on_failure: The destination configuration for failed invocations.
        """
        EventSourceMappingDestinationConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            on_failure=on_failure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             on_failure: Optional[pulumi.Input['EventSourceMappingOnFailureArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if on_failure is not None:
            _setter("on_failure", on_failure)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['EventSourceMappingOnFailureArgs']]:
        """
        The destination configuration for failed invocations.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['EventSourceMappingOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)


@pulumi.input_type
class EventSourceMappingDocumentDbEventSourceConfigArgs:
    def __init__(__self__, *,
                 collection_name: Optional[pulumi.Input[str]] = None,
                 database_name: Optional[pulumi.Input[str]] = None,
                 full_document: Optional[pulumi.Input['EventSourceMappingDocumentDbEventSourceConfigFullDocument']] = None):
        """
        Document db event source config.
        :param pulumi.Input[str] collection_name: The collection name to connect to.
        :param pulumi.Input[str] database_name: The database name to connect to.
        :param pulumi.Input['EventSourceMappingDocumentDbEventSourceConfigFullDocument'] full_document: Include full document in change stream response. The default option will only send the changes made to documents to Lambda. If you want the complete document sent to Lambda, set this to UpdateLookup.
        """
        EventSourceMappingDocumentDbEventSourceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collection_name=collection_name,
            database_name=database_name,
            full_document=full_document,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collection_name: Optional[pulumi.Input[str]] = None,
             database_name: Optional[pulumi.Input[str]] = None,
             full_document: Optional[pulumi.Input['EventSourceMappingDocumentDbEventSourceConfigFullDocument']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if collection_name is not None:
            _setter("collection_name", collection_name)
        if database_name is not None:
            _setter("database_name", database_name)
        if full_document is not None:
            _setter("full_document", full_document)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[str]]:
        """
        The collection name to connect to.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        The database name to connect to.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="fullDocument")
    def full_document(self) -> Optional[pulumi.Input['EventSourceMappingDocumentDbEventSourceConfigFullDocument']]:
        """
        Include full document in change stream response. The default option will only send the changes made to documents to Lambda. If you want the complete document sent to Lambda, set this to UpdateLookup.
        """
        return pulumi.get(self, "full_document")

    @full_document.setter
    def full_document(self, value: Optional[pulumi.Input['EventSourceMappingDocumentDbEventSourceConfigFullDocument']]):
        pulumi.set(self, "full_document", value)


@pulumi.input_type
class EventSourceMappingEndpointsArgs:
    def __init__(__self__, *,
                 kafka_bootstrap_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The endpoints used by AWS Lambda to access a self-managed event source.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kafka_bootstrap_servers: A list of Kafka server endpoints.
        """
        EventSourceMappingEndpointsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kafka_bootstrap_servers=kafka_bootstrap_servers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kafka_bootstrap_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if kafka_bootstrap_servers is not None:
            _setter("kafka_bootstrap_servers", kafka_bootstrap_servers)

    @property
    @pulumi.getter(name="kafkaBootstrapServers")
    def kafka_bootstrap_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Kafka server endpoints.
        """
        return pulumi.get(self, "kafka_bootstrap_servers")

    @kafka_bootstrap_servers.setter
    def kafka_bootstrap_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kafka_bootstrap_servers", value)


@pulumi.input_type
class EventSourceMappingFilterCriteriaArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterArgs']]]] = None):
        """
        The filter criteria to control event filtering.
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterArgs']]] filters: List of filters of this FilterCriteria
        """
        EventSourceMappingFilterCriteriaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filters=filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filters: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if filters is not None:
            _setter("filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterArgs']]]]:
        """
        List of filters of this FilterCriteria
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterArgs']]]]):
        pulumi.set(self, "filters", value)


@pulumi.input_type
class EventSourceMappingFilterArgs:
    def __init__(__self__, *,
                 pattern: Optional[pulumi.Input[str]] = None):
        """
        The filter object that defines parameters for ESM filtering.
        :param pulumi.Input[str] pattern: The filter pattern that defines which events should be passed for invocations.
        """
        EventSourceMappingFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pattern=pattern,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pattern: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pattern is not None:
            _setter("pattern", pattern)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        """
        The filter pattern that defines which events should be passed for invocations.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)


@pulumi.input_type
class EventSourceMappingOnFailureArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        """
        A destination for events that failed processing.
        :param pulumi.Input[str] destination: The Amazon Resource Name (ARN) of the destination resource.
        """
        EventSourceMappingOnFailureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the destination resource.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class EventSourceMappingScalingConfigArgs:
    def __init__(__self__, *,
                 maximum_concurrency: Optional[pulumi.Input[int]] = None):
        """
        The scaling configuration for the event source.
        :param pulumi.Input[int] maximum_concurrency: The maximum number of concurrent functions that the event source can invoke.
        """
        EventSourceMappingScalingConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_concurrency=maximum_concurrency,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_concurrency: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if maximum_concurrency is not None:
            _setter("maximum_concurrency", maximum_concurrency)

    @property
    @pulumi.getter(name="maximumConcurrency")
    def maximum_concurrency(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of concurrent functions that the event source can invoke.
        """
        return pulumi.get(self, "maximum_concurrency")

    @maximum_concurrency.setter
    def maximum_concurrency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_concurrency", value)


@pulumi.input_type
class EventSourceMappingSelfManagedEventSourceArgs:
    def __init__(__self__, *,
                 endpoints: Optional[pulumi.Input['EventSourceMappingEndpointsArgs']] = None):
        """
        The configuration used by AWS Lambda to access a self-managed event source.
        :param pulumi.Input['EventSourceMappingEndpointsArgs'] endpoints: The endpoints for a self-managed event source.
        """
        EventSourceMappingSelfManagedEventSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoints=endpoints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoints: Optional[pulumi.Input['EventSourceMappingEndpointsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if endpoints is not None:
            _setter("endpoints", endpoints)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input['EventSourceMappingEndpointsArgs']]:
        """
        The endpoints for a self-managed event source.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input['EventSourceMappingEndpointsArgs']]):
        pulumi.set(self, "endpoints", value)


@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[str]] = None):
        """
        Specific configuration settings for a Self-Managed Apache Kafka event source.
        :param pulumi.Input[str] consumer_group_id: The identifier for the Kafka Consumer Group to join.
        """
        EventSourceMappingSelfManagedKafkaEventSourceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_group_id=consumer_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_group_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if consumer_group_id is not None:
            _setter("consumer_group_id", consumer_group_id)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the Kafka Consumer Group to join.
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group_id", value)


@pulumi.input_type
class EventSourceMappingSourceAccessConfigurationArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['EventSourceMappingSourceAccessConfigurationType']] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        The configuration used by AWS Lambda to access event source
        :param pulumi.Input['EventSourceMappingSourceAccessConfigurationType'] type: The type of source access configuration.
        :param pulumi.Input[str] uri: The URI for the source access configuration resource.
        """
        EventSourceMappingSourceAccessConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input['EventSourceMappingSourceAccessConfigurationType']] = None,
             uri: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if type is not None:
            _setter("type", type)
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['EventSourceMappingSourceAccessConfigurationType']]:
        """
        The type of source access configuration.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['EventSourceMappingSourceAccessConfigurationType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI for the source access configuration resource.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class FunctionCodeArgs:
    def __init__(__self__, *,
                 image_uri: Optional[pulumi.Input[str]] = None,
                 s3_bucket: Optional[pulumi.Input[str]] = None,
                 s3_key: Optional[pulumi.Input[str]] = None,
                 s3_object_version: Optional[pulumi.Input[str]] = None,
                 zip_file: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_uri: ImageUri.
        :param pulumi.Input[str] s3_bucket: An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
        :param pulumi.Input[str] s3_key: The Amazon S3 key of the deployment package.
        :param pulumi.Input[str] s3_object_version: For versioned objects, the version of the deployment package object to use.
        :param pulumi.Input[str] zip_file: The source code of your Lambda function. If you include your function source inline with this parameter, AWS CloudFormation places it in a file named index and zips it to create a deployment package..
        """
        FunctionCodeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            image_uri=image_uri,
            s3_bucket=s3_bucket,
            s3_key=s3_key,
            s3_object_version=s3_object_version,
            zip_file=zip_file,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             image_uri: Optional[pulumi.Input[str]] = None,
             s3_bucket: Optional[pulumi.Input[str]] = None,
             s3_key: Optional[pulumi.Input[str]] = None,
             s3_object_version: Optional[pulumi.Input[str]] = None,
             zip_file: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if image_uri is not None:
            _setter("image_uri", image_uri)
        if s3_bucket is not None:
            _setter("s3_bucket", s3_bucket)
        if s3_key is not None:
            _setter("s3_key", s3_key)
        if s3_object_version is not None:
            _setter("s3_object_version", s3_object_version)
        if zip_file is not None:
            _setter("zip_file", zip_file)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[pulumi.Input[str]]:
        """
        ImageUri.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_uri", value)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> Optional[pulumi.Input[str]]:
        """
        An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_bucket", value)

    @property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 key of the deployment package.
        """
        return pulumi.get(self, "s3_key")

    @s3_key.setter
    def s3_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_key", value)

    @property
    @pulumi.getter(name="s3ObjectVersion")
    def s3_object_version(self) -> Optional[pulumi.Input[str]]:
        """
        For versioned objects, the version of the deployment package object to use.
        """
        return pulumi.get(self, "s3_object_version")

    @s3_object_version.setter
    def s3_object_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_object_version", value)

    @property
    @pulumi.getter(name="zipFile")
    def zip_file(self) -> Optional[pulumi.Input[str]]:
        """
        The source code of your Lambda function. If you include your function source inline with this parameter, AWS CloudFormation places it in a file named index and zips it to create a deployment package..
        """
        return pulumi.get(self, "zip_file")

    @zip_file.setter
    def zip_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zip_file", value)


@pulumi.input_type
class FunctionDeadLetterConfigArgs:
    def __init__(__self__, *,
                 target_arn: Optional[pulumi.Input[str]] = None):
        """
        The dead-letter queue for failed asynchronous invocations.
        :param pulumi.Input[str] target_arn: The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        """
        FunctionDeadLetterConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_arn=target_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if target_arn is not None:
            _setter("target_arn", target_arn)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_arn", value)


@pulumi.input_type
class FunctionEnvironmentArgs:
    def __init__(__self__, *,
                 variables: Optional[Any] = None):
        """
        A function's environment variable settings.
        :param Any variables: Environment variable key-value pairs.
        """
        FunctionEnvironmentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            variables=variables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             variables: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if variables is not None:
            _setter("variables", variables)

    @property
    @pulumi.getter
    def variables(self) -> Optional[Any]:
        """
        Environment variable key-value pairs.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[Any]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class FunctionEphemeralStorageArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[int]):
        """
        A function's ephemeral storage settings.
        :param pulumi.Input[int] size: The amount of ephemeral storage that your function has access to.
        """
        FunctionEphemeralStorageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             size: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("size", size)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The amount of ephemeral storage that your function has access to.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)


@pulumi.input_type
class FunctionFileSystemConfigArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 local_mount_path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        :param pulumi.Input[str] local_mount_path: The path where the function can access the file system, starting with /mnt/.
        """
        FunctionFileSystemConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            local_mount_path=local_mount_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: pulumi.Input[str],
             local_mount_path: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("arn", arn)
        _setter("local_mount_path", local_mount_path)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> pulumi.Input[str]:
        """
        The path where the function can access the file system, starting with /mnt/.
        """
        return pulumi.get(self, "local_mount_path")

    @local_mount_path.setter
    def local_mount_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_path", value)


@pulumi.input_type
class FunctionImageConfigArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 entry_point: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 working_directory: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] command: Command.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] entry_point: EntryPoint.
        :param pulumi.Input[str] working_directory: WorkingDirectory.
        """
        FunctionImageConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            command=command,
            entry_point=entry_point,
            working_directory=working_directory,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             command: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             entry_point: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             working_directory: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if command is not None:
            _setter("command", command)
        if entry_point is not None:
            _setter("entry_point", entry_point)
        if working_directory is not None:
            _setter("working_directory", working_directory)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Command.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        EntryPoint.
        """
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[pulumi.Input[str]]:
        """
        WorkingDirectory.
        """
        return pulumi.get(self, "working_directory")

    @working_directory.setter
    def working_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "working_directory", value)


@pulumi.input_type
class FunctionRuntimeManagementConfigArgs:
    def __init__(__self__, *,
                 update_runtime_on: pulumi.Input['FunctionRuntimeManagementConfigUpdateRuntimeOn'],
                 runtime_version_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['FunctionRuntimeManagementConfigUpdateRuntimeOn'] update_runtime_on: Trigger for runtime update
        :param pulumi.Input[str] runtime_version_arn: Unique identifier for a runtime version arn
        """
        FunctionRuntimeManagementConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            update_runtime_on=update_runtime_on,
            runtime_version_arn=runtime_version_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             update_runtime_on: pulumi.Input['FunctionRuntimeManagementConfigUpdateRuntimeOn'],
             runtime_version_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("update_runtime_on", update_runtime_on)
        if runtime_version_arn is not None:
            _setter("runtime_version_arn", runtime_version_arn)

    @property
    @pulumi.getter(name="updateRuntimeOn")
    def update_runtime_on(self) -> pulumi.Input['FunctionRuntimeManagementConfigUpdateRuntimeOn']:
        """
        Trigger for runtime update
        """
        return pulumi.get(self, "update_runtime_on")

    @update_runtime_on.setter
    def update_runtime_on(self, value: pulumi.Input['FunctionRuntimeManagementConfigUpdateRuntimeOn']):
        pulumi.set(self, "update_runtime_on", value)

    @property
    @pulumi.getter(name="runtimeVersionArn")
    def runtime_version_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for a runtime version arn
        """
        return pulumi.get(self, "runtime_version_arn")

    @runtime_version_arn.setter
    def runtime_version_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version_arn", value)


@pulumi.input_type
class FunctionSnapStartArgs:
    def __init__(__self__, *,
                 apply_on: pulumi.Input['FunctionSnapStartApplyOn']):
        """
        The function's SnapStart setting. When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
        :param pulumi.Input['FunctionSnapStartApplyOn'] apply_on: Applying SnapStart setting on function resource type.
        """
        FunctionSnapStartArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apply_on=apply_on,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apply_on: pulumi.Input['FunctionSnapStartApplyOn'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("apply_on", apply_on)

    @property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> pulumi.Input['FunctionSnapStartApplyOn']:
        """
        Applying SnapStart setting on function resource type.
        """
        return pulumi.get(self, "apply_on")

    @apply_on.setter
    def apply_on(self, value: pulumi.Input['FunctionSnapStartApplyOn']):
        pulumi.set(self, "apply_on", value)


@pulumi.input_type
class FunctionTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param pulumi.Input[str] value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        FunctionTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class FunctionTracingConfigArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input['FunctionTracingConfigMode']] = None):
        """
        The function's AWS X-Ray tracing configuration. To sample and record incoming requests, set Mode to Active.
        :param pulumi.Input['FunctionTracingConfigMode'] mode: The tracing mode.
        """
        FunctionTracingConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[pulumi.Input['FunctionTracingConfigMode']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input['FunctionTracingConfigMode']]:
        """
        The tracing mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input['FunctionTracingConfigMode']]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class FunctionVpcConfigArgs:
    def __init__(__self__, *,
                 ipv6_allowed_for_dual_stack: Optional[pulumi.Input[bool]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The VPC security groups and subnets that are attached to a Lambda function. When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC.
        :param pulumi.Input[bool] ipv6_allowed_for_dual_stack: A boolean indicating whether IPv6 protocols will be allowed for dual stack subnets
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: A list of VPC security groups IDs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: A list of VPC subnet IDs.
        """
        FunctionVpcConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6_allowed_for_dual_stack=ipv6_allowed_for_dual_stack,
            security_group_ids=security_group_ids,
            subnet_ids=subnet_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6_allowed_for_dual_stack: Optional[pulumi.Input[bool]] = None,
             security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6_allowed_for_dual_stack is not None:
            _setter("ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)
        if subnet_ids is not None:
            _setter("subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean indicating whether IPv6 protocols will be allowed for dual stack subnets
        """
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @ipv6_allowed_for_dual_stack.setter
    def ipv6_allowed_for_dual_stack(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6_allowed_for_dual_stack", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of VPC security groups IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of VPC subnet IDs.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnet_ids", value)


@pulumi.input_type
class LayerVersionContentArgs:
    def __init__(__self__, *,
                 s3_bucket: pulumi.Input[str],
                 s3_key: pulumi.Input[str],
                 s3_object_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] s3_bucket: The Amazon S3 bucket of the layer archive.
        :param pulumi.Input[str] s3_key: The Amazon S3 key of the layer archive.
        :param pulumi.Input[str] s3_object_version: For versioned objects, the version of the layer archive object to use.
        """
        LayerVersionContentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            s3_bucket=s3_bucket,
            s3_key=s3_key,
            s3_object_version=s3_object_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             s3_bucket: pulumi.Input[str],
             s3_key: pulumi.Input[str],
             s3_object_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("s3_bucket", s3_bucket)
        _setter("s3_key", s3_key)
        if s3_object_version is not None:
            _setter("s3_object_version", s3_object_version)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input[str]:
        """
        The Amazon S3 bucket of the layer archive.
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket", value)

    @property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> pulumi.Input[str]:
        """
        The Amazon S3 key of the layer archive.
        """
        return pulumi.get(self, "s3_key")

    @s3_key.setter
    def s3_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_key", value)

    @property
    @pulumi.getter(name="s3ObjectVersion")
    def s3_object_version(self) -> Optional[pulumi.Input[str]]:
        """
        For versioned objects, the version of the layer archive object to use.
        """
        return pulumi.get(self, "s3_object_version")

    @s3_object_version.setter
    def s3_object_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_object_version", value)


@pulumi.input_type
class UrlCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input['UrlAllowMethodsItem']]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] allow_credentials: Specifies whether credentials are included in the CORS request.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_headers: Represents a collection of allowed headers.
        :param pulumi.Input[Sequence[pulumi.Input['UrlAllowMethodsItem']]] allow_methods: Represents a collection of allowed HTTP methods.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_origins: Represents a collection of allowed origins.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: Represents a collection of exposed headers.
        """
        UrlCorsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_credentials: Optional[pulumi.Input[bool]] = None,
             allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input['UrlAllowMethodsItem']]]] = None,
             allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             max_age: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_credentials is not None:
            _setter("allow_credentials", allow_credentials)
        if allow_headers is not None:
            _setter("allow_headers", allow_headers)
        if allow_methods is not None:
            _setter("allow_methods", allow_methods)
        if allow_origins is not None:
            _setter("allow_origins", allow_origins)
        if expose_headers is not None:
            _setter("expose_headers", expose_headers)
        if max_age is not None:
            _setter("max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether credentials are included in the CORS request.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Represents a collection of allowed headers.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_headers", value)

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UrlAllowMethodsItem']]]]:
        """
        Represents a collection of allowed HTTP methods.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UrlAllowMethodsItem']]]]):
        pulumi.set(self, "allow_methods", value)

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Represents a collection of allowed origins.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_origins", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Represents a collection of exposed headers.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


@pulumi.input_type
class VersionProvisionedConcurrencyConfigurationArgs:
    def __init__(__self__, *,
                 provisioned_concurrent_executions: pulumi.Input[int]):
        """
        A provisioned concurrency configuration for a function's version.
        :param pulumi.Input[int] provisioned_concurrent_executions: The amount of provisioned concurrency to allocate for the version.
        """
        VersionProvisionedConcurrencyConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioned_concurrent_executions=provisioned_concurrent_executions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioned_concurrent_executions: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("provisioned_concurrent_executions", provisioned_concurrent_executions)

    @property
    @pulumi.getter(name="provisionedConcurrentExecutions")
    def provisioned_concurrent_executions(self) -> pulumi.Input[int]:
        """
        The amount of provisioned concurrency to allocate for the version.
        """
        return pulumi.get(self, "provisioned_concurrent_executions")

    @provisioned_concurrent_executions.setter
    def provisioned_concurrent_executions(self, value: pulumi.Input[int]):
        pulumi.set(self, "provisioned_concurrent_executions", value)


@pulumi.input_type
class VersionRuntimePolicyArgs:
    def __init__(__self__, *,
                 update_runtime_on: pulumi.Input[str],
                 runtime_version_arn: Optional[pulumi.Input[str]] = None):
        """
        Runtime Management Config of a function.
        :param pulumi.Input[str] update_runtime_on: The runtime update mode.
        :param pulumi.Input[str] runtime_version_arn: The ARN of the runtime the function is configured to use. If the runtime update mode is manual, the ARN is returned, otherwise null is returned.
        """
        VersionRuntimePolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            update_runtime_on=update_runtime_on,
            runtime_version_arn=runtime_version_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             update_runtime_on: pulumi.Input[str],
             runtime_version_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("update_runtime_on", update_runtime_on)
        if runtime_version_arn is not None:
            _setter("runtime_version_arn", runtime_version_arn)

    @property
    @pulumi.getter(name="updateRuntimeOn")
    def update_runtime_on(self) -> pulumi.Input[str]:
        """
        The runtime update mode.
        """
        return pulumi.get(self, "update_runtime_on")

    @update_runtime_on.setter
    def update_runtime_on(self, value: pulumi.Input[str]):
        pulumi.set(self, "update_runtime_on", value)

    @property
    @pulumi.getter(name="runtimeVersionArn")
    def runtime_version_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the runtime the function is configured to use. If the runtime update mode is manual, the ARN is returned, otherwise null is returned.
        """
        return pulumi.get(self, "runtime_version_arn")

    @runtime_version_arn.setter
    def runtime_version_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version_arn", value)


