# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AliasProvisionedConcurrencyConfigurationArgs',
    'AliasProvisionedConcurrencyConfigurationArgsDict',
    'AliasRoutingConfigurationArgs',
    'AliasRoutingConfigurationArgsDict',
    'AliasVersionWeightArgs',
    'AliasVersionWeightArgsDict',
    'CodeSigningConfigAllowedPublishersArgs',
    'CodeSigningConfigAllowedPublishersArgsDict',
    'CodeSigningConfigCodeSigningPoliciesArgs',
    'CodeSigningConfigCodeSigningPoliciesArgsDict',
    'EventInvokeConfigDestinationConfigArgs',
    'EventInvokeConfigDestinationConfigArgsDict',
    'EventInvokeConfigOnFailureArgs',
    'EventInvokeConfigOnFailureArgsDict',
    'EventInvokeConfigOnSuccessArgs',
    'EventInvokeConfigOnSuccessArgsDict',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict',
    'EventSourceMappingDestinationConfigArgs',
    'EventSourceMappingDestinationConfigArgsDict',
    'EventSourceMappingDocumentDbEventSourceConfigArgs',
    'EventSourceMappingDocumentDbEventSourceConfigArgsDict',
    'EventSourceMappingEndpointsArgs',
    'EventSourceMappingEndpointsArgsDict',
    'EventSourceMappingFilterCriteriaArgs',
    'EventSourceMappingFilterCriteriaArgsDict',
    'EventSourceMappingFilterArgs',
    'EventSourceMappingFilterArgsDict',
    'EventSourceMappingMetricsConfigArgs',
    'EventSourceMappingMetricsConfigArgsDict',
    'EventSourceMappingOnFailureArgs',
    'EventSourceMappingOnFailureArgsDict',
    'EventSourceMappingProvisionedPollerConfigArgs',
    'EventSourceMappingProvisionedPollerConfigArgsDict',
    'EventSourceMappingScalingConfigArgs',
    'EventSourceMappingScalingConfigArgsDict',
    'EventSourceMappingSchemaRegistryAccessConfigArgs',
    'EventSourceMappingSchemaRegistryAccessConfigArgsDict',
    'EventSourceMappingSchemaRegistryConfigArgs',
    'EventSourceMappingSchemaRegistryConfigArgsDict',
    'EventSourceMappingSchemaValidationConfigArgs',
    'EventSourceMappingSchemaValidationConfigArgsDict',
    'EventSourceMappingSelfManagedEventSourceArgs',
    'EventSourceMappingSelfManagedEventSourceArgsDict',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict',
    'EventSourceMappingSourceAccessConfigurationArgs',
    'EventSourceMappingSourceAccessConfigurationArgsDict',
    'FunctionCodeArgs',
    'FunctionCodeArgsDict',
    'FunctionDeadLetterConfigArgs',
    'FunctionDeadLetterConfigArgsDict',
    'FunctionEnvironmentArgs',
    'FunctionEnvironmentArgsDict',
    'FunctionEphemeralStorageArgs',
    'FunctionEphemeralStorageArgsDict',
    'FunctionFileSystemConfigArgs',
    'FunctionFileSystemConfigArgsDict',
    'FunctionImageConfigArgs',
    'FunctionImageConfigArgsDict',
    'FunctionLoggingConfigArgs',
    'FunctionLoggingConfigArgsDict',
    'FunctionRuntimeManagementConfigArgs',
    'FunctionRuntimeManagementConfigArgsDict',
    'FunctionSnapStartArgs',
    'FunctionSnapStartArgsDict',
    'FunctionTracingConfigArgs',
    'FunctionTracingConfigArgsDict',
    'FunctionVpcConfigArgs',
    'FunctionVpcConfigArgsDict',
    'LayerVersionContentArgs',
    'LayerVersionContentArgsDict',
    'UrlCorsArgs',
    'UrlCorsArgsDict',
    'VersionProvisionedConcurrencyConfigurationArgs',
    'VersionProvisionedConcurrencyConfigurationArgsDict',
    'VersionRuntimePolicyArgs',
    'VersionRuntimePolicyArgsDict',
]

MYPY = False

if not MYPY:
    class AliasProvisionedConcurrencyConfigurationArgsDict(TypedDict):
        """
        A provisioned concurrency configuration for a function's alias.
        """
        provisioned_concurrent_executions: pulumi.Input[_builtins.int]
        """
        The amount of provisioned concurrency to allocate for the alias.
        """
elif False:
    AliasProvisionedConcurrencyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AliasProvisionedConcurrencyConfigurationArgs:
    def __init__(__self__, *,
                 provisioned_concurrent_executions: pulumi.Input[_builtins.int]):
        """
        A provisioned concurrency configuration for a function's alias.
        :param pulumi.Input[_builtins.int] provisioned_concurrent_executions: The amount of provisioned concurrency to allocate for the alias.
        """
        pulumi.set(__self__, "provisioned_concurrent_executions", provisioned_concurrent_executions)

    @_builtins.property
    @pulumi.getter(name="provisionedConcurrentExecutions")
    def provisioned_concurrent_executions(self) -> pulumi.Input[_builtins.int]:
        """
        The amount of provisioned concurrency to allocate for the alias.
        """
        return pulumi.get(self, "provisioned_concurrent_executions")

    @provisioned_concurrent_executions.setter
    def provisioned_concurrent_executions(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "provisioned_concurrent_executions", value)


if not MYPY:
    class AliasRoutingConfigurationArgsDict(TypedDict):
        """
        The traffic-shifting configuration of a Lambda function alias.
        """
        additional_version_weights: NotRequired[pulumi.Input[Sequence[pulumi.Input['AliasVersionWeightArgsDict']]]]
        """
        The second version, and the percentage of traffic that's routed to it.
        """
elif False:
    AliasRoutingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AliasRoutingConfigurationArgs:
    def __init__(__self__, *,
                 additional_version_weights: Optional[pulumi.Input[Sequence[pulumi.Input['AliasVersionWeightArgs']]]] = None):
        """
        The traffic-shifting configuration of a Lambda function alias.
        :param pulumi.Input[Sequence[pulumi.Input['AliasVersionWeightArgs']]] additional_version_weights: The second version, and the percentage of traffic that's routed to it.
        """
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @_builtins.property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AliasVersionWeightArgs']]]]:
        """
        The second version, and the percentage of traffic that's routed to it.
        """
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AliasVersionWeightArgs']]]]):
        pulumi.set(self, "additional_version_weights", value)


if not MYPY:
    class AliasVersionWeightArgsDict(TypedDict):
        """
        The traffic-shifting configuration of a Lambda function alias.
        """
        function_version: pulumi.Input[_builtins.str]
        """
        The qualifier of the second version.
        """
        function_weight: pulumi.Input[_builtins.float]
        """
        The percentage of traffic that the alias routes to the second version.
        """
elif False:
    AliasVersionWeightArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AliasVersionWeightArgs:
    def __init__(__self__, *,
                 function_version: pulumi.Input[_builtins.str],
                 function_weight: pulumi.Input[_builtins.float]):
        """
        The traffic-shifting configuration of a Lambda function alias.
        :param pulumi.Input[_builtins.str] function_version: The qualifier of the second version.
        :param pulumi.Input[_builtins.float] function_weight: The percentage of traffic that the alias routes to the second version.
        """
        pulumi.set(__self__, "function_version", function_version)
        pulumi.set(__self__, "function_weight", function_weight)

    @_builtins.property
    @pulumi.getter(name="functionVersion")
    def function_version(self) -> pulumi.Input[_builtins.str]:
        """
        The qualifier of the second version.
        """
        return pulumi.get(self, "function_version")

    @function_version.setter
    def function_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "function_version", value)

    @_builtins.property
    @pulumi.getter(name="functionWeight")
    def function_weight(self) -> pulumi.Input[_builtins.float]:
        """
        The percentage of traffic that the alias routes to the second version.
        """
        return pulumi.get(self, "function_weight")

    @function_weight.setter
    def function_weight(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "function_weight", value)


if not MYPY:
    class CodeSigningConfigAllowedPublishersArgsDict(TypedDict):
        """
        When the CodeSigningConfig is later on attached to a function, the function code will be expected to be signed by profiles from this list
        """
        signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of Signing profile version Arns
        """
elif False:
    CodeSigningConfigAllowedPublishersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSigningConfigAllowedPublishersArgs:
    def __init__(__self__, *,
                 signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        When the CodeSigningConfig is later on attached to a function, the function code will be expected to be signed by profiles from this list
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] signing_profile_version_arns: List of Signing profile version Arns
        """
        pulumi.set(__self__, "signing_profile_version_arns", signing_profile_version_arns)

    @_builtins.property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of Signing profile version Arns
        """
        return pulumi.get(self, "signing_profile_version_arns")

    @signing_profile_version_arns.setter
    def signing_profile_version_arns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "signing_profile_version_arns", value)


if not MYPY:
    class CodeSigningConfigCodeSigningPoliciesArgsDict(TypedDict):
        """
        Policies to control how to act if a signature is invalid
        """
        untrusted_artifact_on_deployment: pulumi.Input['CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment']
        """
        Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
        """
elif False:
    CodeSigningConfigCodeSigningPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSigningConfigCodeSigningPoliciesArgs:
    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: pulumi.Input['CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment']):
        """
        Policies to control how to act if a signature is invalid
        :param pulumi.Input['CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment'] untrusted_artifact_on_deployment: Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
        """
        pulumi.set(__self__, "untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @_builtins.property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> pulumi.Input['CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment']:
        """
        Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
        """
        return pulumi.get(self, "untrusted_artifact_on_deployment")

    @untrusted_artifact_on_deployment.setter
    def untrusted_artifact_on_deployment(self, value: pulumi.Input['CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment']):
        pulumi.set(self, "untrusted_artifact_on_deployment", value)


if not MYPY:
    class EventInvokeConfigDestinationConfigArgsDict(TypedDict):
        """
        A destination for events after they have been sent to a function for processing.
        """
        on_failure: NotRequired[pulumi.Input['EventInvokeConfigOnFailureArgsDict']]
        """
        The destination configuration for failed invocations.

        > When using an Amazon SQS queue as a destination, FIFO queues cannot be used.
        """
        on_success: NotRequired[pulumi.Input['EventInvokeConfigOnSuccessArgsDict']]
        """
        The destination configuration for successful invocations.

        > When using an Amazon SQS queue as a destination, FIFO queues cannot be used.
        """
elif False:
    EventInvokeConfigDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventInvokeConfigDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['EventInvokeConfigOnFailureArgs']] = None,
                 on_success: Optional[pulumi.Input['EventInvokeConfigOnSuccessArgs']] = None):
        """
        A destination for events after they have been sent to a function for processing.
        :param pulumi.Input['EventInvokeConfigOnFailureArgs'] on_failure: The destination configuration for failed invocations.
               
               > When using an Amazon SQS queue as a destination, FIFO queues cannot be used.
        :param pulumi.Input['EventInvokeConfigOnSuccessArgs'] on_success: The destination configuration for successful invocations.
               
               > When using an Amazon SQS queue as a destination, FIFO queues cannot be used.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['EventInvokeConfigOnFailureArgs']]:
        """
        The destination configuration for failed invocations.

        > When using an Amazon SQS queue as a destination, FIFO queues cannot be used.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['EventInvokeConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['EventInvokeConfigOnSuccessArgs']]:
        """
        The destination configuration for successful invocations.

        > When using an Amazon SQS queue as a destination, FIFO queues cannot be used.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['EventInvokeConfigOnSuccessArgs']]):
        pulumi.set(self, "on_success", value)


if not MYPY:
    class EventInvokeConfigOnFailureArgsDict(TypedDict):
        """
        The destination configuration for failed invocations.
        """
        destination: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the destination resource.
        """
elif False:
    EventInvokeConfigOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventInvokeConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str]):
        """
        The destination configuration for failed invocations.
        :param pulumi.Input[_builtins.str] destination: The Amazon Resource Name (ARN) of the destination resource.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the destination resource.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class EventInvokeConfigOnSuccessArgsDict(TypedDict):
        """
        The destination configuration for successful invocations.
        """
        destination: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the destination resource.
        """
elif False:
    EventInvokeConfigOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventInvokeConfigOnSuccessArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str]):
        """
        The destination configuration for successful invocations.
        :param pulumi.Input[_builtins.str] destination: The Amazon Resource Name (ARN) of the destination resource.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the destination resource.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict(TypedDict):
        """
        Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
        """
        consumer_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id).
        """
        schema_registry_config: NotRequired[pulumi.Input['EventSourceMappingSchemaRegistryConfigArgsDict']]
        """
        Specific configuration settings for a Kafka schema registry.
        """
elif False:
    EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry_config: Optional[pulumi.Input['EventSourceMappingSchemaRegistryConfigArgs']] = None):
        """
        Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
        :param pulumi.Input[_builtins.str] consumer_group_id: The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id).
        :param pulumi.Input['EventSourceMappingSchemaRegistryConfigArgs'] schema_registry_config: Specific configuration settings for a Kafka schema registry.
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id).
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_group_id", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional[pulumi.Input['EventSourceMappingSchemaRegistryConfigArgs']]:
        """
        Specific configuration settings for a Kafka schema registry.
        """
        return pulumi.get(self, "schema_registry_config")

    @schema_registry_config.setter
    def schema_registry_config(self, value: Optional[pulumi.Input['EventSourceMappingSchemaRegistryConfigArgs']]):
        pulumi.set(self, "schema_registry_config", value)


if not MYPY:
    class EventSourceMappingDestinationConfigArgsDict(TypedDict):
        """
        A configuration object that specifies the destination of an event after Lambda processes it. For more information, see [Adding a destination](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-async-destinations).
        """
        on_failure: NotRequired[pulumi.Input['EventSourceMappingOnFailureArgsDict']]
        """
        The destination configuration for failed invocations.
        """
elif False:
    EventSourceMappingDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['EventSourceMappingOnFailureArgs']] = None):
        """
        A configuration object that specifies the destination of an event after Lambda processes it. For more information, see [Adding a destination](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-async-destinations).
        :param pulumi.Input['EventSourceMappingOnFailureArgs'] on_failure: The destination configuration for failed invocations.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['EventSourceMappingOnFailureArgs']]:
        """
        The destination configuration for failed invocations.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['EventSourceMappingOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)


if not MYPY:
    class EventSourceMappingDocumentDbEventSourceConfigArgsDict(TypedDict):
        """
        Specific configuration settings for a DocumentDB event source.
        """
        collection_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the database to consume within the DocumentDB cluster.
        """
        full_document: NotRequired[pulumi.Input['EventSourceMappingDocumentDbEventSourceConfigFullDocument']]
        """
        Determines what DocumentDB sends to your event stream during document update operations. If set to UpdateLookup, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes.
        """
elif False:
    EventSourceMappingDocumentDbEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDocumentDbEventSourceConfigArgs:
    def __init__(__self__, *,
                 collection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 full_document: Optional[pulumi.Input['EventSourceMappingDocumentDbEventSourceConfigFullDocument']] = None):
        """
        Specific configuration settings for a DocumentDB event source.
        :param pulumi.Input[_builtins.str] collection_name: The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        :param pulumi.Input[_builtins.str] database_name: The name of the database to consume within the DocumentDB cluster.
        :param pulumi.Input['EventSourceMappingDocumentDbEventSourceConfigFullDocument'] full_document: Determines what DocumentDB sends to your event stream during document update operations. If set to UpdateLookup, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes.
        """
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if full_document is not None:
            pulumi.set(__self__, "full_document", full_document)

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collection_name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the database to consume within the DocumentDB cluster.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="fullDocument")
    def full_document(self) -> Optional[pulumi.Input['EventSourceMappingDocumentDbEventSourceConfigFullDocument']]:
        """
        Determines what DocumentDB sends to your event stream during document update operations. If set to UpdateLookup, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes.
        """
        return pulumi.get(self, "full_document")

    @full_document.setter
    def full_document(self, value: Optional[pulumi.Input['EventSourceMappingDocumentDbEventSourceConfigFullDocument']]):
        pulumi.set(self, "full_document", value)


if not MYPY:
    class EventSourceMappingEndpointsArgsDict(TypedDict):
        """
        The list of bootstrap servers for your Kafka brokers in the following format: ``"KafkaBootstrapServers": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]``.
        """
        kafka_bootstrap_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of bootstrap servers for your Kafka brokers in the following format: ``"KafkaBootstrapServers": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]``.
        """
elif False:
    EventSourceMappingEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingEndpointsArgs:
    def __init__(__self__, *,
                 kafka_bootstrap_servers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The list of bootstrap servers for your Kafka brokers in the following format: ``"KafkaBootstrapServers": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]``.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] kafka_bootstrap_servers: The list of bootstrap servers for your Kafka brokers in the following format: ``"KafkaBootstrapServers": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]``.
        """
        if kafka_bootstrap_servers is not None:
            pulumi.set(__self__, "kafka_bootstrap_servers", kafka_bootstrap_servers)

    @_builtins.property
    @pulumi.getter(name="kafkaBootstrapServers")
    def kafka_bootstrap_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of bootstrap servers for your Kafka brokers in the following format: ``"KafkaBootstrapServers": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]``.
        """
        return pulumi.get(self, "kafka_bootstrap_servers")

    @kafka_bootstrap_servers.setter
    def kafka_bootstrap_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "kafka_bootstrap_servers", value)


if not MYPY:
    class EventSourceMappingFilterCriteriaArgsDict(TypedDict):
        """
        An object that contains the filters for an event source.
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterArgsDict']]]]
        """
        A list of filters.
        """
elif False:
    EventSourceMappingFilterCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingFilterCriteriaArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterArgs']]]] = None):
        """
        An object that contains the filters for an event source.
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterArgs']]] filters: A list of filters.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterArgs']]]]:
        """
        A list of filters.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class EventSourceMappingFilterArgsDict(TypedDict):
        """
        A structure within a ``FilterCriteria`` object that defines an event filtering pattern.
        """
        pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter pattern. For more information on the syntax of a filter pattern, see [Filter rule syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
elif False:
    EventSourceMappingFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingFilterArgs:
    def __init__(__self__, *,
                 pattern: Optional[pulumi.Input[_builtins.str]] = None):
        """
        A structure within a ``FilterCriteria`` object that defines an event filtering pattern.
        :param pulumi.Input[_builtins.str] pattern: A filter pattern. For more information on the syntax of a filter pattern, see [Filter rule syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter pattern. For more information on the syntax of a filter pattern, see [Filter rule syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class EventSourceMappingMetricsConfigArgsDict(TypedDict):
        """
        The metrics configuration for your event source. Use this configuration object to define which metrics you want your event source mapping to produce.
        """
        metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingMetricsConfigMetricsItem']]]]
        """
        The metrics you want your event source mapping to produce. Include ``EventCount`` to receive event source mapping metrics related to the number of events processed by your event source mapping. For more information about these metrics, see [Event source mapping metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
        """
elif False:
    EventSourceMappingMetricsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingMetricsConfigArgs:
    def __init__(__self__, *,
                 metrics: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingMetricsConfigMetricsItem']]]] = None):
        """
        The metrics configuration for your event source. Use this configuration object to define which metrics you want your event source mapping to produce.
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingMetricsConfigMetricsItem']]] metrics: The metrics you want your event source mapping to produce. Include ``EventCount`` to receive event source mapping metrics related to the number of events processed by your event source mapping. For more information about these metrics, see [Event source mapping metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
        """
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingMetricsConfigMetricsItem']]]]:
        """
        The metrics you want your event source mapping to produce. Include ``EventCount`` to receive event source mapping metrics related to the number of events processed by your event source mapping. For more information about these metrics, see [Event source mapping metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingMetricsConfigMetricsItem']]]]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class EventSourceMappingOnFailureArgsDict(TypedDict):
        """
        A destination for events that failed processing. For more information, see [Adding a destination](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-async-destinations).
        """
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the destination resource.
         To retain records of unsuccessful [asynchronous invocations](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations), you can configure an Amazon SNS topic, Amazon SQS queue, Amazon S3 bucket, Lambda function, or Amazon EventBridge event bus as the destination.
         To retain records of failed invocations from [Kinesis](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html), [DynamoDB](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html), [self-managed Kafka](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka.html#services-smaa-onfailure-destination) or [Amazon MSK](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-onfailure-destination), you can configure an Amazon SNS topic, Amazon SQS queue, or Amazon S3 bucket as the destination.
        """
elif False:
    EventSourceMappingOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingOnFailureArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None):
        """
        A destination for events that failed processing. For more information, see [Adding a destination](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-async-destinations).
        :param pulumi.Input[_builtins.str] destination: The Amazon Resource Name (ARN) of the destination resource.
                To retain records of unsuccessful [asynchronous invocations](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations), you can configure an Amazon SNS topic, Amazon SQS queue, Amazon S3 bucket, Lambda function, or Amazon EventBridge event bus as the destination.
                To retain records of failed invocations from [Kinesis](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html), [DynamoDB](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html), [self-managed Kafka](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka.html#services-smaa-onfailure-destination) or [Amazon MSK](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-onfailure-destination), you can configure an Amazon SNS topic, Amazon SQS queue, or Amazon S3 bucket as the destination.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the destination resource.
         To retain records of unsuccessful [asynchronous invocations](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations), you can configure an Amazon SNS topic, Amazon SQS queue, Amazon S3 bucket, Lambda function, or Amazon EventBridge event bus as the destination.
         To retain records of failed invocations from [Kinesis](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html), [DynamoDB](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html), [self-managed Kafka](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka.html#services-smaa-onfailure-destination) or [Amazon MSK](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-onfailure-destination), you can configure an Amazon SNS topic, Amazon SQS queue, or Amazon S3 bucket as the destination.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class EventSourceMappingProvisionedPollerConfigArgsDict(TypedDict):
        """
        The [provisioned mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode) configuration for the event source. Use provisioned mode to customize the minimum and maximum number of event pollers for your event source.
        """
        maximum_pollers: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of event pollers this event source can scale up to.
        """
        minimum_pollers: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of event pollers this event source can scale down to.
        """
elif False:
    EventSourceMappingProvisionedPollerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingProvisionedPollerConfigArgs:
    def __init__(__self__, *,
                 maximum_pollers: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum_pollers: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The [provisioned mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode) configuration for the event source. Use provisioned mode to customize the minimum and maximum number of event pollers for your event source.
        :param pulumi.Input[_builtins.int] maximum_pollers: The maximum number of event pollers this event source can scale up to.
        :param pulumi.Input[_builtins.int] minimum_pollers: The minimum number of event pollers this event source can scale down to.
        """
        if maximum_pollers is not None:
            pulumi.set(__self__, "maximum_pollers", maximum_pollers)
        if minimum_pollers is not None:
            pulumi.set(__self__, "minimum_pollers", minimum_pollers)

    @_builtins.property
    @pulumi.getter(name="maximumPollers")
    def maximum_pollers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of event pollers this event source can scale up to.
        """
        return pulumi.get(self, "maximum_pollers")

    @maximum_pollers.setter
    def maximum_pollers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_pollers", value)

    @_builtins.property
    @pulumi.getter(name="minimumPollers")
    def minimum_pollers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of event pollers this event source can scale down to.
        """
        return pulumi.get(self, "minimum_pollers")

    @minimum_pollers.setter
    def minimum_pollers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum_pollers", value)


if not MYPY:
    class EventSourceMappingScalingConfigArgsDict(TypedDict):
        """
        (Amazon SQS only) The scaling configuration for the event source. To remove the configuration, pass an empty value.
        """
        maximum_concurrency: NotRequired[pulumi.Input[_builtins.int]]
        """
        Limits the number of concurrent instances that the SQS event source can invoke.
        """
elif False:
    EventSourceMappingScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingScalingConfigArgs:
    def __init__(__self__, *,
                 maximum_concurrency: Optional[pulumi.Input[_builtins.int]] = None):
        """
        (Amazon SQS only) The scaling configuration for the event source. To remove the configuration, pass an empty value.
        :param pulumi.Input[_builtins.int] maximum_concurrency: Limits the number of concurrent instances that the SQS event source can invoke.
        """
        if maximum_concurrency is not None:
            pulumi.set(__self__, "maximum_concurrency", maximum_concurrency)

    @_builtins.property
    @pulumi.getter(name="maximumConcurrency")
    def maximum_concurrency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Limits the number of concurrent instances that the SQS event source can invoke.
        """
        return pulumi.get(self, "maximum_concurrency")

    @maximum_concurrency.setter
    def maximum_concurrency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_concurrency", value)


if not MYPY:
    class EventSourceMappingSchemaRegistryAccessConfigArgsDict(TypedDict):
        """
        Specific access configuration settings that tell Lambda how to authenticate with your schema registry.
         If you're working with an GLU schema registry, don't provide authentication details in this object. Instead, ensure that your execution role has the required permissions for Lambda to access your cluster.
         If you're working with a Confluent schema registry, choose the authentication method in the ``Type`` field, and provide the ASMlong secret ARN in the ``URI`` field.
        """
        type: NotRequired[pulumi.Input['EventSourceMappingSchemaRegistryAccessConfigType']]
        """
        The type of authentication Lambda uses to access your schema registry.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI of the secret (Secrets Manager secret ARN) to authenticate with your schema registry.
        """
elif False:
    EventSourceMappingSchemaRegistryAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSchemaRegistryAccessConfigArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['EventSourceMappingSchemaRegistryAccessConfigType']] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specific access configuration settings that tell Lambda how to authenticate with your schema registry.
         If you're working with an GLU schema registry, don't provide authentication details in this object. Instead, ensure that your execution role has the required permissions for Lambda to access your cluster.
         If you're working with a Confluent schema registry, choose the authentication method in the ``Type`` field, and provide the ASMlong secret ARN in the ``URI`` field.
        :param pulumi.Input['EventSourceMappingSchemaRegistryAccessConfigType'] type: The type of authentication Lambda uses to access your schema registry.
        :param pulumi.Input[_builtins.str] uri: The URI of the secret (Secrets Manager secret ARN) to authenticate with your schema registry.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['EventSourceMappingSchemaRegistryAccessConfigType']]:
        """
        The type of authentication Lambda uses to access your schema registry.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['EventSourceMappingSchemaRegistryAccessConfigType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI of the secret (Secrets Manager secret ARN) to authenticate with your schema registry.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class EventSourceMappingSchemaRegistryConfigArgsDict(TypedDict):
        """
        Specific configuration settings for a Kafka schema registry.
        """
        access_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSchemaRegistryAccessConfigArgsDict']]]]
        """
        An array of access configuration objects that tell Lambda how to authenticate with your schema registry.
        """
        event_record_format: NotRequired[pulumi.Input['EventSourceMappingSchemaRegistryConfigEventRecordFormat']]
        """
        The record format that Lambda delivers to your function after schema validation.
          +  Choose ``JSON`` to have Lambda deliver the record to your function as a standard JSON object.
          +  Choose ``SOURCE`` to have Lambda deliver the record to your function in its original source format. Lambda removes all schema metadata, such as the schema ID, before sending the record to your function.
        """
        schema_registry_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI for your schema registry. The correct URI format depends on the type of schema registry you're using.
          +  For GLU schema registries, use the ARN of the registry.
          +  For Confluent schema registries, use the URL of the registry.
        """
        schema_validation_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSchemaValidationConfigArgsDict']]]]
        """
        An array of schema validation configuration objects, which tell Lambda the message attributes you want to validate and filter using your schema registry.
        """
elif False:
    EventSourceMappingSchemaRegistryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSchemaRegistryConfigArgs:
    def __init__(__self__, *,
                 access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSchemaRegistryAccessConfigArgs']]]] = None,
                 event_record_format: Optional[pulumi.Input['EventSourceMappingSchemaRegistryConfigEventRecordFormat']] = None,
                 schema_registry_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_validation_configs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSchemaValidationConfigArgs']]]] = None):
        """
        Specific configuration settings for a Kafka schema registry.
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSchemaRegistryAccessConfigArgs']]] access_configs: An array of access configuration objects that tell Lambda how to authenticate with your schema registry.
        :param pulumi.Input['EventSourceMappingSchemaRegistryConfigEventRecordFormat'] event_record_format: The record format that Lambda delivers to your function after schema validation.
                 +  Choose ``JSON`` to have Lambda deliver the record to your function as a standard JSON object.
                 +  Choose ``SOURCE`` to have Lambda deliver the record to your function in its original source format. Lambda removes all schema metadata, such as the schema ID, before sending the record to your function.
        :param pulumi.Input[_builtins.str] schema_registry_uri: The URI for your schema registry. The correct URI format depends on the type of schema registry you're using.
                 +  For GLU schema registries, use the ARN of the registry.
                 +  For Confluent schema registries, use the URL of the registry.
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSchemaValidationConfigArgs']]] schema_validation_configs: An array of schema validation configuration objects, which tell Lambda the message attributes you want to validate and filter using your schema registry.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if event_record_format is not None:
            pulumi.set(__self__, "event_record_format", event_record_format)
        if schema_registry_uri is not None:
            pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)
        if schema_validation_configs is not None:
            pulumi.set(__self__, "schema_validation_configs", schema_validation_configs)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSchemaRegistryAccessConfigArgs']]]]:
        """
        An array of access configuration objects that tell Lambda how to authenticate with your schema registry.
        """
        return pulumi.get(self, "access_configs")

    @access_configs.setter
    def access_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSchemaRegistryAccessConfigArgs']]]]):
        pulumi.set(self, "access_configs", value)

    @_builtins.property
    @pulumi.getter(name="eventRecordFormat")
    def event_record_format(self) -> Optional[pulumi.Input['EventSourceMappingSchemaRegistryConfigEventRecordFormat']]:
        """
        The record format that Lambda delivers to your function after schema validation.
          +  Choose ``JSON`` to have Lambda deliver the record to your function as a standard JSON object.
          +  Choose ``SOURCE`` to have Lambda deliver the record to your function in its original source format. Lambda removes all schema metadata, such as the schema ID, before sending the record to your function.
        """
        return pulumi.get(self, "event_record_format")

    @event_record_format.setter
    def event_record_format(self, value: Optional[pulumi.Input['EventSourceMappingSchemaRegistryConfigEventRecordFormat']]):
        pulumi.set(self, "event_record_format", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI for your schema registry. The correct URI format depends on the type of schema registry you're using.
          +  For GLU schema registries, use the ARN of the registry.
          +  For Confluent schema registries, use the URL of the registry.
        """
        return pulumi.get(self, "schema_registry_uri")

    @schema_registry_uri.setter
    def schema_registry_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_registry_uri", value)

    @_builtins.property
    @pulumi.getter(name="schemaValidationConfigs")
    def schema_validation_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSchemaValidationConfigArgs']]]]:
        """
        An array of schema validation configuration objects, which tell Lambda the message attributes you want to validate and filter using your schema registry.
        """
        return pulumi.get(self, "schema_validation_configs")

    @schema_validation_configs.setter
    def schema_validation_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSchemaValidationConfigArgs']]]]):
        pulumi.set(self, "schema_validation_configs", value)


if not MYPY:
    class EventSourceMappingSchemaValidationConfigArgsDict(TypedDict):
        """
        Specific schema validation configuration settings that tell Lambda the message attributes you want to validate and filter using your schema registry.
        """
        attribute: NotRequired[pulumi.Input['EventSourceMappingSchemaValidationConfigAttribute']]
        """
        The attributes you want your schema registry to validate and filter for. If you selected ``JSON`` as the ``EventRecordFormat``, Lambda also deserializes the selected message attributes.
        """
elif False:
    EventSourceMappingSchemaValidationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSchemaValidationConfigArgs:
    def __init__(__self__, *,
                 attribute: Optional[pulumi.Input['EventSourceMappingSchemaValidationConfigAttribute']] = None):
        """
        Specific schema validation configuration settings that tell Lambda the message attributes you want to validate and filter using your schema registry.
        :param pulumi.Input['EventSourceMappingSchemaValidationConfigAttribute'] attribute: The attributes you want your schema registry to validate and filter for. If you selected ``JSON`` as the ``EventRecordFormat``, Lambda also deserializes the selected message attributes.
        """
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> Optional[pulumi.Input['EventSourceMappingSchemaValidationConfigAttribute']]:
        """
        The attributes you want your schema registry to validate and filter for. If you selected ``JSON`` as the ``EventRecordFormat``, Lambda also deserializes the selected message attributes.
        """
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: Optional[pulumi.Input['EventSourceMappingSchemaValidationConfigAttribute']]):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class EventSourceMappingSelfManagedEventSourceArgsDict(TypedDict):
        """
        The self-managed Apache Kafka cluster for your event source.
        """
        endpoints: NotRequired[pulumi.Input['EventSourceMappingEndpointsArgsDict']]
        """
        The list of bootstrap servers for your Kafka brokers in the following format: ``"KafkaBootstrapServers": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]``.
        """
elif False:
    EventSourceMappingSelfManagedEventSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedEventSourceArgs:
    def __init__(__self__, *,
                 endpoints: Optional[pulumi.Input['EventSourceMappingEndpointsArgs']] = None):
        """
        The self-managed Apache Kafka cluster for your event source.
        :param pulumi.Input['EventSourceMappingEndpointsArgs'] endpoints: The list of bootstrap servers for your Kafka brokers in the following format: ``"KafkaBootstrapServers": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]``.
        """
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input['EventSourceMappingEndpointsArgs']]:
        """
        The list of bootstrap servers for your Kafka brokers in the following format: ``"KafkaBootstrapServers": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]``.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input['EventSourceMappingEndpointsArgs']]):
        pulumi.set(self, "endpoints", value)


if not MYPY:
    class EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict(TypedDict):
        """
        Specific configuration settings for a self-managed Apache Kafka event source.
        """
        consumer_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka-process.html#services-smaa-topic-add).
        """
        schema_registry_config: NotRequired[pulumi.Input['EventSourceMappingSchemaRegistryConfigArgsDict']]
        """
        Specific configuration settings for a Kafka schema registry.
        """
elif False:
    EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry_config: Optional[pulumi.Input['EventSourceMappingSchemaRegistryConfigArgs']] = None):
        """
        Specific configuration settings for a self-managed Apache Kafka event source.
        :param pulumi.Input[_builtins.str] consumer_group_id: The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka-process.html#services-smaa-topic-add).
        :param pulumi.Input['EventSourceMappingSchemaRegistryConfigArgs'] schema_registry_config: Specific configuration settings for a Kafka schema registry.
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka-process.html#services-smaa-topic-add).
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_group_id", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional[pulumi.Input['EventSourceMappingSchemaRegistryConfigArgs']]:
        """
        Specific configuration settings for a Kafka schema registry.
        """
        return pulumi.get(self, "schema_registry_config")

    @schema_registry_config.setter
    def schema_registry_config(self, value: Optional[pulumi.Input['EventSourceMappingSchemaRegistryConfigArgs']]):
        pulumi.set(self, "schema_registry_config", value)


if not MYPY:
    class EventSourceMappingSourceAccessConfigurationArgsDict(TypedDict):
        """
        An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
        """
        type: NotRequired[pulumi.Input['EventSourceMappingSourceAccessConfigurationType']]
        """
        The type of authentication protocol, VPC components, or virtual host for your event source. For example: ``"Type":"SASL_SCRAM_512_AUTH"``.
          +  ``BASIC_AUTH``  (Amazon MQ) The ASMlong secret that stores your broker credentials.
          +  ``BASIC_AUTH``  (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.
          +  ``VPC_SUBNET``  (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.
          +  ``VPC_SECURITY_GROUP``  (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.
          +  ``SASL_SCRAM_256_AUTH``  (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.
          +  ``SASL_SCRAM_512_AUTH``  (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.
          +  ``VIRTUAL_HOST`` - (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.
          +  ``CLIENT_CERTIFICATE_TLS_AUTH``  (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.
          +  ``SERVER_ROOT_CA_CERTIFICATE``  (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value for your chosen configuration in ``Type``. For example: ``"URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName"``.
        """
elif False:
    EventSourceMappingSourceAccessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSourceAccessConfigurationArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['EventSourceMappingSourceAccessConfigurationType']] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
        :param pulumi.Input['EventSourceMappingSourceAccessConfigurationType'] type: The type of authentication protocol, VPC components, or virtual host for your event source. For example: ``"Type":"SASL_SCRAM_512_AUTH"``.
                 +  ``BASIC_AUTH``  (Amazon MQ) The ASMlong secret that stores your broker credentials.
                 +  ``BASIC_AUTH``  (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.
                 +  ``VPC_SUBNET``  (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.
                 +  ``VPC_SECURITY_GROUP``  (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.
                 +  ``SASL_SCRAM_256_AUTH``  (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.
                 +  ``SASL_SCRAM_512_AUTH``  (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.
                 +  ``VIRTUAL_HOST`` - (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.
                 +  ``CLIENT_CERTIFICATE_TLS_AUTH``  (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.
                 +  ``SERVER_ROOT_CA_CERTIFICATE``  (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers.
        :param pulumi.Input[_builtins.str] uri: The value for your chosen configuration in ``Type``. For example: ``"URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName"``.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['EventSourceMappingSourceAccessConfigurationType']]:
        """
        The type of authentication protocol, VPC components, or virtual host for your event source. For example: ``"Type":"SASL_SCRAM_512_AUTH"``.
          +  ``BASIC_AUTH``  (Amazon MQ) The ASMlong secret that stores your broker credentials.
          +  ``BASIC_AUTH``  (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.
          +  ``VPC_SUBNET``  (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.
          +  ``VPC_SECURITY_GROUP``  (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.
          +  ``SASL_SCRAM_256_AUTH``  (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.
          +  ``SASL_SCRAM_512_AUTH``  (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.
          +  ``VIRTUAL_HOST`` - (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.
          +  ``CLIENT_CERTIFICATE_TLS_AUTH``  (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.
          +  ``SERVER_ROOT_CA_CERTIFICATE``  (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['EventSourceMappingSourceAccessConfigurationType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value for your chosen configuration in ``Type``. For example: ``"URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName"``.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class FunctionCodeArgsDict(TypedDict):
        """
        The [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html) for a Lambda function. To deploy a function defined as a container image, you specify the location of a container image in the Amazon ECR registry. For a .zip file deployment package, you can specify the location of an object in Amazon S3. For Node.js and Python functions, you can specify the function code inline in the template.
          When you specify source code inline for a Node.js function, the ``index`` file that CFN creates uses the extension ``.js``. This means that LAM treats the file as a CommonJS module. ES modules aren't supported for inline functions.
          Changes to a deployment package in Amazon S3 or a container image in ECR are not detected automatically during stack updates. To update the function code, change the object key or version in the template.
        """
        image_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of a [container image](https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html) in the Amazon ECR registry.
        """
        s3_bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        An Amazon S3 bucket in the same AWS-Region as your function. The bucket can be in a different AWS-account.
        """
        s3_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon S3 key of the deployment package.
        """
        s3_object_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        For versioned objects, the version of the deployment package object to use.
        """
        source_kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the KMSlong (KMS) customer managed key that's used to encrypt your function's .zip deployment package. If you don't provide a customer managed key, Lambda uses an [owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk).
        """
        zip_file: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Node.js and Python) The source code of your Lambda function. If you include your function source inline with this parameter, CFN places it in a file named ``index`` and zips it to create a [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html). This zip file cannot exceed 4MB. For the ``Handler`` property, the first part of the handler identifier must be ``index``. For example, ``index.handler``.
          When you specify source code inline for a Node.js function, the ``index`` file that CFN creates uses the extension ``.js``. This means that LAM treats the file as a CommonJS module. ES modules aren't supported for inline functions.
           For JSON, you must escape quotes and special characters such as newline (``\\n``) with a backslash.
         If you specify a function that interacts with an AWS CloudFormation custom resource, you don't have to write your own functions to send responses to the custom resource that invoked the function. AWS CloudFormation provides a response module ([cfn-response](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-lambda-function-code-cfnresponsemodule.html)) that simplifies sending responses. See [Using Lambda with CloudFormation](https://docs.aws.amazon.com/lambda/latest/dg/services-cloudformation.html) for details.
        """
elif False:
    FunctionCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionCodeArgs:
    def __init__(__self__, *,
                 image_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_key: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_object_version: Optional[pulumi.Input[_builtins.str]] = None,
                 source_kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 zip_file: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html) for a Lambda function. To deploy a function defined as a container image, you specify the location of a container image in the Amazon ECR registry. For a .zip file deployment package, you can specify the location of an object in Amazon S3. For Node.js and Python functions, you can specify the function code inline in the template.
          When you specify source code inline for a Node.js function, the ``index`` file that CFN creates uses the extension ``.js``. This means that LAM treats the file as a CommonJS module. ES modules aren't supported for inline functions.
          Changes to a deployment package in Amazon S3 or a container image in ECR are not detected automatically during stack updates. To update the function code, change the object key or version in the template.
        :param pulumi.Input[_builtins.str] image_uri: URI of a [container image](https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html) in the Amazon ECR registry.
        :param pulumi.Input[_builtins.str] s3_bucket: An Amazon S3 bucket in the same AWS-Region as your function. The bucket can be in a different AWS-account.
        :param pulumi.Input[_builtins.str] s3_key: The Amazon S3 key of the deployment package.
        :param pulumi.Input[_builtins.str] s3_object_version: For versioned objects, the version of the deployment package object to use.
        :param pulumi.Input[_builtins.str] source_kms_key_arn: The ARN of the KMSlong (KMS) customer managed key that's used to encrypt your function's .zip deployment package. If you don't provide a customer managed key, Lambda uses an [owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk).
        :param pulumi.Input[_builtins.str] zip_file: (Node.js and Python) The source code of your Lambda function. If you include your function source inline with this parameter, CFN places it in a file named ``index`` and zips it to create a [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html). This zip file cannot exceed 4MB. For the ``Handler`` property, the first part of the handler identifier must be ``index``. For example, ``index.handler``.
                 When you specify source code inline for a Node.js function, the ``index`` file that CFN creates uses the extension ``.js``. This means that LAM treats the file as a CommonJS module. ES modules aren't supported for inline functions.
                  For JSON, you must escape quotes and special characters such as newline (``\\n``) with a backslash.
                If you specify a function that interacts with an AWS CloudFormation custom resource, you don't have to write your own functions to send responses to the custom resource that invoked the function. AWS CloudFormation provides a response module ([cfn-response](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-lambda-function-code-cfnresponsemodule.html)) that simplifies sending responses. See [Using Lambda with CloudFormation](https://docs.aws.amazon.com/lambda/latest/dg/services-cloudformation.html) for details.
        """
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)
        if s3_bucket is not None:
            pulumi.set(__self__, "s3_bucket", s3_bucket)
        if s3_key is not None:
            pulumi.set(__self__, "s3_key", s3_key)
        if s3_object_version is not None:
            pulumi.set(__self__, "s3_object_version", s3_object_version)
        if source_kms_key_arn is not None:
            pulumi.set(__self__, "source_kms_key_arn", source_kms_key_arn)
        if zip_file is not None:
            pulumi.set(__self__, "zip_file", zip_file)

    @_builtins.property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of a [container image](https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html) in the Amazon ECR registry.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_uri", value)

    @_builtins.property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An Amazon S3 bucket in the same AWS-Region as your function. The bucket can be in a different AWS-account.
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_bucket", value)

    @_builtins.property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon S3 key of the deployment package.
        """
        return pulumi.get(self, "s3_key")

    @s3_key.setter
    def s3_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_key", value)

    @_builtins.property
    @pulumi.getter(name="s3ObjectVersion")
    def s3_object_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For versioned objects, the version of the deployment package object to use.
        """
        return pulumi.get(self, "s3_object_version")

    @s3_object_version.setter
    def s3_object_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_object_version", value)

    @_builtins.property
    @pulumi.getter(name="sourceKmsKeyArn")
    def source_kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the KMSlong (KMS) customer managed key that's used to encrypt your function's .zip deployment package. If you don't provide a customer managed key, Lambda uses an [owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk).
        """
        return pulumi.get(self, "source_kms_key_arn")

    @source_kms_key_arn.setter
    def source_kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_kms_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="zipFile")
    def zip_file(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Node.js and Python) The source code of your Lambda function. If you include your function source inline with this parameter, CFN places it in a file named ``index`` and zips it to create a [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html). This zip file cannot exceed 4MB. For the ``Handler`` property, the first part of the handler identifier must be ``index``. For example, ``index.handler``.
          When you specify source code inline for a Node.js function, the ``index`` file that CFN creates uses the extension ``.js``. This means that LAM treats the file as a CommonJS module. ES modules aren't supported for inline functions.
           For JSON, you must escape quotes and special characters such as newline (``\\n``) with a backslash.
         If you specify a function that interacts with an AWS CloudFormation custom resource, you don't have to write your own functions to send responses to the custom resource that invoked the function. AWS CloudFormation provides a response module ([cfn-response](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-lambda-function-code-cfnresponsemodule.html)) that simplifies sending responses. See [Using Lambda with CloudFormation](https://docs.aws.amazon.com/lambda/latest/dg/services-cloudformation.html) for details.
        """
        return pulumi.get(self, "zip_file")

    @zip_file.setter
    def zip_file(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zip_file", value)


if not MYPY:
    class FunctionDeadLetterConfigArgsDict(TypedDict):
        """
        The [dead-letter queue](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-dlq) for failed asynchronous invocations.
        """
        target_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        """
elif False:
    FunctionDeadLetterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionDeadLetterConfigArgs:
    def __init__(__self__, *,
                 target_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The [dead-letter queue](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-dlq) for failed asynchronous invocations.
        :param pulumi.Input[_builtins.str] target_arn: The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        """
        if target_arn is not None:
            pulumi.set(__self__, "target_arn", target_arn)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_arn", value)


if not MYPY:
    class FunctionEnvironmentArgsDict(TypedDict):
        """
        A function's environment variable settings. You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.
        """
        variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Environment variable key-value pairs. For more information, see [Using Lambda environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
         If the value of the environment variable is a time or a duration, enclose the value in quotes.
        """
elif False:
    FunctionEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEnvironmentArgs:
    def __init__(__self__, *,
                 variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        A function's environment variable settings. You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] variables: Environment variable key-value pairs. For more information, see [Using Lambda environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
                If the value of the environment variable is a time or a duration, enclose the value in quotes.
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Environment variable key-value pairs. For more information, see [Using Lambda environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
         If the value of the environment variable is a time or a duration, enclose the value in quotes.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class FunctionEphemeralStorageArgsDict(TypedDict):
        """
        The size of the function's ``/tmp`` directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.
        """
        size: pulumi.Input[_builtins.int]
        """
        The size of the function's ``/tmp`` directory.
        """
elif False:
    FunctionEphemeralStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEphemeralStorageArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int]):
        """
        The size of the function's ``/tmp`` directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.
        :param pulumi.Input[_builtins.int] size: The size of the function's ``/tmp`` directory.
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        The size of the function's ``/tmp`` directory.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)


if not MYPY:
    class FunctionFileSystemConfigArgsDict(TypedDict):
        """
        Details about the connection between a Lambda function and an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
        """
        arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        """
        local_mount_path: pulumi.Input[_builtins.str]
        """
        The path where the function can access the file system, starting with ``/mnt/``.
        """
elif False:
    FunctionFileSystemConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionFileSystemConfigArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 local_mount_path: pulumi.Input[_builtins.str]):
        """
        Details about the connection between a Lambda function and an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
        :param pulumi.Input[_builtins.str] arn: The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        :param pulumi.Input[_builtins.str] local_mount_path: The path where the function can access the file system, starting with ``/mnt/``.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "local_mount_path", local_mount_path)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        The path where the function can access the file system, starting with ``/mnt/``.
        """
        return pulumi.get(self, "local_mount_path")

    @local_mount_path.setter
    def local_mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "local_mount_path", value)


if not MYPY:
    class FunctionImageConfigArgsDict(TypedDict):
        """
        Configuration values that override the container image Dockerfile settings. For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms).
        """
        command: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies parameters that you want to pass in with ENTRYPOINT. You can specify a maximum of 1,500 parameters in the list.
        """
        entry_point: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the entry point to their application, which is typically the location of the runtime executable. You can specify a maximum of 1,500 string entries in the list.
        """
        working_directory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the working directory. The length of the directory string cannot exceed 1,000 characters.
        """
elif False:
    FunctionImageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionImageConfigArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entry_point: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 working_directory: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configuration values that override the container image Dockerfile settings. For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] command: Specifies parameters that you want to pass in with ENTRYPOINT. You can specify a maximum of 1,500 parameters in the list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entry_point: Specifies the entry point to their application, which is typically the location of the runtime executable. You can specify a maximum of 1,500 string entries in the list.
        :param pulumi.Input[_builtins.str] working_directory: Specifies the working directory. The length of the directory string cannot exceed 1,000 characters.
        """
        if command is not None:
            pulumi.set(__self__, "command", command)
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies parameters that you want to pass in with ENTRYPOINT. You can specify a maximum of 1,500 parameters in the list.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the entry point to their application, which is typically the location of the runtime executable. You can specify a maximum of 1,500 string entries in the list.
        """
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entry_point", value)

    @_builtins.property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the working directory. The length of the directory string cannot exceed 1,000 characters.
        """
        return pulumi.get(self, "working_directory")

    @working_directory.setter
    def working_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_directory", value)


if not MYPY:
    class FunctionLoggingConfigArgsDict(TypedDict):
        """
        The function's Amazon CloudWatch Logs configuration settings.
        """
        application_log_level: NotRequired[pulumi.Input['FunctionLoggingConfigApplicationLogLevel']]
        """
        Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where ``TRACE`` is the highest level and ``FATAL`` is the lowest.
        """
        log_format: NotRequired[pulumi.Input['FunctionLoggingConfigLogFormat']]
        """
        The format in which Lambda sends your function's application and system logs to CloudWatch. Select between plain text and structured JSON.
        """
        log_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named ``/aws/lambda/<function name>``. To use a different log group, enter an existing log group or enter a new log group name.
        """
        system_log_level: NotRequired[pulumi.Input['FunctionLoggingConfigSystemLogLevel']]
        """
        Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where ``DEBUG`` is the highest level and ``WARN`` is the lowest.
        """
elif False:
    FunctionLoggingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionLoggingConfigArgs:
    def __init__(__self__, *,
                 application_log_level: Optional[pulumi.Input['FunctionLoggingConfigApplicationLogLevel']] = None,
                 log_format: Optional[pulumi.Input['FunctionLoggingConfigLogFormat']] = None,
                 log_group: Optional[pulumi.Input[_builtins.str]] = None,
                 system_log_level: Optional[pulumi.Input['FunctionLoggingConfigSystemLogLevel']] = None):
        """
        The function's Amazon CloudWatch Logs configuration settings.
        :param pulumi.Input['FunctionLoggingConfigApplicationLogLevel'] application_log_level: Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where ``TRACE`` is the highest level and ``FATAL`` is the lowest.
        :param pulumi.Input['FunctionLoggingConfigLogFormat'] log_format: The format in which Lambda sends your function's application and system logs to CloudWatch. Select between plain text and structured JSON.
        :param pulumi.Input[_builtins.str] log_group: The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named ``/aws/lambda/<function name>``. To use a different log group, enter an existing log group or enter a new log group name.
        :param pulumi.Input['FunctionLoggingConfigSystemLogLevel'] system_log_level: Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where ``DEBUG`` is the highest level and ``WARN`` is the lowest.
        """
        if application_log_level is not None:
            pulumi.set(__self__, "application_log_level", application_log_level)
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)
        if system_log_level is not None:
            pulumi.set(__self__, "system_log_level", system_log_level)

    @_builtins.property
    @pulumi.getter(name="applicationLogLevel")
    def application_log_level(self) -> Optional[pulumi.Input['FunctionLoggingConfigApplicationLogLevel']]:
        """
        Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where ``TRACE`` is the highest level and ``FATAL`` is the lowest.
        """
        return pulumi.get(self, "application_log_level")

    @application_log_level.setter
    def application_log_level(self, value: Optional[pulumi.Input['FunctionLoggingConfigApplicationLogLevel']]):
        pulumi.set(self, "application_log_level", value)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[pulumi.Input['FunctionLoggingConfigLogFormat']]:
        """
        The format in which Lambda sends your function's application and system logs to CloudWatch. Select between plain text and structured JSON.
        """
        return pulumi.get(self, "log_format")

    @log_format.setter
    def log_format(self, value: Optional[pulumi.Input['FunctionLoggingConfigLogFormat']]):
        pulumi.set(self, "log_format", value)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named ``/aws/lambda/<function name>``. To use a different log group, enter an existing log group or enter a new log group name.
        """
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group", value)

    @_builtins.property
    @pulumi.getter(name="systemLogLevel")
    def system_log_level(self) -> Optional[pulumi.Input['FunctionLoggingConfigSystemLogLevel']]:
        """
        Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where ``DEBUG`` is the highest level and ``WARN`` is the lowest.
        """
        return pulumi.get(self, "system_log_level")

    @system_log_level.setter
    def system_log_level(self, value: Optional[pulumi.Input['FunctionLoggingConfigSystemLogLevel']]):
        pulumi.set(self, "system_log_level", value)


if not MYPY:
    class FunctionRuntimeManagementConfigArgsDict(TypedDict):
        """
        Sets the runtime management configuration for a function's version. For more information, see [Runtime updates](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html).
        """
        update_runtime_on: pulumi.Input['FunctionRuntimeManagementConfigUpdateRuntimeOn']
        """
        Specify the runtime update mode.
          +  *Auto (default)* - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.
          +  *FunctionUpdate* - LAM updates the runtime of you function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.
          +  *Manual* - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).
          
         *Valid Values*: ``Auto`` | ``FunctionUpdate`` | ``Manual``
        """
        runtime_version_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the runtime version you want the function to use.
          This is only required if you're using the *Manual* runtime update mode.
        """
elif False:
    FunctionRuntimeManagementConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionRuntimeManagementConfigArgs:
    def __init__(__self__, *,
                 update_runtime_on: pulumi.Input['FunctionRuntimeManagementConfigUpdateRuntimeOn'],
                 runtime_version_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Sets the runtime management configuration for a function's version. For more information, see [Runtime updates](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html).
        :param pulumi.Input['FunctionRuntimeManagementConfigUpdateRuntimeOn'] update_runtime_on: Specify the runtime update mode.
                 +  *Auto (default)* - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.
                 +  *FunctionUpdate* - LAM updates the runtime of you function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.
                 +  *Manual* - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).
                 
                *Valid Values*: ``Auto`` | ``FunctionUpdate`` | ``Manual``
        :param pulumi.Input[_builtins.str] runtime_version_arn: The ARN of the runtime version you want the function to use.
                 This is only required if you're using the *Manual* runtime update mode.
        """
        pulumi.set(__self__, "update_runtime_on", update_runtime_on)
        if runtime_version_arn is not None:
            pulumi.set(__self__, "runtime_version_arn", runtime_version_arn)

    @_builtins.property
    @pulumi.getter(name="updateRuntimeOn")
    def update_runtime_on(self) -> pulumi.Input['FunctionRuntimeManagementConfigUpdateRuntimeOn']:
        """
        Specify the runtime update mode.
          +  *Auto (default)* - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.
          +  *FunctionUpdate* - LAM updates the runtime of you function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.
          +  *Manual* - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).
          
         *Valid Values*: ``Auto`` | ``FunctionUpdate`` | ``Manual``
        """
        return pulumi.get(self, "update_runtime_on")

    @update_runtime_on.setter
    def update_runtime_on(self, value: pulumi.Input['FunctionRuntimeManagementConfigUpdateRuntimeOn']):
        pulumi.set(self, "update_runtime_on", value)

    @_builtins.property
    @pulumi.getter(name="runtimeVersionArn")
    def runtime_version_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the runtime version you want the function to use.
          This is only required if you're using the *Manual* runtime update mode.
        """
        return pulumi.get(self, "runtime_version_arn")

    @runtime_version_arn.setter
    def runtime_version_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runtime_version_arn", value)


if not MYPY:
    class FunctionSnapStartArgsDict(TypedDict):
        """
        The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
        """
        apply_on: pulumi.Input['FunctionSnapStartApplyOn']
        """
        Set ``ApplyOn`` to ``PublishedVersions`` to create a snapshot of the initialized execution environment when you publish a function version.
        """
elif False:
    FunctionSnapStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionSnapStartArgs:
    def __init__(__self__, *,
                 apply_on: pulumi.Input['FunctionSnapStartApplyOn']):
        """
        The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
        :param pulumi.Input['FunctionSnapStartApplyOn'] apply_on: Set ``ApplyOn`` to ``PublishedVersions`` to create a snapshot of the initialized execution environment when you publish a function version.
        """
        pulumi.set(__self__, "apply_on", apply_on)

    @_builtins.property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> pulumi.Input['FunctionSnapStartApplyOn']:
        """
        Set ``ApplyOn`` to ``PublishedVersions`` to create a snapshot of the initialized execution environment when you publish a function version.
        """
        return pulumi.get(self, "apply_on")

    @apply_on.setter
    def apply_on(self, value: pulumi.Input['FunctionSnapStartApplyOn']):
        pulumi.set(self, "apply_on", value)


if not MYPY:
    class FunctionTracingConfigArgsDict(TypedDict):
        """
        The function's [](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) tracing configuration. To sample and record incoming requests, set ``Mode`` to ``Active``.
        """
        mode: NotRequired[pulumi.Input['FunctionTracingConfigMode']]
        """
        The tracing mode.
        """
elif False:
    FunctionTracingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTracingConfigArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input['FunctionTracingConfigMode']] = None):
        """
        The function's [](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) tracing configuration. To sample and record incoming requests, set ``Mode`` to ``Active``.
        :param pulumi.Input['FunctionTracingConfigMode'] mode: The tracing mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input['FunctionTracingConfigMode']]:
        """
        The tracing mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input['FunctionTracingConfigMode']]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class FunctionVpcConfigArgsDict(TypedDict):
        """
        The VPC security groups and subnets that are attached to a Lambda function. When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
          When you delete a function, CFN monitors the state of its network interfaces and waits for Lambda to delete them before proceeding. If the VPC is defined in the same stack, the network interfaces need to be deleted by Lambda before CFN can delete the VPC's resources.
         To monitor network interfaces, CFN needs the ``ec2:DescribeNetworkInterfaces`` permission. It obtains this from the user or role that modifies the stack. If you don't provide this permission, CFN does not wait for network interfaces to be deleted.
        """
        ipv6_allowed_for_dual_stack: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of VPC security group IDs.
        """
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of VPC subnet IDs.
        """
elif False:
    FunctionVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionVpcConfigArgs:
    def __init__(__self__, *,
                 ipv6_allowed_for_dual_stack: Optional[pulumi.Input[_builtins.bool]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The VPC security groups and subnets that are attached to a Lambda function. When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
          When you delete a function, CFN monitors the state of its network interfaces and waits for Lambda to delete them before proceeding. If the VPC is defined in the same stack, the network interfaces need to be deleted by Lambda before CFN can delete the VPC's resources.
         To monitor network interfaces, CFN needs the ``ec2:DescribeNetworkInterfaces`` permission. It obtains this from the user or role that modifies the stack. If you don't provide this permission, CFN does not wait for network interfaces to be deleted.
        :param pulumi.Input[_builtins.bool] ipv6_allowed_for_dual_stack: Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: A list of VPC security group IDs.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: A list of VPC subnet IDs.
        """
        if ipv6_allowed_for_dual_stack is not None:
            pulumi.set(__self__, "ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.
        """
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @ipv6_allowed_for_dual_stack.setter
    def ipv6_allowed_for_dual_stack(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_allowed_for_dual_stack", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of VPC security group IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of VPC subnet IDs.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class LayerVersionContentArgsDict(TypedDict):
        s3_bucket: pulumi.Input[_builtins.str]
        """
        The Amazon S3 bucket of the layer archive.
        """
        s3_key: pulumi.Input[_builtins.str]
        """
        The Amazon S3 key of the layer archive.
        """
        s3_object_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        For versioned objects, the version of the layer archive object to use.
        """
elif False:
    LayerVersionContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LayerVersionContentArgs:
    def __init__(__self__, *,
                 s3_bucket: pulumi.Input[_builtins.str],
                 s3_key: pulumi.Input[_builtins.str],
                 s3_object_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] s3_bucket: The Amazon S3 bucket of the layer archive.
        :param pulumi.Input[_builtins.str] s3_key: The Amazon S3 key of the layer archive.
        :param pulumi.Input[_builtins.str] s3_object_version: For versioned objects, the version of the layer archive object to use.
        """
        pulumi.set(__self__, "s3_bucket", s3_bucket)
        pulumi.set(__self__, "s3_key", s3_key)
        if s3_object_version is not None:
            pulumi.set(__self__, "s3_object_version", s3_object_version)

    @_builtins.property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon S3 bucket of the layer archive.
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_bucket", value)

    @_builtins.property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon S3 key of the layer archive.
        """
        return pulumi.get(self, "s3_key")

    @s3_key.setter
    def s3_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_key", value)

    @_builtins.property
    @pulumi.getter(name="s3ObjectVersion")
    def s3_object_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For versioned objects, the version of the layer archive object to use.
        """
        return pulumi.get(self, "s3_object_version")

    @s3_object_version.setter
    def s3_object_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_object_version", value)


if not MYPY:
    class UrlCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether credentials are included in the CORS request.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Represents a collection of allowed headers.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input['UrlAllowMethodsItem']]]]
        """
        Represents a collection of allowed HTTP methods.
        """
        allow_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Represents a collection of allowed origins.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Represents a collection of exposed headers.
        """
        max_age: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum amount of time, in seconds, that browsers can cache results of a preflight request. By default, this is set to `0` , which means the browser will not cache results.
        """
elif False:
    UrlCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UrlCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input['UrlAllowMethodsItem']]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_credentials: Specifies whether credentials are included in the CORS request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_headers: Represents a collection of allowed headers.
        :param pulumi.Input[Sequence[pulumi.Input['UrlAllowMethodsItem']]] allow_methods: Represents a collection of allowed HTTP methods.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_origins: Represents a collection of allowed origins.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: Represents a collection of exposed headers.
        :param pulumi.Input[_builtins.int] max_age: The maximum amount of time, in seconds, that browsers can cache results of a preflight request. By default, this is set to `0` , which means the browser will not cache results.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether credentials are included in the CORS request.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Represents a collection of allowed headers.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UrlAllowMethodsItem']]]]:
        """
        Represents a collection of allowed HTTP methods.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UrlAllowMethodsItem']]]]):
        pulumi.set(self, "allow_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Represents a collection of allowed origins.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_origins", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Represents a collection of exposed headers.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum amount of time, in seconds, that browsers can cache results of a preflight request. By default, this is set to `0` , which means the browser will not cache results.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class VersionProvisionedConcurrencyConfigurationArgsDict(TypedDict):
        """
        A provisioned concurrency configuration for a function's version.
        """
        provisioned_concurrent_executions: pulumi.Input[_builtins.int]
        """
        The amount of provisioned concurrency to allocate for the version.
        """
elif False:
    VersionProvisionedConcurrencyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VersionProvisionedConcurrencyConfigurationArgs:
    def __init__(__self__, *,
                 provisioned_concurrent_executions: pulumi.Input[_builtins.int]):
        """
        A provisioned concurrency configuration for a function's version.
        :param pulumi.Input[_builtins.int] provisioned_concurrent_executions: The amount of provisioned concurrency to allocate for the version.
        """
        pulumi.set(__self__, "provisioned_concurrent_executions", provisioned_concurrent_executions)

    @_builtins.property
    @pulumi.getter(name="provisionedConcurrentExecutions")
    def provisioned_concurrent_executions(self) -> pulumi.Input[_builtins.int]:
        """
        The amount of provisioned concurrency to allocate for the version.
        """
        return pulumi.get(self, "provisioned_concurrent_executions")

    @provisioned_concurrent_executions.setter
    def provisioned_concurrent_executions(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "provisioned_concurrent_executions", value)


if not MYPY:
    class VersionRuntimePolicyArgsDict(TypedDict):
        """
        Runtime Management Config of a function.
        """
        update_runtime_on: pulumi.Input[_builtins.str]
        """
        The runtime update mode.
        """
        runtime_version_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the runtime the function is configured to use. If the runtime update mode is manual, the ARN is returned, otherwise null is returned.
        """
elif False:
    VersionRuntimePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VersionRuntimePolicyArgs:
    def __init__(__self__, *,
                 update_runtime_on: pulumi.Input[_builtins.str],
                 runtime_version_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Runtime Management Config of a function.
        :param pulumi.Input[_builtins.str] update_runtime_on: The runtime update mode.
        :param pulumi.Input[_builtins.str] runtime_version_arn: The ARN of the runtime the function is configured to use. If the runtime update mode is manual, the ARN is returned, otherwise null is returned.
        """
        pulumi.set(__self__, "update_runtime_on", update_runtime_on)
        if runtime_version_arn is not None:
            pulumi.set(__self__, "runtime_version_arn", runtime_version_arn)

    @_builtins.property
    @pulumi.getter(name="updateRuntimeOn")
    def update_runtime_on(self) -> pulumi.Input[_builtins.str]:
        """
        The runtime update mode.
        """
        return pulumi.get(self, "update_runtime_on")

    @update_runtime_on.setter
    def update_runtime_on(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "update_runtime_on", value)

    @_builtins.property
    @pulumi.getter(name="runtimeVersionArn")
    def runtime_version_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the runtime the function is configured to use. If the runtime update mode is manual, the ARN is returned, otherwise null is returned.
        """
        return pulumi.get(self, "runtime_version_arn")

    @runtime_version_arn.setter
    def runtime_version_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runtime_version_arn", value)


